/*!
* DevExtreme (dx.viz.js)
* Version: 21.2.0
* Build date: Wed Jun 30 2021
*
* Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED
* Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
*/
"use strict";

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1138);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.extend = exports.extendFromObject = void 0;

var _type = __webpack_require__(1);

var extendFromObject = function extendFromObject(target, source, overrideExistingValues) {
  target = target || {};

  for (var prop in source) {
    if (Object.prototype.hasOwnProperty.call(source, prop)) {
      var value = source[prop];

      if (!(prop in target) || overrideExistingValues) {
        target[prop] = value;
      }
    }
  }

  return target;
};

exports.extendFromObject = extendFromObject;

var extend = function extend(target) {
  target = target || {};
  var i = 1;
  var deep = false;

  if (typeof target === 'boolean') {
    deep = target;
    target = arguments[1] || {};
    i++;
  }

  for (; i < arguments.length; i++) {
    var source = arguments[i];

    if (source == null) {
      continue;
    }

    for (var key in source) {
      var targetValue = target[key];
      var sourceValue = source[key];
      var sourceValueIsArray = false;
      var clone = void 0;

      if (key === '__proto__' || key === 'constructor' || target === sourceValue) {
        continue;
      }

      if (deep && sourceValue && ((0, _type.isPlainObject)(sourceValue) || (sourceValueIsArray = Array.isArray(sourceValue)))) {
        if (sourceValueIsArray) {
          clone = targetValue && Array.isArray(targetValue) ? targetValue : [];
        } else {
          clone = targetValue && (0, _type.isPlainObject)(targetValue) ? targetValue : {};
        }

        target[key] = extend(deep, clone, sourceValue);
      } else if (sourceValue !== undefined) {
        target[key] = sourceValue;
      }
    }
  }

  return target;
};

exports.extend = extend;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.isEvent = exports.type = exports.isDeferred = exports.isPromise = exports.isRenderer = exports.isWindow = exports.isPrimitive = exports.isPlainObject = exports.isEmptyObject = exports.isObject = exports.isNumeric = exports.isString = exports.isFunction = exports.isDefined = exports.isDate = exports.isExponential = exports.isBoolean = void 0;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var types = {
  '[object Array]': 'array',
  '[object Date]': 'date',
  '[object Object]': 'object',
  '[object String]': 'string',
  '[object Null]': 'null'
};

var type = function type(object) {
  var typeOfObject = Object.prototype.toString.call(object);
  return _typeof(object) === 'object' ? types[typeOfObject] || 'object' : _typeof(object);
};

exports.type = type;

var isBoolean = function isBoolean(object) {
  return typeof object === 'boolean';
};

exports.isBoolean = isBoolean;

var isExponential = function isExponential(value) {
  return isNumeric(value) && value.toString().indexOf('e') !== -1;
};

exports.isExponential = isExponential;

var isDate = function isDate(object) {
  return type(object) === 'date';
};

exports.isDate = isDate;

var isDefined = function isDefined(object) {
  return object !== null && object !== undefined;
};

exports.isDefined = isDefined;

var isFunction = function isFunction(object) {
  return typeof object === 'function';
};

exports.isFunction = isFunction;

var isString = function isString(object) {
  return typeof object === 'string';
};

exports.isString = isString;

var isNumeric = function isNumeric(object) {
  return typeof object === 'number' && isFinite(object) || !isNaN(object - parseFloat(object));
};

exports.isNumeric = isNumeric;

var isObject = function isObject(object) {
  return type(object) === 'object';
};

exports.isObject = isObject;

var isEmptyObject = function isEmptyObject(object) {
  var property;

  for (property in object) {
    return false;
  }

  return true;
};

exports.isEmptyObject = isEmptyObject;

var isPlainObject = function isPlainObject(object) {
  if (!object || Object.prototype.toString.call(object) !== '[object Object]') {
    return false;
  }

  var proto = Object.getPrototypeOf(object);
  var ctor = Object.hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof ctor === 'function' && Object.toString.call(ctor) === Object.toString.call(Object);
};

exports.isPlainObject = isPlainObject;

var isPrimitive = function isPrimitive(value) {
  return ['object', 'array', 'function'].indexOf(type(value)) === -1;
};

exports.isPrimitive = isPrimitive;

var isWindow = function isWindow(object) {
  return object != null && object === object.window;
};

exports.isWindow = isWindow;

var isRenderer = function isRenderer(object) {
  return !!(object.jquery || object.dxRenderer);
};

exports.isRenderer = isRenderer;

var isPromise = function isPromise(object) {
  return object && isFunction(object.then);
};

exports.isPromise = isPromise;

var isDeferred = function isDeferred(object) {
  return object && isFunction(object.done) && isFunction(object.fail);
};

exports.isDeferred = isDeferred;

var isEvent = function isEvent(object) {
  return !!(object && object.preventDefault);
};

exports.isEvent = isEvent;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer_base = _interopRequireDefault(__webpack_require__(247));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = _renderer_base.default.get();

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.reverseEach = exports.each = exports.map = void 0;

var map = function map(values, callback) {
  if (Array.isArray(values)) {
    return values.map(callback);
  }

  var result = [];

  for (var key in values) {
    result.push(callback(values[key], key));
  }

  return result;
};

exports.map = map;

var each = function each(values, callback) {
  if (!values) return;

  if ('length' in values) {
    for (var i = 0; i < values.length; i++) {
      if (callback.call(values[i], i, values[i]) === false) {
        break;
      }
    }
  } else {
    for (var key in values) {
      if (callback.call(values[key], key, values[key]) === false) {
        break;
      }
    }
  }

  return values;
};

exports.each = each;

var reverseEach = function reverseEach(array, callback) {
  if (!array || !('length' in array) || array.length === 0) return;

  for (var i = array.length - 1; i >= 0; i--) {
    if (callback.call(array[i], i, array[i]) === false) {
      break;
    }
  }
};

exports.reverseEach = reverseEach;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.equalByValue = exports.grep = exports.asyncNoop = exports.noop = exports.applyServerDecimalSeparator = exports.escapeRegExp = exports.getKeyHash = exports.pairToObject = exports.denormalizeKey = exports.normalizeKey = exports.splitPair = exports.findBestMatches = exports.deferUpdater = exports.deferRenderer = exports.deferUpdate = exports.deferRender = exports.executeAsync = exports.ensureDefined = void 0;

var _config = _interopRequireDefault(__webpack_require__(29));

var _guid = _interopRequireDefault(__webpack_require__(36));

var _deferred = __webpack_require__(6);

var _data = __webpack_require__(21);

var _iterator = __webpack_require__(3);

var _type = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ensureDefined = function ensureDefined(value, defaultValue) {
  return (0, _type.isDefined)(value) ? value : defaultValue;
};

exports.ensureDefined = ensureDefined;

var executeAsync = function executeAsync(action, context
/* , internal */
) {
  var deferred = new _deferred.Deferred();
  var normalizedContext = context || this;
  var task = {
    promise: deferred.promise(),
    abort: function abort() {
      clearTimeout(timerId);
      deferred.rejectWith(normalizedContext);
    }
  };

  var callback = function callback() {
    var result = action.call(normalizedContext);

    if (result && result.done && (0, _type.isFunction)(result.done)) {
      result.done(function () {
        deferred.resolveWith(normalizedContext);
      });
    } else {
      deferred.resolveWith(normalizedContext);
    }
  };

  var timerId = (arguments[2] || setTimeout)(callback, typeof context === 'number' ? context : 0);
  return task;
};

exports.executeAsync = executeAsync;
var delayedFuncs = [];
var delayedNames = [];
var delayedDeferreds = [];
var executingName;

var deferExecute = function deferExecute(name, func, deferred) {
  if (executingName && executingName !== name) {
    delayedFuncs.push(func);
    delayedNames.push(name);
    deferred = deferred || new _deferred.Deferred();
    delayedDeferreds.push(deferred);
    return deferred;
  } else {
    var oldExecutingName = executingName;
    var currentDelayedCount = delayedDeferreds.length;
    executingName = name;
    var result = func();

    if (!result) {
      if (delayedDeferreds.length > currentDelayedCount) {
        result = _deferred.when.apply(this, delayedDeferreds.slice(currentDelayedCount));
      } else if (deferred) {
        deferred.resolve();
      }
    }

    executingName = oldExecutingName;

    if (deferred && result && result.done) {
      result.done(deferred.resolve).fail(deferred.reject);
    }

    if (!executingName && delayedFuncs.length) {
      (delayedNames.shift() === 'render' ? deferRender : deferUpdate)(delayedFuncs.shift(), delayedDeferreds.shift());
    }

    return result || (0, _deferred.when)();
  }
};

var deferRender = function deferRender(func, deferred) {
  return deferExecute('render', func, deferred);
};

exports.deferRender = deferRender;

var deferUpdate = function deferUpdate(func, deferred) {
  return deferExecute('update', func, deferred);
};

exports.deferUpdate = deferUpdate;

var deferRenderer = function deferRenderer(func) {
  return function () {
    var that = this;
    return deferExecute('render', function () {
      return func.call(that);
    });
  };
};

exports.deferRenderer = deferRenderer;

var deferUpdater = function deferUpdater(func) {
  return function () {
    var that = this;
    return deferExecute('update', function () {
      return func.call(that);
    });
  };
};

exports.deferUpdater = deferUpdater;

var findBestMatches = function findBestMatches(targetFilter, items, mapFn) {
  var bestMatches = [];
  var maxMatchCount = 0;
  (0, _iterator.each)(items, function (index, itemSrc) {
    var matchCount = 0;
    var item = mapFn ? mapFn(itemSrc) : itemSrc;
    (0, _iterator.each)(targetFilter, function (paramName, targetValue) {
      var value = item[paramName];

      if (value === undefined) {
        return;
      }

      if (match(value, targetValue)) {
        matchCount++;
        return;
      }

      matchCount = -1;
      return false;
    });

    if (matchCount < maxMatchCount) {
      return;
    }

    if (matchCount > maxMatchCount) {
      bestMatches.length = 0;
      maxMatchCount = matchCount;
    }

    bestMatches.push(itemSrc);
  });
  return bestMatches;
};

exports.findBestMatches = findBestMatches;

var match = function match(value, targetValue) {
  if (Array.isArray(value) && Array.isArray(targetValue)) {
    var mismatch = false;
    (0, _iterator.each)(value, function (index, valueItem) {
      if (valueItem !== targetValue[index]) {
        mismatch = true;
        return false;
      }
    });

    if (mismatch) {
      return false;
    }

    return true;
  }

  if (value === targetValue) {
    return true;
  }

  return false;
};

var splitPair = function splitPair(raw) {
  var _raw$x, _raw$y;

  switch ((0, _type.type)(raw)) {
    case 'string':
      return raw.split(/\s+/, 2);

    case 'object':
      return [(_raw$x = raw.x) !== null && _raw$x !== void 0 ? _raw$x : raw.h, (_raw$y = raw.y) !== null && _raw$y !== void 0 ? _raw$y : raw.v];

    case 'number':
      return [raw];

    case 'array':
      return raw;

    default:
      return null;
  }
};

exports.splitPair = splitPair;

var normalizeKey = function normalizeKey(id) {
  var key = (0, _type.isString)(id) ? id : id.toString();
  var arr = key.match(/[^a-zA-Z0-9_]/g);
  arr && (0, _iterator.each)(arr, function (_, sign) {
    key = key.replace(sign, '__' + sign.charCodeAt() + '__');
  });
  return key;
};

exports.normalizeKey = normalizeKey;

var denormalizeKey = function denormalizeKey(key) {
  var arr = key.match(/__\d+__/g);
  arr && arr.forEach(function (char) {
    var charCode = parseInt(char.replace('__', ''));
    key = key.replace(char, String.fromCharCode(charCode));
  });
  return key;
};

exports.denormalizeKey = denormalizeKey;

var pairToObject = function pairToObject(raw, preventRound) {
  var pair = splitPair(raw);
  var h = preventRound ? parseFloat(pair && pair[0]) : parseInt(pair && pair[0], 10);
  var v = preventRound ? parseFloat(pair && pair[1]) : parseInt(pair && pair[1], 10);

  if (!isFinite(h)) {
    h = 0;
  }

  if (!isFinite(v)) {
    v = h;
  }

  return {
    h: h,
    v: v
  };
};

exports.pairToObject = pairToObject;

var getKeyHash = function getKeyHash(key) {
  if (key instanceof _guid.default) {
    return key.toString();
  } else if ((0, _type.isObject)(key) || Array.isArray(key)) {
    try {
      var keyHash = JSON.stringify(key);
      return keyHash === '{}' ? key : keyHash;
    } catch (e) {
      return key;
    }
  }

  return key;
};

exports.getKeyHash = getKeyHash;

var escapeRegExp = function escapeRegExp(string) {
  return string.replace(/[[\]{}\-()*+?.\\^$|\s]/g, '\\$&');
};

exports.escapeRegExp = escapeRegExp;

var applyServerDecimalSeparator = function applyServerDecimalSeparator(value) {
  var separator = (0, _config.default)().serverDecimalSeparator;

  if ((0, _type.isDefined)(value)) {
    value = value.toString().replace('.', separator);
  }

  return value;
};

exports.applyServerDecimalSeparator = applyServerDecimalSeparator;

var noop = function noop() {};

exports.noop = noop;

var asyncNoop = function asyncNoop() {
  return new _deferred.Deferred().resolve().promise();
};

exports.asyncNoop = asyncNoop;

var grep = function grep(elements, checkFunction, invert) {
  var result = [];
  var check;
  var expectedCheck = !invert;

  for (var i = 0; i < elements.length; i++) {
    check = !!checkFunction(elements[i], i);

    if (check === expectedCheck) {
      result.push(elements[i]);
    }
  }

  return result;
};

exports.grep = grep;

var arraysEqualByValue = function arraysEqualByValue(array1, array2, depth) {
  if (array1.length !== array2.length) {
    return false;
  }

  for (var i = 0; i < array1.length; i++) {
    if (!equalByValue(array1[i], array2[i], depth + 1)) {
      return false;
    }
  }

  return true;
};

var objectsEqualByValue = function objectsEqualByValue(object1, object2, depth, strict) {
  for (var propertyName in object1) {
    if (Object.prototype.hasOwnProperty.call(object1, propertyName) && !equalByValue(object1[propertyName], object2[propertyName], depth + 1, strict)) {
      return false;
    }
  }

  for (var _propertyName in object2) {
    if (!(_propertyName in object1)) {
      return false;
    }
  }

  return true;
};

var maxEqualityDepth = 3;

var equalByValue = function equalByValue(object1, object2) {
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var strict = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  object1 = (0, _data.toComparable)(object1, true);
  object2 = (0, _data.toComparable)(object2, true); // eslint-disable-next-line eqeqeq

  var comparisonResult = strict ? object1 === object2 : object1 == object2;

  if (comparisonResult || depth >= maxEqualityDepth) {
    return true;
  }

  if ((0, _type.isObject)(object1) && (0, _type.isObject)(object2)) {
    return objectsEqualByValue(object1, object2, depth, strict);
  } else if (Array.isArray(object1) && Array.isArray(object2)) {
    return arraysEqualByValue(object1, object2, depth);
  }

  return false;
};

exports.equalByValue = equalByValue;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _event_registrator_callbacks = _interopRequireDefault(__webpack_require__(124));

var _extend = __webpack_require__(0);

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _window = __webpack_require__(7);

var _dependency_injector = _interopRequireDefault(__webpack_require__(55));

var _type = __webpack_require__(1);

var _callbacks = _interopRequireDefault(__webpack_require__(28));

var _errors = _interopRequireDefault(__webpack_require__(24));

var _weak_map = _interopRequireDefault(__webpack_require__(193));

var _hook_touch_props = _interopRequireDefault(__webpack_require__(248));

var _call_once = _interopRequireDefault(__webpack_require__(79));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var window = (0, _window.getWindow)();
var EMPTY_EVENT_NAME = 'dxEmptyEventType';
var NATIVE_EVENTS_TO_SUBSCRIBE = {
  'mouseenter': 'mouseover',
  'mouseleave': 'mouseout',
  'pointerenter': 'pointerover',
  'pointerleave': 'pointerout'
};
var NATIVE_EVENTS_TO_TRIGGER = {
  'focusin': 'focus',
  'focusout': 'blur'
};
var NO_BUBBLE_EVENTS = ['blur', 'focus', 'load'];
var forcePassiveFalseEventNames = ['touchmove', 'wheel', 'mousewheel', 'touchstart'];

function matchesSafe(target, selector) {
  return !(0, _type.isWindow)(target) && target.nodeName !== '#document' && _dom_adapter.default.elementMatches(target, selector);
}

var elementDataMap = new _weak_map.default();
var guid = 0;
var skipEvent;

var special = function () {
  var specialData = {};

  _event_registrator_callbacks.default.add(function (eventName, eventObject) {
    specialData[eventName] = eventObject;
  });

  return {
    getField: function getField(eventName, field) {
      return specialData[eventName] && specialData[eventName][field];
    },
    callMethod: function callMethod(eventName, methodName, context, args) {
      return specialData[eventName] && specialData[eventName][methodName] && specialData[eventName][methodName].apply(context, args);
    }
  };
}();

var eventsEngine = (0, _dependency_injector.default)({
  on: getHandler(normalizeOnArguments(iterate(function (element, eventName, selector, data, handler) {
    var handlersController = getHandlersController(element, eventName);
    handlersController.addHandler(handler, selector, data);
  }))),
  one: getHandler(normalizeOnArguments(function (element, eventName, selector, data, handler) {
    var oneTimeHandler = function oneTimeHandler() {
      eventsEngine.off(element, eventName, selector, oneTimeHandler);
      handler.apply(this, arguments);
    };

    eventsEngine.on(element, eventName, selector, data, oneTimeHandler);
  })),
  off: getHandler(normalizeOffArguments(iterate(function (element, eventName, selector, handler) {
    var handlersController = getHandlersController(element, eventName);
    handlersController.removeHandler(handler, selector);
  }))),
  trigger: getHandler(normalizeTriggerArguments(function (element, event, extraParameters) {
    var eventName = event.type;
    var handlersController = getHandlersController(element, event.type);
    special.callMethod(eventName, 'trigger', element, [event, extraParameters]);
    handlersController.callHandlers(event, extraParameters);
    var noBubble = special.getField(eventName, 'noBubble') || event.isPropagationStopped() || NO_BUBBLE_EVENTS.indexOf(eventName) !== -1;

    if (!noBubble) {
      var parents = [];

      var getParents = function getParents(element) {
        var parent = element.parentNode;

        if (parent) {
          parents.push(parent);
          getParents(parent);
        }
      };

      getParents(element);
      parents.push(window);
      var i = 0;

      while (parents[i] && !event.isPropagationStopped()) {
        var parentDataByEvent = getHandlersController(parents[i], event.type);
        parentDataByEvent.callHandlers((0, _extend.extend)(event, {
          currentTarget: parents[i]
        }), extraParameters);
        i++;
      }
    }

    if (element.nodeType || (0, _type.isWindow)(element)) {
      special.callMethod(eventName, '_default', element, [event, extraParameters]);
      callNativeMethod(eventName, element);
    }
  })),
  triggerHandler: getHandler(normalizeTriggerArguments(function (element, event, extraParameters) {
    var handlersController = getHandlersController(element, event.type);
    handlersController.callHandlers(event, extraParameters);
  }))
});

function applyForEach(args, method) {
  var element = args[0];

  if (!element) {
    return;
  }

  if (_dom_adapter.default.isNode(element) || (0, _type.isWindow)(element)) {
    method.apply(eventsEngine, args);
  } else if (!(0, _type.isString)(element) && 'length' in element) {
    var itemArgs = Array.prototype.slice.call(args, 0);
    Array.prototype.forEach.call(element, function (itemElement) {
      itemArgs[0] = itemElement;
      applyForEach(itemArgs, method);
    });
  } else {
    throw _errors.default.Error('E0025');
  }
}

function getHandler(method) {
  return function () {
    applyForEach(arguments, method);
  };
}

function detectPassiveEventHandlersSupport() {
  var isSupported = false;

  try {
    var options = Object.defineProperty({}, 'passive', {
      get: function get() {
        isSupported = true;
        return true;
      }
    });
    window.addEventListener('test', null, options);
  } catch (e) {}

  return isSupported;
}

var passiveEventHandlersSupported = (0, _call_once.default)(detectPassiveEventHandlersSupport);

var contains = function contains(container, element) {
  if ((0, _type.isWindow)(container)) {
    return contains(container.document, element);
  }

  return container.contains ? container.contains(element) : !!(element.compareDocumentPosition(container) & element.DOCUMENT_POSITION_CONTAINS);
};

function getHandlersController(element, eventName) {
  var elementData = elementDataMap.get(element);
  eventName = eventName || '';
  var eventNameParts = eventName.split('.');
  var namespaces = eventNameParts.slice(1);
  var eventNameIsDefined = !!eventNameParts[0];
  eventName = eventNameParts[0] || EMPTY_EVENT_NAME;

  if (!elementData) {
    elementData = {};
    elementDataMap.set(element, elementData);
  }

  if (!elementData[eventName]) {
    elementData[eventName] = {
      handleObjects: [],
      nativeHandler: null
    };
  }

  var eventData = elementData[eventName];
  return {
    addHandler: function addHandler(handler, selector, data) {
      var callHandler = function callHandler(e, extraParameters) {
        var handlerArgs = [e];
        var target = e.currentTarget;
        var relatedTarget = e.relatedTarget;
        var secondaryTargetIsInside;
        var result;

        if (eventName in NATIVE_EVENTS_TO_SUBSCRIBE) {
          secondaryTargetIsInside = relatedTarget && target && (relatedTarget === target || contains(target, relatedTarget));
        }

        if (extraParameters !== undefined) {
          handlerArgs.push(extraParameters);
        }

        special.callMethod(eventName, 'handle', element, [e, data]);

        if (!secondaryTargetIsInside) {
          result = handler.apply(target, handlerArgs);
        }

        if (result === false) {
          e.preventDefault();
          e.stopPropagation();
        }
      };

      var wrappedHandler = function wrappedHandler(e, extraParameters) {
        if (skipEvent && e.type === skipEvent) {
          return;
        }

        e.data = data;
        e.delegateTarget = element;

        if (selector) {
          var currentTarget = e.target;

          while (currentTarget && currentTarget !== element) {
            if (matchesSafe(currentTarget, selector)) {
              e.currentTarget = currentTarget;
              callHandler(e, extraParameters);
            }

            currentTarget = currentTarget.parentNode;
          }
        } else {
          e.currentTarget = e.delegateTarget || e.target;
          callHandler(e, extraParameters);
        }
      };

      var handleObject = {
        handler: handler,
        wrappedHandler: wrappedHandler,
        selector: selector,
        type: eventName,
        data: data,
        namespace: namespaces.join('.'),
        namespaces: namespaces,
        guid: ++guid
      };
      eventData.handleObjects.push(handleObject);
      var firstHandlerForTheType = eventData.handleObjects.length === 1;
      var shouldAddNativeListener = firstHandlerForTheType && eventNameIsDefined;
      var nativeListenerOptions;

      if (shouldAddNativeListener) {
        shouldAddNativeListener = !special.callMethod(eventName, 'setup', element, [data, namespaces, handler]);
      }

      if (shouldAddNativeListener) {
        eventData.nativeHandler = getNativeHandler(eventName);

        if (passiveEventHandlersSupported() && forcePassiveFalseEventNames.indexOf(eventName) > -1) {
          nativeListenerOptions = {
            passive: false
          };
        }

        eventData.removeListener = _dom_adapter.default.listen(element, NATIVE_EVENTS_TO_SUBSCRIBE[eventName] || eventName, eventData.nativeHandler, nativeListenerOptions);
      }

      special.callMethod(eventName, 'add', element, [handleObject]);
    },
    removeHandler: function removeHandler(handler, selector) {
      var removeByEventName = function removeByEventName(eventName) {
        var eventData = elementData[eventName];

        if (!eventData.handleObjects.length) {
          delete elementData[eventName];
          return;
        }

        var removedHandler;
        eventData.handleObjects = eventData.handleObjects.filter(function (handleObject) {
          var skip = namespaces.length && !isSubset(handleObject.namespaces, namespaces) || handler && handleObject.handler !== handler || selector && handleObject.selector !== selector;

          if (!skip) {
            removedHandler = handleObject.handler;
            special.callMethod(eventName, 'remove', element, [handleObject]);
          }

          return skip;
        });
        var lastHandlerForTheType = !eventData.handleObjects.length;
        var shouldRemoveNativeListener = lastHandlerForTheType && eventName !== EMPTY_EVENT_NAME;

        if (shouldRemoveNativeListener) {
          special.callMethod(eventName, 'teardown', element, [namespaces, removedHandler]);

          if (eventData.nativeHandler) {
            eventData.removeListener();
          }

          delete elementData[eventName];
        }
      };

      if (eventNameIsDefined) {
        removeByEventName(eventName);
      } else {
        for (var name in elementData) {
          removeByEventName(name);
        }
      }

      var elementDataIsEmpty = Object.keys(elementData).length === 0;

      if (elementDataIsEmpty) {
        elementDataMap.delete(element);
      }
    },
    callHandlers: function callHandlers(event, extraParameters) {
      var forceStop = false;

      var handleCallback = function handleCallback(handleObject) {
        if (forceStop) {
          return;
        }

        if (!namespaces.length || isSubset(handleObject.namespaces, namespaces)) {
          handleObject.wrappedHandler(event, extraParameters);
          forceStop = event.isImmediatePropagationStopped();
        }
      };

      eventData.handleObjects.forEach(handleCallback);

      if (namespaces.length && elementData[EMPTY_EVENT_NAME]) {
        elementData[EMPTY_EVENT_NAME].handleObjects.forEach(handleCallback);
      }
    }
  };
}

function getNativeHandler(subscribeName) {
  return function (event, extraParameters) {
    var handlersController = getHandlersController(this, subscribeName);
    event = eventsEngine.Event(event);
    handlersController.callHandlers(event, extraParameters);
  };
}

function isSubset(original, checked) {
  for (var i = 0; i < checked.length; i++) {
    if (original.indexOf(checked[i]) < 0) return false;
  }

  return true;
}

function normalizeOnArguments(callback) {
  return function (element, eventName, selector, data, handler) {
    if (!handler) {
      handler = data;
      data = undefined;
    }

    if (typeof selector !== 'string') {
      data = selector;
      selector = undefined;
    }

    if (!handler && typeof eventName === 'string') {
      handler = data || selector;
      selector = undefined;
      data = undefined;
    }

    callback(element, eventName, selector, data, handler);
  };
}

function normalizeOffArguments(callback) {
  return function (element, eventName, selector, handler) {
    if (typeof selector === 'function') {
      handler = selector;
      selector = undefined;
    }

    callback(element, eventName, selector, handler);
  };
}

function normalizeTriggerArguments(callback) {
  return function (element, src, extraParameters) {
    if (typeof src === 'string') {
      src = {
        type: src
      };
    }

    if (!src.target) {
      src.target = element;
    }

    src.currentTarget = element;

    if (!src.delegateTarget) {
      src.delegateTarget = element;
    }

    if (!src.type && src.originalEvent) {
      src.type = src.originalEvent.type;
    }

    callback(element, src instanceof eventsEngine.Event ? src : eventsEngine.Event(src), extraParameters);
  };
}

function normalizeEventArguments(callback) {
  return function (src, config) {
    if (!(this instanceof eventsEngine.Event)) {
      return new eventsEngine.Event(src, config);
    }

    if (!src) {
      src = {};
    }

    if (typeof src === 'string') {
      src = {
        type: src
      };
    }

    if (!config) {
      config = {};
    }

    callback.call(this, src, config);
  };
}

function iterate(callback) {
  var iterateEventNames = function iterateEventNames(element, eventName) {
    if (eventName && eventName.indexOf(' ') > -1) {
      var args = Array.prototype.slice.call(arguments, 0);
      eventName.split(' ').forEach(function (eventName) {
        args[1] = eventName;
        callback.apply(this, args);
      });
    } else {
      callback.apply(this, arguments);
    }
  };

  return function (element, eventName) {
    if (_typeof(eventName) === 'object') {
      var args = Array.prototype.slice.call(arguments, 0);

      for (var name in eventName) {
        args[1] = name;
        args[args.length - 1] = eventName[name];
        iterateEventNames.apply(this, args);
      }
    } else {
      iterateEventNames.apply(this, arguments);
    }
  };
}

function callNativeMethod(eventName, element) {
  var nativeMethodName = NATIVE_EVENTS_TO_TRIGGER[eventName] || eventName;

  var isLinkClickEvent = function isLinkClickEvent(eventName, element) {
    return eventName === 'click' && element.localName === 'a';
  };

  if (isLinkClickEvent(eventName, element)) return;

  if ((0, _type.isFunction)(element[nativeMethodName])) {
    skipEvent = eventName;
    element[nativeMethodName]();
    skipEvent = undefined;
  }
}

function calculateWhich(event) {
  var setForMouseEvent = function setForMouseEvent(event) {
    var mouseEventRegex = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
    return !event.which && event.button !== undefined && mouseEventRegex.test(event.type);
  };

  var setForKeyEvent = function setForKeyEvent(event) {
    return event.which == null && event.type.indexOf('key') === 0;
  };

  if (setForKeyEvent(event)) {
    return event.charCode != null ? event.charCode : event.keyCode;
  }

  if (setForMouseEvent(event)) {
    var whichByButton = {
      1: 1,
      2: 3,
      3: 1,
      4: 2
    };
    return whichByButton[event.button];
  }

  return event.which;
}

function initEvent(EventClass) {
  if (EventClass) {
    eventsEngine.Event = EventClass;
    eventsEngine.Event.prototype = EventClass.prototype;
  }
}

initEvent(normalizeEventArguments(function (src, config) {
  var that = this;
  var propagationStopped = false;
  var immediatePropagationStopped = false;
  var defaultPrevented = false;
  (0, _extend.extend)(that, src);

  if (src instanceof eventsEngine.Event || (0, _window.hasWindow)() && src instanceof window.Event) {
    that.originalEvent = src;
    that.currentTarget = undefined;
  }

  if (!(src instanceof eventsEngine.Event)) {
    (0, _extend.extend)(that, {
      isPropagationStopped: function isPropagationStopped() {
        return !!(propagationStopped || that.originalEvent && that.originalEvent.propagationStopped);
      },
      stopPropagation: function stopPropagation() {
        propagationStopped = true;
        that.originalEvent && that.originalEvent.stopPropagation();
      },
      isImmediatePropagationStopped: function isImmediatePropagationStopped() {
        return immediatePropagationStopped;
      },
      stopImmediatePropagation: function stopImmediatePropagation() {
        this.stopPropagation();
        immediatePropagationStopped = true;
        that.originalEvent && that.originalEvent.stopImmediatePropagation();
      },
      isDefaultPrevented: function isDefaultPrevented() {
        return !!(defaultPrevented || that.originalEvent && that.originalEvent.defaultPrevented);
      },
      preventDefault: function preventDefault() {
        defaultPrevented = true;
        that.originalEvent && that.originalEvent.preventDefault();
      }
    });
  }

  addProperty('which', calculateWhich, that);

  if (src.type.indexOf('touch') === 0) {
    delete config.pageX;
    delete config.pageY;
  }

  (0, _extend.extend)(that, config);
  that.guid = ++guid;
}));

function addProperty(propName, hook, eventInstance) {
  Object.defineProperty(eventInstance || eventsEngine.Event.prototype, propName, {
    enumerable: true,
    configurable: true,
    get: function get() {
      return this.originalEvent && hook(this.originalEvent);
    },
    set: function set(value) {
      Object.defineProperty(this, propName, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: value
      });
    }
  });
}

(0, _hook_touch_props.default)(addProperty);
var beforeSetStrategy = (0, _callbacks.default)();
var afterSetStrategy = (0, _callbacks.default)();

eventsEngine.set = function (engine) {
  beforeSetStrategy.fire();
  eventsEngine.inject(engine);
  initEvent(engine.Event);
  afterSetStrategy.fire();
};

eventsEngine.subscribeGlobal = function () {
  applyForEach(arguments, normalizeOnArguments(function () {
    var args = arguments;
    eventsEngine.on.apply(this, args);
    beforeSetStrategy.add(function () {
      var offArgs = Array.prototype.slice.call(args, 0);
      offArgs.splice(3, 1);
      eventsEngine.off.apply(this, offArgs);
    });
    afterSetStrategy.add(function () {
      eventsEngine.on.apply(this, args);
    });
  }));
};

eventsEngine.forcePassiveFalseEventNames = forcePassiveFalseEventNames;
eventsEngine.passiveEventHandlersSupported = passiveEventHandlersSupported;
var _default = eventsEngine;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.fromPromise = fromPromise;
exports.setStrategy = setStrategy;
exports.Deferred = Deferred;
exports.when = when;

var _type = __webpack_require__(1);

var _extend = __webpack_require__(0);

var _callbacks = _interopRequireDefault(__webpack_require__(28));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var deferredConfig = [{
  method: 'resolve',
  handler: 'done',
  state: 'resolved'
}, {
  method: 'reject',
  handler: 'fail',
  state: 'rejected'
}, {
  method: 'notify',
  handler: 'progress'
}];

var _DeferredObj = function DeferredObj() {
  var that = this;
  this._state = 'pending';
  this._promise = {};
  deferredConfig.forEach(function (config) {
    var methodName = config.method;
    this[methodName + 'Callbacks'] = new _callbacks.default();

    this[methodName] = function () {
      return this[methodName + 'With'](this._promise, arguments);
    }.bind(this);

    this._promise[config.handler] = function (handler) {
      if (!handler) return this;
      var callbacks = that[methodName + 'Callbacks'];

      if (callbacks.fired()) {
        handler.apply(that[methodName + 'Context'], that[methodName + 'Args']);
      } else {
        callbacks.add(function (context, args) {
          handler.apply(context, args);
        }.bind(this));
      }

      return this;
    };
  }.bind(this));

  this._promise.always = function (handler) {
    return this.done(handler).fail(handler);
  };

  this._promise.catch = function (handler) {
    return this.then(null, handler);
  };

  this._promise.then = function (resolve, reject) {
    var result = new _DeferredObj();
    ['done', 'fail'].forEach(function (method) {
      var callback = method === 'done' ? resolve : reject;
      this[method](function () {
        if (!callback) {
          result[method === 'done' ? 'resolve' : 'reject'].apply(this, arguments);
          return;
        }

        var callbackResult = callback && callback.apply(this, arguments);

        if ((0, _type.isDeferred)(callbackResult)) {
          callbackResult.done(result.resolve).fail(result.reject);
        } else if ((0, _type.isPromise)(callbackResult)) {
          callbackResult.then(result.resolve, result.reject);
        } else {
          result.resolve.apply(this, (0, _type.isDefined)(callbackResult) ? [callbackResult] : arguments);
        }
      });
    }.bind(this));
    return result.promise();
  };

  this._promise.state = function () {
    return that._state;
  };

  this._promise.promise = function (args) {
    return args ? (0, _extend.extend)(args, that._promise) : that._promise;
  };

  this._promise.promise(this);
};

deferredConfig.forEach(function (config) {
  var methodName = config.method;
  var state = config.state;

  _DeferredObj.prototype[methodName + 'With'] = function (context, args) {
    var callbacks = this[methodName + 'Callbacks'];

    if (this.state() === 'pending') {
      this[methodName + 'Args'] = args;
      this[methodName + 'Context'] = context;
      if (state) this._state = state;
      callbacks.fire(context, args);
    }

    return this;
  };
});

function fromPromise(promise, context) {
  if ((0, _type.isDeferred)(promise)) {
    return promise;
  } else if ((0, _type.isPromise)(promise)) {
    var d = new _DeferredObj();
    promise.then(function () {
      d.resolveWith.apply(d, [context].concat([[].slice.call(arguments)]));
    }, function () {
      d.rejectWith.apply(d, [context].concat([[].slice.call(arguments)]));
    });
    return d;
  }

  return new _DeferredObj().resolveWith(context, [promise]);
}

var whenFunc = function whenFunc() {
  if (arguments.length === 1) {
    return fromPromise(arguments[0]);
  }

  var values = [].slice.call(arguments);
  var contexts = [];
  var resolvedCount = 0;
  var deferred = new _DeferredObj();

  var updateState = function updateState(i) {
    return function (value) {
      contexts[i] = this;
      values[i] = arguments.length > 1 ? [].slice.call(arguments) : value;
      resolvedCount++;

      if (resolvedCount === values.length) {
        deferred.resolveWith(contexts, values);
      }
    };
  };

  for (var i = 0; i < values.length; i++) {
    if ((0, _type.isDeferred)(values[i])) {
      values[i].promise().done(updateState(i)).fail(deferred.reject);
    } else {
      resolvedCount++;
    }
  }

  if (resolvedCount === values.length) {
    deferred.resolveWith(contexts, values);
  }

  return deferred.promise();
};

function setStrategy(value) {
  _DeferredObj = value.Deferred;
  whenFunc = value.when;
}

function Deferred() {
  return new _DeferredObj();
}

function when() {
  return whenFunc.apply(this, arguments);
}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getNavigator = exports.getCurrentScreenFactor = exports.defaultScreenFactorFunc = exports.hasProperty = exports.setWindow = exports.getWindow = exports.hasWindow = void 0;

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* global window */
var hasWindowValue = typeof window !== 'undefined';

var hasWindow = function hasWindow() {
  return hasWindowValue;
};

exports.hasWindow = hasWindow;
var windowObject = hasWindow() ? window : undefined;

if (!windowObject) {
  windowObject = {};
  windowObject.window = windowObject;
}

var getWindow = function getWindow() {
  return windowObject;
};

exports.getWindow = getWindow;

var setWindow = function setWindow(newWindowObject, hasWindow) {
  if (hasWindow === undefined) {
    hasWindowValue = typeof window !== 'undefined' && window === newWindowObject;
  } else {
    hasWindowValue = hasWindow;
  }

  windowObject = newWindowObject;
};

exports.setWindow = setWindow;

var hasProperty = function hasProperty(prop) {
  return hasWindow() && prop in windowObject;
};

exports.hasProperty = hasProperty;

var defaultScreenFactorFunc = function defaultScreenFactorFunc(width) {
  if (width < 768) {
    return 'xs';
  } else if (width < 992) {
    return 'sm';
  } else if (width < 1200) {
    return 'md';
  } else {
    return 'lg';
  }
};

exports.defaultScreenFactorFunc = defaultScreenFactorFunc;

var getCurrentScreenFactor = function getCurrentScreenFactor(screenFactorCallback) {
  var screenFactorFunc = screenFactorCallback || defaultScreenFactorFunc;

  var windowWidth = _dom_adapter.default.getDocumentElement()['clientWidth'];

  return screenFactorFunc(windowWidth);
};

exports.getCurrentScreenFactor = getCurrentScreenFactor;

var getNavigator = function getNavigator() {
  return hasWindow() ? windowObject.navigator : {
    userAgent: ''
  };
};

exports.getNavigator = getNavigator;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.isCommandKeyPressed = exports.addNamespace = exports.getChar = exports.normalizeKeyName = exports.fireEvent = exports.createEvent = exports.setEventFixMethod = exports.needSkipEvent = exports.stopEventsSkipping = exports.forceSkipEvents = exports.hasTouches = exports.eventDelta = exports.eventData = exports.isFakeClickEvent = exports.isKeyboardEvent = exports.isTouchEvent = exports.isDxMouseWheelEvent = exports.isMouseEvent = exports.isPointerEvent = exports.eventSource = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _add_namespace = _interopRequireDefault(__webpack_require__(386));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _iterator = __webpack_require__(3);

var _extend = __webpack_require__(0);

var _selectors = __webpack_require__(67);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var KEY_MAP = {
  'backspace': 'backspace',
  'tab': 'tab',
  'enter': 'enter',
  'escape': 'escape',
  'pageup': 'pageUp',
  'pagedown': 'pageDown',
  'end': 'end',
  'home': 'home',
  'arrowleft': 'leftArrow',
  'arrowup': 'upArrow',
  'arrowright': 'rightArrow',
  'arrowdown': 'downArrow',
  'delete': 'del',
  ' ': 'space',
  'f': 'F',
  'a': 'A',
  '*': 'asterisk',
  '-': 'minus',
  'alt': 'alt',
  'control': 'control',
  'shift': 'shift',
  // IE11:
  'left': 'leftArrow',
  'up': 'upArrow',
  'right': 'rightArrow',
  'down': 'downArrow',
  'multiply': 'asterisk',
  'spacebar': 'space',
  'del': 'del',
  'subtract': 'minus',
  'esc': 'escape'
};
var LEGACY_KEY_CODES = {
  // iOS 10.2 and lower didn't supports KeyboardEvent.key
  '8': 'backspace',
  '9': 'tab',
  '13': 'enter',
  '27': 'escape',
  '33': 'pageUp',
  '34': 'pageDown',
  '35': 'end',
  '36': 'home',
  '37': 'leftArrow',
  '38': 'upArrow',
  '39': 'rightArrow',
  '40': 'downArrow',
  '46': 'del',
  '32': 'space',
  '70': 'F',
  '65': 'A',
  '106': 'asterisk',
  '109': 'minus',
  '189': 'minus',
  '173': 'minus',
  '16': 'shift',
  '17': 'control',
  '18': 'alt'
};
var EVENT_SOURCES_REGEX = {
  dx: /^dx/i,
  mouse: /(mouse|wheel)/i,
  touch: /^touch/i,
  keyboard: /^key/i,
  pointer: /^(ms)?pointer/i
};

var fixMethod = function fixMethod(e) {
  return e;
};

var copyEvent = function copyEvent(originalEvent) {
  return fixMethod(_events_engine.default.Event(originalEvent, originalEvent), originalEvent);
};

var isDxEvent = function isDxEvent(e) {
  return eventSource(e) === 'dx';
};

var isNativeMouseEvent = function isNativeMouseEvent(e) {
  return eventSource(e) === 'mouse';
};

var isNativeTouchEvent = function isNativeTouchEvent(e) {
  return eventSource(e) === 'touch';
};

var eventSource = function eventSource(_ref) {
  var type = _ref.type;
  var result = 'other';
  (0, _iterator.each)(EVENT_SOURCES_REGEX, function (key) {
    if (this.test(type)) {
      result = key;
      return false;
    }
  });
  return result;
};

exports.eventSource = eventSource;

var isPointerEvent = function isPointerEvent(e) {
  return eventSource(e) === 'pointer';
};

exports.isPointerEvent = isPointerEvent;

var isMouseEvent = function isMouseEvent(e) {
  return isNativeMouseEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && e.pointerType === 'mouse';
};

exports.isMouseEvent = isMouseEvent;

var isDxMouseWheelEvent = function isDxMouseWheelEvent(e) {
  return e && e.type === 'dxmousewheel';
};

exports.isDxMouseWheelEvent = isDxMouseWheelEvent;

var isTouchEvent = function isTouchEvent(e) {
  return isNativeTouchEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && e.pointerType === 'touch';
};

exports.isTouchEvent = isTouchEvent;

var isKeyboardEvent = function isKeyboardEvent(e) {
  return eventSource(e) === 'keyboard';
};

exports.isKeyboardEvent = isKeyboardEvent;

var isFakeClickEvent = function isFakeClickEvent(_ref2) {
  var screenX = _ref2.screenX,
      offsetX = _ref2.offsetX,
      pageX = _ref2.pageX;
  return screenX === 0 && !offsetX && pageX === 0;
};

exports.isFakeClickEvent = isFakeClickEvent;

var eventData = function eventData(_ref3) {
  var pageX = _ref3.pageX,
      pageY = _ref3.pageY,
      timeStamp = _ref3.timeStamp;
  return {
    x: pageX,
    y: pageY,
    time: timeStamp
  };
};

exports.eventData = eventData;

var eventDelta = function eventDelta(from, to) {
  return {
    x: to.x - from.x,
    y: to.y - from.y,
    time: to.time - from.time || 1
  };
};

exports.eventDelta = eventDelta;

var hasTouches = function hasTouches(e) {
  var originalEvent = e.originalEvent,
      pointers = e.pointers;

  if (isNativeTouchEvent(e)) {
    return (originalEvent.touches || []).length;
  }

  if (isDxEvent(e)) {
    return (pointers || []).length;
  }

  return 0;
}; // TODO: for tests


exports.hasTouches = hasTouches;
var skipEvents = false;

var forceSkipEvents = function forceSkipEvents() {
  return skipEvents = true;
};

exports.forceSkipEvents = forceSkipEvents;

var stopEventsSkipping = function stopEventsSkipping() {
  return skipEvents = false;
};

exports.stopEventsSkipping = stopEventsSkipping;

var needSkipEvent = function needSkipEvent(e) {
  // TODO: for tests
  if (skipEvents) {
    return true;
  } // TODO: this checking used in swipeable first move handler. is it correct?


  var target = e.target;
  var $target = (0, _renderer.default)(target);
  var isContentEditable = (target === null || target === void 0 ? void 0 : target.isContentEditable) || (target === null || target === void 0 ? void 0 : target.hasAttribute('contenteditable'));
  var touchInEditable = $target.is('input, textarea, select') || isContentEditable;

  if ($target.is('.dx-skip-gesture-event *, .dx-skip-gesture-event')) {
    return true;
  }

  if (isDxMouseWheelEvent(e)) {
    var isTextArea = $target.is('textarea') && $target.hasClass('dx-texteditor-input');

    if (isTextArea || isContentEditable) {
      return false;
    }

    var isInputFocused = $target.is('input[type=\'number\'], textarea, select') && $target.is(':focus');
    return isInputFocused;
  }

  if (isMouseEvent(e)) {
    return touchInEditable || e.which > 1; // only left mouse button
  }

  if (isTouchEvent(e)) {
    return touchInEditable && (0, _selectors.focused)($target);
  }
};

exports.needSkipEvent = needSkipEvent;

var setEventFixMethod = function setEventFixMethod(func) {
  return fixMethod = func;
};

exports.setEventFixMethod = setEventFixMethod;

var createEvent = function createEvent(originalEvent, args) {
  var event = copyEvent(originalEvent);
  args && (0, _extend.extend)(event, args);
  return event;
};

exports.createEvent = createEvent;

var fireEvent = function fireEvent(props) {
  var originalEvent = props.originalEvent,
      delegateTarget = props.delegateTarget;
  var event = createEvent(originalEvent, props);

  _events_engine.default.trigger(delegateTarget || event.target, event);

  return event;
};

exports.fireEvent = fireEvent;

var normalizeKeyName = function normalizeKeyName(_ref4) {
  var key = _ref4.key,
      which = _ref4.which;
  var isKeySupported = !!key;
  key = isKeySupported ? key : which;

  if (key) {
    if (isKeySupported) {
      key = KEY_MAP[key.toLowerCase()] || key;
    } else {
      key = LEGACY_KEY_CODES[key] || String.fromCharCode(key);
    }

    return key;
  }
};

exports.normalizeKeyName = normalizeKeyName;

var getChar = function getChar(_ref5) {
  var key = _ref5.key,
      which = _ref5.which;
  return key || String.fromCharCode(which);
};

exports.getChar = getChar;
var addNamespace = _add_namespace.default;
exports.addNamespace = addNamespace;

var isCommandKeyPressed = function isCommandKeyPressed(_ref6) {
  var ctrlKey = _ref6.ctrlKey,
      metaKey = _ref6.metaKey;
  return ctrlKey || metaKey;
};

exports.isCommandKeyPressed = isCommandKeyPressed;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _component_registrator_callbacks = _interopRequireDefault(__webpack_require__(144));

var _errors = _interopRequireDefault(__webpack_require__(24));

var _public_component = __webpack_require__(143);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var registerComponent = function registerComponent(name, namespace, componentClass) {
  if (!componentClass) {
    componentClass = namespace;
  } else {
    namespace[name] = componentClass;
  }

  (0, _public_component.name)(componentClass, name);

  _component_registrator_callbacks.default.fire(name, componentClass);
};

var registerRendererComponent = function registerRendererComponent(name, componentClass) {
  _renderer.default.fn[name] = function (options) {
    var isMemberInvoke = typeof options === 'string';
    var result;

    if (isMemberInvoke) {
      var memberName = options;
      var memberArgs = [].slice.call(arguments).slice(1);
      this.each(function () {
        var instance = componentClass.getInstance(this);

        if (!instance) {
          throw _errors.default.Error('E0009', name);
        }

        var member = instance[memberName];
        var memberValue = member.apply(instance, memberArgs);

        if (result === undefined) {
          result = memberValue;
        }
      });
    } else {
      this.each(function () {
        var instance = componentClass.getInstance(this);

        if (instance) {
          instance.option(options);
        } else {
          new componentClass(this, options);
        }
      });
      result = this;
    }

    return result;
  };
};

_component_registrator_callbacks.default.add(registerRendererComponent);

var _default = registerComponent;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _dependency_injector = _interopRequireDefault(__webpack_require__(55));

var _extend = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _string = __webpack_require__(40);

var _inflector = __webpack_require__(41);

var _core = _interopRequireDefault(__webpack_require__(85));

var _default_messages = __webpack_require__(373);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var baseDictionary = (0, _extend.extend)(true, {}, _default_messages.defaultMessages);

var getDataByLocale = function getDataByLocale(localeData, locale) {
  return localeData[locale] || {};
};

var newMessages = {};
var messageLocalization = (0, _dependency_injector.default)({
  engine: function engine() {
    return 'base';
  },
  _dictionary: baseDictionary,
  load: function load(messages) {
    (0, _extend.extend)(true, this._dictionary, messages);
  },
  _localizablePrefix: '@',
  setup: function setup(localizablePrefix) {
    this._localizablePrefix = localizablePrefix;
  },
  localizeString: function localizeString(text) {
    var that = this;
    var regex = new RegExp('(^|[^a-zA-Z_0-9' + that._localizablePrefix + '-]+)(' + that._localizablePrefix + '{1,2})([a-zA-Z_0-9-]+)', 'g');
    var escapeString = that._localizablePrefix + that._localizablePrefix;
    return text.replace(regex, function (str, prefix, escape, localizationKey) {
      var defaultResult = that._localizablePrefix + localizationKey;
      var result;

      if (escape !== escapeString) {
        result = that.format(localizationKey);
      }

      if (!result) {
        newMessages[localizationKey] = (0, _inflector.humanize)(localizationKey);
      }

      return prefix + (result || defaultResult);
    });
  },
  localizeNode: function localizeNode(node) {
    var that = this;
    (0, _renderer.default)(node).each(function (index, nodeItem) {
      if (!nodeItem.nodeType) {
        return;
      }

      if (nodeItem.nodeType === 3) {
        nodeItem.nodeValue = that.localizeString(nodeItem.nodeValue);
      } else {
        if (!(0, _renderer.default)(nodeItem).is('iframe')) {
          // T199912
          (0, _iterator.each)(nodeItem.attributes || [], function (index, attr) {
            if (typeof attr.value === 'string') {
              var localizedValue = that.localizeString(attr.value);

              if (attr.value !== localizedValue) {
                attr.value = localizedValue;
              }
            }
          });
          (0, _renderer.default)(nodeItem).contents().each(function (index, node) {
            that.localizeNode(node);
          });
        }
      }
    });
  },
  getMessagesByLocales: function getMessagesByLocales() {
    return this._dictionary;
  },
  getDictionary: function getDictionary(onlyNew) {
    if (onlyNew) {
      return newMessages;
    }

    return (0, _extend.extend)({}, newMessages, this.getMessagesByLocales()[_core.default.locale()]);
  },
  getFormatter: function getFormatter(key) {
    return this._getFormatterBase(key) || this._getFormatterBase(key, 'en');
  },
  _getFormatterBase: function _getFormatterBase(key, locale) {
    var _this = this;

    var message = _core.default.getValueByClosestLocale(function (locale) {
      return getDataByLocale(_this._dictionary, locale)[key];
    });

    if (message) {
      return function () {
        var args = arguments.length === 1 && Array.isArray(arguments[0]) ? arguments[0].slice(0) : Array.prototype.slice.call(arguments, 0);
        args.unshift(message);
        return _string.format.apply(this, args);
      };
    }
  },
  format: function format(key) {
    var formatter = this.getFormatter(key);
    var values = Array.prototype.slice.call(arguments, 1);
    return formatter && formatter.apply(this, values) || '';
  }
});
var _default = messageLocalization;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _dependency_injector = _interopRequireDefault(__webpack_require__(55));

var _common = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var DOCUMENT_NODE = 9;
var nativeDOMAdapterStrategy = {
  querySelectorAll: function querySelectorAll(element, selector) {
    return element.querySelectorAll(selector);
  },
  elementMatches: function elementMatches(element, selector) {
    var _this = this;

    var matches = element.matches || element.matchesSelector || element.mozMatchesSelector || element.msMatchesSelector || element.oMatchesSelector || element.webkitMatchesSelector || function (selector) {
      var doc = element.document || element.ownerDocument;

      if (!doc) {
        return false;
      }

      var items = _this.querySelectorAll(doc, selector);

      for (var i = 0; i < items.length; i++) {
        if (items[i] === element) {
          return true;
        }
      }
    };

    return matches.call(element, selector);
  },
  createElement: function createElement(tagName, context) {
    context = context || this._document;
    return context.createElement(tagName);
  },
  createElementNS: function createElementNS(ns, tagName, context) {
    context = context || this._document;
    return context.createElementNS(ns, tagName);
  },
  createTextNode: function createTextNode(text, context) {
    context = context || this._document;
    return context.createTextNode(text);
  },
  isNode: function isNode(element) {
    return element && _typeof(element) === 'object' && 'nodeType' in element && 'nodeName' in element;
  },
  isElementNode: function isElementNode(element) {
    return element && element.nodeType === ELEMENT_NODE;
  },
  isTextNode: function isTextNode(element) {
    return element && element.nodeType === TEXT_NODE;
  },
  isDocument: function isDocument(element) {
    return element && element.nodeType === DOCUMENT_NODE;
  },
  removeElement: function removeElement(element) {
    var parentNode = element && element.parentNode;

    if (parentNode) {
      parentNode.removeChild(element);
    }
  },
  insertElement: function insertElement(parentElement, newElement, nextSiblingElement) {
    if (parentElement && newElement && parentElement !== newElement) {
      if (nextSiblingElement) {
        parentElement.insertBefore(newElement, nextSiblingElement);
      } else {
        parentElement.appendChild(newElement);
      }
    }
  },
  getAttribute: function getAttribute(element, name) {
    return element.getAttribute(name);
  },
  setAttribute: function setAttribute(element, name, value) {
    element.setAttribute(name, value);
  },
  removeAttribute: function removeAttribute(element, name) {
    element.removeAttribute(name);
  },
  setProperty: function setProperty(element, name, value) {
    element[name] = value;
  },
  setText: function setText(element, text) {
    if (element) {
      element.textContent = text;
    }
  },
  setClass: function setClass(element, className, isAdd) {
    if (element.nodeType === 1 && className) {
      if (element.classList) {
        if (isAdd) {
          element.classList.add(className);
        } else {
          element.classList.remove(className);
        }
      } else {
        // IE9
        var classNameSupported = typeof element.className === 'string';
        var elementClass = classNameSupported ? element.className : this.getAttribute(element, 'class') || '';
        var classNames = elementClass.split(' ');
        var classIndex = classNames.indexOf(className);
        var resultClassName;

        if (isAdd && classIndex < 0) {
          resultClassName = elementClass ? elementClass + ' ' + className : className;
        }

        if (!isAdd && classIndex >= 0) {
          classNames.splice(classIndex, 1);
          resultClassName = classNames.join(' ');
        }

        if (resultClassName !== undefined) {
          if (classNameSupported) {
            element.className = resultClassName;
          } else {
            this.setAttribute(element, 'class', resultClassName);
          }
        }
      }
    }
  },
  setStyle: function setStyle(element, name, value) {
    element.style[name] = value || '';
  },
  _document: typeof document === 'undefined' ? undefined : document,
  getDocument: function getDocument() {
    return this._document;
  },
  getActiveElement: function getActiveElement() {
    return this._document.activeElement;
  },
  getBody: function getBody() {
    return this._document.body;
  },
  createDocumentFragment: function createDocumentFragment() {
    return this._document.createDocumentFragment();
  },
  getDocumentElement: function getDocumentElement() {
    return this._document.documentElement;
  },
  getLocation: function getLocation() {
    return this._document.location;
  },
  getSelection: function getSelection() {
    return this._document.selection;
  },
  getReadyState: function getReadyState() {
    return this._document.readyState;
  },
  getHead: function getHead() {
    return this._document.head;
  },
  hasDocumentProperty: function hasDocumentProperty(property) {
    return property in this._document;
  },
  listen: function listen(element, event, callback, options) {
    if (!element || !('addEventListener' in element)) {
      return _common.noop;
    }

    element.addEventListener(event, callback, options);
    return function () {
      element.removeEventListener(event, callback);
    };
  }
};

var _default = (0, _dependency_injector.default)(nativeDOMAdapterStrategy);

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.groupBy = exports.find = exports.merge = exports.normalizeIndexes = exports.removeDuplicates = exports.uniqueValues = exports.intersection = exports.inArray = exports.wrapToArray = exports.isEmpty = void 0;

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

var _object = __webpack_require__(52);

var _config = _interopRequireDefault(__webpack_require__(29));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var isEmpty = function isEmpty(entity) {
  return Array.isArray(entity) && !entity.length;
};

exports.isEmpty = isEmpty;

var wrapToArray = function wrapToArray(entity) {
  return Array.isArray(entity) ? entity : [entity];
};

exports.wrapToArray = wrapToArray;

var inArray = function inArray(value, object) {
  if (!object) {
    return -1;
  }

  var array = Array.isArray(object) ? object : object.toArray();
  return array.indexOf(value);
};

exports.inArray = inArray;

var intersection = function intersection(a, b) {
  if (!Array.isArray(a) || a.length === 0 || !Array.isArray(b) || b.length === 0) {
    return [];
  }

  var result = [];
  (0, _iterator.each)(a, function (_, value) {
    var index = inArray(value, b);

    if (index !== -1) {
      result.push(value);
    }
  });
  return result;
};

exports.intersection = intersection;

var uniqueValues = function uniqueValues(data) {
  return data.filter(function (item, position) {
    return data.indexOf(item) === position;
  });
};

exports.uniqueValues = uniqueValues;

var removeDuplicates = function removeDuplicates(from, what) {
  if (!Array.isArray(from) || from.length === 0) {
    return [];
  }

  if (!Array.isArray(what) || what.length === 0) {
    return from.slice();
  }

  var result = [];
  (0, _iterator.each)(from, function (_, value) {
    var index = inArray(value, what);

    if (index === -1) {
      result.push(value);
    }
  });
  return result;
};

exports.removeDuplicates = removeDuplicates;

var normalizeIndexes = function normalizeIndexes(items, indexParameterName, currentItem, needIndexCallback) {
  var indexedItems = {};
  var parameterIndex = 0;
  var useLegacyVisibleIndex = (0, _config.default)().useLegacyVisibleIndex;
  (0, _iterator.each)(items, function (index, item) {
    index = item[indexParameterName];

    if (index >= 0) {
      indexedItems[index] = indexedItems[index] || [];

      if (item === currentItem) {
        indexedItems[index].unshift(item);
      } else {
        indexedItems[index].push(item);
      }
    } else {
      item[indexParameterName] = undefined;
    }
  });

  if (!useLegacyVisibleIndex) {
    (0, _iterator.each)(items, function () {
      if (!(0, _type.isDefined)(this[indexParameterName]) && (!needIndexCallback || needIndexCallback(this))) {
        while (indexedItems[parameterIndex]) {
          parameterIndex++;
        }

        indexedItems[parameterIndex] = [this];
        parameterIndex++;
      }
    });
  }

  parameterIndex = 0;
  (0, _object.orderEach)(indexedItems, function (index, items) {
    (0, _iterator.each)(items, function () {
      if (index >= 0) {
        this[indexParameterName] = parameterIndex++;
      }
    });
  });

  if (useLegacyVisibleIndex) {
    (0, _iterator.each)(items, function () {
      if (!(0, _type.isDefined)(this[indexParameterName]) && (!needIndexCallback || needIndexCallback(this))) {
        this[indexParameterName] = parameterIndex++;
      }
    });
  }

  return parameterIndex;
};

exports.normalizeIndexes = normalizeIndexes;

var merge = function merge(array1, array2) {
  for (var i = 0; i < array2.length; i++) {
    array1[array1.length] = array2[i];
  }

  return array1;
};

exports.merge = merge;

var find = function find(array, condition) {
  for (var i = 0; i < array.length; i++) {
    if (condition(array[i])) {
      return array[i];
    }
  }
};

exports.find = find;

var groupBy = function groupBy(array, cb) {
  return array.reduce(function (result, item) {
    return _extends({}, result, _defineProperty({}, cb(item), [].concat(_toConsumableArray(result[cb(item)] || []), [item])));
  }, {});
};

exports.groupBy = groupBy;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _window = __webpack_require__(7);

var _extend = __webpack_require__(0);

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

var _errors = _interopRequireDefault(__webpack_require__(24));

var _callbacks = _interopRequireDefault(__webpack_require__(28));

var _ready_callbacks = _interopRequireDefault(__webpack_require__(51));

var _resize_callbacks = _interopRequireDefault(__webpack_require__(103));

var _events_strategy = __webpack_require__(96);

var _storage = __webpack_require__(278);

var _view_port = __webpack_require__(77);

var _config = _interopRequireDefault(__webpack_require__(29));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var navigator = (0, _window.getNavigator)();
var window = (0, _window.getWindow)();
var KNOWN_UA_TABLE = {
  'iPhone': 'iPhone',
  'iPhone5': 'iPhone',
  'iPhone6': 'iPhone',
  'iPhone6plus': 'iPhone',
  'iPad': 'iPad',
  'iPadMini': 'iPad Mini',
  'androidPhone': 'Android Mobile',
  'androidTablet': 'Android',
  'msSurface': 'Windows ARM Tablet PC',
  'desktop': 'desktop'
};
var DEFAULT_DEVICE = {
  deviceType: 'desktop',
  platform: 'generic',
  version: [],
  phone: false,
  tablet: false,
  android: false,
  ios: false,
  generic: true,
  grade: 'A',
  // TODO: For internal use (draft, do not document these options!)
  mac: false
};
var uaParsers = {
  generic: function generic(userAgent) {
    var isPhone = /windows phone/i.test(userAgent) || userAgent.match(/WPDesktop/);
    var isTablet = !isPhone && /Windows(.*)arm(.*)Tablet PC/i.test(userAgent);
    var isDesktop = !isPhone && !isTablet && /msapphost/i.test(userAgent);
    var isMac = /((intel|ppc) mac os x)/.test(userAgent.toLowerCase());

    if (!(isPhone || isTablet || isDesktop || isMac)) {
      return;
    }

    return {
      deviceType: isPhone ? 'phone' : isTablet ? 'tablet' : 'desktop',
      platform: 'generic',
      version: [],
      grade: 'A',
      mac: isMac
    };
  },
  ios: function ios(userAgent) {
    if (!/ip(hone|od|ad)/i.test(userAgent)) {
      return;
    }

    var isPhone = /ip(hone|od)/i.test(userAgent);
    var matches = userAgent.match(/os (\d+)_(\d+)_?(\d+)?/i);
    var version = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [];
    var isIPhone4 = window.screen.height === 960 / 2;
    var grade = isIPhone4 ? 'B' : 'A';
    return {
      deviceType: isPhone ? 'phone' : 'tablet',
      platform: 'ios',
      version: version,
      grade: grade
    };
  },
  android: function android(userAgent) {
    if (!/android|htc_|silk/i.test(userAgent)) {
      return;
    }

    var isPhone = /mobile/i.test(userAgent);
    var matches = userAgent.match(/android (\d+)\.?(\d+)?\.?(\d+)?/i);
    var version = matches ? [parseInt(matches[1], 10), parseInt(matches[2] || 0, 10), parseInt(matches[3] || 0, 10)] : [];
    var worseThan4_4 = version.length > 1 && (version[0] < 4 || version[0] === 4 && version[1] < 4);
    var grade = worseThan4_4 ? 'B' : 'A';
    return {
      deviceType: isPhone ? 'phone' : 'tablet',
      platform: 'android',
      version: version,
      grade: grade
    };
  }
};

var Devices = /*#__PURE__*/function () {
  /**
  * @name DevicesObject.ctor
  * @publicName ctor(options)
  * @param1 options:object
  * @param1_field1 window:Window
  * @hidden
  */
  function Devices(options) {
    this._window = (options === null || options === void 0 ? void 0 : options.window) || window;
    this._realDevice = this._getDevice();
    this._currentDevice = undefined;
    this._currentOrientation = undefined;
    this._eventsStrategy = new _events_strategy.EventsStrategy(this);
    this.changed = (0, _callbacks.default)();

    if ((0, _window.hasWindow)()) {
      _ready_callbacks.default.add(this._recalculateOrientation.bind(this));

      _resize_callbacks.default.add(this._recalculateOrientation.bind(this));
    }
  }

  var _proto = Devices.prototype;

  _proto.current = function current(deviceOrName) {
    if (deviceOrName) {
      this._currentDevice = this._getDevice(deviceOrName);
      this._forced = true;
      this.changed.fire();
      return;
    }

    if (!this._currentDevice) {
      deviceOrName = undefined;

      try {
        deviceOrName = this._getDeviceOrNameFromWindowScope();
      } catch (e) {
        deviceOrName = this._getDeviceNameFromSessionStorage();
      } finally {
        if (!deviceOrName) {
          deviceOrName = this._getDeviceNameFromSessionStorage();
        }

        if (deviceOrName) {
          this._forced = true;
        }
      }

      this._currentDevice = this._getDevice(deviceOrName);
    }

    return this._currentDevice;
  };

  _proto.real = function real(forceDevice) {
    return (0, _extend.extend)({}, this._realDevice);
  };

  _proto.orientation = function orientation() {
    return this._currentOrientation;
  };

  _proto.isForced = function isForced() {
    return this._forced;
  };

  _proto.isRippleEmulator = function isRippleEmulator() {
    return !!this._window.tinyHippos;
  };

  _proto._getCssClasses = function _getCssClasses(device) {
    var result = [];
    var realDevice = this._realDevice;
    device = device || this.current(); // TODO: use real device here?

    if (device.deviceType) {
      result.push("dx-device-".concat(device.deviceType));

      if (device.deviceType !== 'desktop') {
        result.push('dx-device-mobile');
      }
    }

    result.push("dx-device-".concat(realDevice.platform));

    if (realDevice.version && realDevice.version.length) {
      result.push("dx-device-".concat(realDevice.platform, "-").concat(realDevice.version[0]));
    }

    if (this.isSimulator()) {
      result.push('dx-simulator');
    }

    if ((0, _config.default)().rtlEnabled) {
      result.push('dx-rtl');
    }

    return result;
  };

  _proto.attachCssClasses = function attachCssClasses(element, device) {
    this._deviceClasses = this._getCssClasses(device).join(' ');
    (0, _renderer.default)(element).addClass(this._deviceClasses);
  };

  _proto.detachCssClasses = function detachCssClasses(element) {
    (0, _renderer.default)(element).removeClass(this._deviceClasses);
  };

  _proto.isSimulator = function isSimulator() {
    // NOTE: error may happen due to same-origin policy
    try {
      return this._isSimulator || (0, _window.hasWindow)() && this._window.top !== this._window.self && this._window.top['dx-force-device'] || this.isRippleEmulator();
    } catch (e) {
      return false;
    }
  };

  _proto.forceSimulator = function forceSimulator() {
    this._isSimulator = true;
  };

  _proto._getDevice = function _getDevice(deviceName) {
    if (deviceName === 'genericPhone') {
      deviceName = {
        deviceType: 'phone',
        platform: 'generic',
        generic: true
      };
    }

    if ((0, _type.isPlainObject)(deviceName)) {
      return this._fromConfig(deviceName);
    } else {
      var ua;

      if (deviceName) {
        ua = KNOWN_UA_TABLE[deviceName];

        if (!ua) {
          throw _errors.default.Error('E0005');
        }
      } else {
        ua = navigator.userAgent;
      }

      return this._fromUA(ua);
    }
  };

  _proto._getDeviceOrNameFromWindowScope = function _getDeviceOrNameFromWindowScope() {
    var result;

    if ((0, _window.hasWindow)() && (this._window.top['dx-force-device-object'] || this._window.top['dx-force-device'])) {
      result = this._window.top['dx-force-device-object'] || this._window.top['dx-force-device'];
    }

    return result;
  };

  _proto._getDeviceNameFromSessionStorage = function _getDeviceNameFromSessionStorage() {
    var sessionStorage = (0, _storage.sessionStorage)();

    if (!sessionStorage) {
      return;
    }

    var deviceOrName = sessionStorage.getItem('dx-force-device');

    try {
      return JSON.parse(deviceOrName);
    } catch (ex) {
      return deviceOrName;
    }
  };

  _proto._fromConfig = function _fromConfig(config) {
    var result = (0, _extend.extend)({}, DEFAULT_DEVICE, this._currentDevice, config);
    var shortcuts = {
      phone: result.deviceType === 'phone',
      tablet: result.deviceType === 'tablet',
      android: result.platform === 'android',
      ios: result.platform === 'ios',
      generic: result.platform === 'generic'
    };
    return (0, _extend.extend)(result, shortcuts);
  };

  _proto._fromUA = function _fromUA(ua) {
    var config;
    (0, _iterator.each)(uaParsers, function (platform, parser) {
      config = parser(ua);
      return !config;
    });

    if (config) {
      return this._fromConfig(config);
    }

    return DEFAULT_DEVICE;
  };

  _proto._changeOrientation = function _changeOrientation() {
    var $window = (0, _renderer.default)(this._window);
    var orientation = $window.height() > $window.width() ? 'portrait' : 'landscape';

    if (this._currentOrientation === orientation) {
      return;
    }

    this._currentOrientation = orientation;

    this._eventsStrategy.fireEvent('orientationChanged', [{
      orientation: orientation
    }]);
  };

  _proto._recalculateOrientation = function _recalculateOrientation() {
    var windowWidth = (0, _renderer.default)(this._window).width();

    if (this._currentWidth === windowWidth) {
      return;
    }

    this._currentWidth = windowWidth;

    this._changeOrientation();
  };

  _proto.on = function on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);

    return this;
  };

  _proto.off = function off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);

    return this;
  };

  return Devices;
}();

var devices = new Devices();

_view_port.changeCallback.add(function (viewPort, prevViewport) {
  devices.detachCssClasses(prevViewport);
  devices.attachCssClasses(viewPort);
});

var _default = devices;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.map = map;
exports.normalizeEnum = normalizeEnum;
exports.setCanvasValues = setCanvasValues;
exports.normalizeBBox = normalizeBBox;
exports.rotateBBox = rotateBBox;
exports.convertPolarToXY = convertPolarToXY;
exports.isRelativeHeightPane = isRelativeHeightPane;
exports.normalizePanesHeight = normalizePanesHeight;
exports.updatePanesCanvases = updatePanesCanvases;
exports.mergeMarginOptions = mergeMarginOptions;
exports.getVizRangeObject = getVizRangeObject;
exports.convertVisualRangeObject = convertVisualRangeObject;
exports.getAddFunction = getAddFunction;
exports.adjustVisualRange = adjustVisualRange;
exports.getLogExt = getLogExt;
exports.raiseToExt = raiseToExt;
exports.rangesAreEqual = rangesAreEqual;
exports.valueOf = valueOf;
exports.pointInCanvas = pointInCanvas;
exports.getVerticallyShiftedAngularCoords = exports.unique = exports.getCategoriesInfo = exports.processSeriesTemplate = exports.convertXYToPolar = exports.patchFontOptions = exports.enumParser = exports.parseScalar = exports.decreaseGaps = exports.getPower = exports.roundValue = exports.getAppropriateFormat = exports.getDecimalOrder = exports.getDistance = exports.getCosAndSin = exports.degreesToRadians = exports.convertAngleToRendererSpace = exports.normalizeAngle = exports.raiseTo = exports.getAdjustedLog10 = exports.getLog = exports.PANE_PADDING = void 0;

var _common = __webpack_require__(4);

var _type = __webpack_require__(1);

var _extend = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _math = __webpack_require__(31);

var _date = _interopRequireDefault(__webpack_require__(18));

var _color = _interopRequireDefault(__webpack_require__(102));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PI = Math.PI,
    LN10 = Math.LN10,
    abs = Math.abs,
    log = Math.log,
    floor = Math.floor,
    ceil = Math.ceil,
    pow = Math.pow,
    sqrt = Math.sqrt,
    atan2 = Math.atan2;
var _min = Math.min;
var _max = Math.max;
var _cos = Math.cos;
var _sin = Math.sin;
var _round = Math.round;
var dateToMilliseconds = _date.default.dateToMilliseconds;
var MAX_PIXEL_COUNT = 1E10;
var PI_DIV_180 = PI / 180;
var _isNaN = isNaN;
var _Number = Number;
var _NaN = NaN;
var PANE_PADDING = 10;
exports.PANE_PADDING = PANE_PADDING;

var getLog = function getLog(value, base) {
  if (!value) {
    return _NaN;
  }

  return log(value) / log(base);
};

exports.getLog = getLog;

var getAdjustedLog10 = function getAdjustedLog10(value) {
  return (0, _math.adjust)(getLog(value, 10));
};

exports.getAdjustedLog10 = getAdjustedLog10;

var raiseTo = function raiseTo(power, base) {
  return pow(base, power);
}; //  Translates angle to [0, 360)
//  Expects number, no validation


exports.raiseTo = raiseTo;

var normalizeAngle = function normalizeAngle(angle) {
  return (angle % 360 + 360) % 360;
}; //  Maps angle in trigonometric space to angle in 'renderer' space
//  Expects numbers, no validation


exports.normalizeAngle = normalizeAngle;

var convertAngleToRendererSpace = function convertAngleToRendererSpace(angle) {
  return 90 - angle;
}; //  Maps angle in degrees to angle in radians
//  Expects number, no validation


exports.convertAngleToRendererSpace = convertAngleToRendererSpace;

var degreesToRadians = function degreesToRadians(value) {
  return PI * value / 180;
}; //  Calculates sin and cos for <angle> in degrees
//  Expects number, no validation


exports.degreesToRadians = degreesToRadians;

var getCosAndSin = function getCosAndSin(angle) {
  var angleInRadians = degreesToRadians(angle);
  return {
    cos: _cos(angleInRadians),
    sin: _sin(angleInRadians)
  };
}; //  Because Math.log(1000) / Math.LN10 < 3 though it is exactly 3
//  Same happens for 1E6, 1E9, 1E12, 1E13, 1E15, ...


exports.getCosAndSin = getCosAndSin;
var DECIMAL_ORDER_THRESHOLD = 1E-14; //    ____________________
//   /       2          2
// \/ (y2-y1)  + (x2-x1)

var getDistance = function getDistance(x1, y1, x2, y2) {
  var diffX = x2 - x1;
  var diffY = y2 - y1;
  return sqrt(diffY * diffY + diffX * diffX);
};

exports.getDistance = getDistance;

var getDecimalOrder = function getDecimalOrder(number) {
  var n = abs(number);
  var cn;

  if (!_isNaN(n)) {
    if (n > 0) {
      n = log(n) / LN10;
      cn = ceil(n);
      return cn - n < DECIMAL_ORDER_THRESHOLD ? cn : floor(n);
    }

    return 0;
  }

  return _NaN;
};

exports.getDecimalOrder = getDecimalOrder;

var getAppropriateFormat = function getAppropriateFormat(start, end, count) {
  var order = _max(getDecimalOrder(start), getDecimalOrder(end));

  var precision = -getDecimalOrder(abs(end - start) / count);
  var format;

  if (!_isNaN(order) && !_isNaN(precision)) {
    if (abs(order) <= 4) {
      format = 'fixedPoint';
      precision < 0 && (precision = 0);
      precision > 4 && (precision = 4);
    } else {
      format = 'exponential';
      precision += order - 1;
      precision > 3 && (precision = 3);
    }

    return {
      type: format,
      precision: precision
    };
  }

  return null;
};

exports.getAppropriateFormat = getAppropriateFormat;

var roundValue = function roundValue(value, precision) {
  if (precision > 20) {
    precision = 20;
  }

  if ((0, _type.isNumeric)(value)) {
    if ((0, _type.isExponential)(value)) {
      return _Number(value.toExponential(precision));
    } else {
      return _Number(value.toFixed(precision));
    }
  }
};

exports.roundValue = roundValue;

var getPower = function getPower(value) {
  return value.toExponential().split('e')[1];
};

exports.getPower = getPower;

function map(array, callback) {
  var i = 0;
  var len = array.length;
  var result = [];
  var value;

  while (i < len) {
    value = callback(array[i], i);

    if (value !== null) {
      result.push(value);
    }

    i++;
  }

  return result;
}

function selectByKeys(object, keys) {
  return map(keys, function (key) {
    return object[key] ? object[key] : null;
  });
}

function decreaseFields(object, keys, eachDecrease, decrease) {
  var dec = decrease;
  (0, _iterator.each)(keys, function (_, key) {
    if (object[key]) {
      object[key] -= eachDecrease;
      dec -= eachDecrease;
    }
  });
  return dec;
}

function normalizeEnum(value) {
  return String(value).toLowerCase();
}

function setCanvasValues(canvas) {
  if (canvas) {
    canvas.originalTop = canvas.top;
    canvas.originalBottom = canvas.bottom;
    canvas.originalLeft = canvas.left;
    canvas.originalRight = canvas.right;
  }

  return canvas;
}

function normalizeBBoxField(value) {
  return -MAX_PIXEL_COUNT < value && value < +MAX_PIXEL_COUNT ? value : 0;
}

function normalizeBBox(bBox) {
  var xl = normalizeBBoxField(floor(bBox.x));
  var yt = normalizeBBoxField(floor(bBox.y));
  var xr = normalizeBBoxField(ceil(bBox.width + bBox.x));
  var yb = normalizeBBoxField(ceil(bBox.height + bBox.y));
  var result = {
    x: xl,
    y: yt,
    width: xr - xl,
    height: yb - yt
  };
  result.isEmpty = !result.x && !result.y && !result.width && !result.height;
  return result;
} // Angle is expected to be from right-handed cartesian (not svg) space - positive is counterclockwise


function rotateBBox(bBox, center, angle) {
  var cos = _Number(_cos(angle * PI_DIV_180).toFixed(3));

  var sin = _Number(_sin(angle * PI_DIV_180).toFixed(3));

  var w2 = bBox.width / 2;
  var h2 = bBox.height / 2;
  var centerX = bBox.x + w2;
  var centerY = bBox.y + h2;
  var w2_ = abs(w2 * cos) + abs(h2 * sin);
  var h2_ = abs(w2 * sin) + abs(h2 * cos); // Note that the following slightly differs from theoretical formula:
  // x' = x * cos - y * sin, y' = x * sin + y * cos
  // That is because in svg y goes down (not up) - so sign of sin is reverted
  // x' = x * cos + y * sin, y' = -x * sin + y * cos

  var centerX_ = center[0] + (centerX - center[0]) * cos + (centerY - center[1]) * sin;
  var centerY_ = center[1] - (centerX - center[0]) * sin + (centerY - center[1]) * cos;
  return normalizeBBox({
    x: centerX_ - w2_,
    y: centerY_ - h2_,
    width: 2 * w2_,
    height: 2 * h2_
  });
}

var decreaseGaps = function decreaseGaps(object, keys, decrease) {
  var arrayGaps;

  do {
    arrayGaps = selectByKeys(object, keys);
    arrayGaps.push(ceil(decrease / arrayGaps.length));
    decrease = decreaseFields(object, keys, _min.apply(null, arrayGaps), decrease);
  } while (decrease > 0 && arrayGaps.length > 1);

  return decrease;
};

exports.decreaseGaps = decreaseGaps;

var parseScalar = function parseScalar(value, defaultValue) {
  return value !== undefined ? value : defaultValue;
};

exports.parseScalar = parseScalar;

var enumParser = function enumParser(values) {
  var stored = {};
  var i;
  var ii;

  for (i = 0, ii = values.length; i < ii; ++i) {
    stored[normalizeEnum(values[i])] = 1;
  }

  return function (value, defaultValue) {
    var _value = normalizeEnum(value);

    return stored[_value] ? _value : defaultValue;
  };
};

exports.enumParser = enumParser;

var patchFontOptions = function patchFontOptions(options) {
  var fontOptions = {};
  (0, _iterator.each)(options || {}, function (key, value) {
    if (/^(cursor)$/i.test(key)) {// TODO check other properties, add tests
    } else if (key === 'opacity') {
      value = null;
    } else if (key === 'color') {
      key = 'fill';

      if ('opacity' in options) {
        var color = new _color.default(value);
        value = "rgba(".concat(color.r, ",").concat(color.g, ",").concat(color.b, ",").concat(options.opacity, ")");
      }
    } else {
      key = 'font-' + key;
    }

    fontOptions[key] = value;
  });
  return fontOptions;
};

exports.patchFontOptions = patchFontOptions;

function convertPolarToXY(centerCoords, startAngle, angle, radius) {
  var shiftAngle = 90;
  var normalizedRadius = radius > 0 ? radius : 0;
  angle = (0, _type.isDefined)(angle) ? angle + startAngle - shiftAngle : 0;
  var cosSin = getCosAndSin(angle);
  return {
    x: _round(centerCoords.x + normalizedRadius * cosSin.cos),
    y: _round(centerCoords.y + normalizedRadius * cosSin.sin)
  };
}

var convertXYToPolar = function convertXYToPolar(centerCoords, x, y) {
  var radius = getDistance(centerCoords.x, centerCoords.y, x, y);
  var angle = atan2(y - centerCoords.y, x - centerCoords.x);
  return {
    phi: _round(normalizeAngle(angle * 180 / PI)),
    r: _round(radius)
  };
};

exports.convertXYToPolar = convertXYToPolar;

var processSeriesTemplate = function processSeriesTemplate(seriesTemplate, items) {
  var customizeSeries = (0, _type.isFunction)(seriesTemplate.customizeSeries) ? seriesTemplate.customizeSeries : _common.noop;
  var nameField = seriesTemplate.nameField;
  var generatedSeries = {};
  var seriesOrder = [];
  var series;
  var i = 0;
  var length;
  var data;
  items = items || [];

  for (length = items.length; i < length; i++) {
    data = items[i];

    if (nameField in data) {
      series = generatedSeries[data[nameField]];

      if (!series) {
        series = generatedSeries[data[nameField]] = {
          name: data[nameField],
          nameFieldValue: data[nameField]
        };
        seriesOrder.push(series.name);
      }
    }
  }

  return map(seriesOrder, function (orderedName) {
    var group = generatedSeries[orderedName];
    return (0, _extend.extend)(group, customizeSeries.call(null, group.name));
  });
};

exports.processSeriesTemplate = processSeriesTemplate;

var getCategoriesInfo = function getCategoriesInfo(categories, startValue, endValue) {
  if (categories.length === 0) {
    return {
      categories: []
    };
  }

  startValue = (0, _type.isDefined)(startValue) ? startValue : categories[0];
  endValue = (0, _type.isDefined)(endValue) ? endValue : categories[categories.length - 1];
  var categoriesValue = map(categories, function (category) {
    return category === null || category === void 0 ? void 0 : category.valueOf();
  });
  var indexStartValue = categoriesValue.indexOf(startValue.valueOf());
  var indexEndValue = categoriesValue.indexOf(endValue.valueOf());
  var swapBuf;
  var inverted = false;
  indexStartValue < 0 && (indexStartValue = 0);
  indexEndValue < 0 && (indexEndValue = categories.length - 1);

  if (indexEndValue < indexStartValue) {
    swapBuf = indexEndValue;
    indexEndValue = indexStartValue;
    indexStartValue = swapBuf;
    inverted = true;
  }

  var visibleCategories = categories.slice(indexStartValue, indexEndValue + 1);
  var lastIdx = visibleCategories.length - 1;
  return {
    categories: visibleCategories,
    start: visibleCategories[inverted ? lastIdx : 0],
    end: visibleCategories[inverted ? 0 : lastIdx],
    inverted: inverted
  };
};

exports.getCategoriesInfo = getCategoriesInfo;

function isRelativeHeightPane(pane) {
  return !(pane.unit % 2);
}

function normalizePanesHeight(panes) {
  panes.forEach(function (pane) {
    var height = pane.height;
    var unit = 0;
    var parsedHeight = parseFloat(height) || undefined;

    if ((0, _type.isString)(height) && height.indexOf('px') > -1 || (0, _type.isNumeric)(height) && height > 1) {
      parsedHeight = _round(parsedHeight);
      unit = 1;
    }

    if (!unit && parsedHeight) {
      if ((0, _type.isString)(height) && height.indexOf('%') > -1) {
        parsedHeight = parsedHeight / 100;
        unit = 2;
      } else if (parsedHeight < 0) {
        parsedHeight = parsedHeight < -1 ? 1 : abs(parsedHeight);
      }
    }

    pane.height = parsedHeight;
    pane.unit = unit;
  });
  var relativeHeightPanes = panes.filter(isRelativeHeightPane);
  var weightSum = relativeHeightPanes.reduce(function (prev, next) {
    return prev + (next.height || 0);
  }, 0);
  var weightHeightCount = relativeHeightPanes.length;
  var emptyHeightPanes = relativeHeightPanes.filter(function (pane) {
    return !pane.height;
  });
  var emptyHeightCount = emptyHeightPanes.length;

  if (weightSum < 1 && emptyHeightCount) {
    emptyHeightPanes.forEach(function (pane) {
      return pane.height = (1 - weightSum) / emptyHeightCount;
    });
  } else if (weightSum > 1 || weightSum < 1 && !emptyHeightCount || weightSum === 1 && emptyHeightCount) {
    if (emptyHeightCount) {
      var weightForEmpty = weightSum / weightHeightCount;
      var emptyWeightSum = emptyHeightCount * weightForEmpty;
      relativeHeightPanes.filter(function (pane) {
        return pane.height;
      }).forEach(function (pane) {
        return pane.height *= (weightSum - emptyWeightSum) / weightSum;
      });
      emptyHeightPanes.forEach(function (pane) {
        return pane.height = weightForEmpty;
      });
    }

    relativeHeightPanes.forEach(function (pane) {
      return pane.height *= 1 / weightSum;
    });
  }
}

function updatePanesCanvases(panes, canvas, rotated) {
  var distributedSpace = 0;
  var padding = PANE_PADDING;
  var paneSpace = rotated ? canvas.width - canvas.left - canvas.right : canvas.height - canvas.top - canvas.bottom;
  var totalCustomSpace = panes.reduce(function (prev, cur) {
    return prev + (!isRelativeHeightPane(cur) ? cur.height : 0);
  }, 0);
  var usefulSpace = paneSpace - padding * (panes.length - 1) - totalCustomSpace;
  var startName = rotated ? 'left' : 'top';
  var endName = rotated ? 'right' : 'bottom';
  panes.forEach(function (pane) {
    var calcLength = !isRelativeHeightPane(pane) ? pane.height : _round(pane.height * usefulSpace);
    pane.canvas = pane.canvas || {};
    (0, _extend.extend)(pane.canvas, canvas);
    pane.canvas[startName] = canvas[startName] + distributedSpace;
    pane.canvas[endName] = canvas[endName] + (paneSpace - calcLength - distributedSpace);
    distributedSpace = distributedSpace + calcLength + padding;
    setCanvasValues(pane.canvas);
  });
}

var unique = function unique(array) {
  var values = {};
  return map(array, function (item) {
    var result = !values[item] ? item : null;
    values[item] = true;
    return result;
  });
};

exports.unique = unique;

var getVerticallyShiftedAngularCoords = function getVerticallyShiftedAngularCoords(bBox, dy, center) {
  // TODO: Use center instead of left top corner - that is more correct and allows to get rid of "isPositive"
  //   horizontalOffset1 = bBox.x + bBox.width / 2 - center.x
  //   horizontalOffset2 = bBox.y + bBox.height / 2 - center.y
  //   verticalOffset2 = newCoord.y + bBox.height / 2 - center.y
  var isPositive = bBox.x + bBox.width / 2 >= center.x;
  var horizontalOffset1 = (isPositive ? bBox.x : bBox.x + bBox.width) - center.x;
  var verticalOffset1 = bBox.y - center.y;
  var verticalOffset2 = verticalOffset1 + dy;

  var horizontalOffset2 = _round(sqrt(horizontalOffset1 * horizontalOffset1 + verticalOffset1 * verticalOffset1 - verticalOffset2 * verticalOffset2));

  var dx = (isPositive ? +horizontalOffset2 : -horizontalOffset2) || horizontalOffset1;
  return {
    x: center.x + (isPositive ? dx : dx - bBox.width),
    y: bBox.y + dy
  };
};

exports.getVerticallyShiftedAngularCoords = getVerticallyShiftedAngularCoords;

function mergeMarginOptions(opt1, opt2) {
  return {
    checkInterval: opt1.checkInterval || opt2.checkInterval,
    size: _max(opt1.size || 0, opt2.size || 0),
    percentStick: opt1.percentStick || opt2.percentStick,
    sizePointNormalState: _max(opt1.sizePointNormalState || 0, opt2.sizePointNormalState || 0)
  };
}

function getVizRangeObject(value) {
  if (Array.isArray(value)) {
    return {
      startValue: value[0],
      endValue: value[1]
    };
  } else {
    return value || {};
  }
}

function convertVisualRangeObject(visualRange, convertToVisualRange) {
  if (convertToVisualRange) {
    return visualRange;
  }

  return [visualRange.startValue, visualRange.endValue];
}

function getAddFunction(range, correctZeroLevel) {
  // T170398
  if (range.dataType === 'datetime') {
    return function (rangeValue, marginValue) {
      var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      return new Date(rangeValue.getTime() + sign * marginValue);
    };
  }

  if (range.axisType === 'logarithmic') {
    return function (rangeValue, marginValue) {
      var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var log = getLogExt(rangeValue, range.base) + sign * marginValue;
      return raiseToExt(log, range.base);
    };
  }

  return function (rangeValue, marginValue) {
    var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var newValue = rangeValue + sign * marginValue;
    return correctZeroLevel && newValue * rangeValue <= 0 ? 0 : newValue;
  };
}

function adjustVisualRange(options, visualRange, wholeRange, dataRange) {
  var minDefined = (0, _type.isDefined)(visualRange.startValue);
  var maxDefined = (0, _type.isDefined)(visualRange.endValue);
  var nonDiscrete = options.axisType !== 'discrete';
  dataRange = dataRange || wholeRange;
  var add = getAddFunction(options, false);
  var min = minDefined ? visualRange.startValue : dataRange.min;
  var max = maxDefined ? visualRange.endValue : dataRange.max;
  var rangeLength = visualRange.length;
  var categories = dataRange.categories;

  if (nonDiscrete && !(0, _type.isDefined)(min) && !(0, _type.isDefined)(max)) {
    return {
      startValue: min,
      endValue: max
    };
  }

  if ((0, _type.isDefined)(rangeLength)) {
    if (nonDiscrete) {
      if (options.dataType === 'datetime' && !(0, _type.isNumeric)(rangeLength)) {
        rangeLength = dateToMilliseconds(rangeLength);
      }

      if (maxDefined && !minDefined || !maxDefined && !minDefined) {
        (0, _type.isDefined)(wholeRange.max) && (max = max > wholeRange.max ? wholeRange.max : max);
        min = add(max, rangeLength, -1);
      } else if (minDefined && !maxDefined) {
        (0, _type.isDefined)(wholeRange.min) && (min = min < wholeRange.min ? wholeRange.min : min);
        max = add(min, rangeLength);
      }
    } else {
      rangeLength = parseInt(rangeLength);

      if (!isNaN(rangeLength) && isFinite(rangeLength)) {
        rangeLength--;

        if (!maxDefined && !minDefined) {
          max = categories[categories.length - 1];
          min = categories[categories.length - 1 - rangeLength];
        } else if (minDefined && !maxDefined) {
          var categoriesInfo = getCategoriesInfo(categories, min, undefined);
          max = categoriesInfo.categories[rangeLength];
        } else if (!minDefined && maxDefined) {
          var _categoriesInfo = getCategoriesInfo(categories, undefined, max);

          min = _categoriesInfo.categories[_categoriesInfo.categories.length - 1 - rangeLength];
        }
      }
    }
  }

  if (nonDiscrete) {
    if ((0, _type.isDefined)(wholeRange.max) && max > wholeRange.max) {
      max = wholeRange.max;
    }

    if ((0, _type.isDefined)(wholeRange.min) && min < wholeRange.min) {
      min = wholeRange.min;
    }
  }

  return {
    startValue: min,
    endValue: max
  };
}

function getLogExt(value, base) {
  var allowNegatives = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var linearThreshold = arguments.length > 3 ? arguments[3] : undefined;

  if (!allowNegatives) {
    return getLog(value, base);
  }

  if (value === 0) {
    return 0;
  }

  var transformValue = getLog(abs(value), base) - (linearThreshold - 1);

  if (transformValue < 0) {
    return 0;
  }

  return (0, _math.adjust)((0, _math.sign)(value) * transformValue, Number(pow(base, linearThreshold - 1).toFixed(abs(linearThreshold))));
}

function raiseToExt(value, base) {
  var allowNegatives = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var linearThreshold = arguments.length > 3 ? arguments[3] : undefined;

  if (!allowNegatives) {
    return raiseTo(value, base);
  }

  if (value === 0) {
    return 0;
  }

  var transformValue = raiseTo(abs(value) + (linearThreshold - 1), base);

  if (transformValue < 0) {
    return 0;
  }

  return (0, _math.adjust)((0, _math.sign)(value) * transformValue, Number(pow(base, linearThreshold).toFixed(abs(linearThreshold))));
}

function rangesAreEqual(range, rangeFromOptions) {
  if (Array.isArray(rangeFromOptions)) {
    return range.length === rangeFromOptions.length && range.every(function (item, i) {
      return valueOf(item) === valueOf(rangeFromOptions[i]);
    });
  } else {
    return valueOf(range.startValue) === valueOf(rangeFromOptions.startValue) && valueOf(range.endValue) === valueOf(rangeFromOptions.endValue);
  }
}

function valueOf(value) {
  return value && value.valueOf();
}

function pointInCanvas(canvas, x, y) {
  return x >= canvas.left && x <= canvas.right && y >= canvas.top && y <= canvas.bottom;
}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _errors = _interopRequireDefault(__webpack_require__(24));

var _type = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var wrapOverridden = function wrapOverridden(baseProto, methodName, method) {
  return function () {
    var prevCallBase = this.callBase;
    this.callBase = baseProto[methodName];

    try {
      return method.apply(this, arguments);
    } finally {
      this.callBase = prevCallBase;
    }
  };
};

var clonePrototype = function clonePrototype(obj) {
  var func = function func() {};

  func.prototype = obj.prototype;
  return new func();
};

var redefine = function redefine(members) {
  var that = this;
  var overridden;
  var memberName;
  var member;

  if (!members) {
    return that;
  }

  for (memberName in members) {
    member = members[memberName];
    overridden = typeof that.prototype[memberName] === 'function' && typeof member === 'function';
    that.prototype[memberName] = overridden ? wrapOverridden(that.parent.prototype, memberName, member) : member;
  }

  return that;
};

var include = function include() {
  var classObj = this;
  var argument;
  var name;
  var i; // NOTE: For ES6 classes. They don't have _includedCtors/_includedPostCtors
  // properties and get them from the ancestor class.

  var hasClassObjOwnProperty = Object.prototype.hasOwnProperty.bind(classObj);
  var isES6Class = !hasClassObjOwnProperty('_includedCtors') && !hasClassObjOwnProperty('_includedPostCtors');

  if (isES6Class) {
    classObj._includedCtors = classObj._includedCtors.slice(0);
    classObj._includedPostCtors = classObj._includedPostCtors.slice(0);
  }

  for (i = 0; i < arguments.length; i++) {
    argument = arguments[i];

    if (argument.ctor) {
      classObj._includedCtors.push(argument.ctor);
    }

    if (argument.postCtor) {
      classObj._includedPostCtors.push(argument.postCtor);
    }

    for (name in argument) {
      if (name === 'ctor' || name === 'postCtor' || name === 'default') {
        continue;
      }

      classObj.prototype[name] = argument[name];
    }
  }

  return classObj;
};

var subclassOf = function subclassOf(parentClass) {
  var hasParentProperty = Object.prototype.hasOwnProperty.bind(this)('parent');
  var isES6Class = !hasParentProperty && this.parent;

  if (isES6Class) {
    var baseClass = Object.getPrototypeOf(this);
    return baseClass === parentClass || baseClass.subclassOf(parentClass);
  } else {
    if (this.parent === parentClass) {
      return true;
    }

    if (!this.parent || !this.parent.subclassOf) {
      return false;
    }

    return this.parent.subclassOf(parentClass);
  }
};

var abstract = function abstract() {
  throw _errors.default.Error('E0001');
};

var copyStatic = function () {
  var hasOwn = Object.prototype.hasOwnProperty;
  return function (source, destination) {
    for (var key in source) {
      if (!hasOwn.call(source, key)) {
        return;
      }

      destination[key] = source[key];
    }
  };
}();

var classImpl = function classImpl() {};

classImpl.inherit = function (members) {
  var inheritor = function inheritor() {
    if (!this || (0, _type.isWindow)(this) || typeof this.constructor !== 'function') {
      throw _errors.default.Error('E0003');
    }

    var instance = this;
    var ctor = instance.ctor;
    var includedCtors = instance.constructor._includedCtors;
    var includedPostCtors = instance.constructor._includedPostCtors;
    var i;

    for (i = 0; i < includedCtors.length; i++) {
      includedCtors[i].call(instance);
    }

    if (ctor) {
      ctor.apply(instance, arguments);
    }

    for (i = 0; i < includedPostCtors.length; i++) {
      includedPostCtors[i].call(instance);
    }
  };

  inheritor.prototype = clonePrototype(this);
  copyStatic(this, inheritor);
  inheritor.inherit = this.inherit;
  inheritor.abstract = abstract;
  inheritor.redefine = redefine;
  inheritor.include = include;
  inheritor.subclassOf = subclassOf;
  inheritor.parent = this;
  inheritor._includedCtors = this._includedCtors ? this._includedCtors.slice(0) : [];
  inheritor._includedPostCtors = this._includedPostCtors ? this._includedPostCtors.slice(0) : [];
  inheritor.prototype.constructor = inheritor;
  inheritor.redefine(members);
  return inheritor;
};

classImpl.abstract = abstract;
var _default = classImpl;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 16 */,
/* 17 */,
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _type = __webpack_require__(1);

var _math = __webpack_require__(31);

var _iterator = __webpack_require__(3);

var _inflector = __webpack_require__(41);

var _browser = _interopRequireDefault(__webpack_require__(32));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var isIE11 = _browser.default.msie && parseInt(_browser.default.version) <= 11;
var dateUnitIntervals = ['millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'];

var toMilliseconds = function toMilliseconds(value) {
  switch (value) {
    case 'millisecond':
      return 1;

    case 'second':
      return toMilliseconds('millisecond') * 1000;

    case 'minute':
      return toMilliseconds('second') * 60;

    case 'hour':
      return toMilliseconds('minute') * 60;

    case 'day':
      return toMilliseconds('hour') * 24;

    case 'week':
      return toMilliseconds('day') * 7;

    case 'month':
      return toMilliseconds('day') * 30;

    case 'quarter':
      return toMilliseconds('month') * 3;

    case 'year':
      return toMilliseconds('day') * 365;

    default:
      return 0;
  }
};

var getDatesInterval = function getDatesInterval(startDate, endDate, intervalUnit) {
  var delta = endDate.getTime() - startDate.getTime();
  var millisecondCount = toMilliseconds(intervalUnit) || 1;
  return Math.floor(delta / millisecondCount);
};

var getNextDateUnit = function getNextDateUnit(unit, withWeeks) {
  var interval = getDateUnitInterval(unit);

  switch (interval) {
    case 'millisecond':
      return 'second';

    case 'second':
      return 'minute';

    case 'minute':
      return 'hour';

    case 'hour':
      return 'day';

    case 'day':
      return withWeeks ? 'week' : 'month';

    case 'week':
      return 'month';

    case 'month':
      return 'quarter';

    case 'quarter':
      return 'year';

    case 'year':
      return 'year';

    default:
      return 0;
  }
};

var convertMillisecondsToDateUnits = function convertMillisecondsToDateUnits(value) {
  var i;
  var dateUnitCount;
  var dateUnitInterval;
  var dateUnitIntervals = ['millisecond', 'second', 'minute', 'hour', 'day', 'month', 'year'];
  var result = {};

  for (i = dateUnitIntervals.length - 1; i >= 0; i--) {
    dateUnitInterval = dateUnitIntervals[i];
    dateUnitCount = Math.floor(value / toMilliseconds(dateUnitInterval));

    if (dateUnitCount > 0) {
      result[dateUnitInterval + 's'] = dateUnitCount;
      value -= convertDateUnitToMilliseconds(dateUnitInterval, dateUnitCount);
    }
  }

  return result;
};

var dateToMilliseconds = function dateToMilliseconds(tickInterval) {
  var milliseconds = 0;

  if ((0, _type.isObject)(tickInterval)) {
    (0, _iterator.each)(tickInterval, function (key, value) {
      milliseconds += convertDateUnitToMilliseconds(key.substr(0, key.length - 1), value);
    });
  }

  if ((0, _type.isString)(tickInterval)) {
    milliseconds = convertDateUnitToMilliseconds(tickInterval, 1);
  }

  return milliseconds;
};

function convertDateUnitToMilliseconds(dateUnit, count) {
  return toMilliseconds(dateUnit) * count;
} // refactor for performance


function getDateUnitInterval(tickInterval) {
  var maxInterval = -1;
  var i;

  if ((0, _type.isString)(tickInterval)) {
    return tickInterval;
  }

  if ((0, _type.isObject)(tickInterval)) {
    (0, _iterator.each)(tickInterval, function (key, value) {
      for (i = 0; i < dateUnitIntervals.length; i++) {
        if (value && (key === dateUnitIntervals[i] + 's' || key === dateUnitIntervals[i]) && maxInterval < i) {
          maxInterval = i;
        }
      }
    });
    return dateUnitIntervals[maxInterval];
  }

  return '';
} // T375972


var tickIntervalToFormatMap = {
  millisecond: 'millisecond',
  second: 'longtime',
  minute: 'shorttime',
  hour: 'shorttime',
  day: 'day',
  week: 'day',
  month: 'month',
  quarter: 'quarter',
  year: 'year'
}; // Because of changes in formatting (Globalize has been updated) common date formatting has been changed.
// The purpose of the following method is to preserve original dates formatting in axes and range selector slider markers.

function getDateFormatByTickInterval(tickInterval) {
  return tickIntervalToFormatMap[getDateUnitInterval(tickInterval)] || '';
}

var getQuarter = function getQuarter(month) {
  return Math.floor(month / 3);
};

var getFirstQuarterMonth = function getFirstQuarterMonth(month) {
  return getQuarter(month) * 3;
};

function correctDateWithUnitBeginning(date, dateInterval, withCorrection, firstDayOfWeek) {
  date = new Date(date.getTime());
  var oldDate = new Date(date.getTime());
  var firstQuarterMonth;
  var month;
  var dateUnitInterval = getDateUnitInterval(dateInterval);

  switch (dateUnitInterval) {
    case 'second':
      date = new Date(Math.floor(oldDate.getTime() / 1000) * 1000);
      break;

    case 'minute':
      date = new Date(Math.floor(oldDate.getTime() / 60000) * 60000);
      break;

    case 'hour':
      date = new Date(Math.floor(oldDate.getTime() / 3600000) * 3600000);
      break;

    case 'year':
      date.setMonth(0);

    /* falls through */

    case 'month':
      date.setDate(1);

    /* falls through */

    case 'day':
      date.setHours(0, 0, 0, 0);
      break;

    case 'week':
      date = getFirstWeekDate(date, firstDayOfWeek || 0);
      date.setHours(0, 0, 0, 0);
      break;

    case 'quarter':
      firstQuarterMonth = getFirstQuarterMonth(date.getMonth());
      month = date.getMonth();
      date.setDate(1);
      date.setHours(0, 0, 0, 0);

      if (month !== firstQuarterMonth) {
        date.setMonth(firstQuarterMonth);
      }

      break;
  }

  if (withCorrection && dateUnitInterval !== 'hour' && dateUnitInterval !== 'minute' && dateUnitInterval !== 'second') {
    fixTimezoneGap(oldDate, date);
  }

  return date;
}

function trimTime(date) {
  return correctDateWithUnitBeginning(date, 'day');
}

var setToDayEnd = function setToDayEnd(date) {
  var result = trimTime(date);
  result.setDate(result.getDate() + 1);
  return new Date(result.getTime() - 1);
};

var getDatesDifferences = function getDatesDifferences(date1, date2) {
  var counter = 0;
  var differences = {
    year: date1.getFullYear() !== date2.getFullYear(),
    month: date1.getMonth() !== date2.getMonth(),
    day: date1.getDate() !== date2.getDate(),
    hour: date1.getHours() !== date2.getHours(),
    minute: date1.getMinutes() !== date2.getMinutes(),
    second: date1.getSeconds() !== date2.getSeconds(),
    millisecond: date1.getMilliseconds() !== date2.getMilliseconds()
  };
  (0, _iterator.each)(differences, function (key, value) {
    if (value) {
      counter++;
    }
  });

  if (counter === 0 && getTimezonesDifference(date1, date2) !== 0) {
    differences.hour = true;
    counter++;
  }

  differences.count = counter;
  return differences;
};

function addDateInterval(value, interval, dir) {
  var result = new Date(value.getTime());
  var intervalObject = (0, _type.isString)(interval) ? getDateIntervalByString(interval.toLowerCase()) : (0, _type.isNumeric)(interval) ? convertMillisecondsToDateUnits(interval) : interval;

  if (intervalObject.years) {
    result.setFullYear(result.getFullYear() + intervalObject.years * dir);
  }

  if (intervalObject.quarters) {
    result.setMonth(result.getMonth() + 3 * intervalObject.quarters * dir);
  }

  if (intervalObject.months) {
    result.setMonth(result.getMonth() + intervalObject.months * dir);
  }

  if (intervalObject.weeks) {
    result.setDate(result.getDate() + 7 * intervalObject.weeks * dir);
  }

  if (intervalObject.days) {
    result.setDate(result.getDate() + intervalObject.days * dir);
  }

  if (intervalObject.hours) {
    result.setTime(result.getTime() + intervalObject.hours * 3600000 * dir);
  }

  if (intervalObject.minutes) {
    result.setTime(result.getTime() + intervalObject.minutes * 60000 * dir);
  }

  if (intervalObject.seconds) {
    result.setTime(result.getTime() + intervalObject.seconds * 1000 * dir);
  }

  if (intervalObject.milliseconds) {
    result.setTime(result.getTime() + intervalObject.milliseconds * dir);
  }

  return result;
}

var addInterval = function addInterval(value, interval, isNegative) {
  var dir = isNegative ? -1 : +1;
  return (0, _type.isDate)(value) ? addDateInterval(value, interval, dir) : (0, _math.adjust)(value + interval * dir, interval);
};

var getSequenceByInterval = function getSequenceByInterval(min, max, interval) {
  var intervals = [];
  var cur;
  intervals.push((0, _type.isDate)(min) ? new Date(min.getTime()) : min);
  cur = min;

  while (cur < max) {
    cur = addInterval(cur, interval);
    intervals.push(cur);
  }

  return intervals;
};

var getViewFirstCellDate = function getViewFirstCellDate(viewType, date) {
  if (viewType === 'month') {
    return createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
  }

  if (viewType === 'year') {
    return createDateWithFullYear(date.getFullYear(), 0, date.getDate());
  }

  if (viewType === 'decade') {
    return createDateWithFullYear(getFirstYearInDecade(date), date.getMonth(), date.getDate());
  }

  if (viewType === 'century') {
    return createDateWithFullYear(getFirstDecadeInCentury(date), date.getMonth(), date.getDate());
  }
};

var getViewLastCellDate = function getViewLastCellDate(viewType, date) {
  if (viewType === 'month') {
    return createDateWithFullYear(date.getFullYear(), date.getMonth(), getLastMonthDay(date));
  }

  if (viewType === 'year') {
    return createDateWithFullYear(date.getFullYear(), 11, date.getDate());
  }

  if (viewType === 'decade') {
    return createDateWithFullYear(getFirstYearInDecade(date) + 9, date.getMonth(), date.getDate());
  }

  if (viewType === 'century') {
    return createDateWithFullYear(getFirstDecadeInCentury(date) + 90, date.getMonth(), date.getDate());
  }
};

var getViewMinBoundaryDate = function getViewMinBoundaryDate(viewType, date) {
  var resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);

  if (viewType === 'month') {
    return resultDate;
  }

  resultDate.setMonth(0);

  if (viewType === 'year') {
    return resultDate;
  }

  if (viewType === 'decade') {
    resultDate.setFullYear(getFirstYearInDecade(date));
  }

  if (viewType === 'century') {
    resultDate.setFullYear(getFirstDecadeInCentury(date));
  }

  return resultDate;
};

var getViewMaxBoundaryDate = function getViewMaxBoundaryDate(viewType, date) {
  var resultDate = new Date(date);
  resultDate.setDate(getLastMonthDay(date));

  if (viewType === 'month') {
    return resultDate;
  }

  resultDate.setMonth(11);
  resultDate.setDate(getLastMonthDay(resultDate));

  if (viewType === 'year') {
    return resultDate;
  }

  if (viewType === 'decade') {
    resultDate.setFullYear(getFirstYearInDecade(date) + 9);
  }

  if (viewType === 'century') {
    resultDate.setFullYear(getFirstDecadeInCentury(date) + 99);
  }

  return resultDate;
};

function getLastMonthDay(date) {
  var resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth() + 1, 0);
  return resultDate.getDate();
}

var getViewUp = function getViewUp(typeView) {
  switch (typeView) {
    case 'month':
      return 'year';

    case 'year':
      return 'decade';

    case 'decade':
      return 'century';

    default:
      break;
  }
};

var getViewDown = function getViewDown(typeView) {
  switch (typeView) {
    case 'century':
      return 'decade';

    case 'decade':
      return 'year';

    case 'year':
      return 'month';

    default:
      break;
  }
};

var getDifferenceInMonth = function getDifferenceInMonth(typeView) {
  var difference = 1;

  if (typeView === 'year') {
    difference = 12;
  }

  if (typeView === 'decade') {
    difference = 12 * 10;
  }

  if (typeView === 'century') {
    difference = 12 * 100;
  }

  return difference;
};

var getDifferenceInMonthForCells = function getDifferenceInMonthForCells(typeView) {
  var difference = 1;

  if (typeView === 'decade') {
    difference = 12;
  }

  if (typeView === 'century') {
    difference = 12 * 10;
  }

  return difference;
};

function getDateIntervalByString(intervalString) {
  var result = {};

  switch (intervalString) {
    case 'year':
      result.years = 1;
      break;

    case 'month':
      result.months = 1;
      break;

    case 'quarter':
      result.months = 3;
      break;

    case 'week':
      result.weeks = 1;
      break;

    case 'day':
      result.days = 1;
      break;

    case 'hour':
      result.hours = 1;
      break;

    case 'minute':
      result.minutes = 1;
      break;

    case 'second':
      result.seconds = 1;
      break;

    case 'millisecond':
      result.milliseconds = 1;
      break;
  }

  return result;
}

function sameDate(date1, date2) {
  return sameMonthAndYear(date1, date2) && date1.getDate() === date2.getDate();
}

function sameMonthAndYear(date1, date2) {
  return sameYear(date1, date2) && date1.getMonth() === date2.getMonth();
}

function sameYear(date1, date2) {
  return date1 && date2 && date1.getFullYear() === date2.getFullYear();
}

var sameDecade = function sameDecade(date1, date2) {
  if (!(0, _type.isDefined)(date1) || !(0, _type.isDefined)(date2)) return;
  var startDecadeDate1 = date1.getFullYear() - date1.getFullYear() % 10;
  var startDecadeDate2 = date2.getFullYear() - date2.getFullYear() % 10;
  return date1 && date2 && startDecadeDate1 === startDecadeDate2;
};

var sameCentury = function sameCentury(date1, date2) {
  if (!(0, _type.isDefined)(date1) || !(0, _type.isDefined)(date2)) return;
  var startCenturyDate1 = date1.getFullYear() - date1.getFullYear() % 100;
  var startCenturyDate2 = date2.getFullYear() - date2.getFullYear() % 100;
  return date1 && date2 && startCenturyDate1 === startCenturyDate2;
};

function getFirstDecadeInCentury(date) {
  return date && date.getFullYear() - date.getFullYear() % 100;
}

function getFirstYearInDecade(date) {
  return date && date.getFullYear() - date.getFullYear() % 10;
}

var getShortDateFormat = function getShortDateFormat() {
  return 'yyyy/MM/dd';
};

var getFirstMonthDate = function getFirstMonthDate(date) {
  if (!(0, _type.isDefined)(date)) return;
  return createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
};

var getLastMonthDate = function getLastMonthDate(date) {
  if (!(0, _type.isDefined)(date)) return;
  return createDateWithFullYear(date.getFullYear(), date.getMonth() + 1, 0);
};

function getFirstWeekDate(date, firstDayOfWeek) {
  var delta = (date.getDay() - firstDayOfWeek + 7) % 7;
  var result = new Date(date);
  result.setDate(date.getDate() - delta);
  return result;
}

var normalizeDateByWeek = function normalizeDateByWeek(date, currentDate) {
  var differenceInDays = dateUtils.getDatesInterval(date, currentDate, 'day');
  var resultDate = new Date(date);

  if (differenceInDays >= 6) {
    resultDate = new Date(resultDate.setDate(resultDate.getDate() + 7));
  }

  return resultDate;
};

var dateInRange = function dateInRange(date, min, max, format) {
  if (format === 'date') {
    min = min && dateUtils.correctDateWithUnitBeginning(min, 'day');
    max = max && dateUtils.correctDateWithUnitBeginning(max, 'day');
    date = date && dateUtils.correctDateWithUnitBeginning(date, 'day');
  }

  return normalizeDate(date, min, max) === date;
};

var intervalsOverlap = function intervalsOverlap(options) {
  var firstMin = options.firstMin,
      firstMax = options.firstMax,
      secondMin = options.secondMin,
      secondMax = options.secondMax;
  return firstMin <= secondMin && secondMin <= firstMax || firstMin > secondMin && firstMin < secondMax || firstMin < secondMax && firstMax > secondMax;
};

var dateTimeFromDecimal = function dateTimeFromDecimal(number) {
  var hours = Math.floor(number);
  var minutes = number % 1 * 60;
  return {
    hours: hours,
    minutes: minutes
  };
};

var roundDateByStartDayHour = function roundDateByStartDayHour(date, startDayHour) {
  var startTime = this.dateTimeFromDecimal(startDayHour);
  var result = new Date(date);

  if (date.getHours() === startTime.hours && date.getMinutes() < startTime.minutes || date.getHours() < startTime.hours) {
    result.setHours(startTime.hours, startTime.minutes, 0, 0);
  }

  return result;
};

function normalizeDate(date, min, max) {
  var normalizedDate = date;

  if (!(0, _type.isDefined)(date)) {
    return date;
  }

  if ((0, _type.isDefined)(min) && date < min) {
    normalizedDate = min;
  }

  if ((0, _type.isDefined)(max) && date > max) {
    normalizedDate = max;
  }

  return normalizedDate;
}

function fixTimezoneGap(oldDate, newDate) {
  // NOTE: T182866
  if (!(0, _type.isDefined)(oldDate)) {
    return;
  }

  var diff = newDate.getHours() - oldDate.getHours();

  if (diff === 0) {
    return;
  }

  var sign = diff === 1 || diff === -23 ? -1 : 1;
  var trial = new Date(newDate.getTime() + sign * 3600000);

  if (sign > 0 || trial.getDate() === newDate.getDate()) {
    newDate.setTime(trial.getTime());
  }
}

var roundToHour = function roundToHour(date) {
  date.setHours(date.getHours() + 1);
  date.setMinutes(0);
  return date;
};

function getTimezonesDifference(min, max) {
  return (max.getTimezoneOffset() - min.getTimezoneOffset()) * 60 * 1000;
}

var makeDate = function makeDate(date) {
  // TODO: will be useful later for work with different timezones
  return new Date(date);
};

var getDatesOfInterval = function getDatesOfInterval(startDate, endDate, step) {
  var result = [];
  var currentDate = new Date(startDate.getTime());

  while (currentDate < endDate) {
    result.push(new Date(currentDate.getTime()));
    currentDate = this.addInterval(currentDate, step);
  }

  return result;
};

var createDate = function createDate(date) {
  return new Date(isIE11 && (0, _type.isDate)(date) ? date.getTime() : date);
};

var createDateWithFullYear = function createDateWithFullYear(year) {
  var result = _construct(Date, Array.prototype.slice.call(arguments));

  result.setFullYear(year);
  return result;
};

var dateUtils = {
  dateUnitIntervals: dateUnitIntervals,
  convertMillisecondsToDateUnits: convertMillisecondsToDateUnits,
  dateToMilliseconds: dateToMilliseconds,
  getNextDateUnit: getNextDateUnit,
  convertDateUnitToMilliseconds: convertDateUnitToMilliseconds,
  getDateUnitInterval: getDateUnitInterval,
  getDateFormatByTickInterval: getDateFormatByTickInterval,
  // T375972
  getDatesDifferences: getDatesDifferences,
  correctDateWithUnitBeginning: correctDateWithUnitBeginning,
  trimTime: trimTime,
  setToDayEnd: setToDayEnd,
  roundDateByStartDayHour: roundDateByStartDayHour,
  dateTimeFromDecimal: dateTimeFromDecimal,
  addDateInterval: addDateInterval,
  addInterval: addInterval,
  getSequenceByInterval: getSequenceByInterval,
  getDateIntervalByString: getDateIntervalByString,
  sameDate: sameDate,
  sameMonthAndYear: sameMonthAndYear,
  sameMonth: sameMonthAndYear,
  sameYear: sameYear,
  sameDecade: sameDecade,
  sameCentury: sameCentury,
  getDifferenceInMonth: getDifferenceInMonth,
  getDifferenceInMonthForCells: getDifferenceInMonthForCells,
  getFirstYearInDecade: getFirstYearInDecade,
  getFirstDecadeInCentury: getFirstDecadeInCentury,
  getShortDateFormat: getShortDateFormat,
  getViewFirstCellDate: getViewFirstCellDate,
  getViewLastCellDate: getViewLastCellDate,
  getViewDown: getViewDown,
  getViewUp: getViewUp,
  getLastMonthDay: getLastMonthDay,
  getLastMonthDate: getLastMonthDate,
  getFirstMonthDate: getFirstMonthDate,
  getFirstWeekDate: getFirstWeekDate,
  normalizeDateByWeek: normalizeDateByWeek,
  getQuarter: getQuarter,
  getFirstQuarterMonth: getFirstQuarterMonth,
  dateInRange: dateInRange,
  intervalsOverlap: intervalsOverlap,
  roundToHour: roundToHour,
  normalizeDate: normalizeDate,
  getViewMinBoundaryDate: getViewMinBoundaryDate,
  getViewMaxBoundaryDate: getViewMaxBoundaryDate,
  fixTimezoneGap: fixTimezoneGap,
  getTimezonesDifference: getTimezonesDifference,
  makeDate: makeDate,
  getDatesInterval: getDatesInterval,
  getDatesOfInterval: getDatesOfInterval,
  createDate: createDate,
  createDateWithFullYear: createDateWithFullYear
};

dateUtils.sameView = function (view, date1, date2) {
  return dateUtils[(0, _inflector.camelize)('same ' + view)](date1, date2);
};

var _default = dateUtils;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _error = _interopRequireDefault(__webpack_require__(142));

var _errors = _interopRequireDefault(__webpack_require__(24));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
* @docid
* @name ErrorsUIWidgets
*/
var _default = (0, _error.default)(_errors.default.ERROR_MESSAGES, {
  /**
  * @name ErrorsUIWidgets.E1001
  */
  E1001: 'Module \'{0}\'. Controller \'{1}\' is already registered',

  /**
  * @name ErrorsUIWidgets.E1002
  */
  E1002: 'Module \'{0}\'. Controller \'{1}\' does not inherit from DevExpress.ui.dxDataGrid.Controller',

  /**
  * @name ErrorsUIWidgets.E1003
  */
  E1003: 'Module \'{0}\'. View \'{1}\' is already registered',

  /**
  * @name ErrorsUIWidgets.E1004
  */
  E1004: 'Module \'{0}\'. View \'{1}\' does not inherit from DevExpress.ui.dxDataGrid.View',

  /**
  * @name ErrorsUIWidgets.E1005
  */
  E1005: 'Public method \'{0}\' is already registered',

  /**
  * @name ErrorsUIWidgets.E1006
  */
  E1006: 'Public method \'{0}.{1}\' does not exist',

  /**
  * @name ErrorsUIWidgets.E1007
  */
  E1007: 'State storing cannot be provided due to the restrictions of the browser',

  /**
  * @name ErrorsUIWidgets.E1010
  */
  E1010: 'The template does not contain the TextBox widget',

  /**
  * @name ErrorsUIWidgets.E1011
  */
  E1011: 'Items cannot be deleted from the List. Implement the "remove" function in the data store',

  /**
  * @name ErrorsUIWidgets.E1012
  */
  E1012: 'Editing type \'{0}\' with the name \'{1}\' is unsupported',

  /**
  * @name ErrorsUIWidgets.E1016
  */
  E1016: 'Unexpected type of data source is provided for a lookup column',

  /**
  * @name ErrorsUIWidgets.E1018
  */
  E1018: 'The \'collapseAll\' method cannot be called if you use a remote data source',

  /**
  * @name ErrorsUIWidgets.E1019
  */
  E1019: 'Search mode \'{0}\' is unavailable',

  /**
  * @name ErrorsUIWidgets.E1020
  */
  E1020: 'The type cannot be changed after initialization',

  /**
  * @name ErrorsUIWidgets.E1021
  */
  E1021: '{0} \'{1}\' you are trying to remove does not exist',

  /**
  * @name ErrorsUIWidgets.E1022
  */
  E1022: 'The "markers" option is given an invalid value. Assign an array instead',

  /**
  * @name ErrorsUIWidgets.E1023
  */
  E1023: 'The "routes" option is given an invalid value. Assign an array instead',

  /**
  * @name ErrorsUIWidgets.E1025
  */
  E1025: 'This layout is too complex to render',

  /**
  * @name ErrorsUIWidgets.E1026
  */
  E1026: 'The "calculateCustomSummary" function is missing from a field whose "summaryType" option is set to "custom"',

  /**
  * @name ErrorsUIWidgets.E1031
  */
  E1031: 'Unknown subscription in the Scheduler widget: \'{0}\'',

  /**
  * @name ErrorsUIWidgets.E1032
  */
  E1032: 'Unknown start date in an appointment: \'{0}\'',

  /**
  * @name ErrorsUIWidgets.E1033
  */
  E1033: 'Unknown step in the date navigator: \'{0}\'',

  /**
  * @name ErrorsUIWidgets.E1034
  */
  E1034: 'The browser does not implement an API for saving files',

  /**
   * @name ErrorsUIWidgets.E1035
   */
  E1035: 'The editor cannot be created because of an internal error: {0}',

  /**
   * @name ErrorsUIWidgets.E1037
   */
  E1037: 'Invalid structure of grouped data',

  /**
   * @name ErrorsUIWidgets.E1038
   */
  E1038: 'The browser does not support local storages for local web pages',

  /**
  * @name ErrorsUIWidgets.E1039
  */
  E1039: 'A cell\'s position cannot be calculated',

  /**
   * @name ErrorsUIWidgets.E1040
   */
  E1040: 'The \'{0}\' key value is not unique within the data array',

  /**
   * @name ErrorsUIWidgets.E1041
   */
  E1041: 'The \'{0}\' script is referenced after the DevExtreme scripts or not referenced at all',

  /**
  * @name ErrorsUIWidgets.E1042
  */
  E1042: '{0} requires the key field to be specified',

  /**
  * @name ErrorsUIWidgets.E1043
  */
  E1043: 'Changes cannot be processed due to the incorrectly set key',

  /**
  * @name ErrorsUIWidgets.E1044
  */
  E1044: 'The key field specified by the keyExpr option does not match the key field specified in the data store',

  /**
  * @name ErrorsUIWidgets.E1045
  */
  E1045: 'Editing requires the key field to be specified in the data store',

  /**
  * @name ErrorsUIWidgets.E1046
  */
  E1046: 'The \'{0}\' key field is not found in data objects',

  /**
  * @name ErrorsUIWidgets.E1047
  */
  E1047: 'The "{0}" field is not found in the fields array',

  /**
  * @name ErrorsUIWidgets.E1048
  */
  E1048: 'The "{0}" operation is not found in the filterOperations array',

  /**
  * @name ErrorsUIWidgets.E1049
  */
  E1049: 'Column \'{0}\': filtering is allowed but the \'dataField\' or \'name\' option is not specified',

  /**
  * @name ErrorsUIWidgets.E1050
  */
  E1050: 'The validationRules option does not apply to third-party editors defined in the editCellTemplate',

  /**
   * @name ErrorsUIWidgets.E1051
   */
  E1051: 'HtmlEditor\'s valueType is "{0}", but the {0} converter was not imported.',

  /**
  * @name ErrorsUIWidgets.E1052
  */
  E1052: '{0} should have the "dataSource" option specified',

  /**
  * @name ErrorsUIWidgets.E1053
  */
  E1053: 'The "buttons" option accepts an array that contains only objects or string values',

  /**
  * @name ErrorsUIWidgets.E1054
  */
  E1054: 'All text editor buttons must have names',

  /**
  * @name ErrorsUIWidgets.E1055
  */
  E1055: 'One or several text editor buttons have invalid or non-unique "name" values',

  /**
  * @name ErrorsUIWidgets.E1056
  */
  E1056: 'The {0} widget does not support buttons of the "{1}" type',
  // NOTE:
  // E1057 is reserved. See https://js.devexpress.com/Documentation/19_2/ApiReference/UI_Widgets/Errors_and_Warnings/#E1057

  /**
  * @name ErrorsUIWidgets.E1058
  */
  E1058: 'The "startDayHour" must be earlier than the "endDayHour"',

  /**
  * @name ErrorsUIWidgets.E1059
  */
  E1059: 'The following column names are not unique: {0}',

  /**
  * @name ErrorsUIWidgets.E1060
  */
  E1060: 'All editable columns must have names',

  /**
  * @name ErrorsUIWidgets.W1001
  */
  W1001: 'The "key" option cannot be modified after initialization',

  /**
  * @name ErrorsUIWidgets.W1002
  */
  W1002: 'An item with the key \'{0}\' does not exist',

  /**
  * @name ErrorsUIWidgets.W1003
  */
  W1003: 'A group with the key \'{0}\' in which you are trying to select items does not exist',

  /**
  * @name ErrorsUIWidgets.W1004
  */
  W1004: 'The item \'{0}\' you are trying to select in the group \'{1}\' does not exist',

  /**
  * @name ErrorsUIWidgets.W1005
  */
  W1005: 'Due to column data types being unspecified, data has been loaded twice in order to apply initial filter settings. To resolve this issue, specify data types for all grid columns.',

  /**
  * @name ErrorsUIWidgets.W1006
  */
  W1006: 'The map service returned the following error: \'{0}\'',

  /**
   * @name ErrorsUIWidgets.W1007
   */
  W1007: 'No item with key {0} was found in the data source, but this key was used as the parent key for item {1}',

  /**
   * @name ErrorsUIWidgets.W1008
   */
  W1008: 'Cannot scroll to the \'{0}\' date because it does not exist on the current view',

  /**
   * @name ErrorsUIWidgets.W1009
   */
  W1009: 'Searching works only if data is specified using the dataSource option',

  /**
   * @name ErrorsUIWidgets.W1010
   */
  W1010: 'The capability to select all items works with source data of plain structure only',

  /**
   * @name ErrorsUIWidgets.W1011
   */
  W1011: 'The "keyExpr" option is not applied when dataSource is not an array',
  W1012: 'The \'{0}\' key field is not found in data objects',

  /**
  * @name ErrorsUIWidgets.W1013
  */
  W1013: 'The "message" field in the dialog component was renamed to "messageHtml". Change your code correspondingly. In addition, if you used HTML code in the message, make sure that it is secure',

  /**
  * @name ErrorsUIWidgets.W1014
  */
  W1014: 'The Floating Action Button exceeds the recommended speed dial action count. If you need to display more speed dial actions, increase the maxSpeedDialActionCount option value in the global config.',

  /**
  * @name ErrorsUIWidgets.W1015
  */
  W1015: 'The "cellDuration" should divide the range from the "startDayHour" to the "endDayHour" into even intervals',

  /**
  * @name ErrorsUIWidgets.W1016
  */
  W1016: 'The \'{0}\' field in the HTML Editor toolbar item configuration was renamed to \'{1}\'. Please make a corresponding change in your code.',

  /**
  * @name ErrorsUIWidgets.W1017
  */
  W1017: 'The \'key\' property is not specified for a lookup data source. Please specify it to prevent requests for the entire dataset when users filter data.',

  /**
  * @name ErrorsUIWidgets.W1018
  */
  W1018: 'Infinite scrolling may not work properly with multiple selection. To use these features together, set \'selection.deferred\' to true or set \'selection.selectAllMode\' to \'page\'.',

  /**
  * @name ErrorsUIWidgets.W1019
  */
  W1019: 'Filter query string exceeds maximum length limit of {0} characters.',

  /**
  * @name ErrorsUIWidgets.W1020
  */
  W1020: 'hideEvent is ignored when the shading property is true'
});

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _action = _interopRequireDefault(__webpack_require__(121));

var _dom_component = _interopRequireDefault(__webpack_require__(66));

var _short = __webpack_require__(113);

var _common = __webpack_require__(4);

var _iterator = __webpack_require__(3);

var _extend2 = __webpack_require__(0);

var _selectors = __webpack_require__(67);

var _array = __webpack_require__(12);

var _type = __webpack_require__(1);

__webpack_require__(23);

__webpack_require__(150);

__webpack_require__(145);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function setAttribute(name, value, target) {
  name = name === 'role' || name === 'id' ? name : "aria-".concat(name);
  value = (0, _type.isDefined)(value) ? value.toString() : null;
  target.attr(name, value);
}

var Widget = _dom_component.default.inherit({
  _feedbackHideTimeout: 400,
  _feedbackShowTimeout: 30,
  _supportedKeys: function _supportedKeys() {
    return {};
  },
  _getDefaultOptions: function _getDefaultOptions() {
    return (0, _extend2.extend)(this.callBase(), {
      hoveredElement: null,
      isActive: false,
      disabled: false,
      visible: true,
      hint: undefined,
      activeStateEnabled: false,
      onContentReady: null,
      hoverStateEnabled: false,
      focusStateEnabled: false,
      tabIndex: 0,
      accessKey: undefined,

      /**
      * @name WidgetOptions.onFocusIn
      * @extends Action
      * @action
      * @hidden
      */
      onFocusIn: null,

      /**
      * @name WidgetOptions.onFocusOut
      * @extends Action
      * @action
      * @hidden
      */
      onFocusOut: null,
      onKeyboardHandled: null,
      ignoreParentReadOnly: false
    });
  },
  _init: function _init() {
    this.callBase();

    this._initContentReadyAction();
  },
  _innerWidgetOptionChanged: function _innerWidgetOptionChanged(innerWidget, args) {
    var options = Widget.getOptionsFromContainer(args);
    innerWidget && innerWidget.option(options);

    this._options.cache(args.name, options);
  },
  _bindInnerWidgetOptions: function _bindInnerWidgetOptions(innerWidget, optionsContainer) {
    var _this = this;

    var syncOptions = function syncOptions() {
      return _this._options.silent(optionsContainer, (0, _extend2.extend)({}, innerWidget.option()));
    };

    syncOptions();
    innerWidget.on('optionChanged', syncOptions);
  },
  _getAriaTarget: function _getAriaTarget() {
    return this._focusTarget();
  },
  _initContentReadyAction: function _initContentReadyAction() {
    this._contentReadyAction = this._createActionByOption('onContentReady', {
      excludeValidators: ['disabled', 'readOnly']
    });
  },
  _initMarkup: function _initMarkup() {
    var _this$option = this.option(),
        disabled = _this$option.disabled,
        visible = _this$option.visible;

    this.$element().addClass('dx-widget');

    this._toggleDisabledState(disabled);

    this._toggleVisibility(visible);

    this._renderHint();

    this._isFocusable() && this._renderFocusTarget();
    this.callBase();
  },
  _render: function _render() {
    this.callBase();

    this._renderContent();

    this._renderFocusState();

    this._attachFeedbackEvents();

    this._attachHoverEvents();

    this._toggleIndependentState();
  },
  _renderHint: function _renderHint() {
    var _this$option2 = this.option(),
        hint = _this$option2.hint;

    this.$element().attr('title', hint || null);
  },
  _renderContent: function _renderContent() {
    var _this2 = this;

    (0, _common.deferRender)(function () {
      return !_this2._disposed ? _this2._renderContentImpl() : void 0;
    }).done(function () {
      return !_this2._disposed ? _this2._fireContentReadyAction() : void 0;
    });
  },
  _renderContentImpl: _common.noop,
  _fireContentReadyAction: (0, _common.deferRenderer)(function () {
    return this._contentReadyAction();
  }),
  _dispose: function _dispose() {
    this._contentReadyAction = null;

    this._detachKeyboardEvents();

    this.callBase();
  },
  _resetActiveState: function _resetActiveState() {
    this._toggleActiveState(this._eventBindingTarget(), false);
  },
  _clean: function _clean() {
    this._cleanFocusState();

    this._resetActiveState();

    this.callBase();
    this.$element().empty();
  },
  _toggleVisibility: function _toggleVisibility(visible) {
    this.$element().toggleClass('dx-state-invisible', !visible);
    this.setAria('hidden', !visible || void 0);
  },
  _renderFocusState: function _renderFocusState() {
    this._attachKeyboardEvents();

    if (this._isFocusable()) {
      this._renderFocusTarget();

      this._attachFocusEvents();

      this._renderAccessKey();
    }
  },
  _renderAccessKey: function _renderAccessKey() {
    var $el = this._focusTarget();

    var _this$option3 = this.option(),
        accessKey = _this$option3.accessKey;

    $el.attr('accesskey', accessKey);
  },
  _isFocusable: function _isFocusable() {
    var _this$option4 = this.option(),
        focusStateEnabled = _this$option4.focusStateEnabled,
        disabled = _this$option4.disabled;

    return focusStateEnabled && !disabled;
  },
  _eventBindingTarget: function _eventBindingTarget() {
    return this.$element();
  },
  _focusTarget: function _focusTarget() {
    return this._getActiveElement();
  },
  _getActiveElement: function _getActiveElement() {
    var activeElement = this._eventBindingTarget();

    if (this._activeStateUnit) {
      return activeElement.find(this._activeStateUnit).not('.dx-state-disabled');
    }

    return activeElement;
  },
  _renderFocusTarget: function _renderFocusTarget() {
    var _this$option5 = this.option(),
        tabIndex = _this$option5.tabIndex;

    this._focusTarget().attr('tabIndex', tabIndex);
  },
  _keyboardEventBindingTarget: function _keyboardEventBindingTarget() {
    return this._eventBindingTarget();
  },
  _refreshFocusEvent: function _refreshFocusEvent() {
    this._detachFocusEvents();

    this._attachFocusEvents();
  },
  _focusEventTarget: function _focusEventTarget() {
    return this._focusTarget();
  },
  _focusInHandler: function _focusInHandler(event) {
    var _this3 = this;

    if (!event.isDefaultPrevented()) {
      this._createActionByOption('onFocusIn', {
        beforeExecute: function beforeExecute() {
          return _this3._updateFocusState(event, true);
        },
        excludeValidators: ['readOnly']
      })({
        event: event
      });
    }
  },
  _focusOutHandler: function _focusOutHandler(event) {
    var _this4 = this;

    if (!event.isDefaultPrevented()) {
      this._createActionByOption('onFocusOut', {
        beforeExecute: function beforeExecute() {
          return _this4._updateFocusState(event, false);
        },
        excludeValidators: ['readOnly', 'disabled']
      })({
        event: event
      });
    }
  },
  _updateFocusState: function _updateFocusState(_ref, isFocused) {
    var target = _ref.target;

    if ((0, _array.inArray)(target, this._focusTarget()) !== -1) {
      this._toggleFocusClass(isFocused, (0, _renderer.default)(target));
    }
  },
  _toggleFocusClass: function _toggleFocusClass(isFocused, $element) {
    var $focusTarget = $element && $element.length ? $element : this._focusTarget();
    $focusTarget.toggleClass('dx-state-focused', isFocused);
  },
  _hasFocusClass: function _hasFocusClass(element) {
    var $focusTarget = (0, _renderer.default)(element || this._focusTarget());
    return $focusTarget.hasClass('dx-state-focused');
  },
  _isFocused: function _isFocused() {
    return this._hasFocusClass();
  },
  _getKeyboardListeners: function _getKeyboardListeners() {
    return [];
  },
  _attachKeyboardEvents: function _attachKeyboardEvents() {
    var _this5 = this;

    this._detachKeyboardEvents();

    var _this$option6 = this.option(),
        focusStateEnabled = _this$option6.focusStateEnabled,
        onKeyboardHandled = _this$option6.onKeyboardHandled;

    var hasChildListeners = this._getKeyboardListeners().length;

    var hasKeyboardEventHandler = !!onKeyboardHandled;
    var shouldAttach = focusStateEnabled || hasChildListeners || hasKeyboardEventHandler;

    if (shouldAttach) {
      this._keyboardListenerId = _short.keyboard.on(this._keyboardEventBindingTarget(), this._focusTarget(), function (opts) {
        return _this5._keyboardHandler(opts);
      });
    }
  },
  _keyboardHandler: function _keyboardHandler(options, onlyChildProcessing) {
    if (!onlyChildProcessing) {
      var originalEvent = options.originalEvent,
          keyName = options.keyName,
          which = options.which;

      var keys = this._supportedKeys(originalEvent);

      var func = keys[keyName] || keys[which];

      if (func !== undefined) {
        var handler = func.bind(this);
        var result = handler(originalEvent, options);

        if (!result) {
          return false;
        }
      }
    }

    var keyboardListeners = this._getKeyboardListeners();

    var _this$option7 = this.option(),
        onKeyboardHandled = _this$option7.onKeyboardHandled;

    keyboardListeners.forEach(function (listener) {
      return listener && listener._keyboardHandler(options);
    });
    onKeyboardHandled && onKeyboardHandled(options);
    return true;
  },
  _refreshFocusState: function _refreshFocusState() {
    this._cleanFocusState();

    this._renderFocusState();
  },
  _cleanFocusState: function _cleanFocusState() {
    var $element = this._focusTarget();

    $element.removeAttr('tabIndex');

    this._toggleFocusClass(false);

    this._detachFocusEvents();

    this._detachKeyboardEvents();
  },
  _detachKeyboardEvents: function _detachKeyboardEvents() {
    _short.keyboard.off(this._keyboardListenerId);

    this._keyboardListenerId = null;
  },
  _attachHoverEvents: function _attachHoverEvents() {
    var _this6 = this;

    var _this$option8 = this.option(),
        hoverStateEnabled = _this$option8.hoverStateEnabled;

    var selector = this._activeStateUnit;
    var namespace = 'UIFeedback';

    var $el = this._eventBindingTarget();

    _short.hover.off($el, {
      selector: selector,
      namespace: namespace
    });

    if (hoverStateEnabled) {
      _short.hover.on($el, new _action.default(function (_ref2) {
        var event = _ref2.event,
            element = _ref2.element;

        _this6._hoverStartHandler(event);

        _this6.option('hoveredElement', (0, _renderer.default)(element));
      }, {
        excludeValidators: ['readOnly']
      }), function (event) {
        _this6.option('hoveredElement', null);

        _this6._hoverEndHandler(event);
      }, {
        selector: selector,
        namespace: namespace
      });
    }
  },
  _attachFeedbackEvents: function _attachFeedbackEvents() {
    var _this7 = this;

    var _this$option9 = this.option(),
        activeStateEnabled = _this$option9.activeStateEnabled;

    var selector = this._activeStateUnit;
    var namespace = 'UIFeedback';

    var $el = this._eventBindingTarget();

    _short.active.off($el, {
      namespace: namespace,
      selector: selector
    });

    if (activeStateEnabled) {
      _short.active.on($el, new _action.default(function (_ref3) {
        var event = _ref3.event,
            element = _ref3.element;
        return _this7._toggleActiveState((0, _renderer.default)(element), true, event);
      }), new _action.default(function (_ref4) {
        var event = _ref4.event,
            element = _ref4.element;
        return _this7._toggleActiveState((0, _renderer.default)(element), false, event);
      }, {
        excludeValidators: ['disabled', 'readOnly']
      }), {
        showTimeout: this._feedbackShowTimeout,
        hideTimeout: this._feedbackHideTimeout,
        selector: selector,
        namespace: namespace
      });
    }
  },
  _detachFocusEvents: function _detachFocusEvents() {
    var $el = this._focusEventTarget();

    _short.focus.off($el, {
      namespace: "".concat(this.NAME, "Focus")
    });
  },
  _attachFocusEvents: function _attachFocusEvents() {
    var _this8 = this;

    var $el = this._focusEventTarget();

    _short.focus.on($el, function (e) {
      return _this8._focusInHandler(e);
    }, function (e) {
      return _this8._focusOutHandler(e);
    }, {
      namespace: "".concat(this.NAME, "Focus"),
      isFocusable: function isFocusable(index, el) {
        return (0, _renderer.default)(el).is(_selectors.focusable);
      }
    });
  },
  _hoverStartHandler: _common.noop,
  _hoverEndHandler: _common.noop,
  _toggleActiveState: function _toggleActiveState($element, value) {
    this.option('isActive', value);
    $element.toggleClass('dx-state-active', value);
  },
  _updatedHover: function _updatedHover() {
    var hoveredElement = this._options.silent('hoveredElement');

    this._hover(hoveredElement, hoveredElement);
  },
  _findHoverTarget: function _findHoverTarget($el) {
    return $el && $el.closest(this._activeStateUnit || this._eventBindingTarget());
  },
  _hover: function _hover($el, $previous) {
    var _this$option10 = this.option(),
        hoverStateEnabled = _this$option10.hoverStateEnabled,
        disabled = _this$option10.disabled,
        isActive = _this$option10.isActive;

    $previous = this._findHoverTarget($previous);
    $previous && $previous.toggleClass('dx-state-hover', false);

    if ($el && hoverStateEnabled && !disabled && !isActive) {
      var newHoveredElement = this._findHoverTarget($el);

      newHoveredElement && newHoveredElement.toggleClass('dx-state-hover', true);
    }
  },
  _toggleDisabledState: function _toggleDisabledState(value) {
    this.$element().toggleClass('dx-state-disabled', Boolean(value));
    this.setAria('disabled', value || undefined);
  },
  _toggleIndependentState: function _toggleIndependentState() {
    this.$element().toggleClass('dx-state-independent', this.option('ignoreParentReadOnly'));
  },
  _setWidgetOption: function _setWidgetOption(widgetName, args) {
    var _this9 = this;

    if (!this[widgetName]) {
      return;
    }

    if ((0, _type.isPlainObject)(args[0])) {
      (0, _iterator.each)(args[0], function (option, value) {
        return _this9._setWidgetOption(widgetName, [option, value]);
      });
      return;
    }

    var optionName = args[0];
    var value = args[1];

    if (args.length === 1) {
      value = this.option(optionName);
    }

    var widgetOptionMap = this["".concat(widgetName, "OptionMap")];
    this[widgetName].option(widgetOptionMap ? widgetOptionMap(optionName) : optionName, value);
  },
  _optionChanged: function _optionChanged(args) {
    var name = args.name,
        value = args.value,
        previousValue = args.previousValue;

    switch (name) {
      case 'disabled':
        this._toggleDisabledState(value);

        this._updatedHover();

        this._refreshFocusState();

        break;

      case 'hint':
        this._renderHint();

        break;

      case 'ignoreParentReadOnly':
        this._toggleIndependentState();

        break;

      case 'activeStateEnabled':
        this._attachFeedbackEvents();

        break;

      case 'hoverStateEnabled':
        this._attachHoverEvents();

        this._updatedHover();

        break;

      case 'tabIndex':
      case 'focusStateEnabled':
        this._refreshFocusState();

        break;

      case 'onFocusIn':
      case 'onFocusOut':
        break;

      case 'accessKey':
        this._renderAccessKey();

        break;

      case 'hoveredElement':
        this._hover(value, previousValue);

        break;

      case 'isActive':
        this._updatedHover();

        break;

      case 'visible':
        this._toggleVisibility(value);

        if (this._isVisibilityChangeSupported()) {
          // TODO hiding works wrong
          this._checkVisibilityChanged(value ? 'shown' : 'hiding');
        }

        break;

      case 'onKeyboardHandled':
        this._attachKeyboardEvents();

        break;

      case 'onContentReady':
        this._initContentReadyAction();

        break;

      default:
        this.callBase(args);
    }
  },
  _isVisible: function _isVisible() {
    var _this$option11 = this.option(),
        visible = _this$option11.visible;

    return this.callBase() && visible;
  },
  beginUpdate: function beginUpdate() {
    this._ready(false);

    this.callBase();
  },
  endUpdate: function endUpdate() {
    this.callBase();

    if (this._initialized) {
      this._ready(true);
    }
  },
  _ready: function _ready(value) {
    if (arguments.length === 0) {
      return this._isReady;
    }

    this._isReady = value;
  },
  setAria: function setAria() {
    if (!(0, _type.isPlainObject)(arguments.length <= 0 ? undefined : arguments[0])) {
      setAttribute(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], (arguments.length <= 2 ? undefined : arguments[2]) || this._getAriaTarget());
    } else {
      var target = (arguments.length <= 1 ? undefined : arguments[1]) || this._getAriaTarget();

      (0, _iterator.each)(arguments.length <= 0 ? undefined : arguments[0], function (name, value) {
        return setAttribute(name, value, target);
      });
    }
  },
  isReady: function isReady() {
    return this._ready();
  },
  repaint: function repaint() {
    this._refresh();
  },
  focus: function focus() {
    _short.focus.trigger(this._focusTarget());
  },
  registerKeyHandler: function registerKeyHandler(key, handler) {
    var currentKeys = this._supportedKeys();

    this._supportedKeys = function () {
      return (0, _extend2.extend)(currentKeys, _defineProperty({}, key, handler));
    };
  }
});

Widget.getOptionsFromContainer = function (_ref5) {
  var name = _ref5.name,
      fullName = _ref5.fullName,
      value = _ref5.value;
  var options = {};

  if (name === fullName) {
    options = value;
  } else {
    var option = fullName.split('.').pop();
    options[option] = value;
  }

  return options;
};

var _default = Widget;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.toComparable = exports.compileSetter = exports.compileGetter = exports.getPathParts = void 0;

var _errors = _interopRequireDefault(__webpack_require__(24));

var _class = _interopRequireDefault(__webpack_require__(15));

var _object = __webpack_require__(52);

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

var _variable_wrapper = _interopRequireDefault(__webpack_require__(105));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var unwrapVariable = _variable_wrapper.default.unwrap;
var isWrapped = _variable_wrapper.default.isWrapped;
var assign = _variable_wrapper.default.assign;

var bracketsToDots = function bracketsToDots(expr) {
  return expr.replace(/\[/g, '.').replace(/\]/g, '');
};

var getPathParts = function getPathParts(name) {
  return bracketsToDots(name).split('.');
};

exports.getPathParts = getPathParts;

var readPropValue = function readPropValue(obj, propName, options) {
  options = options || {};

  if (propName === 'this') {
    return unwrap(obj, options);
  }

  return unwrap(obj[propName], options);
};

var assignPropValue = function assignPropValue(obj, propName, value, options) {
  if (propName === 'this') {
    throw new _errors.default.Error('E4016');
  }

  var propValue = obj[propName];

  if (options.unwrapObservables && isWrapped(propValue)) {
    assign(propValue, value);
  } else {
    obj[propName] = value;
  }
};

var prepareOptions = function prepareOptions(options) {
  options = options || {};
  options.unwrapObservables = options.unwrapObservables !== undefined ? options.unwrapObservables : true;
  return options;
};

function unwrap(value, options) {
  return options.unwrapObservables ? unwrapVariable(value) : value;
}

var compileGetter = function compileGetter(expr) {
  if (arguments.length > 1) {
    expr = [].slice.call(arguments);
  }

  if (!expr || expr === 'this') {
    return function (obj) {
      return obj;
    };
  }

  if (typeof expr === 'string') {
    var path = getPathParts(expr);
    return function (obj, options) {
      options = prepareOptions(options);
      var functionAsIs = options.functionsAsIs;
      var hasDefaultValue = ('defaultValue' in options);
      var current = unwrap(obj, options);

      for (var i = 0; i < path.length; i++) {
        if (!current) {
          if (current == null && hasDefaultValue) {
            return options.defaultValue;
          }

          break;
        }

        var pathPart = path[i];

        if (hasDefaultValue && (0, _type.isObject)(current) && !(pathPart in current)) {
          return options.defaultValue;
        }

        var next = unwrap(current[pathPart], options);

        if (!functionAsIs && (0, _type.isFunction)(next)) {
          next = next.call(current);
        }

        current = next;
      }

      return current;
    };
  }

  if (Array.isArray(expr)) {
    return combineGetters(expr);
  }

  if ((0, _type.isFunction)(expr)) {
    return expr;
  }
};

exports.compileGetter = compileGetter;

function combineGetters(getters) {
  var compiledGetters = {};

  for (var i = 0, l = getters.length; i < l; i++) {
    var getter = getters[i];
    compiledGetters[getter] = compileGetter(getter);
  }

  return function (obj, options) {
    var result;
    (0, _iterator.each)(compiledGetters, function (name) {
      var value = this(obj, options);

      if (value === undefined) {
        return;
      }

      var current = result || (result = {});
      var path = name.split('.');
      var last = path.length - 1;

      for (var _i = 0; _i < last; _i++) {
        var pathItem = path[_i];

        if (!(pathItem in current)) {
          current[pathItem] = {};
        }

        current = current[pathItem];
      }

      current[path[last]] = value;
    });
    return result;
  };
}

var ensurePropValueDefined = function ensurePropValueDefined(obj, propName, value, options) {
  if ((0, _type.isDefined)(value)) {
    return value;
  }

  var newValue = {};
  assignPropValue(obj, propName, newValue, options);
  return newValue;
};

var compileSetter = function compileSetter(expr) {
  expr = getPathParts(expr || 'this');
  var lastLevelIndex = expr.length - 1;
  return function (obj, value, options) {
    options = prepareOptions(options);
    var currentValue = unwrap(obj, options);
    expr.forEach(function (propertyName, levelIndex) {
      var propertyValue = readPropValue(currentValue, propertyName, options);
      var isPropertyFunc = !options.functionsAsIs && (0, _type.isFunction)(propertyValue) && !isWrapped(propertyValue);

      if (levelIndex === lastLevelIndex) {
        if (options.merge && (0, _type.isPlainObject)(value) && (!(0, _type.isDefined)(propertyValue) || (0, _type.isPlainObject)(propertyValue))) {
          propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options);
          (0, _object.deepExtendArraySafe)(propertyValue, value, false, true);
        } else if (isPropertyFunc) {
          currentValue[propertyName](value);
        } else {
          assignPropValue(currentValue, propertyName, value, options);
        }
      } else {
        propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options);

        if (isPropertyFunc) {
          propertyValue = propertyValue.call(currentValue);
        }

        currentValue = propertyValue;
      }
    });
  };
};

exports.compileSetter = compileSetter;

var toComparable = function toComparable(value, caseSensitive) {
  if (value instanceof Date) {
    return value.getTime();
  }

  if (value && value instanceof _class.default && value.valueOf) {
    return value.valueOf();
  }

  if (!caseSensitive && typeof value === 'string') {
    return value.toLowerCase();
  }

  return value;
};

exports.toComparable = toComparable;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getPublicElement = getPublicElement;
exports.setPublicElementWrapper = setPublicElementWrapper;

var strategy = function strategy(element) {
  return element && element.get(0);
};

function getPublicElement(element) {
  return strategy(element);
}

function setPublicElementWrapper(newStrategy) {
  strategy = newStrategy;
}

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.name = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _devices = _interopRequireDefault(__webpack_require__(13));

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _dom = __webpack_require__(35);

var _frame = __webpack_require__(122);

var _index = __webpack_require__(8);

var _event_nodes_disposing = __webpack_require__(395);

var _pointer = _interopRequireDefault(__webpack_require__(25));

var _emitter = _interopRequireDefault(__webpack_require__(127));

var _emitter_registrator = _interopRequireDefault(__webpack_require__(104));

var _version = __webpack_require__(71);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CLICK_EVENT_NAME = 'dxclick';
exports.name = CLICK_EVENT_NAME;
var TOUCH_BOUNDARY = 10;
var abs = Math.abs;

var isInput = function isInput(element) {
  return (0, _renderer.default)(element).is('input, textarea, select, button ,:focus, :focus *');
};

var misc = {
  requestAnimationFrame: _frame.requestAnimationFrame,
  cancelAnimationFrame: _frame.cancelAnimationFrame
};

var ClickEmitter = _emitter.default.inherit({
  ctor: function ctor(element) {
    this.callBase(element);

    this._makeElementClickable((0, _renderer.default)(element));
  },
  _makeElementClickable: function _makeElementClickable($element) {
    if (!$element.attr('onclick')) {
      $element.attr('onclick', 'void(0)');
    }
  },
  start: function start(e) {
    this._blurPrevented = e.isDefaultPrevented();
    this._startTarget = e.target;
    this._startEventData = (0, _index.eventData)(e);
  },
  end: function end(e) {
    if (this._eventOutOfElement(e, this.getElement().get(0)) || e.type === _pointer.default.cancel) {
      this._cancel(e);

      return;
    }

    if (!isInput(e.target) && !this._blurPrevented) {
      (0, _dom.resetActiveElement)();
    }

    this._accept(e);

    this._clickAnimationFrame = misc.requestAnimationFrame(function () {
      this._fireClickEvent(e);
    }.bind(this));
  },
  _eventOutOfElement: function _eventOutOfElement(e, element) {
    var target = e.target;
    var targetChanged = !(0, _dom.contains)(element, target) && element !== target;
    var gestureDelta = (0, _index.eventDelta)((0, _index.eventData)(e), this._startEventData);
    var boundsExceeded = abs(gestureDelta.x) > TOUCH_BOUNDARY || abs(gestureDelta.y) > TOUCH_BOUNDARY;
    return targetChanged || boundsExceeded;
  },
  _fireClickEvent: function _fireClickEvent(e) {
    this._fireEvent(CLICK_EVENT_NAME, e, {
      target: (0, _dom.closestCommonParent)(this._startTarget, e.target)
    });
  },
  dispose: function dispose() {
    misc.cancelAnimationFrame(this._clickAnimationFrame);
  }
}); // NOTE: native strategy for desktop, iOS 9.3+, Android 5+


var realDevice = _devices.default.real();

var useNativeClick = realDevice.generic || realDevice.ios && (0, _version.compare)(realDevice.version, [9, 3]) >= 0 || realDevice.android && (0, _version.compare)(realDevice.version, [5]) >= 0;

(function () {
  var NATIVE_CLICK_CLASS = 'dx-native-click';

  var isNativeClickEvent = function isNativeClickEvent(target) {
    return useNativeClick || (0, _renderer.default)(target).closest('.' + NATIVE_CLICK_CLASS).length;
  };

  var prevented = null;
  var lastFiredEvent = null;

  function onNodeRemove() {
    lastFiredEvent = null;
  }

  var clickHandler = function clickHandler(e) {
    var originalEvent = e.originalEvent;
    var eventAlreadyFired = lastFiredEvent === originalEvent || originalEvent && originalEvent.DXCLICK_FIRED;
    var leftButton = !e.which || e.which === 1;

    if (leftButton && !prevented && isNativeClickEvent(e.target) && !eventAlreadyFired) {
      if (originalEvent) {
        originalEvent.DXCLICK_FIRED = true;
      }

      (0, _event_nodes_disposing.unsubscribeNodesDisposing)(lastFiredEvent, onNodeRemove);
      lastFiredEvent = originalEvent;
      (0, _event_nodes_disposing.subscribeNodesDisposing)(lastFiredEvent, onNodeRemove);
      (0, _index.fireEvent)({
        type: CLICK_EVENT_NAME,
        originalEvent: e
      });
    }
  };

  ClickEmitter = ClickEmitter.inherit({
    _makeElementClickable: function _makeElementClickable($element) {
      if (!isNativeClickEvent($element)) {
        this.callBase($element);
      }

      _events_engine.default.on($element, 'click', clickHandler);
    },
    configure: function configure(data) {
      this.callBase(data);

      if (data.useNative) {
        this.getElement().addClass(NATIVE_CLICK_CLASS);
      }
    },
    start: function start(e) {
      prevented = null;

      if (!isNativeClickEvent(e.target)) {
        this.callBase(e);
      }
    },
    end: function end(e) {
      if (!isNativeClickEvent(e.target)) {
        this.callBase(e);
      }
    },
    cancel: function cancel() {
      prevented = true;
    },
    dispose: function dispose() {
      this.callBase();

      _events_engine.default.off(this.getElement(), 'click', clickHandler);
    }
  });
})(); // NOTE: fixes native click blur on slow devices


(function () {
  var desktopDevice = _devices.default.real().generic;

  if (!desktopDevice) {
    var startTarget = null;
    var blurPrevented = false;

    var pointerDownHandler = function pointerDownHandler(e) {
      startTarget = e.target;
      blurPrevented = e.isDefaultPrevented();
    };

    var clickHandler = function clickHandler(e) {
      var $target = (0, _renderer.default)(e.target);

      if (!blurPrevented && startTarget && !$target.is(startTarget) && !(0, _renderer.default)(startTarget).is('label') && isInput($target)) {
        (0, _dom.resetActiveElement)();
      }

      startTarget = null;
      blurPrevented = false;
    };

    var NATIVE_CLICK_FIXER_NAMESPACE = 'NATIVE_CLICK_FIXER';

    var document = _dom_adapter.default.getDocument();

    _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)(_pointer.default.down, NATIVE_CLICK_FIXER_NAMESPACE), pointerDownHandler);

    _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)('click', NATIVE_CLICK_FIXER_NAMESPACE), clickHandler);
  }
})();
/**
  * @name UI Events.dxclick
  * @type eventType
  * @type_function_param1 event:event
  * @module events/click
*/


(0, _emitter_registrator.default)({
  emitter: ClickEmitter,
  bubble: true,
  events: [CLICK_EVENT_NAME]
});

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _error = _interopRequireDefault(__webpack_require__(142));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
* @docid
* @name ErrorsCore
*/
var _default = (0, _error.default)({
  /**
  * @name ErrorsCore.E0001
  */
  E0001: 'Method is not implemented',

  /**
  * @name ErrorsCore.E0002
  */
  E0002: 'Member name collision: {0}',

  /**
  * @name ErrorsCore.E0003
  */
  E0003: 'A class must be instantiated using the \'new\' keyword',

  /**
  * @name ErrorsCore.E0004
  */
  E0004: 'The NAME property of the component is not specified',

  /**
  * @name ErrorsCore.E0005
  */
  E0005: 'Unknown device',

  /**
  * @name ErrorsCore.E0006
  */
  E0006: 'Unknown endpoint key is requested',

  /**
  * @name ErrorsCore.E0007
  */
  E0007: '\'Invalidate\' method is called outside the update transaction',

  /**
  * @name ErrorsCore.E0008
  */
  E0008: 'Type of the option name is not appropriate to create an action',

  /**
  * @name ErrorsCore.E0009
  */
  E0009: 'Component \'{0}\' has not been initialized for an element',

  /**
  * @name ErrorsCore.E0010
  */
  E0010: 'Animation configuration with the \'{0}\' type requires \'{1}\' configuration as {2}',

  /**
  * @name ErrorsCore.E0011
  */
  E0011: 'Unknown animation type \'{0}\'',

  /**
  * @name ErrorsCore.E0012
  */
  E0012: 'jQuery version is too old. Please upgrade jQuery to 1.10.0 or later',

  /**
  * @name ErrorsCore.E0013
  */
  E0013: 'KnockoutJS version is too old. Please upgrade KnockoutJS to 2.3.0 or later',

  /**
  * @name ErrorsCore.E0014
  */
  E0014: 'The \'release\' method shouldn\'t be called for an unlocked Lock object',

  /**
  * @name ErrorsCore.E0015
  */
  E0015: 'Queued task returned an unexpected result',

  /**
  * @name ErrorsCore.E0017
  */
  E0017: 'Event namespace is not defined',

  /**
  * @name ErrorsCore.E0018
  */
  E0018: 'DevExpress.ui.DevExpressPopup widget is required',

  /**
  * @name ErrorsCore.E0020
  */
  E0020: 'Template engine \'{0}\' is not supported',

  /**
  * @name ErrorsCore.E0021
  */
  E0021: 'Unknown theme is set: {0}',

  /**
  * @name ErrorsCore.E0022
  */
  E0022: 'LINK[rel=DevExpress-theme] tags must go before DevExpress included scripts',

  /**
  * @name ErrorsCore.E0023
  */
  E0023: 'Template name is not specified',

  /**
  * @name ErrorsCore.E0024
  */
  E0024: 'DevExtreme bundle already included',

  /**
  * @name ErrorsCore.E0025
  */
  E0025: 'Unexpected argument type',

  /**
  * @name ErrorsCore.E0100
  */
  E0100: 'Unknown validation type is detected',

  /**
  * @name ErrorsCore.E0101
  */
  E0101: 'Misconfigured range validation rule is detected',

  /**
  * @name ErrorsCore.E0102
  */
  E0102: 'Misconfigured comparison validation rule is detected',

  /**
  * @name ErrorsCore.E0103
  */
  E0103: 'validationCallback of an asynchronous rule should return a jQuery or a native promise',

  /**
  * @name ErrorsCore.E0110
  */
  E0110: 'Unknown validation group is detected',

  /**
  * @name ErrorsCore.E0120
  */
  E0120: 'Adapter for a DevExpressValidator component cannot be configured',

  /**
  * @name ErrorsCore.E0121
  */
  E0121: 'The \'customItem\' field of the \'onCustomItemCreating\' function\'s parameter should contain a custom item or Promise that is resolved after the item is created.',

  /**
  * @name ErrorsCore.W0000
  */
  W0000: '\'{0}\' is deprecated in {1}. {2}',

  /**
  * @name ErrorsCore.W0001
  */
  W0001: '{0} - \'{1}\' option is deprecated in {2}. {3}',

  /**
  * @name ErrorsCore.W0002
  */
  W0002: '{0} - \'{1}\' method is deprecated in {2}. {3}',

  /**
  * @name ErrorsCore.W0003
  */
  W0003: '{0} - \'{1}\' property is deprecated in {2}. {3}',

  /**
  * @name ErrorsCore.W0004
  */
  W0004: 'Timeout for theme loading is over: {0}',

  /**
  * @name ErrorsCore.W0005
  */
  W0005: '\'{0}\' event is deprecated in {1}. {2}',

  /**
  * @name ErrorsCore.W0006
  */
  W0006: 'Invalid recurrence rule: \'{0}\'',

  /**
  * @name ErrorsCore.W0007
  */
  W0007: '\'{0}\' Globalize culture is not defined',

  /**
  * @name ErrorsCore.W0008
  */
  W0008: 'Invalid view name: \'{0}\'',

  /**
  * @name ErrorsCore.W0009
  */
  W0009: 'Invalid time zone name: \'{0}\'',

  /**
  * @name ErrorsCore.W0010
  */
  W0010: '{0} is deprecated in {1}. {2}',

  /**
  * @name ErrorsCore.W0011
  */
  W0011: 'Number parsing is invoked while the parser is not defined',

  /**
  * @name ErrorsCore.W0012
  */
  W0012: 'Date parsing is invoked while the parser is not defined',

  /**
  * @name ErrorsCore.W0013
  */
  W0013: '\'{0}\' file is deprecated in {1}. {2}',

  /**
  * @name ErrorsCore.W0014
  */
  W0014: '{0} - \'{1}\' type is deprecated in {2}. {3}',

  /**
  * @name ErrorsCore.W0015
  */
  W0015: 'Instead of returning a value from the \'{0}\' function, write it into the \'{1}\' field of the function\'s parameter.',

  /**
  * @name ErrorsCore.W0016
  */
  W0016: 'The "{0}" option does not accept the "{1}" value since v.{2}. {3}.'
});

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.default = void 0;

var support = _interopRequireWildcard(__webpack_require__(48));

var _iterator = __webpack_require__(3);

var _browser = _interopRequireDefault(__webpack_require__(32));

var _devices = _interopRequireDefault(__webpack_require__(13));

var _event_registrator = _interopRequireDefault(__webpack_require__(68));

var _touch = _interopRequireDefault(__webpack_require__(262));

var _mspointer = _interopRequireDefault(__webpack_require__(387));

var _mouse = _interopRequireDefault(__webpack_require__(264));

var _mouse_and_touch = _interopRequireDefault(__webpack_require__(388));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
  * @name UI Events.dxpointerdown
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 pointerType:string
  * @module events/pointer
*/

/**
  * @name UI Events.dxpointermove
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 pointerType:string
  * @module events/pointer
*/

/**
  * @name UI Events.dxpointerup
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 pointerType:string
  * @module events/pointer
*/

/**
  * @name UI Events.dxpointercancel
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 pointerType:string
  * @module events/pointer
*/

/**
  * @name UI Events.dxpointerover
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 pointerType:string
  * @module events/pointer
*/

/**
  * @name UI Events.dxpointerout
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 pointerType:string
  * @module events/pointer
*/

/**
  * @name UI Events.dxpointerenter
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 pointerType:string
  * @module events/pointer
*/

/**
  * @name UI Events.dxpointerleave
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 pointerType:string
  * @module events/pointer
*/
var getStrategy = function getStrategy(support, device, browser) {
  if (support.pointerEvents && browser.msie) {
    return _mspointer.default;
  }

  var tablet = device.tablet,
      phone = device.phone;

  if (support.touch && !(tablet || phone)) {
    return _mouse_and_touch.default;
  }

  if (support.touch) {
    return _touch.default;
  }

  return _mouse.default;
};

var EventStrategy = getStrategy(support, _devices.default.real(), _browser.default);
(0, _iterator.each)(EventStrategy.map, function (pointerEvent, originalEvents) {
  (0, _event_registrator.default)(pointerEvent, new EventStrategy(pointerEvent, originalEvents));
});
var pointer = {
  down: 'dxpointerdown',
  up: 'dxpointerup',
  move: 'dxpointermove',
  cancel: 'dxpointercancel',
  enter: 'dxpointerenter',
  leave: 'dxpointerleave',
  over: 'dxpointerover',
  out: 'dxpointerout'
};
var _default = pointer;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getElementsFromPoint = exports.getDefaultAlignment = exports.getBoundingRect = void 0;

var _config = _interopRequireDefault(__webpack_require__(29));

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _browser = _interopRequireDefault(__webpack_require__(32));

var _type = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getDefaultAlignment = function getDefaultAlignment(isRtlEnabled) {
  var rtlEnabled = isRtlEnabled !== null && isRtlEnabled !== void 0 ? isRtlEnabled : (0, _config.default)().rtlEnabled;
  return rtlEnabled ? 'right' : 'left';
};

exports.getDefaultAlignment = getDefaultAlignment;

var getElementsFromPoint = function getElementsFromPoint(x, y) {
  var document = _dom_adapter.default.getDocument();

  if (_browser.default.msie) {
    var result = document.msElementsFromPoint(x, y);

    if (result) {
      return Array.prototype.slice.call(result);
    }

    return [];
  }

  return document.elementsFromPoint(x, y);
};

exports.getElementsFromPoint = getElementsFromPoint;

var getBoundingRect = function getBoundingRect(element) {
  if ((0, _type.isWindow)(element)) {
    return {
      width: element.outerWidth,
      height: element.outerHeight
    };
  }

  var rect;

  try {
    rect = element.getBoundingClientRect();
  } catch (e) {
    // NOTE: IE throws 'Unspecified error' if there is no such element on the page DOM
    rect = {
      width: 0,
      height: 0,
      bottom: 0,
      top: 0,
      left: 0,
      right: 0
    };
  }

  return rect;
};

exports.getBoundingRect = getBoundingRect;

/***/ }),
/* 27 */,
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var Callback = function Callback(options) {
  this._options = options || {};
  this._list = [];
  this._queue = [];
  this._firing = false;
  this._fired = false;
  this._firingIndexes = [];
};

Callback.prototype._fireCore = function (context, args) {
  var firingIndexes = this._firingIndexes;
  var list = this._list;
  var stopOnFalse = this._options.stopOnFalse;
  var step = firingIndexes.length;

  for (firingIndexes[step] = 0; firingIndexes[step] < list.length; firingIndexes[step]++) {
    var result = list[firingIndexes[step]].apply(context, args);

    if (result === false && stopOnFalse) {
      break;
    }
  }

  firingIndexes.pop();
};

Callback.prototype.add = function (fn) {
  if (typeof fn === 'function' && (!this._options.unique || !this.has(fn))) {
    this._list.push(fn);
  }

  return this;
};

Callback.prototype.remove = function (fn) {
  var list = this._list;
  var firingIndexes = this._firingIndexes;
  var index = list.indexOf(fn);

  if (index > -1) {
    list.splice(index, 1);

    if (this._firing && firingIndexes.length) {
      for (var step = 0; step < firingIndexes.length; step++) {
        if (index <= firingIndexes[step]) {
          firingIndexes[step]--;
        }
      }
    }
  }

  return this;
};

Callback.prototype.has = function (fn) {
  var list = this._list;
  return fn ? list.indexOf(fn) > -1 : !!list.length;
};

Callback.prototype.empty = function (fn) {
  this._list = [];
  return this;
};

Callback.prototype.fireWith = function (context, args) {
  var queue = this._queue;
  args = args || [];
  args = args.slice ? args.slice() : args;

  if (this._options.syncStrategy) {
    this._firing = true;

    this._fireCore(context, args);
  } else {
    queue.push([context, args]);

    if (this._firing) {
      return;
    }

    this._firing = true;

    while (queue.length) {
      var memory = queue.shift();

      this._fireCore(memory[0], memory[1]);
    }
  }

  this._firing = false;
  this._fired = true;
  return this;
};

Callback.prototype.fire = function () {
  this.fireWith(this, arguments);
};

Callback.prototype.fired = function () {
  return this._fired;
};

var Callbacks = function Callbacks(options) {
  return new Callback(options);
};

var _default = Callbacks;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _extend = __webpack_require__(0);

var _errors = _interopRequireDefault(__webpack_require__(24));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* global DevExpress */
var config = {
  rtlEnabled: false,
  defaultCurrency: 'USD',
  oDataFilterToLower: true,
  serverDecimalSeparator: '.',
  decimalSeparator: '.',
  thousandsSeparator: ',',
  forceIsoDateParsing: true,
  wrapActionsBeforeExecute: true,
  useLegacyStoreResult: false,

  /**
  * @name globalConfig.useJQuery
  * @type boolean
  * @hidden
  */
  useJQuery: undefined,
  editorStylingMode: undefined,
  useLegacyVisibleIndex: false,
  floatingActionButtonConfig: {
    icon: 'add',
    closeIcon: 'close',
    label: '',
    position: {
      at: 'right bottom',
      my: 'right bottom',
      offset: {
        x: -16,
        y: -16
      }
    },
    maxSpeedDialActionCount: 5,
    shading: false,
    direction: 'auto'
  },
  optionsParser: function optionsParser(optionsString) {
    if (optionsString.trim().charAt(0) !== '{') {
      optionsString = '{' + optionsString + '}';
    }

    try {
      // eslint-disable-next-line no-new-func
      return new Function('return ' + optionsString)();
    } catch (ex) {
      throw _errors.default.Error('E3018', ex, optionsString);
    }
  }
};
var deprecatedFields = ['decimalSeparator', 'thousandsSeparator'];

var configMethod = function configMethod() {
  if (!arguments.length) {
    return config;
  }

  var newConfig = arguments.length <= 0 ? undefined : arguments[0];
  deprecatedFields.forEach(function (deprecatedField) {
    if (newConfig[deprecatedField]) {
      var message = "Now, the ".concat(deprecatedField, " is selected based on the specified locale.");

      _errors.default.log('W0003', 'config', deprecatedField, '19.2', message);
    }
  });
  (0, _extend.extend)(config, newConfig);
};

if (typeof DevExpress !== 'undefined' && DevExpress.config) {
  configMethod(DevExpress.config);
}

var _default = configMethod;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 30 */,
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.adjust = adjust;
exports.getPrecision = getPrecision;
exports.getExponent = getExponent;
exports.getRoot = getRoot;
exports.solveCubicEquation = solveCubicEquation;
exports.trunc = trunc;
exports.roundFloatPart = roundFloatPart;
exports.getExponentLength = getExponentLength;
exports.getRemainderByDivision = getRemainderByDivision;
exports.inRange = exports.fitIntoRange = exports.sign = void 0;

var _type = __webpack_require__(1);

var sign = function sign(value) {
  if (value === 0) {
    return 0;
  }

  return value / Math.abs(value);
};

exports.sign = sign;

var fitIntoRange = function fitIntoRange(value, minValue, maxValue) {
  var isMinValueUndefined = !minValue && minValue !== 0;
  var isMaxValueUndefined = !maxValue && maxValue !== 0;
  isMinValueUndefined && (minValue = !isMaxValueUndefined ? Math.min(value, maxValue) : value);
  isMaxValueUndefined && (maxValue = !isMinValueUndefined ? Math.max(value, minValue) : value);
  return Math.min(Math.max(value, minValue), maxValue);
};

exports.fitIntoRange = fitIntoRange;

var inRange = function inRange(value, minValue, maxValue) {
  return value >= minValue && value <= maxValue;
};

exports.inRange = inRange;

function getExponent(value) {
  return Math.abs(parseInt(value.toExponential().split('e')[1]));
} // T570217


function _isEdgeBug() {
  var value = 0.0003;
  var correctValue = '0.000300';
  var precisionValue = 3;
  return correctValue !== value.toPrecision(precisionValue);
}

function adjust(value, interval) {
  var precision = getPrecision(interval || 0) + 2;
  var separatedValue = value.toString().split('.');
  var sourceValue = value;
  var absValue = Math.abs(value);
  var separatedAdjustedValue;
  var isExponentValue = (0, _type.isExponential)(value);
  var integerPart = absValue > 1 ? 10 : 0;

  if (separatedValue.length === 1) {
    return value;
  }

  if (!isExponentValue) {
    if ((0, _type.isExponential)(interval)) {
      precision = separatedValue[0].length + getExponent(interval);
    }

    value = absValue;
    value = value - Math.floor(value) + integerPart;
  }

  precision = _isEdgeBug() && getExponent(value) > 6 || precision > 7 ? 15 : 7; // fix toPrecision() bug in Edge (T570217)

  if (!isExponentValue) {
    separatedAdjustedValue = parseFloat(value.toPrecision(precision)).toString().split('.');

    if (separatedAdjustedValue[0] === integerPart.toString()) {
      return parseFloat(separatedValue[0] + '.' + separatedAdjustedValue[1]);
    }
  }

  return parseFloat(sourceValue.toPrecision(precision));
}

function getPrecision(value) {
  var str = value.toString();

  if (str.indexOf('.') < 0) {
    return 0;
  }

  var mantissa = str.split('.');
  var positionOfDelimiter = mantissa[1].indexOf('e');
  return positionOfDelimiter >= 0 ? positionOfDelimiter : mantissa[1].length;
}

function getRoot(x, n) {
  if (x < 0 && n % 2 !== 1) {
    return NaN;
  }

  var y = Math.pow(Math.abs(x), 1 / n);
  return n % 2 === 1 && x < 0 ? -y : y;
}

function solveCubicEquation(a, b, c, d) {
  var min = 1e-8;

  if (Math.abs(a) < min) {
    a = b;
    b = c;
    c = d;

    if (Math.abs(a) < min) {
      a = b;
      b = c;

      if (Math.abs(a) < min) {
        return [];
      }

      return [-b / a];
    }

    var D2 = b * b - 4 * a * c;

    if (Math.abs(D2) < min) {
      return [-b / (2 * a)];
    } else if (D2 > 0) {
      return [(-b + Math.sqrt(D2)) / (2 * a), (-b - Math.sqrt(D2)) / (2 * a)];
    }

    return [];
  }

  var p = (3 * a * c - b * b) / (3 * a * a);
  var q = (2 * b * b * b - 9 * a * b * c + 27 * a * a * d) / (27 * a * a * a);
  var roots;
  var u;

  if (Math.abs(p) < min) {
    roots = [getRoot(-q, 3)];
  } else if (Math.abs(q) < min) {
    roots = [0].concat(p < 0 ? [Math.sqrt(-p), -Math.sqrt(-p)] : []);
  } else {
    var D3 = q * q / 4 + p * p * p / 27;

    if (Math.abs(D3) < min) {
      roots = [-1.5 * q / p, 3 * q / p];
    } else if (D3 > 0) {
      u = getRoot(-q / 2 - Math.sqrt(D3), 3);
      roots = [u - p / (3 * u)];
    } else {
      u = 2 * Math.sqrt(-p / 3);
      var t = Math.acos(3 * q / p / u) / 3;
      var k = 2 * Math.PI / 3;
      roots = [u * Math.cos(t), u * Math.cos(t - k), u * Math.cos(t - 2 * k)];
    }
  }

  for (var i = 0; i < roots.length; i++) {
    roots[i] -= b / (3 * a);
  }

  return roots;
}

function trunc(value) {
  return Math.trunc ? Math.trunc(value) : value > 0 ? Math.floor(value) : Math.ceil(value);
}

function getRemainderByDivision(dividend, divider, digitsCount) {
  if (divider === parseInt(divider)) {
    return dividend % divider;
  }

  var quotient = roundFloatPart(dividend / divider, digitsCount);
  return (quotient - parseInt(quotient)) * divider;
}

function getExponentLength(value) {
  var _valueString$split$;

  var valueString = value.toString();
  return ((_valueString$split$ = valueString.split('.')[1]) === null || _valueString$split$ === void 0 ? void 0 : _valueString$split$.length) || parseInt(valueString.split('e-')[1]) || 0;
}

function roundFloatPart(value) {
  var digitsCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return parseFloat(value.toFixed(digitsCount));
}

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _extend = __webpack_require__(0);

var _window = __webpack_require__(7);

var navigator = (0, _window.getNavigator)();
var webkitRegExp = /(webkit)[ /]([\w.]+)/;
var ieRegExp = /(msie) (\d{1,2}\.\d)/;
var ie11RegExp = /(trident).*rv:(\d{1,2}\.\d)/;
var msEdge = /(edge)\/((\d+)?[\w.]+)/;
var mozillaRegExp = /(mozilla)(?:.*? rv:([\w.]+))/;

var browserFromUA = function browserFromUA(ua) {
  ua = ua.toLowerCase();
  var result = {};
  var matches = ieRegExp.exec(ua) || ie11RegExp.exec(ua) || msEdge.exec(ua) || ua.indexOf('compatible') < 0 && mozillaRegExp.exec(ua) || webkitRegExp.exec(ua) || [];
  var browserName = matches[1];
  var browserVersion = matches[2];

  if (browserName === 'webkit') {
    result['webkit'] = true;

    if (ua.indexOf('chrome') >= 0 || ua.indexOf('crios') >= 0) {
      browserName = 'chrome';
      browserVersion = /(?:chrome|crios)\/(\d+\.\d+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else if (ua.indexOf('fxios') >= 0) {
      browserName = 'mozilla';
      browserVersion = /fxios\/(\d+\.\d+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else if (ua.indexOf('safari') >= 0 && /version|phantomjs/.test(ua)) {
      browserName = 'safari';
      browserVersion = /(?:version|phantomjs)\/([0-9.]+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else {
      browserName = 'unknown';
      browserVersion = /applewebkit\/([0-9.]+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    }
  }

  if (browserName === 'trident' || browserName === 'edge') {
    browserName = 'msie';
  }

  if (browserName) {
    result[browserName] = true;
    result.version = browserVersion;
  }

  return result;
};

var _default = (0, _extend.extend)({
  _fromUA: browserFromUA
}, browserFromUA(navigator.userAgent));

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _dependency_injector = _interopRequireDefault(__webpack_require__(55));

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

var _array = __webpack_require__(12);

var _errors = _interopRequireDefault(__webpack_require__(24));

var _date = __webpack_require__(253);

var _date2 = __webpack_require__(170);

var _date3 = __webpack_require__(216);

var _default_date_names = _interopRequireDefault(__webpack_require__(254));

var _first_day_of_week_data = _interopRequireDefault(__webpack_require__(361));

var _core = _interopRequireDefault(__webpack_require__(85));

var _number = _interopRequireDefault(__webpack_require__(46));

var _date4 = _interopRequireDefault(__webpack_require__(362));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_DAY_OF_WEEK_INDEX = 0;
var hasIntl = typeof Intl !== 'undefined';
var FORMATS_TO_PATTERN_MAP = {
  'shortdate': 'M/d/y',
  'shorttime': 'h:mm a',
  'longdate': 'EEEE, MMMM d, y',
  'longtime': 'h:mm:ss a',
  'monthandday': 'MMMM d',
  'monthandyear': 'MMMM y',
  'quarterandyear': 'QQQ y',
  'day': 'd',
  'year': 'y',
  'shortdateshorttime': 'M/d/y, h:mm a',
  'longdatelongtime': 'EEEE, MMMM d, y, h:mm:ss a',
  'month': 'LLLL',
  'shortyear': 'yy',
  'dayofweek': 'EEEE',
  'quarter': 'QQQ',
  'hour': 'HH',
  'minute': 'mm',
  'second': 'ss',
  'millisecond': 'SSS',
  'datetime-local': 'yyyy-MM-ddTHH\':\'mm\':\'ss'
};
var possiblePartPatterns = {
  year: ['y', 'yy', 'yyyy'],
  day: ['d', 'dd'],
  month: ['M', 'MM', 'MMM', 'MMMM'],
  hours: ['H', 'HH', 'h', 'hh', 'ah'],
  minutes: ['m', 'mm'],
  seconds: ['s', 'ss'],
  milliseconds: ['S', 'SS', 'SSS']
};
var dateLocalization = (0, _dependency_injector.default)({
  engine: function engine() {
    return 'base';
  },
  _getPatternByFormat: function _getPatternByFormat(format) {
    return FORMATS_TO_PATTERN_MAP[format.toLowerCase()];
  },
  _expandPattern: function _expandPattern(pattern) {
    return this._getPatternByFormat(pattern) || pattern;
  },
  formatUsesMonthName: function formatUsesMonthName(format) {
    return this._expandPattern(format).indexOf('MMMM') !== -1;
  },
  formatUsesDayName: function formatUsesDayName(format) {
    return this._expandPattern(format).indexOf('EEEE') !== -1;
  },
  getFormatParts: function getFormatParts(format) {
    var pattern = this._getPatternByFormat(format) || format;
    var result = [];
    (0, _iterator.each)(pattern.split(/\W+/), function (_, formatPart) {
      (0, _iterator.each)(possiblePartPatterns, function (partName, possiblePatterns) {
        if ((0, _array.inArray)(formatPart, possiblePatterns) > -1) {
          result.push(partName);
        }
      });
    });
    return result;
  },
  getMonthNames: function getMonthNames(format) {
    return _default_date_names.default.getMonthNames(format);
  },
  getDayNames: function getDayNames(format) {
    return _default_date_names.default.getDayNames(format);
  },
  getQuarterNames: function getQuarterNames(format) {
    return _default_date_names.default.getQuarterNames(format);
  },
  getPeriodNames: function getPeriodNames(format) {
    return _default_date_names.default.getPeriodNames(format);
  },
  getTimeSeparator: function getTimeSeparator() {
    return ':';
  },
  is24HourFormat: function is24HourFormat(format) {
    var amTime = new Date(2017, 0, 20, 11, 0, 0, 0);
    var pmTime = new Date(2017, 0, 20, 23, 0, 0, 0);
    var amTimeFormatted = this.format(amTime, format);
    var pmTimeFormatted = this.format(pmTime, format);

    for (var i = 0; i < amTimeFormatted.length; i++) {
      if (amTimeFormatted[i] !== pmTimeFormatted[i]) {
        return !isNaN(parseInt(amTimeFormatted[i]));
      }
    }
  },
  format: function format(date, _format) {
    if (!date) {
      return;
    }

    if (!_format) {
      return date;
    }

    var formatter;

    if (typeof _format === 'function') {
      formatter = _format;
    } else if (_format.formatter) {
      formatter = _format.formatter;
    } else {
      _format = _format.type || _format;

      if ((0, _type.isString)(_format)) {
        _format = FORMATS_TO_PATTERN_MAP[_format.toLowerCase()] || _format;
        return _number.default.convertDigits((0, _date.getFormatter)(_format, this)(date));
      }
    }

    if (!formatter) {
      // TODO: log warning or error
      return;
    }

    return formatter(date);
  },
  parse: function parse(text, format) {
    var that = this;
    var ldmlFormat;
    var formatter;

    if (!text) {
      return;
    }

    if (!format) {
      return this.parse(text, 'shortdate');
    }

    if (format.parser) {
      return format.parser(text);
    }

    if (typeof format === 'string' && !FORMATS_TO_PATTERN_MAP[format.toLowerCase()]) {
      ldmlFormat = format;
    } else {
      formatter = function formatter(value) {
        var text = that.format(value, format);
        return _number.default.convertDigits(text, true);
      };

      try {
        ldmlFormat = (0, _date2.getFormat)(formatter);
      } catch (e) {}
    }

    if (ldmlFormat) {
      text = _number.default.convertDigits(text, true);
      return (0, _date3.getParser)(ldmlFormat, this)(text);
    }

    _errors.default.log('W0012');

    var result = new Date(text);

    if (!result || isNaN(result.getTime())) {
      return;
    }

    return result;
  },
  firstDayOfWeekIndex: function firstDayOfWeekIndex() {
    var index = _core.default.getValueByClosestLocale(function (locale) {
      return _first_day_of_week_data.default[locale];
    });

    return index === undefined ? DEFAULT_DAY_OF_WEEK_INDEX : index;
  }
});

if (hasIntl) {
  dateLocalization.inject(_date4.default);
}

var _default = dateLocalization;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.parseTranslate = exports.resetPosition = exports.move = exports.getTranslate = exports.getTranslateCss = exports.clearCache = exports.locate = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _element_data = __webpack_require__(43);

var _type = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TRANSLATOR_DATA_KEY = 'dxTranslator';
var TRANSFORM_MATRIX_REGEX = /matrix(3d)?\((.+?)\)/;
var TRANSLATE_REGEX = /translate(?:3d)?\((.+?)\)/;

var locate = function locate($element) {
  $element = (0, _renderer.default)($element);
  var translate = getTranslate($element);
  return {
    left: translate.x,
    top: translate.y
  };
};

exports.locate = locate;

function isPercentValue(value) {
  return (0, _type.type)(value) === 'string' && value[value.length - 1] === '%';
}

function cacheTranslate($element, translate) {
  if ($element.length) {
    (0, _element_data.data)($element.get(0), TRANSLATOR_DATA_KEY, translate);
  }
}

var clearCache = function clearCache($element) {
  if ($element.length) {
    (0, _element_data.removeData)($element.get(0), TRANSLATOR_DATA_KEY);
  }
};

exports.clearCache = clearCache;

var getTranslateCss = function getTranslateCss(translate) {
  translate.x = translate.x || 0;
  translate.y = translate.y || 0;
  var xValueString = isPercentValue(translate.x) ? translate.x : translate.x + 'px';
  var yValueString = isPercentValue(translate.y) ? translate.y : translate.y + 'px';
  return 'translate(' + xValueString + ', ' + yValueString + ')';
};

exports.getTranslateCss = getTranslateCss;

var getTranslate = function getTranslate($element) {
  var result = $element.length ? (0, _element_data.data)($element.get(0), TRANSLATOR_DATA_KEY) : null;

  if (!result) {
    var transformValue = $element.css('transform') || getTranslateCss({
      x: 0,
      y: 0
    });
    var matrix = transformValue.match(TRANSFORM_MATRIX_REGEX);
    var is3D = matrix && matrix[1];

    if (matrix) {
      matrix = matrix[2].split(',');

      if (is3D === '3d') {
        matrix = matrix.slice(12, 15);
      } else {
        matrix.push(0);
        matrix = matrix.slice(4, 7);
      }
    } else {
      matrix = [0, 0, 0];
    }

    result = {
      x: parseFloat(matrix[0]),
      y: parseFloat(matrix[1]),
      z: parseFloat(matrix[2])
    };
    cacheTranslate($element, result);
  }

  return result;
};

exports.getTranslate = getTranslate;

var move = function move($element, position) {
  $element = (0, _renderer.default)($element);
  var left = position.left;
  var top = position.top;
  var translate;

  if (left === undefined) {
    translate = getTranslate($element);
    translate.y = top || 0;
  } else if (top === undefined) {
    translate = getTranslate($element);
    translate.x = left || 0;
  } else {
    translate = {
      x: left || 0,
      y: top || 0,
      z: 0
    };
    cacheTranslate($element, translate);
  }

  $element.css({
    transform: getTranslateCss(translate)
  });

  if (isPercentValue(left) || isPercentValue(top)) {
    clearCache($element);
  }
};

exports.move = move;

var resetPosition = function resetPosition($element, finishTransition) {
  $element = (0, _renderer.default)($element);
  var originalTransition;
  var stylesConfig = {
    left: 0,
    top: 0,
    transform: 'none'
  };

  if (finishTransition) {
    originalTransition = $element.css('transition');
    stylesConfig.transition = 'none';
  }

  $element.css(stylesConfig);
  clearCache($element);

  if (finishTransition) {
    $element.get(0).offsetHeight;
    $element.css('transition', originalTransition);
  }
};

exports.resetPosition = resetPosition;

var parseTranslate = function parseTranslate(translateString) {
  var result = translateString.match(TRANSLATE_REGEX);

  if (!result || !result[1]) {
    return;
  }

  result = result[1].split(',');
  result = {
    x: parseFloat(result[0]),
    y: parseFloat(result[1]),
    z: parseFloat(result[2])
  };
  return result;
};

exports.parseTranslate = parseTranslate;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.replaceWith = exports.insertBefore = exports.createTextElementHiddenCopy = exports.contains = exports.clipboardText = exports.normalizeTemplateElement = exports.extractTemplateMarkup = exports.closestCommonParent = exports.clearSelection = exports.resetActiveElement = void 0;

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _iterator = __webpack_require__(3);

var _type = __webpack_require__(1);

var _window = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var window = (0, _window.getWindow)();

var resetActiveElement = function resetActiveElement() {
  var activeElement = _dom_adapter.default.getActiveElement();

  var body = _dom_adapter.default.getBody(); // TODO: remove this hack after msie 11 support stopped


  if (activeElement && activeElement !== body && activeElement.blur) {
    try {
      activeElement.blur();
    } catch (e) {
      body.blur();
    }
  }
};

exports.resetActiveElement = resetActiveElement;

var clearSelection = function clearSelection() {
  var selection = window.getSelection();
  if (!selection) return;
  if (selection.type === 'Caret') return;

  if (selection.empty) {
    selection.empty();
  } else if (selection.removeAllRanges) {
    // T522811
    try {
      selection.removeAllRanges();
    } catch (e) {}
  }
};

exports.clearSelection = clearSelection;

var closestCommonParent = function closestCommonParent(startTarget, endTarget) {
  var $startTarget = (0, _renderer.default)(startTarget);
  var $endTarget = (0, _renderer.default)(endTarget);

  if ($startTarget[0] === $endTarget[0]) {
    return $startTarget[0];
  }

  var $startParents = $startTarget.parents();
  var $endParents = $endTarget.parents();
  var startingParent = Math.min($startParents.length, $endParents.length);

  for (var i = -startingParent; i < 0; i++) {
    if ($startParents.get(i) === $endParents.get(i)) {
      return $startParents.get(i);
    }
  }
};

exports.closestCommonParent = closestCommonParent;

var extractTemplateMarkup = function extractTemplateMarkup(element) {
  element = (0, _renderer.default)(element);
  var templateTag = element.length && element.filter(function isNotExecutableScript() {
    var $node = (0, _renderer.default)(this);
    return $node.is('script[type]') && $node.attr('type').indexOf('script') < 0;
  });

  if (templateTag.length) {
    return templateTag.eq(0).html();
  } else {
    element = (0, _renderer.default)('<div>').append(element);
    return element.html();
  }
};

exports.extractTemplateMarkup = extractTemplateMarkup;

var normalizeTemplateElement = function normalizeTemplateElement(element) {
  var $element = (0, _type.isDefined)(element) && (element.nodeType || (0, _type.isRenderer)(element)) ? (0, _renderer.default)(element) : (0, _renderer.default)('<div>').html(element).contents();

  if ($element.length === 1) {
    if ($element.is('script')) {
      $element = normalizeTemplateElement($element.html().trim());
    } else if ($element.is('table')) {
      $element = $element.children('tbody').contents();
    }
  }

  return $element;
};

exports.normalizeTemplateElement = normalizeTemplateElement;

var clipboardText = function clipboardText(event, text) {
  var clipboard = event.originalEvent && event.originalEvent.clipboardData || window.clipboardData;

  if (arguments.length === 1) {
    return clipboard && clipboard.getData('Text');
  }

  clipboard && clipboard.setData('Text', text);
};

exports.clipboardText = clipboardText;

var contains = function contains(container, element) {
  if (!element) {
    return false;
  }

  if (_dom_adapter.default.isTextNode(element)) {
    element = element.parentNode;
  }

  if (_dom_adapter.default.isDocument(container)) {
    return container.documentElement.contains(element);
  }

  if ((0, _type.isWindow)(container)) {
    return contains(container.document, element);
  }

  return container.contains ? container.contains(element) : !!(element.compareDocumentPosition(container) & element.DOCUMENT_POSITION_CONTAINS);
};

exports.contains = contains;

var createTextElementHiddenCopy = function createTextElementHiddenCopy(element, text, options) {
  var elementStyles = window.getComputedStyle((0, _renderer.default)(element).get(0));
  var includePaddings = options && options.includePaddings;
  return (0, _renderer.default)('<div>').text(text).css({
    'fontStyle': elementStyles.fontStyle,
    'fontVariant': elementStyles.fontVariant,
    'fontWeight': elementStyles.fontWeight,
    'fontSize': elementStyles.fontSize,
    'fontFamily': elementStyles.fontFamily,
    'letterSpacing': elementStyles.letterSpacing,
    'border': elementStyles.border,
    'paddingTop': includePaddings ? elementStyles.paddingTop : '',
    'paddingRight': includePaddings ? elementStyles.paddingRight : '',
    'paddingBottom': includePaddings ? elementStyles.paddingBottom : '',
    'paddingLeft': includePaddings ? elementStyles.paddingLeft : '',
    'visibility': 'hidden',
    'whiteSpace': 'pre',
    'position': 'absolute',
    'float': 'left'
  });
};

exports.createTextElementHiddenCopy = createTextElementHiddenCopy;

var insertBefore = function insertBefore(element, newElement) {
  if (newElement) {
    _dom_adapter.default.insertElement(element.parentNode, newElement, element);
  }

  return element;
};

exports.insertBefore = insertBefore;

var replaceWith = function replaceWith(element, newElement) {
  if (!(newElement && newElement[0])) return;
  if (newElement.is(element)) return element;
  (0, _iterator.each)(newElement, function (_, currentElement) {
    insertBefore(element[0], currentElement);
  });
  element.remove();
  return newElement;
};

exports.replaceWith = replaceWith;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _class = _interopRequireDefault(__webpack_require__(15));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Guid = _class.default.inherit({
  /**
  * @name Guid.ctor
  * @publicName ctor()
  */

  /**
  * @name Guid.ctor
  * @publicName ctor(value)
  * @param1 value:string
  */
  ctor: function ctor(value) {
    if (value) {
      value = String(value);
    }

    this._value = this._normalize(value || this._generate());
  },
  _normalize: function _normalize(value) {
    value = value.replace(/[^a-f0-9]/ig, '').toLowerCase();

    while (value.length < 32) {
      value += '0';
    }

    return [value.substr(0, 8), value.substr(8, 4), value.substr(12, 4), value.substr(16, 4), value.substr(20, 12)].join('-');
  },
  _generate: function _generate() {
    var value = '';

    for (var i = 0; i < 32; i++) {
      value += Math.round(Math.random() * 15).toString(16);
    }

    return value;
  },
  toString: function toString() {
    return this._value;
  },
  valueOf: function valueOf() {
    return this._value;
  },
  toJSON: function toJSON() {
    return this._value;
  }
});

var _default = Guid;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.setErrorHandler = exports.handleError = exports.errorHandler = exports.errors = void 0;

var _error = _interopRequireDefault(__webpack_require__(142));

var _errors = _interopRequireDefault(__webpack_require__(24));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
* @docid
* @name ErrorsData
*/
var errors = (0, _error.default)(_errors.default.ERROR_MESSAGES, {
  /**
  * @name ErrorsData.E4000
  */
  E4000: '[DevExpress.data]: {0}',

  /**
    * @name ErrorsData.E4001
    */
  E4001: 'Unknown aggregating function is detected: \'{0}\'',

  /**
  * @name ErrorsData.E4002
  */
  E4002: 'Unsupported OData protocol version is used',

  /**
  * @name ErrorsData.E4003
  */
  E4003: 'Unknown filter operation is used: {0}',

  /**
  * @name ErrorsData.E4004
  */
  E4004: 'The thenby() method is called before the sortby() method',

  /**
  * @name ErrorsData.E4005
  */
  E4005: 'Store requires a key expression for this operation',

  /**
  * @name ErrorsData.E4006
  */
  E4006: 'ArrayStore \'data\' option must be an array',

  /**
  * @name ErrorsData.E4007
  */
  E4007: 'Compound keys cannot be auto-generated',

  /**
  * @name ErrorsData.E4008
  */
  E4008: 'Attempt to insert an item with a duplicated key',

  /**
  * @name ErrorsData.E4009
  */
  E4009: 'Data item cannot be found',

  /**
  * @name ErrorsData.E4010
  */
  E4010: 'CustomStore does not support creating queries',

  /**
  * @name ErrorsData.E4011
  */
  E4011: 'Custom Store method is not implemented or is not a function: {0}',

  /**
  * @name ErrorsData.E4012
  */
  E4012: 'Custom Store method returns an invalid value: {0}',

  /**
  * @name ErrorsData.E4013
  */
  E4013: 'Local Store requires the \'name\' configuration option is specified',

  /**
  * @name ErrorsData.E4014
  */
  E4014: 'Unknown data type is specified for ODataStore: {0}',

  /**
  * @name ErrorsData.E4015
  */
  E4015: 'Unknown entity name or alias is used: {0}',

  /**
  * @name ErrorsData.E4016
  */
  E4016: 'The compileSetter(expr) method is called with \'self\' passed as a parameter',

  /**
  * @name ErrorsData.E4017
  */
  E4017: 'Keys cannot be modified',

  /**
  * @name ErrorsData.E4018
  */
  E4018: 'The server has returned a non-numeric value in a response to an item count request',

  /**
  * @name ErrorsData.E4019
  */
  E4019: 'Mixing of group operators inside a single group of filter expression is not allowed',

  /**
  * @name ErrorsData.E4020
  */
  E4020: 'Unknown store type is detected: {0}',

  /**
  * @name ErrorsData.E4021
  */
  E4021: 'The server response does not provide the totalCount value',

  /**
  * @name ErrorsData.E4022
  */
  E4022: 'The server response does not provide the groupCount value',

  /**
  * @name ErrorsData.E4023
  */
  E4023: 'Could not parse the following XML: {0}',

  /**
  * @name ErrorsData.E4024
  */
  E4024: 'String function {0} cannot be used with the data field {1} of type {2}.',

  /**
  * @name ErrorsData.W4000
  */
  W4000: 'Data returned from the server has an incorrect structure',

  /**
  * @name ErrorsData.W4001
  */
  W4001: 'The {0} field is listed in both "keyType" and "fieldTypes". The value of "fieldTypes" is used.',

  /**
  * @name ErrorsData.W4002
  */
  W4002: 'Data loading has failed for some cells due to the following error: {0}'
});
exports.errors = errors;
var errorHandler = null;
exports.errorHandler = errorHandler;

var handleError = function handleError(error) {
  var _errorHandler;

  (_errorHandler = errorHandler) === null || _errorHandler === void 0 ? void 0 : _errorHandler(error);
};

exports.handleError = handleError;

var setErrorHandler = function setErrorHandler(handler) {
  return exports.errorHandler = errorHandler = handler;
};

exports.setErrorHandler = setErrorHandler;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.waitForThemeLoad = waitForThemeLoad;
exports.isPendingThemeLoaded = isPendingThemeLoaded;
exports.init = init;
exports.current = current;
exports.attachCssClasses = attachCssClasses;
exports.detachCssClasses = detachCssClasses;
exports.isMaterial = isMaterial;
exports.isGeneric = isGeneric;
exports.isDark = isDark;
exports.isWebFontLoaded = isWebFontLoaded;
exports.waitWebFont = waitWebFont;
exports.ready = themeReady;
exports.resetTheme = resetTheme;
exports.initialized = initialized;
exports.setDefaultTimeout = setDefaultTimeout;
exports.default = void 0;

var _devices = _interopRequireDefault(__webpack_require__(13));

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _promise = _interopRequireDefault(__webpack_require__(81));

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _deferred = __webpack_require__(6);

var _html_parser = __webpack_require__(249);

var _iterator = __webpack_require__(3);

var _ready_callbacks = _interopRequireDefault(__webpack_require__(51));

var _view_port = __webpack_require__(77);

var _window = __webpack_require__(7);

var _themes_callback = __webpack_require__(214);

var _ui = _interopRequireDefault(__webpack_require__(19));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var window = (0, _window.getWindow)();
var ready = _ready_callbacks.default.add;
var viewPort = _view_port.value;
var viewPortChanged = _view_port.changeCallback;
var initDeferred = new _deferred.Deferred();
var DX_LINK_SELECTOR = 'link[rel=dx-theme]';
var THEME_ATTR = 'data-theme';
var ACTIVE_ATTR = 'data-active';
var DX_HAIRLINES_CLASS = 'dx-hairlines';
var ANY_THEME = 'any';
var context;
var $activeThemeLink;
var knownThemes;
var currentThemeName;
var pendingThemeName;
var defaultTimeout = 15000;
var THEME_MARKER_PREFIX = 'dx.';

function readThemeMarker() {
  if (!(0, _window.hasWindow)()) {
    return null;
  }

  var element = (0, _renderer.default)('<div>', context).addClass('dx-theme-marker').appendTo(context.documentElement);
  var result;

  try {
    result = window.getComputedStyle(element.get(0))['fontFamily'];

    if (!result) {
      return null;
    }

    result = result.replace(/["']/g, '');

    if (result.substr(0, THEME_MARKER_PREFIX.length) !== THEME_MARKER_PREFIX) {
      return null;
    }

    return result.substr(THEME_MARKER_PREFIX.length);
  } finally {
    element.remove();
  }
} // FYI
// http://stackoverflow.com/q/2635814
// http://stackoverflow.com/a/3078636


function waitForThemeLoad(themeName) {
  var waitStartTime;
  var timerId;
  var intervalCleared = true;
  pendingThemeName = themeName;

  function handleLoaded() {
    pendingThemeName = null;
    clearInterval(timerId);
    intervalCleared = true;

    _themes_callback.themeReadyCallback.fire();

    _themes_callback.themeReadyCallback.empty();

    initDeferred.resolve();
  }

  if (isPendingThemeLoaded() || !defaultTimeout) {
    handleLoaded();
  } else {
    if (!intervalCleared) {
      if (pendingThemeName) {
        pendingThemeName = themeName;
      }

      return;
    }

    waitStartTime = Date.now();
    intervalCleared = false;
    timerId = setInterval(function () {
      var isLoaded = isPendingThemeLoaded();
      var isTimeout = !isLoaded && Date.now() - waitStartTime > defaultTimeout;

      if (isTimeout) {
        _ui.default.log('W0004', pendingThemeName);
      }

      if (isLoaded || isTimeout) {
        handleLoaded();
      }
    }, 10);
  }
}

function isPendingThemeLoaded() {
  if (!pendingThemeName) {
    return true;
  }

  var anyThemePending = pendingThemeName === ANY_THEME;

  if (initDeferred.state() === 'resolved' && anyThemePending) {
    return true;
  }

  var themeMarker = readThemeMarker();

  if (themeMarker && anyThemePending) {
    return true;
  }

  return themeMarker === pendingThemeName;
}

function processMarkup() {
  var $allThemeLinks = (0, _renderer.default)(DX_LINK_SELECTOR, context);

  if (!$allThemeLinks.length) {
    return;
  }

  knownThemes = {};
  $activeThemeLink = (0, _renderer.default)((0, _html_parser.parseHTML)('<link rel=stylesheet>'), context);
  $allThemeLinks.each(function () {
    var link = (0, _renderer.default)(this, context);
    var fullThemeName = link.attr(THEME_ATTR);
    var url = link.attr('href');
    var isActive = link.attr(ACTIVE_ATTR) === 'true';
    knownThemes[fullThemeName] = {
      url: url,
      isActive: isActive
    };
  });
  $allThemeLinks.last().after($activeThemeLink);
  $allThemeLinks.remove();
}

function resolveFullThemeName(desiredThemeName) {
  var desiredThemeParts = desiredThemeName ? desiredThemeName.split('.') : [];
  var result = null;

  if (knownThemes) {
    if (desiredThemeName in knownThemes) {
      return desiredThemeName;
    }

    (0, _iterator.each)(knownThemes, function (knownThemeName, themeData) {
      var knownThemeParts = knownThemeName.split('.');

      if (desiredThemeParts[0] && knownThemeParts[0] !== desiredThemeParts[0]) {
        return;
      }

      if (desiredThemeParts[1] && desiredThemeParts[1] !== knownThemeParts[1]) {
        return;
      }

      if (desiredThemeParts[2] && desiredThemeParts[2] !== knownThemeParts[2]) {
        return;
      }

      if (!result || themeData.isActive) {
        result = knownThemeName;
      }

      if (themeData.isActive) {
        return false;
      }
    });
  }

  return result;
}

function initContext(newContext) {
  try {
    if (newContext !== context) {
      knownThemes = null;
    }
  } catch (x) {
    // Cross-origin permission error
    knownThemes = null;
  }

  context = newContext;
}

function init(options) {
  options = options || {};
  initContext(options.context || _dom_adapter.default.getDocument());
  if (!context) return;
  processMarkup();
  currentThemeName = undefined;
  current(options);
}

function current(options) {
  if (!arguments.length) {
    currentThemeName = currentThemeName || readThemeMarker();
    return currentThemeName;
  }

  detachCssClasses(viewPort());
  options = options || {};

  if (typeof options === 'string') {
    options = {
      theme: options
    };
  }

  var isAutoInit = options._autoInit;
  var loadCallback = options.loadCallback;
  var currentThemeData;
  currentThemeName = resolveFullThemeName(options.theme || currentThemeName);

  if (currentThemeName) {
    currentThemeData = knownThemes[currentThemeName];
  }

  if (loadCallback) {
    _themes_callback.themeReadyCallback.add(loadCallback);
  }

  if (currentThemeData) {
    // NOTE:
    // 1. <link> element re-creation leads to incorrect CSS rules priority in Internet Explorer (T246821).
    // 2. We have no reliable info, why this hack has been applied and whether it is still relevant.
    // 3. This hack leads Internet Explorer crashing after icon font has been implemented.
    //    $activeThemeLink.removeAttr("href"); // this is for IE, to stop loading prev CSS
    $activeThemeLink.attr('href', knownThemes[currentThemeName].url);

    if (_themes_callback.themeReadyCallback.has() || initDeferred.state() !== 'resolved' || options._forceTimeout) {
      waitForThemeLoad(currentThemeName);
    }
  } else {
    if (isAutoInit) {
      if ((0, _window.hasWindow)()) {
        waitForThemeLoad(ANY_THEME);
      }

      _themes_callback.themeReadyCallback.fire();

      _themes_callback.themeReadyCallback.empty();
    } else {
      throw _ui.default.Error('E0021', currentThemeName);
    }
  }

  initDeferred.done(function () {
    return attachCssClasses((0, _view_port.originalViewPort)(), currentThemeName);
  });
}

function getCssClasses(themeName) {
  themeName = themeName || current();
  var result = [];
  var themeNameParts = themeName && themeName.split('.');

  if (themeNameParts) {
    result.push('dx-theme-' + themeNameParts[0], 'dx-theme-' + themeNameParts[0] + '-typography');

    if (themeNameParts.length > 1) {
      result.push('dx-color-scheme-' + themeNameParts[1] + (isMaterial(themeName) ? '-' + themeNameParts[2] : ''));
    }
  }

  return result;
}

var themeClasses;

function attachCssClasses(element, themeName) {
  themeClasses = getCssClasses(themeName).join(' ');
  (0, _renderer.default)(element).addClass(themeClasses);

  var activateHairlines = function activateHairlines() {
    var pixelRatio = (0, _window.hasWindow)() && window.devicePixelRatio;

    if (!pixelRatio || pixelRatio < 2) {
      return;
    }

    var $tester = (0, _renderer.default)('<div>');
    $tester.css('border', '.5px solid transparent');
    (0, _renderer.default)('body').append($tester);

    if ($tester.outerHeight() === 1) {
      (0, _renderer.default)(element).addClass(DX_HAIRLINES_CLASS);
      themeClasses += ' ' + DX_HAIRLINES_CLASS;
    }

    $tester.remove();
  };

  activateHairlines();
}

function detachCssClasses(element) {
  (0, _renderer.default)(element).removeClass(themeClasses);
}

function themeReady(callback) {
  _themes_callback.themeReadyCallback.add(callback);
}

function isTheme(themeRegExp, themeName) {
  if (!themeName) {
    themeName = currentThemeName || readThemeMarker();
  }

  return new RegExp(themeRegExp).test(themeName);
}

function isMaterial(themeName) {
  return isTheme('material', themeName);
}

function isGeneric(themeName) {
  return isTheme('generic', themeName);
}

function isDark(themeName) {
  return isTheme('dark', themeName);
}

function isWebFontLoaded(text, fontWeight) {
  var testedFont = 'Roboto, RobotoFallback, Arial';
  var etalonFont = 'Arial';

  var document = _dom_adapter.default.getDocument();

  var testElement = document.createElement('span');
  testElement.style.position = 'absolute';
  testElement.style.top = '-9999px';
  testElement.style.left = '-9999px';
  testElement.style.visibility = 'hidden';
  testElement.style.fontFamily = etalonFont;
  testElement.style.fontSize = '250px';
  testElement.style.fontWeight = fontWeight;
  testElement.innerHTML = text;
  document.body.appendChild(testElement);
  var etalonFontWidth = testElement.offsetWidth;
  testElement.style.fontFamily = testedFont;
  var testedFontWidth = testElement.offsetWidth;
  testElement.parentNode.removeChild(testElement);
  return etalonFontWidth !== testedFontWidth;
}

function waitWebFont(text, fontWeight) {
  var interval = 15;
  var timeout = 2000;
  return new _promise.default(function (resolve) {
    var check = function check() {
      if (isWebFontLoaded(text, fontWeight)) {
        clear();
      }
    };

    var clear = function clear() {
      clearInterval(intervalId);
      clearTimeout(timeoutId);
      resolve();
    };

    var intervalId = setInterval(check, interval);
    var timeoutId = setTimeout(clear, timeout);
  });
}

function autoInit() {
  init({
    _autoInit: true,
    _forceTimeout: true
  });

  if ((0, _renderer.default)(DX_LINK_SELECTOR, context).length) {
    throw _ui.default.Error('E0022');
  }
}

if ((0, _window.hasWindow)()) {
  autoInit();
} else {
  ready(autoInit);
}

viewPortChanged.add(function (viewPort, prevViewPort) {
  initDeferred.done(function () {
    detachCssClasses(prevViewPort);
    attachCssClasses(viewPort);
  });
});

_devices.default.changed.add(function () {
  init({
    _autoInit: true
  });
});

function resetTheme() {
  $activeThemeLink && $activeThemeLink.attr('href', 'about:blank');
  currentThemeName = null;
  pendingThemeName = null;
  initDeferred = new _deferred.Deferred();
}

function initialized(callback) {
  initDeferred.done(callback);
}

function setDefaultTimeout(timeout) {
  defaultTimeout = timeout;
}
/**
 * Added default export according to our documentation
 * https://js.devexpress.com/Documentation/ApiReference/Common/Utils/ui/themes/
 * */


var _default = {
  setDefaultTimeout: setDefaultTimeout,
  initialized: initialized,
  resetTheme: resetTheme,
  ready: themeReady,
  waitWebFont: waitWebFont,
  isWebFontLoaded: isWebFontLoaded,
  isDark: isDark,
  isGeneric: isGeneric,
  isMaterial: isMaterial,
  detachCssClasses: detachCssClasses,
  attachCssClasses: attachCssClasses,
  current: current,
  waitForThemeLoad: waitForThemeLoad,
  isPendingThemeLoaded: isPendingThemeLoaded
};
exports.default = _default;

/***/ }),
/* 39 */,
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.format = format;
exports.isEmpty = exports.replaceAll = exports.quadToObject = exports.encodeHtml = void 0;

var _type = __webpack_require__(1);

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var encodeHtml = function () {
  var encodeRegExp = [new RegExp('&', 'g'), new RegExp('"', 'g'), new RegExp('\'', 'g'), new RegExp('<', 'g'), new RegExp('>', 'g')];
  return function (str) {
    return String(str).replace(encodeRegExp[0], '&amp;').replace(encodeRegExp[1], '&quot;').replace(encodeRegExp[2], '&#39;').replace(encodeRegExp[3], '&lt;').replace(encodeRegExp[4], '&gt;');
  };
}();

exports.encodeHtml = encodeHtml;

var splitQuad = function splitQuad(raw) {
  switch (_typeof(raw)) {
    case 'string':
      return raw.split(/\s+/, 4);

    case 'object':
      return [raw.x || raw.h || raw.left, raw.y || raw.v || raw.top, raw.x || raw.h || raw.right, raw.y || raw.v || raw.bottom];

    case 'number':
      return [raw];

    default:
      return raw;
  }
};

var quadToObject = function quadToObject(raw) {
  var quad = splitQuad(raw);
  var left = parseInt(quad && quad[0], 10);
  var top = parseInt(quad && quad[1], 10);
  var right = parseInt(quad && quad[2], 10);
  var bottom = parseInt(quad && quad[3], 10);

  if (!isFinite(left)) {
    left = 0;
  }

  if (!isFinite(top)) {
    top = left;
  }

  if (!isFinite(right)) {
    right = left;
  }

  if (!isFinite(bottom)) {
    bottom = top;
  }

  return {
    top: top,
    right: right,
    bottom: bottom,
    left: left
  };
};

exports.quadToObject = quadToObject;

function format(template) {
  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }

  if ((0, _type.isFunction)(template)) {
    return template.apply(void 0, values);
  }

  values.forEach(function (value, index) {
    if ((0, _type.isString)(value)) {
      value = value.replace(/\$/g, '$$$$');
    }

    var placeholderReg = new RegExp('\\{' + index + '\\}', 'gm');
    template = template.replace(placeholderReg, value);
  });
  return template;
}

var replaceAll = function () {
  var quote = function quote(str) {
    return (str + '').replace(/([+*?.[^\]$(){}><|=!:])/g, '\\$1'); // lgtm[js/incomplete-sanitization]
  };

  return function (text, searchToken, replacementToken) {
    return text.replace(new RegExp('(' + quote(searchToken) + ')', 'gi'), replacementToken);
  };
}();

exports.replaceAll = replaceAll;

var isEmpty = function () {
  var SPACE_REGEXP = /\s/g;
  return function (text) {
    return !text || !text.replace(SPACE_REGEXP, '');
  };
}();

exports.isEmpty = isEmpty;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.captionize = exports.titleize = exports.humanize = exports.camelize = exports.underscore = exports.dasherize = void 0;

var _iterator = __webpack_require__(3);

var _normalize = function _normalize(text) {
  if (text === undefined || text === null) {
    return '';
  }

  return String(text);
};

var _upperCaseFirst = function _upperCaseFirst(text) {
  return _normalize(text).charAt(0).toUpperCase() + text.substr(1);
};

var _chop = function _chop(text) {
  return _normalize(text).replace(/([a-z\d])([A-Z])/g, '$1 $2').split(/[\s_-]+/);
};

var dasherize = function dasherize(text) {
  return (0, _iterator.map)(_chop(text), function (p) {
    return p.toLowerCase();
  }).join('-');
};

exports.dasherize = dasherize;

var underscore = function underscore(text) {
  return dasherize(text).replace(/-/g, '_');
};

exports.underscore = underscore;

var camelize = function camelize(text, upperFirst) {
  return (0, _iterator.map)(_chop(text), function (p, i) {
    p = p.toLowerCase();

    if (upperFirst || i > 0) {
      p = _upperCaseFirst(p);
    }

    return p;
  }).join('');
};

exports.camelize = camelize;

var humanize = function humanize(text) {
  return _upperCaseFirst(dasherize(text).replace(/-/g, ' '));
};

exports.humanize = humanize;

var titleize = function titleize(text) {
  return (0, _iterator.map)(_chop(text), function (p) {
    return _upperCaseFirst(p.toLowerCase());
  }).join(' ');
};

exports.titleize = titleize;
var DIGIT_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];

var captionize = function captionize(name) {
  var captionList = [];
  var i;
  var char;
  var isPrevCharNewWord = false;
  var isNewWord = false;

  for (i = 0; i < name.length; i++) {
    char = name.charAt(i);
    isNewWord = char === char.toUpperCase() && char !== '-' && char !== ')' && char !== '/' || char in DIGIT_CHARS;

    if (char === '_' || char === '.') {
      char = ' ';
      isNewWord = true;
    } else if (i === 0) {
      char = char.toUpperCase();
      isNewWord = true;
    } else if (!isPrevCharNewWord && isNewWord) {
      if (captionList.length > 0) {
        captionList.push(' ');
      }
    }

    captionList.push(char);
    isPrevCharNewWord = isNewWord;
  }

  return captionList.join('');
};

exports.captionize = captionize;

/***/ }),
/* 42 */,
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getDataStrategy = getDataStrategy;
exports.data = data;
exports.beforeCleanData = beforeCleanData;
exports.afterCleanData = afterCleanData;
exports.cleanData = cleanData;
exports.removeData = removeData;
exports.cleanDataRecursive = cleanDataRecursive;
exports.setDataStrategy = exports.strategyChanging = void 0;

var _weak_map = _interopRequireDefault(__webpack_require__(193));

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _memorized_callbacks = _interopRequireDefault(__webpack_require__(194));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var dataMap = new _weak_map.default();
var strategy;
var strategyChanging = new _memorized_callbacks.default();
exports.strategyChanging = strategyChanging;

var beforeCleanDataFunc = function beforeCleanDataFunc() {};

var afterCleanDataFunc = function afterCleanDataFunc() {};

var setDataStrategy = function setDataStrategy(value) {
  strategyChanging.fire(value);
  strategy = value;
  var cleanData = strategy.cleanData;

  strategy.cleanData = function (nodes) {
    beforeCleanDataFunc(nodes);
    var result = cleanData.call(this, nodes);
    afterCleanDataFunc(nodes);
    return result;
  };
};

exports.setDataStrategy = setDataStrategy;
setDataStrategy({
  data: function data() {
    var element = arguments[0];
    var key = arguments[1];
    var value = arguments[2];
    if (!element) return;
    var elementData = dataMap.get(element);

    if (!elementData) {
      elementData = {};
      dataMap.set(element, elementData);
    }

    if (key === undefined) {
      return elementData;
    }

    if (arguments.length === 2) {
      return elementData[key];
    }

    elementData[key] = value;
    return value;
  },
  removeData: function removeData(element, key) {
    if (!element) return;

    if (key === undefined) {
      dataMap.delete(element);
    } else {
      var elementData = dataMap.get(element);

      if (elementData) {
        delete elementData[key];
      }
    }
  },
  cleanData: function cleanData(elements) {
    for (var i = 0; i < elements.length; i++) {
      _events_engine.default.off(elements[i]);

      dataMap.delete(elements[i]);
    }
  }
});

function getDataStrategy() {
  return strategy;
}

function data() {
  return strategy.data.apply(this, arguments);
}

function beforeCleanData(callback) {
  beforeCleanDataFunc = callback;
}

function afterCleanData(callback) {
  afterCleanDataFunc = callback;
}

function cleanData(nodes) {
  return strategy.cleanData.call(this, nodes);
}

function removeData(element, key) {
  return strategy.removeData.call(this, element, key);
}

function cleanDataRecursive(element, cleanSelf) {
  if (!_dom_adapter.default.isElementNode(element)) {
    return;
  }

  var childElements = element.getElementsByTagName('*');
  strategy.cleanData(childElements);

  if (cleanSelf) {
    strategy.cleanData([element]);
  }
}

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _type = __webpack_require__(1);

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _ready_callbacks = _interopRequireDefault(__webpack_require__(51));

var _window = __webpack_require__(7);

var _iterator = __webpack_require__(3);

var _deferred = __webpack_require__(6);

var _common = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var ready = _ready_callbacks.default.add;
var XHR_ERROR_UNLOAD = 'DEVEXTREME_XHR_ERROR_UNLOAD';

var normalizeBinaryCriterion = function normalizeBinaryCriterion(crit) {
  return [crit[0], crit.length < 3 ? '=' : String(crit[1]).toLowerCase(), crit.length < 2 ? true : crit[crit.length - 1]];
};

var normalizeSortingInfo = function normalizeSortingInfo(info) {
  if (!Array.isArray(info)) {
    info = [info];
  }

  return (0, _iterator.map)(info, function (i) {
    var result = {
      selector: (0, _type.isFunction)(i) || typeof i === 'string' ? i : i.getter || i.field || i.selector,
      desc: !!(i.desc || String(i.dir).charAt(0).toLowerCase() === 'd')
    };

    if (i.compare) {
      result.compare = i.compare;
    }

    return result;
  });
};

var errorMessageFromXhr = function () {
  var textStatusMessages = {
    'timeout': 'Network connection timeout',
    'error': 'Unspecified network error',
    'parsererror': 'Unexpected server response'
  };

  var explainTextStatus = function explainTextStatus(textStatus) {
    var result = textStatusMessages[textStatus];

    if (!result) {
      return textStatus;
    }

    return result;
  }; // T542570, https://stackoverflow.com/a/18170879


  var unloading;
  ready(function () {
    var window = (0, _window.getWindow)();

    _dom_adapter.default.listen(window, 'beforeunload', function () {
      unloading = true;
    });
  });
  return function (xhr, textStatus) {
    if (unloading) {
      return XHR_ERROR_UNLOAD;
    }

    if (xhr.status < 400) {
      return explainTextStatus(textStatus);
    }

    return xhr.statusText;
  };
}();

var aggregators = {
  count: {
    seed: 0,
    step: function step(count) {
      return 1 + count;
    }
  },
  sum: {
    seed: 0,
    step: function step(sum, item) {
      return sum + item;
    }
  },
  min: {
    step: function step(min, item) {
      return item < min ? item : min;
    }
  },
  max: {
    step: function step(max, item) {
      return item > max ? item : max;
    }
  },
  avg: {
    seed: [0, 0],
    step: function step(pair, value) {
      return [pair[0] + value, pair[1] + 1];
    },
    finalize: function finalize(pair) {
      return pair[1] ? pair[0] / pair[1] : NaN;
    }
  }
};

var processRequestResultLock = function () {
  var lockCount = 0;
  var lockDeferred;

  var obtain = function obtain() {
    if (lockCount === 0) {
      lockDeferred = new _deferred.Deferred();
    }

    lockCount++;
  };

  var release = function release() {
    lockCount--;

    if (lockCount < 1) {
      lockDeferred.resolve();
    }
  };

  var promise = function promise() {
    var deferred = lockCount === 0 ? new _deferred.Deferred().resolve() : lockDeferred;
    return deferred.promise();
  };

  var reset = function reset() {
    lockCount = 0;

    if (lockDeferred) {
      lockDeferred.resolve();
    }
  };

  return {
    obtain: obtain,
    release: release,
    promise: promise,
    reset: reset
  };
}();

function isDisjunctiveOperator(condition) {
  return /^(or|\|\||\|)$/i.test(condition);
}

function isConjunctiveOperator(condition) {
  return /^(and|&&|&)$/i.test(condition);
}

var keysEqual = function keysEqual(keyExpr, key1, key2) {
  if (Array.isArray(keyExpr)) {
    var names = (0, _iterator.map)(key1, function (v, k) {
      return k;
    });
    var name;

    for (var i = 0; i < names.length; i++) {
      name = names[i];

      if (!(0, _common.equalByValue)(key1[name], key2[name], 0, false)) {
        return false;
      }
    }

    return true;
  }

  return (0, _common.equalByValue)(key1, key2, 0, false);
};

var BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

var base64_encode = function base64_encode(input) {
  if (!Array.isArray(input)) {
    input = stringToByteArray(String(input));
  }

  var result = '';

  function getBase64Char(index) {
    return BASE64_CHARS.charAt(index);
  }

  for (var i = 0; i < input.length; i += 3) {
    var octet1 = input[i];
    var octet2 = input[i + 1];
    var octet3 = input[i + 2];
    result += (0, _iterator.map)([octet1 >> 2, (octet1 & 3) << 4 | octet2 >> 4, isNaN(octet2) ? 64 : (octet2 & 15) << 2 | octet3 >> 6, isNaN(octet3) ? 64 : octet3 & 63], getBase64Char).join('');
  }

  return result;
};

function stringToByteArray(str) {
  var bytes = [];
  var code;
  var i;

  for (i = 0; i < str.length; i++) {
    code = str.charCodeAt(i);

    if (code < 128) {
      bytes.push(code);
    } else if (code < 2048) {
      bytes.push(192 + (code >> 6), 128 + (code & 63));
    } else if (code < 65536) {
      bytes.push(224 + (code >> 12), 128 + (code >> 6 & 63), 128 + (code & 63));
    } else if (code < 2097152) {
      bytes.push(240 + (code >> 18), 128 + (code >> 12 & 63), 128 + (code >> 6 & 63), 128 + (code & 63));
    }
  }

  return bytes;
}

var isUnaryOperation = function isUnaryOperation(crit) {
  return crit[0] === '!' && Array.isArray(crit[1]);
};

var isGroupOperator = function isGroupOperator(value) {
  return value === 'and' || value === 'or';
};

var isGroupCriterion = function isGroupCriterion(crit) {
  var first = crit[0];
  var second = crit[1];

  if (Array.isArray(first)) {
    return true;
  }

  if ((0, _type.isFunction)(first)) {
    if (Array.isArray(second) || (0, _type.isFunction)(second) || isGroupOperator(second)) {
      return true;
    }
  }

  return false;
};

var trivialPromise = function trivialPromise() {
  var d = new _deferred.Deferred();
  return d.resolve.apply(d, arguments).promise();
};

var rejectedPromise = function rejectedPromise() {
  var d = new _deferred.Deferred();
  return d.reject.apply(d, arguments).promise();
};

function throttle(func, timeout) {
  var timeoutId;
  var lastArgs;
  return function () {
    var _this = this;

    lastArgs = arguments;

    if (!timeoutId) {
      timeoutId = setTimeout(function () {
        timeoutId = undefined;

        if (lastArgs) {
          func.call(_this, lastArgs);
        }
      }, (0, _type.isFunction)(timeout) ? timeout() : timeout);
    }

    return timeoutId;
  };
}

function throttleChanges(func, timeout) {
  var cache = [];
  var throttled = throttle(function () {
    func.call(this, cache);
    cache = [];
  }, timeout);
  return function (changes) {
    if (Array.isArray(changes)) {
      var _cache;

      (_cache = cache).push.apply(_cache, _toConsumableArray(changes));
    }

    return throttled.call(this, cache);
  };
}
/**
* @name Utils
*/


var utils = {
  XHR_ERROR_UNLOAD: XHR_ERROR_UNLOAD,
  normalizeBinaryCriterion: normalizeBinaryCriterion,
  normalizeSortingInfo: normalizeSortingInfo,
  errorMessageFromXhr: errorMessageFromXhr,
  aggregators: aggregators,
  keysEqual: keysEqual,
  throttleChanges: throttleChanges,
  trivialPromise: trivialPromise,
  rejectedPromise: rejectedPromise,
  isDisjunctiveOperator: isDisjunctiveOperator,
  isConjunctiveOperator: isConjunctiveOperator,
  processRequestResultLock: processRequestResultLock,
  isUnaryOperation: isUnaryOperation,
  isGroupCriterion: isGroupCriterion,
  base64_encode: base64_encode
};
var _default = utils;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _window = __webpack_require__(7);

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _errors = _interopRequireDefault(__webpack_require__(24));

var _element = __webpack_require__(22);

var _extend = __webpack_require__(0);

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

var _translator = __webpack_require__(34);

var _easing = __webpack_require__(267);

var _frame = __webpack_require__(122);

var _support = __webpack_require__(48);

var _position = _interopRequireDefault(__webpack_require__(83));

var _remove_event = __webpack_require__(147);

var _index = __webpack_require__(8);

var _deferred = __webpack_require__(6);

var _common = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var window = (0, _window.getWindow)();
var removeEventName = (0, _index.addNamespace)(_remove_event.removeEvent, 'dxFX');
var RELATIVE_VALUE_REGEX = /^([+-])=(.*)/i;
var ANIM_DATA_KEY = 'dxAnimData';
var ANIM_QUEUE_KEY = 'dxAnimQueue';
var TRANSFORM_PROP = 'transform';
var TransitionAnimationStrategy = {
  initAnimation: function initAnimation($element, config) {
    $element.css({
      'transitionProperty': 'none'
    });

    if (typeof config.from === 'string') {
      $element.addClass(config.from);
    } else {
      setProps($element, config.from);
    }

    var that = this;
    var deferred = new _deferred.Deferred();
    var cleanupWhen = config.cleanupWhen;
    config.transitionAnimation = {
      deferred: deferred,
      finish: function finish() {
        that._finishTransition($element);

        if (cleanupWhen) {
          (0, _deferred.when)(deferred, cleanupWhen).always(function () {
            that._cleanup($element, config);
          });
        } else {
          that._cleanup($element, config);
        }

        deferred.resolveWith($element, [config, $element]);
      }
    };

    this._completeAnimationCallback($element, config).done(function () {
      config.transitionAnimation.finish();
    }).fail(function () {
      deferred.rejectWith($element, [config, $element]);
    });

    if (!config.duration) {
      config.transitionAnimation.finish();
    } // NOTE: Hack for setting 'from' css by browser before run animation
    //       Do not move this hack to initAnimation since some css props can be changed in the 'start' callback (T231434)
    //       Unfortunately this can't be unit tested
    // TODO: find better way if possible


    $element.css('transform');
  },
  animate: function animate($element, config) {
    this._startAnimation($element, config);

    return config.transitionAnimation.deferred.promise();
  },
  _completeAnimationCallback: function _completeAnimationCallback($element, config) {
    var that = this;
    var startTime = Date.now() + config.delay;
    var deferred = new _deferred.Deferred();
    var transitionEndFired = new _deferred.Deferred();
    var simulatedTransitionEndFired = new _deferred.Deferred();
    var simulatedEndEventTimer;
    var transitionEndEventFullName = (0, _support.transitionEndEventName)() + '.dxFX';

    config.transitionAnimation.cleanup = function () {
      clearTimeout(simulatedEndEventTimer);
      clearTimeout(waitForJSCompleteTimer);

      _events_engine.default.off($element, transitionEndEventFullName);

      _events_engine.default.off($element, removeEventName);
    };

    _events_engine.default.one($element, transitionEndEventFullName, function () {
      // NOTE: prevent native transitionEnd event from previous animation in queue (Chrome)
      if (Date.now() - startTime >= config.duration) {
        transitionEndFired.reject();
      }
    });

    _events_engine.default.off($element, removeEventName);

    _events_engine.default.on($element, removeEventName, function () {
      that.stop($element, config);
      deferred.reject();
    });

    var waitForJSCompleteTimer = setTimeout(function () {
      // Fix for a visual bug (T244514): do not setup the timer until all js code has finished working
      simulatedEndEventTimer = setTimeout(function () {
        simulatedTransitionEndFired.reject();
      }, config.duration + config.delay + fx._simulatedTransitionEndDelay
      /* T255863 */
      );
      (0, _deferred.when)(transitionEndFired, simulatedTransitionEndFired).fail(function () {
        deferred.resolve();
      }.bind(this));
    });
    return deferred.promise();
  },
  _startAnimation: function _startAnimation($element, config) {
    $element.css({
      'transitionProperty': 'all',
      'transitionDelay': config.delay + 'ms',
      'transitionDuration': config.duration + 'ms',
      'transitionTimingFunction': config.easing
    });

    if (typeof config.to === 'string') {
      $element[0].className += ' ' + config.to; // Do not uncomment: performance critical
      // $element.addClass(config.to);
    } else if (config.to) {
      setProps($element, config.to);
    }
  },
  _finishTransition: function _finishTransition($element) {
    $element.css('transition', 'none');
  },
  _cleanup: function _cleanup($element, config) {
    config.transitionAnimation.cleanup();

    if (typeof config.from === 'string') {
      $element.removeClass(config.from);
      $element.removeClass(config.to);
    }
  },
  stop: function stop($element, config, jumpToEnd) {
    if (!config) {
      return;
    }

    if (jumpToEnd) {
      config.transitionAnimation.finish();
    } else {
      if ((0, _type.isPlainObject)(config.to)) {
        (0, _iterator.each)(config.to, function (key) {
          $element.css(key, $element.css(key));
        });
      }

      this._finishTransition($element);

      this._cleanup($element, config);
    }
  }
};
var FrameAnimationStrategy = {
  initAnimation: function initAnimation($element, config) {
    setProps($element, config.from);
  },
  animate: function animate($element, config) {
    var deferred = new _deferred.Deferred();
    var that = this;

    if (!config) {
      return deferred.reject().promise();
    }

    (0, _iterator.each)(config.to, function (prop) {
      if (config.from[prop] === undefined) {
        config.from[prop] = that._normalizeValue($element.css(prop));
      }
    });

    if (config.to[TRANSFORM_PROP]) {
      config.from[TRANSFORM_PROP] = that._parseTransform(config.from[TRANSFORM_PROP]);
      config.to[TRANSFORM_PROP] = that._parseTransform(config.to[TRANSFORM_PROP]);
    }

    config.frameAnimation = {
      to: config.to,
      from: config.from,
      currentValue: config.from,
      easing: (0, _easing.convertTransitionTimingFuncToEasing)(config.easing),
      duration: config.duration,
      startTime: new Date().valueOf(),
      finish: function finish() {
        this.currentValue = this.to;
        this.draw();
        (0, _frame.cancelAnimationFrame)(config.frameAnimation.animationFrameId);
        deferred.resolve();
      },
      draw: function draw() {
        if (config.draw) {
          config.draw(this.currentValue);
          return;
        }

        var currentValue = (0, _extend.extend)({}, this.currentValue);

        if (currentValue[TRANSFORM_PROP]) {
          currentValue[TRANSFORM_PROP] = (0, _iterator.map)(currentValue[TRANSFORM_PROP], function (value, prop) {
            if (prop === 'translate') {
              return (0, _translator.getTranslateCss)(value);
            } else if (prop === 'scale') {
              return 'scale(' + value + ')';
            } else if (prop.substr(0, prop.length - 1) === 'rotate') {
              return prop + '(' + value + 'deg)';
            }
          }).join(' ');
        }

        $element.css(currentValue);
      }
    };

    if (config.delay) {
      config.frameAnimation.startTime += config.delay;
      config.frameAnimation.delayTimeout = setTimeout(function () {
        that._startAnimation($element, config);
      }, config.delay);
    } else {
      that._startAnimation($element, config);
    }

    return deferred.promise();
  },
  _startAnimation: function _startAnimation($element, config) {
    _events_engine.default.off($element, removeEventName);

    _events_engine.default.on($element, removeEventName, function () {
      if (config.frameAnimation) {
        (0, _frame.cancelAnimationFrame)(config.frameAnimation.animationFrameId);
      }
    });

    this._animationStep($element, config);
  },
  _parseTransform: function _parseTransform(transformString) {
    var result = {};
    (0, _iterator.each)(transformString.match(/\w+\d*\w*\([^)]*\)\s*/g), function (i, part) {
      var translateData = (0, _translator.parseTranslate)(part);
      var scaleData = part.match(/scale\((.+?)\)/);
      var rotateData = part.match(/(rotate.)\((.+)deg\)/);

      if (translateData) {
        result.translate = translateData;
      }

      if (scaleData && scaleData[1]) {
        result.scale = parseFloat(scaleData[1]);
      }

      if (rotateData && rotateData[1]) {
        result[rotateData[1]] = parseFloat(rotateData[2]);
      }
    });
    return result;
  },
  stop: function stop($element, config, jumpToEnd) {
    var frameAnimation = config && config.frameAnimation;

    if (!frameAnimation) {
      return;
    }

    (0, _frame.cancelAnimationFrame)(frameAnimation.animationFrameId);
    clearTimeout(frameAnimation.delayTimeout);

    if (jumpToEnd) {
      frameAnimation.finish();
    }

    delete config.frameAnimation;
  },
  _animationStep: function _animationStep($element, config) {
    var frameAnimation = config && config.frameAnimation;

    if (!frameAnimation) {
      return;
    }

    var now = new Date().valueOf();

    if (now >= frameAnimation.startTime + frameAnimation.duration) {
      frameAnimation.finish();
      return;
    }

    frameAnimation.currentValue = this._calcStepValue(frameAnimation, now - frameAnimation.startTime);
    frameAnimation.draw();
    var that = this;
    frameAnimation.animationFrameId = (0, _frame.requestAnimationFrame)(function () {
      that._animationStep($element, config);
    });
  },
  _calcStepValue: function _calcStepValue(frameAnimation, currentDuration) {
    var calcValueRecursively = function calcValueRecursively(from, to) {
      var result = Array.isArray(to) ? [] : {};

      var calcEasedValue = function calcEasedValue(propName) {
        var x = currentDuration / frameAnimation.duration;
        var t = currentDuration;
        var b = 1 * from[propName];
        var c = to[propName] - from[propName];
        var d = frameAnimation.duration;
        return (0, _easing.getEasing)(frameAnimation.easing)(x, t, b, c, d);
      };

      (0, _iterator.each)(to, function (propName, endPropValue) {
        if (typeof endPropValue === 'string' && parseFloat(endPropValue, 10) === false) {
          return true;
        }

        result[propName] = _typeof(endPropValue) === 'object' ? calcValueRecursively(from[propName], endPropValue) : calcEasedValue(propName);
      });
      return result;
    };

    return calcValueRecursively(frameAnimation.from, frameAnimation.to);
  },
  _normalizeValue: function _normalizeValue(value) {
    var numericValue = parseFloat(value, 10);

    if (numericValue === false) {
      return value;
    }

    return numericValue;
  }
};
var FallbackToNoAnimationStrategy = {
  initAnimation: function initAnimation() {},
  animate: function animate() {
    return new _deferred.Deferred().resolve().promise();
  },
  stop: _common.noop,
  isSynchronous: true
};

var getAnimationStrategy = function getAnimationStrategy(config) {
  config = config || {};
  var animationStrategies = {
    'transition': (0, _support.transition)() ? TransitionAnimationStrategy : FrameAnimationStrategy,
    'frame': FrameAnimationStrategy,
    'noAnimation': FallbackToNoAnimationStrategy
  };
  var strategy = config.strategy || 'transition';

  if (config.type === 'css' && !(0, _support.transition)()) {
    strategy = 'noAnimation';
  }

  return animationStrategies[strategy];
};

var baseConfigValidator = function baseConfigValidator(config, animationType, validate, typeMessage) {
  (0, _iterator.each)(['from', 'to'], function () {
    if (!validate(config[this])) {
      throw _errors.default.Error('E0010', animationType, this, typeMessage);
    }
  });
};

var isObjectConfigValidator = function isObjectConfigValidator(config, animationType) {
  return baseConfigValidator(config, animationType, function (target) {
    return (0, _type.isPlainObject)(target);
  }, 'a plain object');
};

var isStringConfigValidator = function isStringConfigValidator(config, animationType) {
  return baseConfigValidator(config, animationType, function (target) {
    return typeof target === 'string';
  }, 'a string');
};

var CustomAnimationConfigurator = {
  setup: function setup() {}
};
var CssAnimationConfigurator = {
  validateConfig: function validateConfig(config) {
    isStringConfigValidator(config, 'css');
  },
  setup: function setup() {}
};
var positionAliases = {
  'top': {
    my: 'bottom center',
    at: 'top center'
  },
  'bottom': {
    my: 'top center',
    at: 'bottom center'
  },
  'right': {
    my: 'left center',
    at: 'right center'
  },
  'left': {
    my: 'right center',
    at: 'left center'
  }
};
var SlideAnimationConfigurator = {
  validateConfig: function validateConfig(config) {
    isObjectConfigValidator(config, 'slide');
  },
  setup: function setup($element, config) {
    var location = (0, _translator.locate)($element);

    if (config.type !== 'slide') {
      var positioningConfig = config.type === 'slideIn' ? config.from : config.to;
      positioningConfig.position = (0, _extend.extend)({
        of: window
      }, positionAliases[config.direction]);
      setupPosition($element, positioningConfig);
    }

    this._setUpConfig(location, config.from);

    this._setUpConfig(location, config.to);

    (0, _translator.clearCache)($element);
  },
  _setUpConfig: function _setUpConfig(location, config) {
    config.left = 'left' in config ? config.left : '+=0';
    config.top = 'top' in config ? config.top : '+=0';

    this._initNewPosition(location, config);
  },
  _initNewPosition: function _initNewPosition(location, config) {
    var position = {
      left: config.left,
      top: config.top
    };
    delete config.left;
    delete config.top;

    var relativeValue = this._getRelativeValue(position.left);

    if (relativeValue !== undefined) {
      position.left = relativeValue + location.left;
    } else {
      config.left = 0;
    }

    relativeValue = this._getRelativeValue(position.top);

    if (relativeValue !== undefined) {
      position.top = relativeValue + location.top;
    } else {
      config.top = 0;
    }

    config[TRANSFORM_PROP] = (0, _translator.getTranslateCss)({
      x: position.left,
      y: position.top
    });
  },
  _getRelativeValue: function _getRelativeValue(value) {
    var relativeValue;

    if (typeof value === 'string' && (relativeValue = RELATIVE_VALUE_REGEX.exec(value))) {
      return parseInt(relativeValue[1] + '1') * relativeValue[2];
    }
  }
};
var FadeAnimationConfigurator = {
  setup: function setup($element, config) {
    var from = config.from;
    var fromOpacity = (0, _type.isPlainObject)(from) ? config.skipElementInitialStyles ? 0 : $element.css('opacity') : String(from);
    var toOpacity;

    switch (config.type) {
      case 'fadeIn':
        toOpacity = 1;
        break;

      case 'fadeOut':
        toOpacity = 0;
        break;

      default:
        toOpacity = String(config.to);
    }

    config.from = {
      visibility: 'visible',
      opacity: fromOpacity
    };
    config.to = {
      opacity: toOpacity
    };
  }
};
var PopAnimationConfigurator = {
  validateConfig: function validateConfig(config) {
    isObjectConfigValidator(config, 'pop');
  },
  setup: function setup($element, config) {
    var from = config.from;
    var to = config.to;
    var fromOpacity = 'opacity' in from ? from.opacity : $element.css('opacity');
    var toOpacity = 'opacity' in to ? to.opacity : 1;
    var fromScale = 'scale' in from ? from.scale : 0;
    var toScale = 'scale' in to ? to.scale : 1;
    config.from = {
      opacity: fromOpacity
    };
    var translate = (0, _translator.getTranslate)($element);
    config.from[TRANSFORM_PROP] = this._getCssTransform(translate, fromScale);
    config.to = {
      opacity: toOpacity
    };
    config.to[TRANSFORM_PROP] = this._getCssTransform(translate, toScale);
  },
  _getCssTransform: function _getCssTransform(translate, scale) {
    return (0, _translator.getTranslateCss)(translate) + 'scale(' + scale + ')';
  }
};
var animationConfigurators = {
  'custom': CustomAnimationConfigurator,
  'slide': SlideAnimationConfigurator,
  'slideIn': SlideAnimationConfigurator,
  'slideOut': SlideAnimationConfigurator,
  'fade': FadeAnimationConfigurator,
  'fadeIn': FadeAnimationConfigurator,
  'fadeOut': FadeAnimationConfigurator,
  'pop': PopAnimationConfigurator,
  'css': CssAnimationConfigurator
};

var getAnimationConfigurator = function getAnimationConfigurator(config) {
  var result = animationConfigurators[config.type];

  if (!result) {
    throw _errors.default.Error('E0011', config.type);
  }

  return result;
};

var defaultJSConfig = {
  type: 'custom',
  from: {},
  to: {},
  duration: 400,
  start: _common.noop,
  complete: _common.noop,
  easing: 'ease',
  delay: 0
};
var defaultCssConfig = {
  duration: 400,
  easing: 'ease',
  delay: 0
};

function setupAnimationOnElement() {
  var animation = this;
  var $element = animation.element;
  var config = animation.config;
  setupPosition($element, config.from);
  setupPosition($element, config.to);
  animation.configurator.setup($element, config);
  $element.data(ANIM_DATA_KEY, animation);

  if (fx.off) {
    config.duration = 0;
    config.delay = 0;
  }

  animation.strategy.initAnimation($element, config);

  if (config.start) {
    var element = (0, _element.getPublicElement)($element);
    config.start.apply(this, [element, config]);
  }
}

var onElementAnimationComplete = function onElementAnimationComplete(animation) {
  var $element = animation.element;
  var config = animation.config;
  $element.removeData(ANIM_DATA_KEY);

  if (config.complete) {
    var element = (0, _element.getPublicElement)($element);
    config.complete.apply(this, [element, config]);
  }

  animation.deferred.resolveWith(this, [$element, config]);
};

var startAnimationOnElement = function startAnimationOnElement() {
  var animation = this;
  var $element = animation.element;
  var config = animation.config;
  animation.isStarted = true;
  return animation.strategy.animate($element, config).done(function () {
    onElementAnimationComplete(animation);
  }).fail(function () {
    animation.deferred.rejectWith(this, [$element, config]);
  });
};

var stopAnimationOnElement = function stopAnimationOnElement(jumpToEnd) {
  var animation = this;
  var $element = animation.element;
  var config = animation.config;
  clearTimeout(animation.startTimeout);

  if (!animation.isStarted) {
    animation.start();
  }

  animation.strategy.stop($element, config, jumpToEnd);
};

var scopedRemoveEvent = (0, _index.addNamespace)(_remove_event.removeEvent, 'dxFXStartAnimation');

var subscribeToRemoveEvent = function subscribeToRemoveEvent(animation) {
  _events_engine.default.off(animation.element, scopedRemoveEvent);

  _events_engine.default.on(animation.element, scopedRemoveEvent, function () {
    fx.stop(animation.element);
  });

  animation.deferred.always(function () {
    _events_engine.default.off(animation.element, scopedRemoveEvent);
  });
};

var createAnimation = function createAnimation(element, initialConfig) {
  var defaultConfig = initialConfig.type === 'css' ? defaultCssConfig : defaultJSConfig;
  var config = (0, _extend.extend)(true, {}, defaultConfig, initialConfig);
  var configurator = getAnimationConfigurator(config);
  var strategy = getAnimationStrategy(config);
  var animation = {
    element: (0, _renderer.default)(element),
    config: config,
    configurator: configurator,
    strategy: strategy,
    isSynchronous: strategy.isSynchronous,
    setup: setupAnimationOnElement,
    start: startAnimationOnElement,
    stop: stopAnimationOnElement,
    deferred: new _deferred.Deferred()
  };

  if ((0, _type.isFunction)(configurator.validateConfig)) {
    configurator.validateConfig(config);
  }

  subscribeToRemoveEvent(animation);
  return animation;
};

var animate = function animate(element, config) {
  var $element = (0, _renderer.default)(element);

  if (!$element.length) {
    return new _deferred.Deferred().resolve().promise();
  }

  var animation = createAnimation($element, config);
  pushInAnimationQueue($element, animation);
  return animation.deferred.promise();
};

function pushInAnimationQueue($element, animation) {
  var queueData = getAnimQueueData($element);
  writeAnimQueueData($element, queueData);
  queueData.push(animation);

  if (!isAnimating($element)) {
    shiftFromAnimationQueue($element, queueData);
  }
}

function getAnimQueueData($element) {
  return $element.data(ANIM_QUEUE_KEY) || [];
}

function writeAnimQueueData($element, queueData) {
  $element.data(ANIM_QUEUE_KEY, queueData);
}

var destroyAnimQueueData = function destroyAnimQueueData($element) {
  $element.removeData(ANIM_QUEUE_KEY);
};

function isAnimating($element) {
  return !!$element.data(ANIM_DATA_KEY);
}

function shiftFromAnimationQueue($element, queueData) {
  queueData = getAnimQueueData($element);

  if (!queueData.length) {
    return;
  }

  var animation = queueData.shift();

  if (queueData.length === 0) {
    destroyAnimQueueData($element);
  }

  executeAnimation(animation).done(function () {
    if (!isAnimating($element)) {
      shiftFromAnimationQueue($element);
    }
  });
}

function executeAnimation(animation) {
  animation.setup();

  if (fx.off || animation.isSynchronous) {
    animation.start();
  } else {
    animation.startTimeout = setTimeout(function () {
      animation.start();
    });
  }

  return animation.deferred.promise();
}

function setupPosition($element, config) {
  if (!config || !config.position) {
    return;
  }

  var win = (0, _renderer.default)(window);
  var left = 0;
  var top = 0;

  var position = _position.default.calculate($element, config.position);

  var offset = $element.offset();
  var currentPosition = $element.position();

  if (currentPosition.top > offset.top) {
    top = win.scrollTop();
  }

  if (currentPosition.left > offset.left) {
    left = win.scrollLeft();
  }

  (0, _extend.extend)(config, {
    left: position.h.location - offset.left + currentPosition.left - left,
    top: position.v.location - offset.top + currentPosition.top - top
  });
  delete config.position;
}

function setProps($element, props) {
  (0, _iterator.each)(props, function (key, value) {
    try {
      $element.css(key, (0, _type.isFunction)(value) ? value() : value);
    } catch (e) {}
  });
}

var stop = function stop(element, jumpToEnd) {
  var $element = (0, _renderer.default)(element);
  var queueData = getAnimQueueData($element); // TODO: think about complete all animation in queue

  (0, _iterator.each)(queueData, function (_, animation) {
    animation.config.delay = 0;
    animation.config.duration = 0;
    animation.isSynchronous = true;
  });

  if (!isAnimating($element)) {
    shiftFromAnimationQueue($element, queueData);
  }

  var animation = $element.data(ANIM_DATA_KEY);

  if (animation) {
    animation.stop(jumpToEnd);
  }

  $element.removeData(ANIM_DATA_KEY);
  destroyAnimQueueData($element);
};

var fx = {
  off: false,
  animationTypes: animationConfigurators,
  animate: animate,
  createAnimation: createAnimation,
  isAnimating: isAnimating,
  stop: stop,
  _simulatedTransitionEndDelay: 100
};
var _default = fx;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _dependency_injector = _interopRequireDefault(__webpack_require__(55));

var _array = __webpack_require__(12);

var _common = __webpack_require__(4);

var _iterator = __webpack_require__(3);

var _type = __webpack_require__(1);

var _number = __webpack_require__(277);

var _config = _interopRequireDefault(__webpack_require__(29));

var _errors = _interopRequireDefault(__webpack_require__(24));

var _utils = __webpack_require__(251);

var _currency = _interopRequireDefault(__webpack_require__(112));

var _number2 = _interopRequireDefault(__webpack_require__(357));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var hasIntl = typeof Intl !== 'undefined';
var MAX_LARGE_NUMBER_POWER = 4;
var DECIMAL_BASE = 10;
var NUMERIC_FORMATS = ['currency', 'fixedpoint', 'exponential', 'percent', 'decimal'];
var LargeNumberFormatPostfixes = {
  1: 'K',
  // kilo
  2: 'M',
  // mega
  3: 'B',
  // billions
  4: 'T' // tera

};
var LargeNumberFormatPowers = {
  'largenumber': 'auto',
  'thousands': 1,
  'millions': 2,
  'billions': 3,
  'trillions': 4
};
var numberLocalization = (0, _dependency_injector.default)({
  engine: function engine() {
    return 'base';
  },
  numericFormats: NUMERIC_FORMATS,
  defaultLargeNumberFormatPostfixes: LargeNumberFormatPostfixes,
  _parseNumberFormatString: function _parseNumberFormatString(formatType) {
    var formatObject = {};
    if (!formatType || typeof formatType !== 'string') return;
    var formatList = formatType.toLowerCase().split(' ');
    (0, _iterator.each)(formatList, function (index, value) {
      if ((0, _array.inArray)(value, NUMERIC_FORMATS) > -1) {
        formatObject.formatType = value;
      } else if (value in LargeNumberFormatPowers) {
        formatObject.power = LargeNumberFormatPowers[value];
      }
    });

    if (formatObject.power && !formatObject.formatType) {
      formatObject.formatType = 'fixedpoint';
    }

    if (formatObject.formatType) {
      return formatObject;
    }
  },
  _calculateNumberPower: function _calculateNumberPower(value, base, minPower, maxPower) {
    var number = Math.abs(value);
    var power = 0;

    if (number > 1) {
      while (number && number >= base && (maxPower === undefined || power < maxPower)) {
        power++;
        number = number / base;
      }
    } else if (number > 0 && number < 1) {
      while (number < 1 && (minPower === undefined || power > minPower)) {
        power--;
        number = number * base;
      }
    }

    return power;
  },
  _getNumberByPower: function _getNumberByPower(number, power, base) {
    var result = number;

    while (power > 0) {
      result = result / base;
      power--;
    }

    while (power < 0) {
      result = result * base;
      power++;
    }

    return result;
  },
  _formatNumber: function _formatNumber(value, formatObject, formatConfig) {
    if (formatObject.power === 'auto') {
      formatObject.power = this._calculateNumberPower(value, 1000, 0, MAX_LARGE_NUMBER_POWER);
    }

    if (formatObject.power) {
      value = this._getNumberByPower(value, formatObject.power, 1000);
    }

    var powerPostfix = this.defaultLargeNumberFormatPostfixes[formatObject.power] || '';

    var result = this._formatNumberCore(value, formatObject.formatType, formatConfig);

    result = result.replace(/(\d|.$)(\D*)$/, '$1' + powerPostfix + '$2');
    return result;
  },
  _formatNumberExponential: function _formatNumberExponential(value, formatConfig) {
    var power = this._calculateNumberPower(value, DECIMAL_BASE);

    var number = this._getNumberByPower(value, power, DECIMAL_BASE);

    if (formatConfig.precision === undefined) {
      formatConfig.precision = 1;
    }

    if (number.toFixed(formatConfig.precision || 0) >= DECIMAL_BASE) {
      power++;
      number = number / DECIMAL_BASE;
    }

    var powString = (power >= 0 ? '+' : '') + power.toString();
    return this._formatNumberCore(number, 'fixedpoint', formatConfig) + 'E' + powString;
  },
  _addZeroes: function _addZeroes(value, precision) {
    var multiplier = Math.pow(10, precision);
    var sign = value < 0 ? '-' : '';
    value = (Math.abs(value) * multiplier >>> 0) / multiplier;
    var result = value.toString();

    while (result.length < precision) {
      result = '0' + result;
    }

    return sign + result;
  },
  _addGroupSeparators: function _addGroupSeparators(value) {
    var parts = value.toString().split('.');
    return parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, (0, _config.default)().thousandsSeparator) + (parts[1] ? (0, _config.default)().decimalSeparator + parts[1] : '');
  },
  _formatNumberCore: function _formatNumberCore(value, format, formatConfig) {
    if (format === 'exponential') {
      return this._formatNumberExponential(value, formatConfig);
    }

    if (format !== 'decimal' && formatConfig.precision !== null) {
      formatConfig.precision = formatConfig.precision || 0;
    }

    if (format === 'percent') {
      value = value * 100;
    }

    if (formatConfig.precision !== undefined) {
      if (format === 'decimal') {
        value = this._addZeroes(value, formatConfig.precision);
      } else {
        value = formatConfig.precision === null ? value.toPrecision() : (0, _utils.toFixed)(value, formatConfig.precision);
      }
    }

    if (format !== 'decimal') {
      value = this._addGroupSeparators(value);
    } else {
      value = value.toString().replace('.', (0, _config.default)().decimalSeparator);
    }

    if (format === 'percent') {
      value += '%';
    }

    return value;
  },
  _normalizeFormat: function _normalizeFormat(format) {
    if (!format) {
      return {};
    }

    if (typeof format === 'function') {
      return format;
    }

    if (!(0, _type.isPlainObject)(format)) {
      format = {
        type: format
      };
    }

    return format;
  },
  _getSeparators: function _getSeparators() {
    return {
      decimalSeparator: this.getDecimalSeparator(),
      thousandsSeparator: this.getThousandsSeparator()
    };
  },
  getThousandsSeparator: function getThousandsSeparator() {
    return this.format(10000, 'fixedPoint')[2];
  },
  getDecimalSeparator: function getDecimalSeparator() {
    return this.format(1.2, {
      type: 'fixedPoint',
      precision: 1
    })[1];
  },
  convertDigits: function convertDigits(value, toStandard) {
    var digits = this.format(90, 'decimal');

    if (typeof value !== 'string' || digits[1] === '0') {
      return value;
    }

    var fromFirstDigit = toStandard ? digits[1] : '0';
    var toFirstDigit = toStandard ? '0' : digits[1];
    var fromLastDigit = toStandard ? digits[0] : '9';
    var regExp = new RegExp('[' + fromFirstDigit + '-' + fromLastDigit + ']', 'g');
    return value.replace(regExp, function (char) {
      return String.fromCharCode(char.charCodeAt(0) + (toFirstDigit.charCodeAt(0) - fromFirstDigit.charCodeAt(0)));
    });
  },
  getNegativeEtalonRegExp: function getNegativeEtalonRegExp(format) {
    var separators = this._getSeparators();

    var digitalRegExp = new RegExp('[0-9' + (0, _common.escapeRegExp)(separators.decimalSeparator + separators.thousandsSeparator) + ']+', 'g');
    var specialCharacters = ['\\', '(', ')', '[', ']', '*', '+', '$', '^', '?', '|', '{', '}'];
    var negativeEtalon = this.format(-1, format).replace(digitalRegExp, '1');
    specialCharacters.forEach(function (char) {
      negativeEtalon = negativeEtalon.replace(char, "\\".concat(char));
    });
    negativeEtalon = negativeEtalon.replace(' ', '\\s');
    negativeEtalon = negativeEtalon.replace('1', '.+');
    return new RegExp(negativeEtalon, 'g');
  },
  getSign: function getSign(text, format) {
    if (text.replace(/[^0-9-]/g, '').charAt(0) === '-') {
      return -1;
    }

    if (!format) {
      return 1;
    }

    var negativeEtalon = this.getNegativeEtalonRegExp(format);
    return text.match(negativeEtalon) ? -1 : 1;
  },
  format: function format(value, _format) {
    if (typeof value !== 'number') {
      return value;
    }

    if (typeof _format === 'number') {
      return value;
    }

    _format = _format && _format.formatter || _format;

    if (typeof _format === 'function') {
      return _format(value);
    }

    _format = this._normalizeFormat(_format);

    if (!_format.type) {
      _format.type = 'decimal';
    }

    var numberConfig = this._parseNumberFormatString(_format.type);

    if (!numberConfig) {
      var formatterConfig = this._getSeparators();

      formatterConfig.unlimitedIntegerDigits = _format.unlimitedIntegerDigits;
      return this.convertDigits((0, _number.getFormatter)(_format.type, formatterConfig)(value));
    }

    return this._formatNumber(value, numberConfig, _format);
  },
  parse: function parse(text, format) {
    if (!text) {
      return;
    }

    if (format && format.parser) {
      return format.parser(text);
    }

    text = this.convertDigits(text, true);

    if (format && typeof format !== 'string') {
      // Current parser functionality provided as-is and is independent of the most of capabilities of formatter.
      _errors.default.log('W0011');
    }

    var decimalSeparator = this.getDecimalSeparator();
    var regExp = new RegExp('[^0-9' + (0, _common.escapeRegExp)(decimalSeparator) + ']', 'g');
    var cleanedText = text.replace(regExp, '').replace(decimalSeparator, '.').replace(/\.$/g, '');

    if (cleanedText === '.' || cleanedText === '') {
      return null;
    }

    if (this._calcSignificantDigits(cleanedText) > 15) {
      return NaN;
    }

    var parsed = +cleanedText * this.getSign(text, format);
    format = this._normalizeFormat(format);

    var formatConfig = this._parseNumberFormatString(format.type);

    var power = formatConfig === null || formatConfig === void 0 ? void 0 : formatConfig.power;

    if (power) {
      if (power === 'auto') {
        var match = text.match(/\d(K|M|B|T)/);

        if (match) {
          power = (0, _array.find)(Object.keys(LargeNumberFormatPostfixes), function (power) {
            return LargeNumberFormatPostfixes[power] === match[1];
          });
        }
      }

      parsed = parsed * Math.pow(10, 3 * power);
    }

    if ((formatConfig === null || formatConfig === void 0 ? void 0 : formatConfig.formatType) === 'percent') {
      parsed /= 100;
    }

    return parsed;
  },
  _calcSignificantDigits: function _calcSignificantDigits(text) {
    var _text$split = text.split('.'),
        _text$split2 = _slicedToArray(_text$split, 2),
        integer = _text$split2[0],
        fractional = _text$split2[1];

    var calcDigitsAfterLeadingZeros = function calcDigitsAfterLeadingZeros(digits) {
      var index = -1;

      for (var i = 0; i < digits.length; i++) {
        if (digits[i] !== '0') {
          index = i;
          break;
        }
      }

      return index > -1 ? digits.length - index : 0;
    };

    var result = 0;

    if (integer) {
      result += calcDigitsAfterLeadingZeros(integer.split(''));
    }

    if (fractional) {
      result += calcDigitsAfterLeadingZeros(fractional.split('').reverse());
    }

    return result;
  }
});
numberLocalization.inject(_currency.default);

if (hasIntl) {
  numberLocalization.inject(_number2.default);
}

var _default = numberLocalization;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 47 */,
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "stylePropPrefix", {
  enumerable: true,
  get: function get() {
    return _style.stylePropPrefix;
  }
});
Object.defineProperty(exports, "styleProp", {
  enumerable: true,
  get: function get() {
    return _style.styleProp;
  }
});
exports.nativeScrolling = exports.animation = exports.transitionEndEventName = exports.transition = exports.touch = exports.inputType = exports.supportProp = exports.pointerEvents = exports.touchEvents = void 0;

var _array = __webpack_require__(12);

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _common = __webpack_require__(4);

var _call_once = _interopRequireDefault(__webpack_require__(79));

var _window = __webpack_require__(7);

var _devices = _interopRequireDefault(__webpack_require__(13));

var _style = __webpack_require__(92);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _getNavigator = (0, _window.getNavigator)(),
    maxTouchPoints = _getNavigator.maxTouchPoints,
    msMaxTouchPoints = _getNavigator.msMaxTouchPoints,
    pointerEnabled = _getNavigator.pointerEnabled;

var transitionEndEventNames = {
  'webkitTransition': 'webkitTransitionEnd',
  'MozTransition': 'transitionend',
  'OTransition': 'oTransitionEnd',
  'msTransition': 'MsTransitionEnd',
  'transition': 'transitionend'
};

var supportProp = function supportProp(prop) {
  return !!(0, _style.styleProp)(prop);
};

exports.supportProp = supportProp;

var isNativeScrollingSupported = function isNativeScrollingSupported() {
  var _devices$real = _devices.default.real(),
      platform = _devices$real.platform,
      version = _devices$real.version,
      isMac = _devices$real.mac;

  var isObsoleteAndroid = version && version[0] < 4 && platform === 'android';
  var isNativeScrollDevice = !isObsoleteAndroid && (0, _array.inArray)(platform, ['ios', 'android']) > -1 || isMac;
  return isNativeScrollDevice;
};

var inputType = function inputType(type) {
  if (type === 'text') {
    return true;
  }

  var input = _dom_adapter.default.createElement('input');

  try {
    input.setAttribute('type', type);
    input.value = 'wrongValue';
    return !input.value;
  } catch (e) {
    return false;
  }
};

exports.inputType = inputType;

var detectTouchEvents = function detectTouchEvents(hasWindowProperty, maxTouchPoints) {
  return (hasWindowProperty('ontouchstart') || !!maxTouchPoints) && !hasWindowProperty('callPhantom');
};

var detectPointerEvent = function detectPointerEvent(hasWindowProperty, pointerEnabled) {
  // TODO: remove the check of the 'pointerEnabled' when we drop IE support
  var isPointerEnabled = (0, _common.ensureDefined)(pointerEnabled, true);
  var canUsePointerEvent = (0, _common.ensureDefined)(pointerEnabled, false);
  return hasWindowProperty('PointerEvent') && isPointerEnabled || canUsePointerEvent;
};

var touchEvents = detectTouchEvents(_window.hasProperty, maxTouchPoints);
exports.touchEvents = touchEvents;
var pointerEvents = detectPointerEvent(_window.hasProperty, pointerEnabled);
exports.pointerEvents = pointerEvents;
var touchPointersPresent = !!maxTouchPoints || !!msMaxTouchPoints;
var touch = touchEvents || pointerEvents && touchPointersPresent;
exports.touch = touch;
var transition = (0, _call_once.default)(function () {
  return supportProp('transition');
});
exports.transition = transition;
var transitionEndEventName = (0, _call_once.default)(function () {
  return transitionEndEventNames[(0, _style.styleProp)('transition')];
});
exports.transitionEndEventName = transitionEndEventName;
var animation = (0, _call_once.default)(function () {
  return supportProp('animation');
});
exports.animation = animation;
var nativeScrolling = isNativeScrollingSupported();
exports.nativeScrolling = nativeScrolling;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _query_implementation = __webpack_require__(265);

var query = function query() {
  var impl = Array.isArray(arguments[0]) ? 'array' : 'remote';
  return _query_implementation.queryImpl[impl].apply(this, arguments);
};

var _default = query;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 50 */,
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _dependency_injector = _interopRequireDefault(__webpack_require__(55));

var _window = __webpack_require__(7);

var _call_once = _interopRequireDefault(__webpack_require__(79));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var callbacks = [];

var isReady = function isReady() {
  // NOTE: we can't use document.readyState === "interactive" because of ie9/ie10 support
  return _dom_adapter.default.getReadyState() === 'complete' || _dom_adapter.default.getReadyState() !== 'loading' && !_dom_adapter.default.getDocumentElement().doScroll;
};

var subscribeReady = (0, _call_once.default)(function () {
  var removeListener = _dom_adapter.default.listen(_dom_adapter.default.getDocument(), 'DOMContentLoaded', function () {
    readyCallbacks.fire();
    removeListener();
  });
});
var readyCallbacks = {
  add: function add(callback) {
    var windowExists = (0, _window.hasWindow)();

    if (windowExists && isReady()) {
      callback();
    } else {
      callbacks.push(callback);
      windowExists && subscribeReady();
    }
  },
  fire: function fire() {
    callbacks.forEach(function (callback) {
      return callback();
    });
    callbacks = [];
  }
};

var _default = (0, _dependency_injector.default)(readyCallbacks);

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.deepExtendArraySafe = exports.orderEach = exports.clone = void 0;

var _type = __webpack_require__(1);

var _variable_wrapper = _interopRequireDefault(__webpack_require__(105));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var clone = function () {
  function Clone() {}

  return function (obj) {
    Clone.prototype = obj;
    return new Clone();
  };
}();

exports.clone = clone;

var orderEach = function orderEach(map, func) {
  var keys = [];
  var key;
  var i;

  for (key in map) {
    if (Object.prototype.hasOwnProperty.call(map, key)) {
      keys.push(key);
    }
  }

  keys.sort(function (x, y) {
    var isNumberX = (0, _type.isNumeric)(x);
    var isNumberY = (0, _type.isNumeric)(y);
    if (isNumberX && isNumberY) return x - y;
    if (isNumberX && !isNumberY) return -1;
    if (!isNumberX && isNumberY) return 1;
    if (x < y) return -1;
    if (x > y) return 1;
    return 0;
  });

  for (i = 0; i < keys.length; i++) {
    key = keys[i];
    func(key, map[key]);
  }
};

exports.orderEach = orderEach;

var assignValueToProperty = function assignValueToProperty(target, property, value, assignByReference) {
  if (!assignByReference && _variable_wrapper.default.isWrapped(target[property])) {
    _variable_wrapper.default.assign(target[property], value);
  } else {
    target[property] = value;
  }
}; // B239679, http://bugs.jquery.com/ticket/9477


var deepExtendArraySafe = function deepExtendArraySafe(target, changes, extendComplexObject, assignByReference) {
  var prevValue;
  var newValue;

  for (var name in changes) {
    prevValue = target[name];
    newValue = changes[name];

    if (name === '__proto__' || name === 'constructor' || target === newValue) {
      continue;
    }

    if ((0, _type.isPlainObject)(newValue)) {
      var goDeeper = extendComplexObject ? (0, _type.isObject)(prevValue) : (0, _type.isPlainObject)(prevValue);
      newValue = deepExtendArraySafe(goDeeper ? prevValue : {}, newValue, extendComplexObject, assignByReference);
    }

    if (newValue !== undefined && prevValue !== newValue) {
      assignValueToProperty(target, name, newValue, assignByReference);
    }
  }

  return target;
};

exports.deepExtendArraySafe = deepExtendArraySafe;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _element_data = __webpack_require__(43);

var _callbacks = _interopRequireDefault(__webpack_require__(28));

var _window = __webpack_require__(7);

var _index = __webpack_require__(8);

var _extend = __webpack_require__(0);

var _ui = _interopRequireDefault(__webpack_require__(20));

var _validation_engine = _interopRequireDefault(__webpack_require__(94));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _validation_message = _interopRequireDefault(__webpack_require__(282));

var _guid = _interopRequireDefault(__webpack_require__(36));

var _common = __webpack_require__(4);

var _dom = __webpack_require__(35);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var INVALID_MESSAGE_AUTO = 'dx-invalid-message-auto';
var READONLY_STATE_CLASS = 'dx-state-readonly';
var INVALID_CLASS = 'dx-invalid';
var DX_INVALID_BADGE_CLASS = 'dx-show-invalid-badge';
var VALIDATION_TARGET = 'dx-validation-target';
var VALIDATION_STATUS_VALID = 'valid';
var VALIDATION_STATUS_INVALID = 'invalid';
var READONLY_NAMESPACE = 'editorReadOnly';
var ALLOWED_STYLING_MODES = ['outlined', 'filled', 'underlined'];
var VALIDATION_MESSAGE_KEYS_MAP = {
  validationMessageMode: 'mode',
  validationMessageOffset: 'offset',
  validationBoundary: 'boundary'
};

var Editor = _ui.default.inherit({
  ctor: function ctor() {
    this.showValidationMessageTimeout = null;
    this.validationRequest = (0, _callbacks.default)();
    this.callBase.apply(this, arguments);
  },
  _createElement: function _createElement(element) {
    this.callBase(element);
    var $element = this.$element();

    if ($element) {
      (0, _element_data.data)($element[0], VALIDATION_TARGET, this);
    }
  },
  _initOptions: function _initOptions(options) {
    this.callBase.apply(this, arguments);
    this.option(_validation_engine.default.initValidationOptions(options));
  },
  _init: function _init() {
    this.callBase();

    this._options.cache('validationTooltipOptions', this.option('validationTooltipOptions'));

    var $element = this.$element();
    $element.addClass(DX_INVALID_BADGE_CLASS);
  },
  _getDefaultOptions: function _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      value: null,

      /**
      * @name EditorOptions.name
      * @type string
      * @default ""
      * @hidden
      */
      name: '',
      onValueChanged: null,
      readOnly: false,
      isValid: true,
      validationError: null,
      validationErrors: null,
      validationStatus: VALIDATION_STATUS_VALID,
      validationMessageMode: 'auto',
      validationBoundary: undefined,
      validationMessageOffset: {
        h: 0,
        v: 0
      },
      validationTooltipOptions: {}
    });
  },
  _attachKeyboardEvents: function _attachKeyboardEvents() {
    if (!this.option('readOnly')) {
      this.callBase();
    }
  },
  _setOptionsByReference: function _setOptionsByReference() {
    this.callBase();
    (0, _extend.extend)(this._optionsByReference, {
      validationError: true
    });
  },
  _createValueChangeAction: function _createValueChangeAction() {
    this._valueChangeAction = this._createActionByOption('onValueChanged', {
      excludeValidators: ['disabled', 'readOnly']
    });
  },
  _suppressValueChangeAction: function _suppressValueChangeAction() {
    this._valueChangeActionSuppressed = true;
  },
  _resumeValueChangeAction: function _resumeValueChangeAction() {
    this._valueChangeActionSuppressed = false;
  },
  _initMarkup: function _initMarkup() {
    this._toggleReadOnlyState();

    this._setSubmitElementName(this.option('name'));

    this.callBase();

    this._renderValidationState();
  },
  _raiseValueChangeAction: function _raiseValueChangeAction(value, previousValue) {
    if (!this._valueChangeAction) {
      this._createValueChangeAction();
    }

    this._valueChangeAction(this._valueChangeArgs(value, previousValue));
  },
  _valueChangeArgs: function _valueChangeArgs(value, previousValue) {
    return {
      value: value,
      previousValue: previousValue,
      event: this._valueChangeEventInstance
    };
  },
  _saveValueChangeEvent: function _saveValueChangeEvent(e) {
    this._valueChangeEventInstance = e;
  },
  _focusInHandler: function _focusInHandler(e) {
    var isValidationMessageShownOnFocus = this.option('validationMessageMode') === 'auto'; // NOTE: The click should be processed before the validation message is shown because
    // it can change the editor's value

    if (this._canValueBeChangedByClick() && isValidationMessageShownOnFocus) {
      var _this$_validationMess;

      // NOTE: Prevent the validation message from showing
      var $validationMessageWrapper = (_this$_validationMess = this._validationMessage) === null || _this$_validationMess === void 0 ? void 0 : _this$_validationMess.$wrapper();
      $validationMessageWrapper === null || $validationMessageWrapper === void 0 ? void 0 : $validationMessageWrapper.removeClass(INVALID_MESSAGE_AUTO);
      clearTimeout(this.showValidationMessageTimeout); // NOTE: Show the validation message after a click changes the value

      this.showValidationMessageTimeout = setTimeout(function () {
        return $validationMessageWrapper === null || $validationMessageWrapper === void 0 ? void 0 : $validationMessageWrapper.addClass(INVALID_MESSAGE_AUTO);
      }, 150);
    }

    return this.callBase(e);
  },
  _canValueBeChangedByClick: function _canValueBeChangedByClick() {
    return false;
  },
  _getStylingModePrefix: function _getStylingModePrefix() {
    return 'dx-editor-';
  },
  _renderStylingMode: function _renderStylingMode() {
    var _this = this;

    var optionName = 'stylingMode';
    var optionValue = this.option(optionName);

    var prefix = this._getStylingModePrefix();

    var allowedStylingClasses = ALLOWED_STYLING_MODES.map(function (mode) {
      return prefix + mode;
    });
    allowedStylingClasses.forEach(function (className) {
      return _this.$element().removeClass(className);
    });
    var stylingModeClass = prefix + optionValue;

    if (allowedStylingClasses.indexOf(stylingModeClass) === -1) {
      var defaultOptionValue = this._getDefaultOptions()[optionName];

      var platformOptionValue = this._convertRulesToOptions(this._defaultOptionsRules())[optionName];

      stylingModeClass = prefix + (platformOptionValue || defaultOptionValue);
    }

    this.$element().addClass(stylingModeClass);
  },
  _getValidationErrors: function _getValidationErrors() {
    var validationErrors = this.option('validationErrors');

    if (!validationErrors && this.option('validationError')) {
      validationErrors = [this.option('validationError')];
    }

    return validationErrors;
  },
  _disposeValidationMessage: function _disposeValidationMessage() {
    if (this._$validationMessage) {
      this._$validationMessage.remove();

      this.setAria('describedby', null);
      this._$validationMessage = undefined;
      this._validationMessage = undefined;
    }
  },
  _toggleValidationClasses: function _toggleValidationClasses(isInvalid) {
    this.$element().toggleClass(INVALID_CLASS, isInvalid);
    this.setAria(VALIDATION_STATUS_INVALID, isInvalid || undefined);
  },
  _renderValidationState: function _renderValidationState() {
    var isValid = this.option('isValid') && this.option('validationStatus') !== VALIDATION_STATUS_INVALID;

    var validationErrors = this._getValidationErrors();

    var $element = this.$element();

    this._toggleValidationClasses(!isValid);

    if (!(0, _window.hasWindow)()) {
      return;
    }

    this._disposeValidationMessage();

    if (!isValid && validationErrors) {
      var _this$option = this.option(),
          validationMessageMode = _this$option.validationMessageMode,
          validationMessageOffset = _this$option.validationMessageOffset,
          validationBoundary = _this$option.validationBoundary,
          rtlEnabled = _this$option.rtlEnabled;

      this._$validationMessage = (0, _renderer.default)('<div>').appendTo($element);
      this.setAria('describedby', 'dx-' + new _guid.default());
      this._validationMessage = new _validation_message.default(this._$validationMessage, (0, _extend.extend)({
        validationErrors: validationErrors,
        rtlEnabled: rtlEnabled,
        target: this._getValidationMessageTarget(),
        container: $element,
        mode: validationMessageMode,
        positionRequest: 'below',
        offset: validationMessageOffset,
        boundary: validationBoundary,
        describedElement: this._focusTarget()
      }, this._options.cache('validationTooltipOptions')));

      this._bindInnerWidgetOptions(this._validationMessage, 'validationTooltipOptions');
    }
  },
  _getValidationMessageTarget: function _getValidationMessageTarget() {
    return this.$element();
  },
  _toggleReadOnlyState: function _toggleReadOnlyState() {
    var readOnly = this.option('readOnly');

    this._toggleBackspaceHandler(readOnly);

    this.$element().toggleClass(READONLY_STATE_CLASS, !!readOnly);
    this.setAria('readonly', readOnly || undefined);
  },
  _toggleBackspaceHandler: function _toggleBackspaceHandler(isReadOnly) {
    var $eventTarget = this._keyboardEventBindingTarget();

    var eventName = (0, _index.addNamespace)('keydown', READONLY_NAMESPACE);

    _events_engine.default.off($eventTarget, eventName);

    if (isReadOnly) {
      _events_engine.default.on($eventTarget, eventName, function (e) {
        if ((0, _index.normalizeKeyName)(e) === 'backspace') {
          e.preventDefault();
        }
      });
    }
  },
  _dispose: function _dispose() {
    var element = this.$element()[0];
    (0, _element_data.data)(element, VALIDATION_TARGET, null);
    clearTimeout(this.showValidationMessageTimeout);

    this._disposeValidationMessage();

    this.callBase();
  },
  _setSubmitElementName: function _setSubmitElementName(name) {
    var $submitElement = this._getSubmitElement();

    if (!$submitElement) {
      return;
    }

    if (name.length > 0) {
      $submitElement.attr('name', name);
    } else {
      $submitElement.removeAttr('name');
    }
  },
  _getSubmitElement: function _getSubmitElement() {
    return null;
  },
  _setValidationMessageOption: function _setValidationMessageOption(_ref) {
    var _this$_validationMess2;

    var name = _ref.name,
        value = _ref.value;
    var optionKey = VALIDATION_MESSAGE_KEYS_MAP[name] ? VALIDATION_MESSAGE_KEYS_MAP[name] : name;
    (_this$_validationMess2 = this._validationMessage) === null || _this$_validationMess2 === void 0 ? void 0 : _this$_validationMess2.option(optionKey, value);
  },
  _hasActiveElement: _common.noop,
  _optionChanged: function _optionChanged(args) {
    var _this$_validationMess3;

    switch (args.name) {
      case 'onValueChanged':
        this._createValueChangeAction();

        break;

      case 'readOnly':
        this._toggleReadOnlyState();

        this._refreshFocusState();

        break;

      case 'value':
        if (args.value != args.previousValue) {
          // eslint-disable-line eqeqeq
          this.validationRequest.fire({
            value: args.value,
            editor: this
          });
        }

        if (!this._valueChangeActionSuppressed) {
          this._raiseValueChangeAction(args.value, args.previousValue);

          this._saveValueChangeEvent(undefined);
        }

        break;

      case 'width':
        this.callBase(args);
        (_this$_validationMess3 = this._validationMessage) === null || _this$_validationMess3 === void 0 ? void 0 : _this$_validationMess3.updateMaxWidth();
        break;

      case 'name':
        this._setSubmitElementName(args.value);

        break;

      case 'isValid':
      case 'validationError':
      case 'validationErrors':
      case 'validationStatus':
        this.option(_validation_engine.default.synchronizeValidationOptions(args, this.option()));

        this._renderValidationState();

        break;

      case 'validationBoundary':
      case 'validationMessageMode':
      case 'validationMessageOffset':
        this._setValidationMessageOption(args);

        break;

      case 'rtlEnabled':
        this._setValidationMessageOption(args);

        this.callBase(args);
        break;

      case 'validationTooltipOptions':
        this._innerWidgetOptionChanged(this._validationMessage, args);

        break;

      default:
        this.callBase(args);
    }
  },
  blur: function blur() {
    if (this._hasActiveElement()) {
      (0, _dom.resetActiveElement)();
    }
  },
  reset: function reset() {
    var defaultOptions = this._getDefaultOptions();

    this.option('value', defaultOptions.value);
  }
});

Editor.isEditor = function (instance) {
  return instance instanceof Editor;
};

var _default = Editor;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getImageContainer = exports.getImageSourceType = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ICON_CLASS = 'dx-icon';
var SVG_ICON_CLASS = 'dx-svg-icon';

var getImageSourceType = function getImageSourceType(source) {
  if (!source || typeof source !== 'string') {
    return false;
  }

  if (/^\s*<svg[^>]*>(.|\r?\n)*?<\/svg>\s*$/i.test(source)) {
    return 'svg';
  }

  if (/data:.*base64|\.|[^<\s]\//.test(source)) {
    return 'image';
  }

  if (/^[\w-_]+$/.test(source)) {
    return 'dxIcon';
  }

  if (/^\s?([\w-_]\s?)+$/.test(source)) {
    return 'fontIcon';
  }

  return false;
};

exports.getImageSourceType = getImageSourceType;

var getImageContainer = function getImageContainer(source) {
  switch (getImageSourceType(source)) {
    case 'image':
      return (0, _renderer.default)('<img>').attr('src', source).addClass(ICON_CLASS);

    case 'fontIcon':
      return (0, _renderer.default)('<i>').addClass("".concat(ICON_CLASS, " ").concat(source));

    case 'dxIcon':
      return (0, _renderer.default)('<i>').addClass("".concat(ICON_CLASS, " ").concat(ICON_CLASS, "-").concat(source));

    case 'svg':
      return (0, _renderer.default)('<i>').addClass("".concat(ICON_CLASS, " ").concat(SVG_ICON_CLASS)).append(source);

    default:
      return null;
  }
};

exports.getImageContainer = getImageContainer;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = _default;

var _extend = __webpack_require__(0);

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

var _class = _interopRequireDefault(__webpack_require__(15));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(object) {
  var BaseClass = _class.default.inherit(object);

  var InjectedClass = BaseClass;
  var instance = new InjectedClass(object);
  var initialFields = {};

  var injectFields = function injectFields(injectionObject, initial) {
    (0, _iterator.each)(injectionObject, function (key) {
      if ((0, _type.isFunction)(instance[key])) {
        if (initial || !object[key]) {
          object[key] = function () {
            return instance[key].apply(object, arguments);
          };
        }
      } else {
        if (initial) {
          initialFields[key] = object[key];
        }

        object[key] = instance[key];
      }
    });
  };

  injectFields(object, true);

  object.inject = function (injectionObject) {
    InjectedClass = InjectedClass.inherit(injectionObject);
    instance = new InjectedClass();
    injectFields(injectionObject);
  };

  object.resetInjection = function () {
    (0, _extend.extend)(object, initialFields);
    InjectedClass = BaseClass;
    instance = new BaseClass();
  };

  return object;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = window.jQuery;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getTheme = getTheme;
exports.currentTheme = currentTheme;
exports.registerTheme = registerTheme;
exports.registerThemeSchemeAlias = registerThemeSchemeAlias;
exports.addCacheItem = addCacheItem;
exports.removeCacheItem = removeCacheItem;
exports.refreshTheme = refreshTheme;

var _extend2 = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _utils = __webpack_require__(14);

var _themes = __webpack_require__(38);

var themes = {};
var themesMapping = {};
var themesSchemeMapping = {};
var _extend = _extend2.extend;
var _each = _iterator.each;
var currentThemeName = null;
var defaultTheme;
var nextCacheUid = 0;
var widgetsCache = {};

function getTheme(themeName) {
  var name = (0, _utils.normalizeEnum)(themeName);
  return themes[name] || themes[themesMapping[name] || currentTheme()];
}

function findThemeNameByName(name, scheme) {
  return themesMapping[name + '.' + scheme] || themesSchemeMapping[name + '.' + scheme] || themesMapping[name];
}

function findThemeNameByPlatform(platform, version, scheme) {
  return findThemeNameByName(platform + version, scheme) || findThemeNameByName(platform, scheme);
}

function currentTheme(themeName, colorScheme) {
  if (!arguments.length) {
    return currentThemeName || findThemeNameByName((0, _themes.current)()) || defaultTheme;
  }

  var scheme = (0, _utils.normalizeEnum)(colorScheme);
  currentThemeName = (themeName && themeName.platform ? findThemeNameByPlatform((0, _utils.normalizeEnum)(themeName.platform), themeName.version, scheme) : findThemeNameByName((0, _utils.normalizeEnum)(themeName), scheme)) || currentThemeName; // For chaining only

  return this;
}

function getThemeInfo(themeName, splitter) {
  var k = themeName.indexOf(splitter);
  return k > 0 ? {
    name: themeName.substring(0, k),
    scheme: themeName.substring(k + 1)
  } : null;
}

function registerThemeName(themeName, targetThemeName) {
  var themeInfo = getThemeInfo(themeName, '.') || {
    name: themeName
  };
  var name = themeInfo.name;
  var scheme = themeInfo.scheme;

  if (scheme) {
    themesMapping[name] = themesMapping[name] || targetThemeName;
    themesMapping[name + '.' + scheme] = targetThemeName;
  } else {
    themesMapping[name] = targetThemeName;
  }
}

function registerTheme(theme, baseThemeName) {
  var themeName = (0, _utils.normalizeEnum)(theme && theme.name);

  if (themeName) {
    theme.isDefault && (defaultTheme = themeName);
    registerThemeName(themeName, themeName);
    themes[themeName] = _extend(true, {}, getTheme(baseThemeName), patchTheme(theme));
  }
}

function registerThemeSchemeAlias(from, to) {
  themesSchemeMapping[from] = to;
}

function mergeScalar(target, field, source, sourceValue) {
  var _value = source ? source[field] : sourceValue;

  if (_value !== undefined && target[field] === undefined) {
    target[field] = _value;
  }
}

function mergeObject(target, field, source, sourceValue) {
  var _value = source ? source[field] : sourceValue;

  if (_value !== undefined) {
    target[field] = _extend(true, {}, _value, target[field]);
  }
} // TODO: Font initialization should be done here


function patchTheme(theme) {
  theme = _extend(true, {
    loadingIndicator: {
      font: {}
    },
    'export': {
      font: {}
    },
    legend: {
      font: {},
      border: {}
    },
    title: {
      font: {}
    },
    tooltip: {
      font: {}
    },
    'chart:common': {},
    'chart:common:axis': {
      grid: {},
      minorGrid: {},
      tick: {},
      minorTick: {},
      title: {
        font: {}
      },
      label: {
        font: {}
      }
    },
    'chart:common:annotation': {
      font: {},
      border: {}
    },
    chart: {
      commonSeriesSettings: {
        candlestick: {}
      }
    },
    pie: {},
    polar: {},
    gauge: {
      scale: {
        tick: {},
        minorTick: {},
        label: {
          font: {}
        }
      }
    },
    barGauge: {},
    funnel: {},
    sankey: {},
    map: {
      background: {}
    },
    treeMap: {
      tile: {
        selectionStyle: {
          border: {}
        }
      },
      group: {
        border: {},
        selectionStyle: {
          border: {}
        },
        label: {
          font: {}
        }
      }
    },
    rangeSelector: {
      scale: {
        tick: {},
        minorTick: {},
        label: {
          font: {}
        }
      },
      chart: {}
    },
    sparkline: {},
    bullet: {}
  }, theme);
  mergeScalar(theme.loadingIndicator, 'backgroundColor', theme);
  mergeScalar(theme.chart.commonSeriesSettings.candlestick, 'innerColor', null, theme.backgroundColor);
  mergeScalar(theme.map.background, 'color', null, theme.backgroundColor);
  mergeScalar(theme.title.font, 'color', null, theme.primaryTitleColor);
  mergeObject(theme.title, 'subtitle', null, theme.title);
  mergeScalar(theme.legend.font, 'color', null, theme.secondaryTitleColor);
  mergeScalar(theme.legend.border, 'color', null, theme.gridColor);
  patchAxes(theme);

  _each(['chart', 'pie', 'polar', 'gauge', 'barGauge', 'map', 'treeMap', 'funnel', 'rangeSelector', 'sparkline', 'bullet', 'sankey'], function (_, section) {
    mergeScalar(theme[section], 'redrawOnResize', theme);
    mergeScalar(theme[section], 'containerBackgroundColor', null, theme.backgroundColor);
    mergeObject(theme[section], 'tooltip', theme);
    mergeObject(theme[section], 'export', theme);
  });

  _each(['chart', 'pie', 'polar', 'gauge', 'barGauge', 'map', 'treeMap', 'funnel', 'rangeSelector', 'sankey'], function (_, section) {
    mergeObject(theme[section], 'loadingIndicator', theme);
    mergeObject(theme[section], 'legend', theme);
    mergeObject(theme[section], 'title', theme);
  });

  _each(['chart', 'pie', 'polar'], function (_, section) {
    mergeObject(theme, section, null, theme['chart:common']);
  });

  _each(['chart', 'polar'], function (_, section) {
    theme[section] = theme[section] || {};
    mergeObject(theme[section], 'commonAxisSettings', null, theme['chart:common:axis']);
  });

  _each(['chart', 'polar', 'map', 'pie'], function (_, section) {
    theme[section] = theme[section] || {};
    mergeObject(theme[section], 'commonAnnotationSettings', null, theme['chart:common:annotation']);
  });

  mergeObject(theme.rangeSelector.chart, 'commonSeriesSettings', theme.chart);
  mergeObject(theme.rangeSelector.chart, 'dataPrepareSettings', theme.chart);
  mergeScalar(theme.treeMap.group.border, 'color', null, theme.gridColor);
  mergeScalar(theme.treeMap.tile.selectionStyle.border, 'color', null, theme.primaryTitleColor);
  mergeScalar(theme.treeMap.group.selectionStyle.border, 'color', null, theme.primaryTitleColor);
  mergeScalar(theme.map.legend, 'backgroundColor', theme);
  patchMapLayers(theme);
  return theme;
}

function patchAxes(theme) {
  var commonAxisSettings = theme['chart:common:axis'];
  var colorFieldName = 'color';

  _each([commonAxisSettings.grid, commonAxisSettings.minorGrid], function (_, obj) {
    mergeScalar(obj, colorFieldName, null, theme.gridColor);
  });

  _each([commonAxisSettings, commonAxisSettings.tick, commonAxisSettings.minorTick, commonAxisSettings.label.font], function (_, obj) {
    mergeScalar(obj, colorFieldName, null, theme.axisColor);
  });

  mergeScalar(commonAxisSettings.title.font, colorFieldName, null, theme.secondaryTitleColor);
  mergeScalar(theme.gauge.scale.label.font, colorFieldName, null, theme.axisColor);
  mergeScalar(theme.gauge.scale.tick, colorFieldName, null, theme.backgroundColor);
  mergeScalar(theme.gauge.scale.minorTick, colorFieldName, null, theme.backgroundColor);
  mergeScalar(theme.rangeSelector.scale.label.font, colorFieldName, null, theme.axisColor);
}

function patchMapLayers(theme) {
  var map = theme.map;

  _each(['area', 'line', 'marker'], function (_, section) {
    mergeObject(map, 'layer:' + section, null, map.layer);
  });

  _each(['dot', 'bubble', 'pie', 'image'], function (_, section) {
    mergeObject(map, 'layer:marker:' + section, null, map['layer:marker']);
  });
}

function addCacheItem(target) {
  var cacheUid = ++nextCacheUid;
  target._cache = cacheUid;
  widgetsCache[cacheUid] = target;
}

function removeCacheItem(target) {
  delete widgetsCache[target._cache];
}

function refreshTheme() {
  _each(widgetsCache, function () {
    this.refresh();
  }); // For chaining only


  return this;
}

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _uiCollection_widget = _interopRequireDefault(__webpack_require__(410));

var _ui = _interopRequireDefault(__webpack_require__(19));

var _extend = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _common = __webpack_require__(4);

var _type = __webpack_require__(1);

var _uiCollection_widgetEditStrategy = _interopRequireDefault(__webpack_require__(215));

var _data = __webpack_require__(21);

var _data_source = __webpack_require__(72);

var _utils = __webpack_require__(65);

var _selection = _interopRequireDefault(__webpack_require__(218));

var _deferred = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var ITEM_DELETING_DATA_KEY = 'dxItemDeleting';
var NOT_EXISTING_INDEX = -1;

var indexExists = function indexExists(index) {
  return index !== NOT_EXISTING_INDEX;
};

var CollectionWidget = _uiCollection_widget.default.inherit({
  _setOptionsByReference: function _setOptionsByReference() {
    this.callBase();
    (0, _extend.extend)(this._optionsByReference, {
      selectedItem: true
    });
  },
  _getDefaultOptions: function _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      /**
      * @name CollectionWidgetOptions.selectionMode
      * @type string
      * @default 'none'
      * @acceptValues 'multiple'|'single'|'all'|'none'
      * @hidden
      */
      selectionMode: 'none',

      /**
      * @name CollectionWidgetOptions.selectionRequired
      * @type boolean
      * @default false
      * @hidden
      */
      selectionRequired: false,

      /**
      * @name CollectionWidgetOptions.selectionByClick
      * @type boolean
      * @default true
      * @hidden
      */
      selectionByClick: true,
      selectedItems: [],
      selectedItemKeys: [],
      maxFilterLengthInRequest: 1500,
      keyExpr: null,
      selectedIndex: NOT_EXISTING_INDEX,
      selectedItem: null,
      onSelectionChanged: null,

      /**
      * @name CollectionWidgetOptions.onItemReordered
      * @extends Action
      * @type function(e)
      * @type_function_param1 e:object
      * @type_function_param1_field4 itemData:object
      * @type_function_param1_field5 itemElement:DxElement
      * @type_function_param1_field6 itemIndex:number | object
      * @type_function_param1_field7 fromIndex:number
      * @type_function_param1_field8 toIndex:number
      * @action
      * @hidden
      */
      onItemReordered: null,

      /**
      * @name CollectionWidgetOptions.onItemDeleting
      * @extends Action
      * @type function(e)
      * @type_function_param1 e:object
      * @type_function_param1_field4 itemData:object
      * @type_function_param1_field5 itemElement:DxElement
      * @type_function_param1_field6 itemIndex:number | object
      * @type_function_param1_field7 cancel:boolean | Promise<void>
      * @action
      * @hidden
      */
      onItemDeleting: null,

      /**
      * @name CollectionWidgetOptions.onItemDeleted
      * @extends Action
      * @type function(e)
      * @type_function_param1 e:object
      * @type_function_param1_field4 itemData:object
      * @type_function_param1_field5 itemElement:DxElement
      * @type_function_param1_field6 itemIndex:number | object
      * @action
      * @hidden
      */
      onItemDeleted: null
    });
  },
  ctor: function ctor(element, options) {
    this._userOptions = options || {};
    this.callBase(element, options);
  },
  _init: function _init() {
    this._initEditStrategy();

    this.callBase();

    this._initKeyGetter();

    this._initSelectionModule();
  },
  _initKeyGetter: function _initKeyGetter() {
    this._keyGetter = (0, _data.compileGetter)(this.option('keyExpr'));
  },
  _getKeysByItems: function _getKeysByItems(selectedItems) {
    return this._editStrategy.getKeysByItems(selectedItems);
  },
  _getItemsByKeys: function _getItemsByKeys(selectedItemKeys, selectedItems) {
    return this._editStrategy.getItemsByKeys(selectedItemKeys, selectedItems);
  },
  _getKeyByIndex: function _getKeyByIndex(index) {
    return this._editStrategy.getKeyByIndex(index);
  },
  _getIndexByKey: function _getIndexByKey(key) {
    return this._editStrategy.getIndexByKey(key);
  },
  _getIndexByItemData: function _getIndexByItemData(itemData) {
    return this._editStrategy.getIndexByItemData(itemData);
  },
  _isKeySpecified: function _isKeySpecified() {
    return !!(this._dataSource && this._dataSource.key());
  },
  _getCombinedFilter: function _getCombinedFilter() {
    return this._dataSource && this._dataSource.filter();
  },
  key: function key() {
    if (this.option('keyExpr')) return this.option('keyExpr');
    return this._dataSource && this._dataSource.key();
  },
  keyOf: function keyOf(item) {
    var key = item;

    var store = this._dataSource && this._dataSource.store();

    if (this.option('keyExpr')) {
      key = this._keyGetter(item);
    } else if (store) {
      key = store.keyOf(item);
    }

    return key;
  },
  _nullValueSelectionSupported: function _nullValueSelectionSupported() {
    return false;
  },
  _initSelectionModule: function _initSelectionModule() {
    var that = this;
    var itemsGetter = that._editStrategy.itemsGetter;
    this._selection = new _selection.default({
      allowNullValue: this._nullValueSelectionSupported(),
      mode: this.option('selectionMode'),
      maxFilterLengthInRequest: this.option('maxFilterLengthInRequest'),
      equalByReference: !this._isKeySpecified(),
      onSelectionChanged: function onSelectionChanged(args) {
        if (args.addedItemKeys.length || args.removedItemKeys.length) {
          that.option('selectedItems', that._getItemsByKeys(args.selectedItemKeys, args.selectedItems));

          that._updateSelectedItems(args);
        }
      },
      filter: that._getCombinedFilter.bind(that),
      totalCount: function totalCount() {
        var items = that.option('items');
        var dataSource = that._dataSource;
        return dataSource && dataSource.totalCount() >= 0 ? dataSource.totalCount() : items.length;
      },
      key: that.key.bind(that),
      keyOf: that.keyOf.bind(that),
      load: function load(options) {
        if (that._dataSource) {
          var loadOptions = that._dataSource.loadOptions();

          options.customQueryParams = loadOptions.customQueryParams;
          options.userData = that._dataSource._userData;
        }

        var store = that._dataSource && that._dataSource.store();

        if (store) {
          return store.load(options).done(function (loadResult) {
            if (that._disposed) {
              return;
            }

            var items = (0, _utils.normalizeLoadResult)(loadResult).data;

            that._dataSource._applyMapFunction(items);
          });
        } else {
          return new _deferred.Deferred().resolve(this.plainItems());
        }
      },
      dataFields: function dataFields() {
        return that._dataSource && that._dataSource.select();
      },
      plainItems: itemsGetter.bind(that._editStrategy)
    });
  },
  _initEditStrategy: function _initEditStrategy() {
    var Strategy = _uiCollection_widgetEditStrategy.default;
    this._editStrategy = new Strategy(this);
  },
  _getSelectedItemIndices: function _getSelectedItemIndices(keys) {
    var that = this;
    var indices = [];
    keys = keys || this._selection.getSelectedItemKeys();

    that._editStrategy.beginCache();

    (0, _iterator.each)(keys, function (_, key) {
      var selectedIndex = that._getIndexByKey(key);

      if (indexExists(selectedIndex)) {
        indices.push(selectedIndex);
      }
    });

    that._editStrategy.endCache();

    return indices;
  },
  _initMarkup: function _initMarkup() {
    var _this = this;

    this._rendering = true;

    if (!this._dataSource || !this._dataSource.isLoading()) {
      this._syncSelectionOptions().done(function () {
        return _this._normalizeSelectedItems();
      });
    }

    this.callBase();
  },
  _render: function _render() {
    this.callBase();
    this._rendering = false;
  },
  _fireContentReadyAction: function _fireContentReadyAction() {
    this._rendering = false;
    this._rendered = true;
    this.callBase.apply(this, arguments);
  },
  _syncSelectionOptions: function _syncSelectionOptions(byOption) {
    byOption = byOption || this._chooseSelectOption();
    var selectedItem;
    var selectedIndex;
    var selectedItemKeys;
    var selectedItems;

    switch (byOption) {
      case 'selectedIndex':
        selectedItem = this._editStrategy.getItemDataByIndex(this.option('selectedIndex'));

        if ((0, _type.isDefined)(selectedItem)) {
          this._setOptionWithoutOptionChange('selectedItems', [selectedItem]);

          this._setOptionWithoutOptionChange('selectedItem', selectedItem);

          this._setOptionWithoutOptionChange('selectedItemKeys', this._editStrategy.getKeysByItems([selectedItem]));
        } else {
          this._setOptionWithoutOptionChange('selectedItems', []);

          this._setOptionWithoutOptionChange('selectedItemKeys', []);

          this._setOptionWithoutOptionChange('selectedItem', null);
        }

        break;

      case 'selectedItems':
        selectedItems = this.option('selectedItems') || [];
        selectedIndex = selectedItems.length ? this._editStrategy.getIndexByItemData(selectedItems[0]) : NOT_EXISTING_INDEX;

        if (this.option('selectionRequired') && !indexExists(selectedIndex)) {
          return this._syncSelectionOptions('selectedIndex');
        }

        this._setOptionWithoutOptionChange('selectedItem', selectedItems[0]);

        this._setOptionWithoutOptionChange('selectedIndex', selectedIndex);

        this._setOptionWithoutOptionChange('selectedItemKeys', this._editStrategy.getKeysByItems(selectedItems));

        break;

      case 'selectedItem':
        selectedItem = this.option('selectedItem');
        selectedIndex = this._editStrategy.getIndexByItemData(selectedItem);

        if (this.option('selectionRequired') && !indexExists(selectedIndex)) {
          return this._syncSelectionOptions('selectedIndex');
        }

        if ((0, _type.isDefined)(selectedItem)) {
          this._setOptionWithoutOptionChange('selectedItems', [selectedItem]);

          this._setOptionWithoutOptionChange('selectedIndex', selectedIndex);

          this._setOptionWithoutOptionChange('selectedItemKeys', this._editStrategy.getKeysByItems([selectedItem]));
        } else {
          this._setOptionWithoutOptionChange('selectedItems', []);

          this._setOptionWithoutOptionChange('selectedItemKeys', []);

          this._setOptionWithoutOptionChange('selectedIndex', NOT_EXISTING_INDEX);
        }

        break;

      case 'selectedItemKeys':
        selectedItemKeys = this.option('selectedItemKeys');

        if (this.option('selectionRequired')) {
          var selectedItemIndex = this._getIndexByKey(selectedItemKeys[0]);

          if (!indexExists(selectedItemIndex)) {
            return this._syncSelectionOptions('selectedIndex');
          }
        }

        return this._selection.setSelection(selectedItemKeys);
    }

    return new _deferred.Deferred().resolve().promise();
  },
  _chooseSelectOption: function _chooseSelectOption() {
    var optionName = 'selectedIndex';

    var isOptionDefined = function (optionName) {
      var optionValue = this.option(optionName);
      var length = (0, _type.isDefined)(optionValue) && optionValue.length;
      return length || optionName in this._userOptions;
    }.bind(this);

    if (isOptionDefined('selectedItems')) {
      optionName = 'selectedItems';
    } else if (isOptionDefined('selectedItem')) {
      optionName = 'selectedItem';
    } else if (isOptionDefined('selectedItemKeys')) {
      optionName = 'selectedItemKeys';
    }

    return optionName;
  },
  _compareKeys: function _compareKeys(oldKeys, newKeys) {
    if (oldKeys.length !== newKeys.length) {
      return false;
    }

    for (var i = 0; i < newKeys.length; i++) {
      if (oldKeys[i] !== newKeys[i]) {
        return false;
      }
    }

    return true;
  },
  _normalizeSelectedItems: function _normalizeSelectedItems() {
    if (this.option('selectionMode') === 'none') {
      this._setOptionWithoutOptionChange('selectedItems', []);

      this._syncSelectionOptions('selectedItems');
    } else if (this.option('selectionMode') === 'single') {
      var newSelection = this.option('selectedItems');

      if (newSelection.length > 1 || !newSelection.length && this.option('selectionRequired') && this.option('items') && this.option('items').length) {
        var currentSelection = this._selection.getSelectedItems();

        var normalizedSelection = newSelection[0] === undefined ? currentSelection[0] : newSelection[0];

        if (normalizedSelection === undefined) {
          normalizedSelection = this._editStrategy.itemsGetter()[0];
        }

        if (this.option('grouped') && normalizedSelection && normalizedSelection.items) {
          normalizedSelection.items = [normalizedSelection.items[0]];
        }

        this._selection.setSelection(this._getKeysByItems([normalizedSelection]));

        this._setOptionWithoutOptionChange('selectedItems', [normalizedSelection]);

        return this._syncSelectionOptions('selectedItems');
      } else {
        this._selection.setSelection(this._getKeysByItems(newSelection));
      }
    } else {
      var newKeys = this._getKeysByItems(this.option('selectedItems'));

      var oldKeys = this._selection.getSelectedItemKeys();

      if (!this._compareKeys(oldKeys, newKeys)) {
        this._selection.setSelection(newKeys);
      }
    }

    return new _deferred.Deferred().resolve().promise();
  },
  _itemClickHandler: function _itemClickHandler(e) {
    this._createAction(function (e) {
      this._itemSelectHandler(e.event);
    }.bind(this), {
      validatingTargetName: 'itemElement'
    })({
      itemElement: (0, _renderer.default)(e.currentTarget),
      event: e
    });

    this.callBase.apply(this, arguments);
  },
  _itemSelectHandler: function _itemSelectHandler(e) {
    if (!this.option('selectionByClick')) {
      return;
    }

    var $itemElement = e.currentTarget;

    if (this.isItemSelected($itemElement)) {
      this.unselectItem(e.currentTarget);
    } else {
      this.selectItem(e.currentTarget);
    }
  },
  _selectedItemElement: function _selectedItemElement(index) {
    return this._itemElements().eq(index);
  },
  _postprocessRenderItem: function _postprocessRenderItem(args) {
    if (this.option('selectionMode') !== 'none') {
      var $itemElement = (0, _renderer.default)(args.itemElement);

      var normalizedItemIndex = this._editStrategy.getNormalizedIndex($itemElement);

      var isItemSelected = this._isItemSelected(normalizedItemIndex);

      this._processSelectableItem($itemElement, isItemSelected);
    }
  },
  _processSelectableItem: function _processSelectableItem($itemElement, isSelected) {
    $itemElement.toggleClass(this._selectedItemClass(), isSelected);

    this._setAriaSelected($itemElement, String(isSelected));
  },
  _updateSelectedItems: function _updateSelectedItems(args) {
    var that = this;
    var addedItemKeys = args.addedItemKeys;
    var removedItemKeys = args.removedItemKeys;

    if (that._rendered && (addedItemKeys.length || removedItemKeys.length)) {
      var selectionChangePromise = that._selectionChangePromise;

      if (!that._rendering) {
        var addedSelection = [];
        var normalizedIndex;
        var removedSelection = [];

        that._editStrategy.beginCache();

        for (var i = 0; i < addedItemKeys.length; i++) {
          normalizedIndex = that._getIndexByKey(addedItemKeys[i]);
          addedSelection.push(normalizedIndex);

          that._addSelection(normalizedIndex);
        }

        for (var _i = 0; _i < removedItemKeys.length; _i++) {
          normalizedIndex = that._getIndexByKey(removedItemKeys[_i]);
          removedSelection.push(normalizedIndex);

          that._removeSelection(normalizedIndex);
        }

        that._editStrategy.endCache();

        that._updateSelection(addedSelection, removedSelection);
      }

      (0, _deferred.when)(selectionChangePromise).done(function () {
        that._fireSelectionChangeEvent(args.addedItems, args.removedItems);
      });
    }
  },
  _fireSelectionChangeEvent: function _fireSelectionChangeEvent(addedItems, removedItems) {
    this._createActionByOption('onSelectionChanged', {
      excludeValidators: ['disabled', 'readOnly']
    })({
      addedItems: addedItems,
      removedItems: removedItems
    });
  },
  _updateSelection: _common.noop,
  _setAriaSelected: function _setAriaSelected($target, value) {
    this.setAria('selected', value, $target);
  },
  _removeSelection: function _removeSelection(normalizedIndex) {
    var $itemElement = this._editStrategy.getItemElement(normalizedIndex);

    if (indexExists(normalizedIndex)) {
      this._processSelectableItem($itemElement, false);

      _events_engine.default.triggerHandler($itemElement, 'stateChanged', false);
    }
  },
  _addSelection: function _addSelection(normalizedIndex) {
    var $itemElement = this._editStrategy.getItemElement(normalizedIndex);

    if (indexExists(normalizedIndex)) {
      this._processSelectableItem($itemElement, true);

      _events_engine.default.triggerHandler($itemElement, 'stateChanged', true);
    }
  },
  _isItemSelected: function _isItemSelected(index) {
    var key = this._getKeyByIndex(index);

    return this._selection.isItemSelected(key, {
      checkPending: true
    });
  },
  _optionChanged: function _optionChanged(args) {
    var _this2 = this;

    switch (args.name) {
      case 'selectionMode':
        this._invalidate();

        break;

      case 'dataSource':
        if (!args.value || Array.isArray(args.value) && !args.value.length) {
          this.option('selectedItemKeys', []);
        }

        this.callBase(args);
        break;

      case 'selectedIndex':
      case 'selectedItem':
      case 'selectedItems':
      case 'selectedItemKeys':
        this._syncSelectionOptions(args.name).done(function () {
          return _this2._normalizeSelectedItems();
        });

        break;

      case 'keyExpr':
        this._initKeyGetter();

        break;

      case 'selectionRequired':
        this._normalizeSelectedItems();

        break;

      case 'selectionByClick':
      case 'onSelectionChanged':
      case 'onItemDeleting':
      case 'onItemDeleted':
      case 'onItemReordered':
      case 'maxFilterLengthInRequest':
        break;

      default:
        this.callBase(args);
    }
  },
  _clearSelectedItems: function _clearSelectedItems() {
    this._setOptionWithoutOptionChange('selectedItems', []);

    this._syncSelectionOptions('selectedItems');
  },
  _waitDeletingPrepare: function _waitDeletingPrepare($itemElement) {
    if ($itemElement.data(ITEM_DELETING_DATA_KEY)) {
      return new _deferred.Deferred().resolve().promise();
    }

    $itemElement.data(ITEM_DELETING_DATA_KEY, true);
    var deferred = new _deferred.Deferred();
    var deletingActionArgs = {
      cancel: false
    };

    var deletePromise = this._itemEventHandler($itemElement, 'onItemDeleting', deletingActionArgs, {
      excludeValidators: ['disabled', 'readOnly']
    });

    (0, _deferred.when)(deletePromise).always(function (value) {
      var deletePromiseExists = !deletePromise;
      var deletePromiseResolved = !deletePromiseExists && deletePromise.state() === 'resolved';
      var argumentsSpecified = !!arguments.length;
      var shouldDelete = deletePromiseExists || deletePromiseResolved && !argumentsSpecified || deletePromiseResolved && value;
      (0, _deferred.when)((0, _deferred.fromPromise)(deletingActionArgs.cancel)).always(function () {
        $itemElement.data(ITEM_DELETING_DATA_KEY, false);
      }).done(function (cancel) {
        shouldDelete && !cancel ? deferred.resolve() : deferred.reject();
      }).fail(deferred.reject);
    }.bind(this));
    return deferred.promise();
  },
  _deleteItemFromDS: function _deleteItemFromDS($item) {
    if (!this._dataSource) {
      return new _deferred.Deferred().resolve().promise();
    }

    var deferred = new _deferred.Deferred();
    var disabledState = this.option('disabled');

    var dataStore = this._dataSource.store();

    this.option('disabled', true);

    if (!dataStore.remove) {
      throw _ui.default.Error('E1011');
    }

    dataStore.remove(dataStore.keyOf(this._getItemData($item))).done(function (key) {
      if (key !== undefined) {
        deferred.resolve();
      } else {
        deferred.reject();
      }
    }).fail(function () {
      deferred.reject();
    });
    deferred.always(function () {
      this.option('disabled', disabledState);
    }.bind(this));
    return deferred;
  },
  _tryRefreshLastPage: function _tryRefreshLastPage() {
    var deferred = new _deferred.Deferred();

    if (this._isLastPage() || this.option('grouped')) {
      deferred.resolve();
    } else {
      this._refreshLastPage().done(function () {
        deferred.resolve();
      });
    }

    return deferred.promise();
  },
  _refreshLastPage: function _refreshLastPage() {
    this._expectLastItemLoading();

    return this._dataSource.load();
  },
  _updateSelectionAfterDelete: function _updateSelectionAfterDelete(index) {
    var key = this._getKeyByIndex(index);

    this._selection.deselect([key]);
  },
  _updateIndicesAfterIndex: function _updateIndicesAfterIndex(index) {
    var itemElements = this._itemElements();

    for (var i = index + 1; i < itemElements.length; i++) {
      (0, _renderer.default)(itemElements[i]).data(this._itemIndexKey(), i - 1);
    }
  },
  _simulateOptionChange: function _simulateOptionChange(optionName) {
    var optionValue = this.option(optionName);

    if (optionValue instanceof _data_source.DataSource) {
      return;
    }

    this._optionChangedAction({
      name: optionName,
      fullName: optionName,
      value: optionValue
    });
  },

  /**
  * @name CollectionWidget.isItemSelected
  * @publicName isItemSelected(itemElement)
  * @param1 itemElement:Element
  * @return boolean
  * @hidden
  */
  isItemSelected: function isItemSelected(itemElement) {
    return this._isItemSelected(this._editStrategy.getNormalizedIndex(itemElement));
  },

  /**
  * @name CollectionWidget.selectItem
  * @publicName selectItem(itemElement)
  * @param1 itemElement:Element
  * @hidden
  */
  selectItem: function selectItem(itemElement) {
    if (this.option('selectionMode') === 'none') return;

    var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);

    if (!indexExists(itemIndex)) {
      return;
    }

    var key = this._getKeyByIndex(itemIndex);

    if (this._selection.isItemSelected(key)) {
      return;
    }

    if (this.option('selectionMode') === 'single') {
      this._selection.setSelection([key]);
    } else {
      var selectedItemKeys = this.option('selectedItemKeys') || [];

      this._selection.setSelection([].concat(_toConsumableArray(selectedItemKeys), [key]));
    }
  },

  /**
  * @name CollectionWidget.unselectItem
  * @publicName unselectItem(itemElement)
  * @param1 itemElement:Element
  * @hidden
  */
  unselectItem: function unselectItem(itemElement) {
    var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);

    if (!indexExists(itemIndex)) {
      return;
    }

    var selectedItemKeys = this._selection.getSelectedItemKeys();

    if (this.option('selectionRequired') && selectedItemKeys.length <= 1) {
      return;
    }

    var key = this._getKeyByIndex(itemIndex);

    if (!this._selection.isItemSelected(key, {
      checkPending: true
    })) {
      return;
    }

    this._selection.deselect([key]);
  },
  _deleteItemElementByIndex: function _deleteItemElementByIndex(index) {
    this._updateSelectionAfterDelete(index);

    this._updateIndicesAfterIndex(index);

    this._editStrategy.deleteItemAtIndex(index);
  },
  _afterItemElementDeleted: function _afterItemElementDeleted($item, deletedActionArgs) {
    var changingOption = this._dataSource ? 'dataSource' : 'items';

    this._simulateOptionChange(changingOption);

    this._itemEventHandler($item, 'onItemDeleted', deletedActionArgs, {
      beforeExecute: function beforeExecute() {
        $item.remove();
      },
      excludeValidators: ['disabled', 'readOnly']
    });

    this._renderEmptyMessage();
  },

  /**
  * @name CollectionWidget.deleteItem
  * @publicName deleteItem(itemElement)
  * @param1 itemElement:Element
  * @return Promise<void>
  * @hidden
  */
  deleteItem: function deleteItem(itemElement) {
    var that = this;
    var deferred = new _deferred.Deferred();

    var $item = this._editStrategy.getItemElement(itemElement);

    var index = this._editStrategy.getNormalizedIndex(itemElement);

    var itemResponseWaitClass = this._itemResponseWaitClass();

    if (indexExists(index)) {
      this._waitDeletingPrepare($item).done(function () {
        $item.addClass(itemResponseWaitClass);

        var deletedActionArgs = that._extendActionArgs($item);

        that._deleteItemFromDS($item).done(function () {
          that._deleteItemElementByIndex(index);

          that._afterItemElementDeleted($item, deletedActionArgs);

          that._tryRefreshLastPage().done(function () {
            deferred.resolveWith(that);
          });
        }).fail(function () {
          $item.removeClass(itemResponseWaitClass);
          deferred.rejectWith(that);
        });
      }).fail(function () {
        deferred.rejectWith(that);
      });
    } else {
      deferred.rejectWith(that);
    }

    return deferred.promise();
  },

  /**
  * @name CollectionWidget.reorderItem
  * @publicName reorderItem(itemElement, toItemElement)
  * @param1 itemElement:Element
  * @param2 toItemElement:Element
  * @return Promise<void>
  * @hidden
  */
  reorderItem: function reorderItem(itemElement, toItemElement) {
    var deferred = new _deferred.Deferred();
    var that = this;
    var strategy = this._editStrategy;
    var $movingItem = strategy.getItemElement(itemElement);
    var $destinationItem = strategy.getItemElement(toItemElement);
    var movingIndex = strategy.getNormalizedIndex(itemElement);
    var destinationIndex = strategy.getNormalizedIndex(toItemElement);
    var changingOption = this._dataSource ? 'dataSource' : 'items';
    var canMoveItems = indexExists(movingIndex) && indexExists(destinationIndex) && movingIndex !== destinationIndex;

    if (canMoveItems) {
      deferred.resolveWith(this);
    } else {
      deferred.rejectWith(this);
    }

    return deferred.promise().done(function () {
      $destinationItem[strategy.itemPlacementFunc(movingIndex, destinationIndex)]($movingItem);
      strategy.moveItemAtIndexToIndex(movingIndex, destinationIndex);

      this._updateIndicesAfterIndex(movingIndex);

      that.option('selectedItems', that._getItemsByKeys(that._selection.getSelectedItemKeys(), that._selection.getSelectedItems()));

      if (changingOption === 'items') {
        that._simulateOptionChange(changingOption);
      }

      that._itemEventHandler($movingItem, 'onItemReordered', {
        fromIndex: strategy.getIndex(movingIndex),
        toIndex: strategy.getIndex(destinationIndex)
      }, {
        excludeValidators: ['disabled', 'readOnly']
      });
    });
  }
});

var _default = CollectionWidget;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.triggerResizeEvent = exports.triggerHidingEvent = exports.triggerShownEvent = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var triggerVisibilityChangeEvent = function triggerVisibilityChangeEvent(eventName) {
  var VISIBILITY_CHANGE_SELECTOR = '.dx-visibility-change-handler';
  return function (element) {
    var $element = (0, _renderer.default)(element || 'body');
    var changeHandlers = $element.filter(VISIBILITY_CHANGE_SELECTOR).add($element.find(VISIBILITY_CHANGE_SELECTOR));

    for (var i = 0; i < changeHandlers.length; i++) {
      _events_engine.default.triggerHandler(changeHandlers[i], eventName);
    }
  };
};

var triggerShownEvent = triggerVisibilityChangeEvent('dxshown');
exports.triggerShownEvent = triggerShownEvent;
var triggerHidingEvent = triggerVisibilityChangeEvent('dxhiding');
exports.triggerHidingEvent = triggerHidingEvent;
var triggerResizeEvent = triggerVisibilityChangeEvent('dxresize');
exports.triggerResizeEvent = triggerResizeEvent;

/***/ }),
/* 60 */,
/* 61 */,
/* 62 */
/***/ (function(module, exports) {

module.exports = window.ko;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _config = _interopRequireDefault(__webpack_require__(29));

var _date = __webpack_require__(253);

var _default_date_names = _interopRequireDefault(__webpack_require__(254));

var _type = __webpack_require__(1);

var _browser = _interopRequireDefault(__webpack_require__(32));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NUMBER_SERIALIZATION_FORMAT = 'number';
var DATE_SERIALIZATION_FORMAT = 'yyyy/MM/dd';
var DATETIME_SERIALIZATION_FORMAT = 'yyyy/MM/dd HH:mm:ss';
var ISO8601_PATTERN = /^(\d{4,})(-)?(\d{2})(-)?(\d{2})(?:T(\d{2})(:)?(\d{2})?(:)?(\d{2}(?:\.(\d{1,3})\d*)?)?)?(Z|([+-])(\d{2})(:)?(\d{2})?)?$/;
var ISO8601_TIME_PATTERN = /^(\d{2}):(\d{2})(:(\d{2}))?$/;
var ISO8601_PATTERN_PARTS = ['', 'yyyy', '', 'MM', '', 'dd', 'THH', '', 'mm', '', 'ss', '.SSS'];
var DATE_SERIALIZATION_PATTERN = /^(\d{4})\/(\d{2})\/(\d{2})$/;
var MILLISECOND_LENGHT = 3;
var isIE11 = _browser.default.msie && parseInt(_browser.default.version) <= 11;

var dateParser = function dateParser(text, skipISO8601Parsing) {
  var result;

  if ((0, _type.isString)(text) && !skipISO8601Parsing) {
    result = parseISO8601String(text);
  }

  return result || parseDate(text);
};

function getTimePart(part) {
  return +part || 0;
}

function parseDate(text) {
  var isDefaultSerializationFormat = getDateSerializationFormat(text) === DATE_SERIALIZATION_FORMAT;
  var parsedValue = !(0, _type.isDate)(text) && Date.parse(text);

  if ((!parsedValue || isIE11) && isDefaultSerializationFormat) {
    var parts = text.match(DATE_SERIALIZATION_PATTERN);

    if (parts) {
      var newDate = new Date(getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[3]));
      newDate.setFullYear(getTimePart(parts[1]));
      newDate.setMonth(getTimePart(parts[2]) - 1);
      newDate.setDate(getTimePart(parts[3]));
      return newDate;
    }
  }

  return (0, _type.isNumeric)(parsedValue) ? new Date(parsedValue) : text;
}

function parseISO8601String(text) {
  var parts = text.match(ISO8601_PATTERN);

  if (!parts) {
    parts = text.match(ISO8601_TIME_PATTERN);

    if (parts) {
      return new Date(0, 0, 0, getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[4]));
    }

    return;
  }

  var year = parts[1];
  var month = --parts[3];
  var day = parts[5];
  var timeZoneHour = 0;
  var timeZoneMinute = 0;
  timeZoneHour = getTimePart(parts[14]);
  timeZoneMinute = getTimePart(parts[16]);

  if (parts[13] === '-') {
    timeZoneHour = -timeZoneHour;
    timeZoneMinute = -timeZoneMinute;
  }

  var hour = getTimePart(parts[6]) - timeZoneHour;
  var minute = getTimePart(parts[8]) - timeZoneMinute;
  var second = getTimePart(parts[10]);

  var parseMilliseconds = function parseMilliseconds(part) {
    part = part || '';
    return getTimePart(part) * Math.pow(10, MILLISECOND_LENGHT - part.length);
  };

  var millisecond = parseMilliseconds(parts[11]);

  if (parts[12]) {
    return new Date(Date.UTC(year, month, day, hour, minute, second, millisecond));
  }

  return new Date(year, month, day, hour, minute, second, millisecond);
}

var getIso8601Format = function getIso8601Format(text, useUtc) {
  var parts = text.match(ISO8601_PATTERN);
  var result = '';

  if (!parts) {
    parts = text.match(ISO8601_TIME_PATTERN);

    if (parts) {
      return parts[3] ? 'HH:mm:ss' : 'HH:mm';
    }

    return;
  }

  for (var i = 1; i < ISO8601_PATTERN_PARTS.length; i++) {
    if (parts[i]) {
      result += ISO8601_PATTERN_PARTS[i] || parts[i];
    }
  }

  if (parts[12] === 'Z') {
    result += '\'Z\'';
  }

  if (parts[14]) {
    if (parts[15]) {
      result += 'xxx';
    } else if (parts[16]) {
      result += 'xx';
    } else {
      result += 'x';
    }
  }

  return result;
};

var deserializeDate = function deserializeDate(value) {
  if (typeof value === 'number') {
    return new Date(value);
  }

  return dateParser(value, !(0, _config.default)().forceIsoDateParsing);
};

var serializeDate = function serializeDate(value, serializationFormat) {
  if (!serializationFormat) {
    return value;
  }

  if (!(0, _type.isDate)(value)) {
    return null;
  }

  if (serializationFormat === NUMBER_SERIALIZATION_FORMAT) {
    return value && value.valueOf ? value.valueOf() : null;
  }

  return (0, _date.getFormatter)(serializationFormat, _default_date_names.default)(value);
};

var getDateSerializationFormat = function getDateSerializationFormat(value) {
  if (typeof value === 'number') {
    return NUMBER_SERIALIZATION_FORMAT;
  } else if ((0, _type.isString)(value)) {
    var format;

    if ((0, _config.default)().forceIsoDateParsing) {
      format = getIso8601Format(value);
    }

    if (format) {
      return format;
    } else if (value.indexOf(':') >= 0) {
      return DATETIME_SERIALIZATION_FORMAT;
    } else {
      return DATE_SERIALIZATION_FORMAT;
    }
  } else if (value) {
    return null;
  }
};

var _default = {
  dateParser: dateParser,
  deserializeDate: deserializeDate,
  serializeDate: serializeDate,
  getDateSerializationFormat: getDateSerializationFormat
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _fx = _interopRequireDefault(__webpack_require__(45));

var _position = _interopRequireDefault(__webpack_require__(83));

var _translator = __webpack_require__(34);

var _component_registrator = _interopRequireDefault(__webpack_require__(9));

var _devices = _interopRequireDefault(__webpack_require__(13));

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _element = __webpack_require__(22);

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _empty_template = __webpack_require__(93);

var _array = __webpack_require__(12);

var _common = __webpack_require__(4);

var _deferred = __webpack_require__(6);

var _dom = __webpack_require__(35);

var _extend = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _math = __webpack_require__(31);

var _ready_callbacks = _interopRequireDefault(__webpack_require__(51));

var _type = __webpack_require__(1);

var _view_port = __webpack_require__(77);

var _window = __webpack_require__(7);

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _drag = __webpack_require__(78);

var _pointer = _interopRequireDefault(__webpack_require__(25));

var _short = __webpack_require__(113);

var _index = __webpack_require__(8);

var _visibility_change = __webpack_require__(59);

var _hide_callback = __webpack_require__(217);

var _resizable = _interopRequireDefault(__webpack_require__(198));

var _selectors = __webpack_require__(67);

var _swatch_container = _interopRequireDefault(__webpack_require__(173));

var _ui = _interopRequireDefault(__webpack_require__(20));

var _browser = _interopRequireDefault(__webpack_require__(32));

var zIndexPool = _interopRequireWildcard(__webpack_require__(283));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var ready = _ready_callbacks.default.add;
var window = (0, _window.getWindow)();
var viewPortChanged = _view_port.changeCallback;
var OVERLAY_CLASS = 'dx-overlay';
var OVERLAY_WRAPPER_CLASS = 'dx-overlay-wrapper';
var OVERLAY_CONTENT_CLASS = 'dx-overlay-content';
var OVERLAY_SHADER_CLASS = 'dx-overlay-shader';
var OVERLAY_MODAL_CLASS = 'dx-overlay-modal';
var INNER_OVERLAY_CLASS = 'dx-inner-overlay';
var INVISIBLE_STATE_CLASS = 'dx-state-invisible';
var ANONYMOUS_TEMPLATE_NAME = 'content';
var RTL_DIRECTION_CLASS = 'dx-rtl';
var ACTIONS = ['onShowing', 'onShown', 'onHiding', 'onHidden', 'onPositioned', 'onResizeStart', 'onResize', 'onResizeEnd'];
var OVERLAY_STACK = [];
var DISABLED_STATE_CLASS = 'dx-state-disabled';
var PREVENT_SAFARI_SCROLLING_CLASS = 'dx-prevent-safari-scrolling';
var TAB_KEY = 'tab';
var POSITION_ALIASES = {
  'top': {
    my: 'top center',
    at: 'top center'
  },
  'bottom': {
    my: 'bottom center',
    at: 'bottom center'
  },
  'right': {
    my: 'right center',
    at: 'right center'
  },
  'left': {
    my: 'left center',
    at: 'left center'
  },
  'center': {
    my: 'center',
    at: 'center'
  },
  'right bottom': {
    my: 'right bottom',
    at: 'right bottom'
  },
  'right top': {
    my: 'right top',
    at: 'right top'
  },
  'left bottom': {
    my: 'left bottom',
    at: 'left bottom'
  },
  'left top': {
    my: 'left top',
    at: 'left top'
  }
};

var getElement = function getElement(value) {
  if ((0, _type.isEvent)(value)) {
    value = value.target;
  }

  return (0, _renderer.default)(value);
};

ready(function () {
  _events_engine.default.subscribeGlobal(_dom_adapter.default.getDocument(), _pointer.default.down, function (e) {
    for (var i = OVERLAY_STACK.length - 1; i >= 0; i--) {
      if (!OVERLAY_STACK[i]._proxiedDocumentDownHandler(e)) {
        return;
      }
    }
  });
});

var Overlay = _ui.default.inherit({
  _supportedKeys: function _supportedKeys() {
    var offsetSize = 5;

    var move = function move(top, left, e) {
      if (!this.option('dragEnabled')) {
        return;
      }

      e.preventDefault();
      e.stopPropagation();

      var allowedOffsets = this._allowedOffsets();

      var offset = {
        top: (0, _math.fitIntoRange)(top, -allowedOffsets.top, allowedOffsets.bottom),
        left: (0, _math.fitIntoRange)(left, -allowedOffsets.left, allowedOffsets.right)
      };

      this._changePosition(offset);
    };

    return (0, _extend.extend)(this.callBase(), {
      escape: function escape() {
        this.hide();
      },
      upArrow: move.bind(this, -offsetSize, 0),
      downArrow: move.bind(this, offsetSize, 0),
      leftArrow: move.bind(this, 0, -offsetSize),
      rightArrow: move.bind(this, 0, offsetSize)
    });
  },
  _getDefaultOptions: function _getDefaultOptions() {
    var _this = this;

    return (0, _extend.extend)(this.callBase(), {
      /**
      * @name dxOverlayOptions.activeStateEnabled
      * @hidden
      */
      activeStateEnabled: false,
      visible: false,
      deferRendering: true,
      shading: true,
      shadingColor: '',
      wrapperAttr: {},
      position: {
        my: 'center',
        at: 'center'
      },
      width: function width() {
        return (0, _renderer.default)(window).width() * 0.8;
      },
      minWidth: null,
      maxWidth: null,
      height: function height() {
        return (0, _renderer.default)(window).height() * 0.8;
      },
      minHeight: null,
      maxHeight: null,
      animation: {
        show: {
          type: 'pop',
          duration: 300,
          from: {
            scale: 0.55
          }
        },
        hide: {
          type: 'pop',
          duration: 300,
          to: {
            opacity: 0,
            scale: 0.55
          },
          from: {
            opacity: 1,
            scale: 1
          }
        }
      },
      closeOnOutsideClick: false,
      onShowing: null,
      onShown: null,
      onHiding: null,
      onHidden: null,
      contentTemplate: 'content',
      dragEnabled: false,
      resizeEnabled: false,
      onResizeStart: null,
      onResize: null,
      onResizeEnd: null,
      innerOverlay: false,
      // NOTE: private options
      target: undefined,
      container: undefined,
      hideTopOverlayHandler: function hideTopOverlayHandler() {
        _this.hide();
      },
      closeOnTargetScroll: false,
      onPositioned: null,
      boundaryOffset: {
        h: 0,
        v: 0
      },
      propagateOutsideClick: false,
      ignoreChildEvents: true,
      _checkParentVisibility: true,
      _fixWrapperPosition: false
    });
  },
  _defaultOptionsRules: function _defaultOptionsRules() {
    return this.callBase().concat([{
      device: function device() {
        return !(0, _window.hasWindow)();
      },
      options: {
        width: null,
        height: null,
        animation: null,
        _checkParentVisibility: false
      }
    }]);
  },
  _setOptionsByReference: function _setOptionsByReference() {
    this.callBase();
    (0, _extend.extend)(this._optionsByReference, {
      animation: true
    });
  },
  $wrapper: function $wrapper() {
    return this._$wrapper;
  },
  _eventBindingTarget: function _eventBindingTarget() {
    return this._$content;
  },
  _setDeprecatedOptions: function _setDeprecatedOptions() {
    this.callBase();
    (0, _extend.extend)(this._deprecatedOptions, {
      'elementAttr': {
        since: '21.2',
        message: 'Use the "wrapperAttr" option instead'
      }
    });
  },
  _init: function _init() {
    this.callBase();

    this._initActions();

    this._initCloseOnOutsideClickHandler();

    this._initTabTerminatorHandler();

    this._$wrapper = (0, _renderer.default)('<div>').addClass(OVERLAY_WRAPPER_CLASS);
    this._$content = (0, _renderer.default)('<div>').addClass(OVERLAY_CONTENT_CLASS);

    this._initInnerOverlayClass();

    var $element = this.$element();

    this._$wrapper.addClass($element.attr('class'));

    $element.addClass(OVERLAY_CLASS);

    this._$wrapper.attr('data-bind', 'dxControlsDescendantBindings: true'); // NOTE: bootstrap integration T342292


    _events_engine.default.on(this._$wrapper, 'focusin', function (e) {
      e.stopPropagation();
    });

    this._toggleViewPortSubscription(true);

    this._initHideTopOverlayHandler(this.option('hideTopOverlayHandler'));
  },
  _initOptions: function _initOptions(options) {
    this._initTarget(options.target);

    var container = options.container === undefined ? this.option('container') : options.container;

    this._initContainer(container);

    this.callBase(options);
  },
  _initInnerOverlayClass: function _initInnerOverlayClass() {
    this._$content.toggleClass(INNER_OVERLAY_CLASS, this.option('innerOverlay'));
  },
  _initTarget: function _initTarget(target) {
    if (!(0, _type.isDefined)(target)) {
      return;
    }

    var options = this.option();
    (0, _iterator.each)(['position.of', 'animation.show.from.position.of', 'animation.show.to.position.of', 'animation.hide.from.position.of', 'animation.hide.to.position.of'], function (_, path) {
      var pathParts = path.split('.');
      var option = options;

      while (option) {
        if (pathParts.length === 1) {
          if ((0, _type.isPlainObject)(option)) {
            option[pathParts.shift()] = target;
          }

          break;
        } else {
          option = option[pathParts.shift()];
        }
      }
    });
  },
  _initContainer: function _initContainer(container) {
    container = container === undefined ? (0, _view_port.value)() : container;
    var $element = this.$element();
    var $container = $element.closest(container);

    if (!$container.length) {
      $container = (0, _renderer.default)(container).first();
    }

    this._$container = $container.length ? $container : $element.parent();
  },
  _initHideTopOverlayHandler: function _initHideTopOverlayHandler(handler) {
    this._hideTopOverlayHandler = handler;
  },
  _initActions: function _initActions() {
    var _this2 = this;

    this._actions = {};
    (0, _iterator.each)(ACTIONS, function (_, action) {
      _this2._actions[action] = _this2._createActionByOption(action, {
        excludeValidators: ['disabled', 'readOnly']
      }) || _common.noop;
    });
  },
  _initCloseOnOutsideClickHandler: function _initCloseOnOutsideClickHandler() {
    var that = this;

    this._proxiedDocumentDownHandler = function () {
      return that._documentDownHandler.apply(that, arguments);
    };
  },
  _initMarkup: function _initMarkup() {
    this.callBase();

    this._renderWrapperAttributes();
  },
  _documentDownHandler: function _documentDownHandler(e) {
    if (this._showAnimationProcessing) {
      this._stopAnimation();
    }

    var closeOnOutsideClick = this.option('closeOnOutsideClick');

    if ((0, _type.isFunction)(closeOnOutsideClick)) {
      closeOnOutsideClick = closeOnOutsideClick(e);
    }

    var $container = this._$content;
    var isAttachedTarget = (0, _renderer.default)(window.document).is(e.target) || (0, _dom.contains)(window.document, e.target);
    var isInnerOverlay = (0, _renderer.default)(e.target).closest('.' + INNER_OVERLAY_CLASS).length;
    var outsideClick = isAttachedTarget && !isInnerOverlay && !($container.is(e.target) || (0, _dom.contains)($container.get(0), e.target));

    if (outsideClick && closeOnOutsideClick) {
      this._outsideClickHandler(e);
    }

    return this.option('propagateOutsideClick');
  },
  _outsideClickHandler: function _outsideClickHandler(e) {
    if (this.option('shading')) {
      e.preventDefault();
    }

    this.hide();
  },
  _getAnonymousTemplateName: function _getAnonymousTemplateName() {
    return ANONYMOUS_TEMPLATE_NAME;
  },
  _initTemplates: function _initTemplates() {
    this._templateManager.addDefaultTemplates({
      content: new _empty_template.EmptyTemplate()
    });

    this.callBase();
  },
  _isTopOverlay: function _isTopOverlay() {
    var overlayStack = this._overlayStack();

    for (var i = overlayStack.length - 1; i >= 0; i--) {
      var tabbableElements = overlayStack[i]._findTabbableBounds();

      if (tabbableElements.first || tabbableElements.last) {
        return overlayStack[i] === this;
      }
    }

    return false;
  },
  _overlayStack: function _overlayStack() {
    return OVERLAY_STACK;
  },
  _zIndexInitValue: function _zIndexInitValue() {
    return Overlay.baseZIndex();
  },
  _toggleViewPortSubscription: function _toggleViewPortSubscription(toggle) {
    viewPortChanged.remove(this._viewPortChangeHandle);

    if (toggle) {
      this._viewPortChangeHandle = this._viewPortChangeHandler.bind(this);
      viewPortChanged.add(this._viewPortChangeHandle);
    }
  },
  _viewPortChangeHandler: function _viewPortChangeHandler() {
    this._initContainer(this.option('container'));

    this._refresh();
  },
  _renderWrapperAttributes: function _renderWrapperAttributes() {
    var _this$option = this.option(),
        wrapperAttr = _this$option.wrapperAttr;

    this._$wrapper.attr(wrapperAttr !== null && wrapperAttr !== void 0 ? wrapperAttr : {});
  },
  _renderVisibilityAnimate: function _renderVisibilityAnimate(visible) {
    this._stopAnimation();

    return visible ? this._show() : this._hide();
  },
  _normalizePosition: function _normalizePosition() {
    var position = this.option('position');
    this._position = typeof position === 'function' ? position() : position;
  },
  _getAnimationConfig: function _getAnimationConfig() {
    var animation = this.option('animation');
    if ((0, _type.isFunction)(animation)) animation = animation.call(this);
    return animation;
  },
  _show: function _show() {
    var _this3 = this;

    var that = this;
    var deferred = new _deferred.Deferred();
    this._parentHidden = this._isParentHidden();
    deferred.done(function () {
      delete that._parentHidden;
    });

    if (this._parentHidden) {
      this._isHidden = true;
      return deferred.resolve();
    }

    if (this._currentVisible) {
      return new _deferred.Deferred().resolve().promise();
    }

    this._currentVisible = true;
    this._isShown = false;

    this._normalizePosition();

    var animation = that._getAnimationConfig() || {};

    var showAnimation = this._normalizeAnimation(animation.show, 'to');

    var startShowAnimation = showAnimation && showAnimation.start || _common.noop;
    var completeShowAnimation = showAnimation && showAnimation.complete || _common.noop;

    if (this._isHidingActionCanceled) {
      delete this._isHidingActionCanceled;
      deferred.resolve();
    } else {
      var show = function show() {
        _this3._renderVisibility(true);

        if (_this3._isShowingActionCanceled) {
          delete _this3._isShowingActionCanceled;
          deferred.resolve();
          return;
        }

        _this3._animate(showAnimation, function () {
          if (that.option('focusStateEnabled')) {
            _events_engine.default.trigger(that._focusTarget(), 'focus');
          }

          completeShowAnimation.apply(this, arguments);
          that._showAnimationProcessing = false;
          that._isShown = true;

          that._actions.onShown();

          that._toggleSafariScrolling();

          deferred.resolve();
        }, function () {
          startShowAnimation.apply(this, arguments);
          that._showAnimationProcessing = true;
        });
      };

      if (this.option('templatesRenderAsynchronously')) {
        this._stopShowTimer();

        this._asyncShowTimeout = setTimeout(show);
      } else {
        show();
      }
    }

    return deferred.promise();
  },
  _normalizeAnimation: function _normalizeAnimation(animation, prop) {
    if (animation) {
      animation = (0, _extend.extend)({
        type: 'slide'
      }, animation);

      if (animation[prop] && _typeof(animation[prop]) === 'object') {
        (0, _extend.extend)(animation[prop], {
          position: this._position
        });
      }
    }

    return animation;
  },
  _hide: function _hide() {
    if (!this._currentVisible) {
      return new _deferred.Deferred().resolve().promise();
    }

    this._currentVisible = false;
    var that = this;
    var deferred = new _deferred.Deferred();
    var animation = that._getAnimationConfig() || {};

    var hideAnimation = this._normalizeAnimation(animation.hide, 'from');

    var startHideAnimation = hideAnimation && hideAnimation.start || _common.noop;
    var completeHideAnimation = hideAnimation && hideAnimation.complete || _common.noop;
    var hidingArgs = {
      cancel: false
    };

    if (this._isShowingActionCanceled) {
      deferred.resolve();
    } else {
      this._actions.onHiding(hidingArgs);

      that._toggleSafariScrolling();

      if (hidingArgs.cancel) {
        this._isHidingActionCanceled = true;
        this.option('visible', true);
        deferred.resolve();
      } else {
        this._forceFocusLost();

        this._toggleShading(false);

        this._toggleSubscriptions(false);

        this._stopShowTimer();

        this._animate(hideAnimation, function () {
          var _that$_actions;

          that._$content.css('pointerEvents', '');

          that._renderVisibility(false);

          completeHideAnimation.apply(this, arguments);
          that._hideAnimationProcessing = false;
          (_that$_actions = that._actions) === null || _that$_actions === void 0 ? void 0 : _that$_actions.onHidden();
          deferred.resolve();
        }, function () {
          that._$content.css('pointerEvents', 'none');

          startHideAnimation.apply(this, arguments);
          that._hideAnimationProcessing = true;
        });
      }
    }

    return deferred.promise();
  },
  _forceFocusLost: function _forceFocusLost() {
    var activeElement = _dom_adapter.default.getActiveElement();

    var shouldResetActiveElement = !!this._$content.find(activeElement).length;

    if (shouldResetActiveElement) {
      (0, _dom.resetActiveElement)();
    }
  },
  _animate: function _animate(animation, completeCallback, startCallback) {
    if (animation) {
      startCallback = startCallback || animation.start || _common.noop;

      _fx.default.animate(this._$content, (0, _extend.extend)({}, animation, {
        start: startCallback,
        complete: completeCallback
      }));
    } else {
      completeCallback();
    }
  },
  _stopAnimation: function _stopAnimation() {
    _fx.default.stop(this._$content, true);
  },
  _renderVisibility: function _renderVisibility(visible) {
    if (visible && this._isParentHidden()) {
      return;
    }

    this._currentVisible = visible;

    this._stopAnimation();

    if (!visible) {
      (0, _visibility_change.triggerHidingEvent)(this._$content);
    }

    this._toggleVisibility(visible);

    this._$content.toggleClass(INVISIBLE_STATE_CLASS, !visible);

    this._updateZIndexStackPosition(visible);

    if (visible) {
      this._renderContent();

      var showingArgs = {
        cancel: false
      };

      this._actions.onShowing(showingArgs);

      if (showingArgs.cancel) {
        this._toggleVisibility(false);

        this._$content.toggleClass(INVISIBLE_STATE_CLASS, true);

        this._updateZIndexStackPosition(false);

        this._moveFromContainer();

        this._isShowingActionCanceled = true;
        this.option('visible', false);
        return;
      }

      this._moveToContainer();

      this._renderGeometry();

      (0, _visibility_change.triggerShownEvent)(this._$content);
      (0, _visibility_change.triggerResizeEvent)(this._$content);
    } else {
      this._moveFromContainer();
    }

    this._toggleShading(visible);

    this._toggleSubscriptions(visible);
  },
  _updateZIndexStackPosition: function _updateZIndexStackPosition(pushToStack) {
    var overlayStack = this._overlayStack();

    var index = (0, _array.inArray)(this, overlayStack);

    if (pushToStack) {
      if (index === -1) {
        this._zIndex = zIndexPool.create(this._zIndexInitValue());
        overlayStack.push(this);
      }

      this._$wrapper.css('zIndex', this._zIndex);

      this._$content.css('zIndex', this._zIndex);
    } else if (index !== -1) {
      overlayStack.splice(index, 1);
      zIndexPool.remove(this._zIndex);
    }
  },
  _toggleShading: function _toggleShading(visible) {
    this._$wrapper.toggleClass(OVERLAY_MODAL_CLASS, this.option('shading') && !this.option('container'));

    this._$wrapper.toggleClass(OVERLAY_SHADER_CLASS, visible && this.option('shading'));

    this._$wrapper.css('backgroundColor', this.option('shading') ? this.option('shadingColor') : '');

    this._toggleTabTerminator(visible && this.option('shading'));
  },
  _initTabTerminatorHandler: function _initTabTerminatorHandler() {
    var that = this;

    this._proxiedTabTerminatorHandler = function () {
      that._tabKeyHandler.apply(that, arguments);
    };
  },
  _toggleTabTerminator: function _toggleTabTerminator(enabled) {
    var eventName = (0, _index.addNamespace)('keydown', this.NAME);

    if (enabled) {
      _events_engine.default.on(_dom_adapter.default.getDocument(), eventName, this._proxiedTabTerminatorHandler);
    } else {
      _events_engine.default.off(_dom_adapter.default.getDocument(), eventName, this._proxiedTabTerminatorHandler);
    }
  },
  _findTabbableBounds: function _findTabbableBounds() {
    var $elements = this._$wrapper.find('*');

    var elementsCount = $elements.length - 1;
    var result = {
      first: null,
      last: null
    };

    for (var i = 0; i <= elementsCount; i++) {
      if (!result.first && $elements.eq(i).is(_selectors.tabbable)) {
        result.first = $elements.eq(i);
      }

      if (!result.last && $elements.eq(elementsCount - i).is(_selectors.tabbable)) {
        result.last = $elements.eq(elementsCount - i);
      }

      if (result.first && result.last) {
        break;
      }
    }

    return result;
  },
  _tabKeyHandler: function _tabKeyHandler(e) {
    if ((0, _index.normalizeKeyName)(e) !== TAB_KEY || !this._isTopOverlay()) {
      return;
    }

    var tabbableElements = this._findTabbableBounds();

    var $firstTabbable = tabbableElements.first;
    var $lastTabbable = tabbableElements.last;
    var isTabOnLast = !e.shiftKey && e.target === $lastTabbable.get(0);
    var isShiftTabOnFirst = e.shiftKey && e.target === $firstTabbable.get(0);
    var isEmptyTabList = tabbableElements.length === 0;
    var isOutsideTarget = !(0, _dom.contains)(this._$wrapper.get(0), e.target);

    if (isTabOnLast || isShiftTabOnFirst || isEmptyTabList || isOutsideTarget) {
      e.preventDefault();
      var $focusElement = e.shiftKey ? $lastTabbable : $firstTabbable;

      _events_engine.default.trigger($focusElement, 'focusin');

      _events_engine.default.trigger($focusElement, 'focus');
    }
  },
  _toggleSubscriptions: function _toggleSubscriptions(enabled) {
    if ((0, _window.hasWindow)()) {
      this._toggleHideTopOverlayCallback(enabled);

      this._toggleParentsScrollSubscription(enabled);
    }
  },
  _toggleHideTopOverlayCallback: function _toggleHideTopOverlayCallback(subscribe) {
    if (!this._hideTopOverlayHandler) {
      return;
    }

    if (subscribe) {
      _hide_callback.hideCallback.add(this._hideTopOverlayHandler);
    } else {
      _hide_callback.hideCallback.remove(this._hideTopOverlayHandler);
    }
  },
  _toggleParentsScrollSubscription: function _toggleParentsScrollSubscription(subscribe) {
    var _this4 = this;

    if (!this._position) {
      return;
    }

    var target = this._position.of || (0, _renderer.default)();
    var closeOnScroll = this.option('closeOnTargetScroll');
    var $parents = getElement(target).parents();
    var scrollEvent = (0, _index.addNamespace)('scroll', this.NAME);

    if (_devices.default.real().deviceType === 'desktop') {
      $parents = $parents.add(window);
    }

    this._proxiedTargetParentsScrollHandler = this._proxiedTargetParentsScrollHandler || function (e) {
      _this4._targetParentsScrollHandler(e);
    };

    _events_engine.default.off((0, _renderer.default)().add(this._$prevTargetParents), scrollEvent, this._proxiedTargetParentsScrollHandler);

    if (subscribe && closeOnScroll) {
      _events_engine.default.on($parents, scrollEvent, this._proxiedTargetParentsScrollHandler);

      this._$prevTargetParents = $parents;
    }
  },
  _targetParentsScrollHandler: function _targetParentsScrollHandler(e) {
    var closeHandled = false;
    var closeOnScroll = this.option('closeOnTargetScroll');

    if ((0, _type.isFunction)(closeOnScroll)) {
      closeHandled = closeOnScroll(e);
    }

    if (!closeHandled && !this._showAnimationProcessing) {
      this.hide();
    }
  },
  _render: function _render() {
    this.callBase();

    this._appendContentToElement();

    this._renderVisibilityAnimate(this.option('visible'));
  },
  _appendContentToElement: function _appendContentToElement() {
    if (!this._$content.parent().is(this.$element())) {
      this._$content.appendTo(this.$element());
    }
  },
  _renderContent: function _renderContent() {
    var shouldDeferRendering = !this._currentVisible && this.option('deferRendering');

    var isParentHidden = this.option('visible') && this._isParentHidden();

    if (isParentHidden) {
      this._isHidden = true;
      return;
    }

    if (this._contentAlreadyRendered || shouldDeferRendering) {
      return;
    }

    this._contentAlreadyRendered = true;

    this._appendContentToElement();

    this.callBase();
  },
  _isParentHidden: function _isParentHidden() {
    if (!this.option('_checkParentVisibility')) {
      return false;
    }

    if (this._parentHidden !== undefined) {
      return this._parentHidden;
    }

    var $parent = this.$element().parent();

    if ($parent.is(':visible')) {
      return false;
    }

    var isHidden = false;
    $parent.add($parent.parents()).each(function () {
      var $element = (0, _renderer.default)(this);

      if ($element.css('display') === 'none') {
        isHidden = true;
        return false;
      }
    });
    return isHidden || !_dom_adapter.default.getBody().contains($parent.get(0));
  },
  _renderContentImpl: function _renderContentImpl() {
    var _this5 = this;

    var whenContentRendered = new _deferred.Deferred();
    var contentTemplateOption = this.option('contentTemplate');

    var contentTemplate = this._getTemplate(contentTemplateOption);

    var transclude = this._templateManager.anonymousTemplateName === contentTemplateOption;
    contentTemplate && contentTemplate.render({
      container: (0, _element.getPublicElement)(this.$content()),
      noModel: true,
      transclude: transclude,
      onRendered: function onRendered() {
        whenContentRendered.resolve();
      }
    });

    this._renderDrag();

    this._renderResize();

    this._renderScrollTerminator();

    whenContentRendered.done(function () {
      if (_this5.option('visible')) {
        _this5._moveToContainer();
      }
    });
    return whenContentRendered.promise();
  },
  _renderDrag: function _renderDrag() {
    var $dragTarget = this._getDragTarget();

    if (!$dragTarget) {
      return;
    }

    var startEventName = (0, _index.addNamespace)(_drag.start, this.NAME);
    var updateEventName = (0, _index.addNamespace)(_drag.move, this.NAME);

    _events_engine.default.off($dragTarget, startEventName);

    _events_engine.default.off($dragTarget, updateEventName);

    if (!this.option('dragEnabled')) {
      return;
    }

    _events_engine.default.on($dragTarget, startEventName, this._dragStartHandler.bind(this));

    _events_engine.default.on($dragTarget, updateEventName, this._dragUpdateHandler.bind(this));
  },
  _renderResize: function _renderResize() {
    this._resizable = this._createComponent(this._$content, _resizable.default, {
      handles: this.option('resizeEnabled') ? 'all' : 'none',
      onResizeEnd: this._resizeEndHandler.bind(this),
      onResize: this._actions.onResize.bind(this),
      onResizeStart: this._actions.onResizeStart.bind(this),
      minHeight: 100,
      minWidth: 100,
      area: this._getDragResizeContainer()
    });
  },
  _resizeEndHandler: function _resizeEndHandler() {
    this._positionChangeHandled = true;

    var width = this._resizable.option('width');

    var height = this._resizable.option('height');

    width && this.option('width', width);
    height && this.option('height', height);

    this._actions.onResizeEnd();
  },
  _renderScrollTerminator: function _renderScrollTerminator() {
    var $scrollTerminator = this._$wrapper;
    var terminatorEventName = (0, _index.addNamespace)(_drag.move, this.NAME);

    _events_engine.default.off($scrollTerminator, terminatorEventName);

    _events_engine.default.on($scrollTerminator, terminatorEventName, {
      validate: function validate() {
        return true;
      },
      getDirection: function getDirection() {
        return 'both';
      },
      _toggleGestureCover: function _toggleGestureCover(toggle) {
        if (!toggle) {
          this._toggleGestureCoverImpl(toggle);
        }
      },
      _clearSelection: _common.noop,
      isNative: true
    }, function (e) {
      var originalEvent = e.originalEvent.originalEvent;

      var _ref = originalEvent || {},
          type = _ref.type;

      var isWheel = type === 'wheel';
      var isMouseMove = type === 'mousemove';
      var isScrollByWheel = isWheel && !(0, _index.isCommandKeyPressed)(e);
      e._cancelPreventDefault = true;

      if (originalEvent && e.cancelable !== false && (!isMouseMove && !isWheel || isScrollByWheel)) {
        e.preventDefault();
      }
    });
  },
  _getDragTarget: function _getDragTarget() {
    return this.$content();
  },
  _dragStartHandler: function _dragStartHandler(e) {
    e.targetElements = [];
    this._prevOffset = {
      x: 0,
      y: 0
    };

    var allowedOffsets = this._allowedOffsets();

    e.maxTopOffset = allowedOffsets.top;
    e.maxBottomOffset = allowedOffsets.bottom;
    e.maxLeftOffset = allowedOffsets.left;
    e.maxRightOffset = allowedOffsets.right;
  },
  _getDragResizeContainer: function _getDragResizeContainer() {
    var isContainerDefined = (0, _view_port.originalViewPort)().get(0) || this.option('container');
    var $container = !isContainerDefined ? (0, _renderer.default)(window) : this._$container;
    return $container;
  },
  _deltaSize: function _deltaSize() {
    var $content = this._$content;

    var $container = this._getDragResizeContainer();

    var contentWidth = $content.outerWidth();
    var contentHeight = $content.outerHeight();
    var containerWidth = $container.outerWidth();
    var containerHeight = $container.outerHeight();

    if (this._isWindow($container)) {
      var document = _dom_adapter.default.getDocument();

      var fullPageHeight = Math.max((0, _renderer.default)(document).outerHeight(), containerHeight);
      var fullPageWidth = Math.max((0, _renderer.default)(document).outerWidth(), containerWidth);
      containerHeight = fullPageHeight;
      containerWidth = fullPageWidth;
    }

    return {
      width: containerWidth - contentWidth,
      height: containerHeight - contentHeight
    };
  },
  _dragUpdateHandler: function _dragUpdateHandler(e) {
    var offset = e.offset;
    var prevOffset = this._prevOffset;
    var targetOffset = {
      top: offset.y - prevOffset.y,
      left: offset.x - prevOffset.x
    };

    this._changePosition(targetOffset);

    this._prevOffset = offset;
  },
  _changePosition: function _changePosition(offset) {
    var position = (0, _translator.locate)(this._$content);
    (0, _translator.move)(this._$content, {
      left: position.left + offset.left,
      top: position.top + offset.top
    });
    this._positionChangeHandled = true;
  },
  _allowedOffsets: function _allowedOffsets() {
    var position = (0, _translator.locate)(this._$content);

    var deltaSize = this._deltaSize();

    var isAllowedDrag = deltaSize.height >= 0 && deltaSize.width >= 0;
    var shaderOffset = this.option('shading') && !this.option('container') && !this._isContainerWindow() ? (0, _translator.locate)(this._$wrapper) : {
      top: 0,
      left: 0
    };
    var boundaryOffset = this.option('boundaryOffset');
    return {
      top: isAllowedDrag ? position.top + shaderOffset.top + boundaryOffset.v : 0,
      bottom: isAllowedDrag ? -position.top - shaderOffset.top + deltaSize.height - boundaryOffset.v : 0,
      left: isAllowedDrag ? position.left + shaderOffset.left + boundaryOffset.h : 0,
      right: isAllowedDrag ? -position.left - shaderOffset.left + deltaSize.width - boundaryOffset.h : 0
    };
  },
  _moveFromContainer: function _moveFromContainer() {
    this._$content.appendTo(this.$element());

    this._detachWrapperToContainer();
  },
  _detachWrapperToContainer: function _detachWrapperToContainer() {
    this._$wrapper.detach();
  },
  _moveToContainer: function _moveToContainer() {
    this._attachWrapperToContainer();

    this._$content.appendTo(this._$wrapper);
  },
  _attachWrapperToContainer: function _attachWrapperToContainer() {
    var $element = this.$element();
    var containerDefined = this.option('container') !== undefined;
    var renderContainer = containerDefined ? this._$container : _swatch_container.default.getSwatchContainer($element);

    if (renderContainer && renderContainer[0] === $element.parent()[0]) {
      renderContainer = $element;
    }

    this._$wrapper.appendTo(renderContainer);
  },
  _renderGeometry: function _renderGeometry(isDimensionChanged) {
    if (this.option('visible') && (0, _window.hasWindow)()) {
      this._renderGeometryImpl(isDimensionChanged);
    }
  },
  _renderGeometryImpl: function _renderGeometryImpl(isDimensionChanged) {
    this._stopAnimation();

    this._normalizePosition();

    this._renderWrapper();

    this._renderDimensions();

    var resultPosition = this._renderPosition();

    this._actions.onPositioned({
      position: resultPosition
    });
  },
  _styleWrapperPosition: function _styleWrapperPosition() {
    var useFixed = this._isContainerWindow() || this.option('_fixWrapperPosition');
    var positionStyle = useFixed ? 'fixed' : 'absolute';

    this._$wrapper.css('position', positionStyle);
  },
  _isContainerWindow: function _isContainerWindow() {
    var $container = this._getContainer();

    return this._isWindow($container) || !($container !== null && $container !== void 0 && $container.get(0));
  },
  _isAllWindowCovered: function _isAllWindowCovered() {
    return this._isContainerWindow() && this.option('shading');
  },
  _toggleSafariScrolling: function _toggleSafariScrolling() {
    var visible = this.option('visible');
    var $body = (0, _renderer.default)(_dom_adapter.default.getBody());

    var isIosSafari = _devices.default.real().platform === 'ios' && _browser.default.safari;

    var isAllWindowCovered = this._isAllWindowCovered();

    var isScrollingPrevented = $body.hasClass(PREVENT_SAFARI_SCROLLING_CLASS);
    var shouldPreventScrolling = !isScrollingPrevented && visible && isAllWindowCovered;
    var shouldEnableScrolling = isScrollingPrevented && (!visible || !isAllWindowCovered || this._disposed);

    if (isIosSafari) {
      if (shouldEnableScrolling) {
        $body.removeClass(PREVENT_SAFARI_SCROLLING_CLASS);
        window.scrollTo(0, this._cachedBodyScrollTop);
        this._cachedBodyScrollTop = undefined;
      } else if (shouldPreventScrolling) {
        this._cachedBodyScrollTop = window.pageYOffset;
        $body.addClass(PREVENT_SAFARI_SCROLLING_CLASS);
      }
    }
  },
  _renderWrapper: function _renderWrapper() {
    this._styleWrapperPosition();

    this._renderWrapperDimensions();

    this._renderWrapperPosition();
  },
  _renderWrapperDimensions: function _renderWrapperDimensions() {
    var wrapperWidth;
    var wrapperHeight;

    var $container = this._getContainer();

    if (!$container) {
      return;
    }

    var isWindow = this._isWindow($container);

    var documentElement = _dom_adapter.default.getDocumentElement();

    wrapperWidth = isWindow ? documentElement.clientWidth : $container.outerWidth(), wrapperHeight = isWindow ? window.innerHeight : $container.outerHeight();

    this._$wrapper.css({
      width: wrapperWidth,
      height: wrapperHeight
    });
  },
  _isWindow: function _isWindow($element) {
    return !!$element && (0, _type.isWindow)($element.get(0));
  },
  _renderWrapperPosition: function _renderWrapperPosition() {
    var $container = this._getContainer();

    if ($container) {
      _position.default.setup(this._$wrapper, {
        my: 'top left',
        at: 'top left',
        of: $container
      });
    }
  },
  _getContainer: function _getContainer() {
    var position = this._position;
    var container = this.option('container');
    var positionOf = null;

    if (!container && position) {
      positionOf = (0, _type.isEvent)(position.of) ? window : position.of || window;
    }

    return getElement(container || positionOf);
  },
  _renderDimensions: function _renderDimensions() {
    var content = this._$content.get(0);

    this._$content.css({
      minWidth: this._getOptionValue('minWidth', content),
      maxWidth: this._getOptionValue('maxWidth', content),
      minHeight: this._getOptionValue('minHeight', content),
      maxHeight: this._getOptionValue('maxHeight', content),
      width: this._getOptionValue('width', content),
      height: this._getOptionValue('height', content)
    });
  },
  _renderPosition: function _renderPosition() {
    if (this._positionChangeHandled) {
      var allowedOffsets = this._allowedOffsets();

      this._changePosition({
        top: (0, _math.fitIntoRange)(0, -allowedOffsets.top, allowedOffsets.bottom),
        left: (0, _math.fitIntoRange)(0, -allowedOffsets.left, allowedOffsets.right)
      });
    } else {
      this._renderOverlayBoundaryOffset();

      (0, _translator.resetPosition)(this._$content);

      var position = this._transformStringPosition(this._position, POSITION_ALIASES);

      var resultPosition = _position.default.setup(this._$content, position);

      return resultPosition;
    }
  },
  _transformStringPosition: function _transformStringPosition(position, positionAliases) {
    if ((0, _type.isString)(position)) {
      position = (0, _extend.extend)({}, positionAliases[position]);
    }

    return position;
  },
  _renderOverlayBoundaryOffset: function _renderOverlayBoundaryOffset() {
    var boundaryOffset = this.option('boundaryOffset');

    this._$content.css('margin', boundaryOffset.v + 'px ' + boundaryOffset.h + 'px');
  },
  _focusTarget: function _focusTarget() {
    return this._$content;
  },
  _attachKeyboardEvents: function _attachKeyboardEvents() {
    var _this6 = this;

    this._keyboardListenerId = _short.keyboard.on(this._$content, null, function (opts) {
      return _this6._keyboardHandler(opts);
    });
  },
  _keyboardHandler: function _keyboardHandler(options) {
    var e = options.originalEvent;
    var $target = (0, _renderer.default)(e.target);

    if ($target.is(this._$content) || !this.option('ignoreChildEvents')) {
      this.callBase.apply(this, arguments);
    }
  },
  _isVisible: function _isVisible() {
    return this.option('visible');
  },
  _visibilityChanged: function _visibilityChanged(visible) {
    if (visible) {
      if (this.option('visible')) {
        this._renderVisibilityAnimate(visible);
      }
    } else {
      this._renderVisibilityAnimate(visible);
    }
  },
  _dimensionChanged: function _dimensionChanged() {
    this._renderGeometry(true);
  },
  _clean: function _clean() {
    if (!this._contentAlreadyRendered) {
      this.$content().empty();
    }

    this._renderVisibility(false);

    this._stopShowTimer();

    this._cleanFocusState();
  },
  _stopShowTimer: function _stopShowTimer() {
    if (this._asyncShowTimeout) {
      clearTimeout(this._asyncShowTimeout);
    }

    this._asyncShowTimeout = null;
  },
  _dispose: function _dispose() {
    _fx.default.stop(this._$content, false);

    clearTimeout(this._deferShowTimer);

    this._toggleViewPortSubscription(false);

    this._toggleSubscriptions(false);

    this._updateZIndexStackPosition(false);

    this._toggleTabTerminator(false);

    this._actions = null;
    this.callBase();

    this._toggleSafariScrolling();

    zIndexPool.remove(this._zIndex);

    this._$wrapper.remove();

    this._$content.remove();
  },
  _toggleDisabledState: function _toggleDisabledState(value) {
    this.callBase.apply(this, arguments);

    this._$content.toggleClass(DISABLED_STATE_CLASS, Boolean(value));
  },
  _toggleRTLDirection: function _toggleRTLDirection(rtl) {
    this._$content.toggleClass(RTL_DIRECTION_CLASS, rtl);
  },
  _optionChanged: function _optionChanged(args) {
    var _this7 = this;

    var value = args.value;

    if ((0, _array.inArray)(args.name, ACTIONS) > -1) {
      this._initActions();

      return;
    }

    switch (args.name) {
      case 'dragEnabled':
        this._renderDrag();

        this._renderGeometry();

        break;

      case 'resizeEnabled':
        this._renderResize();

        this._renderGeometry();

        break;

      case 'shading':
        this._toggleShading(this.option('visible'));

        this._toggleSafariScrolling();

        break;

      case 'shadingColor':
        this._toggleShading(this.option('visible'));

        break;

      case 'width':
      case 'height':
      case 'minWidth':
      case 'maxWidth':
      case 'minHeight':
      case 'maxHeight':
      case 'boundaryOffset':
        this._renderGeometry();

        break;

      case 'position':
        this._positionChangeHandled = false;

        this._renderGeometry();

        this._toggleSafariScrolling();

        break;

      case 'visible':
        this._renderVisibilityAnimate(value).done(function () {
          if (!_this7._animateDeferred) {
            return;
          }

          _this7._animateDeferred.resolveWith(_this7);
        });

        break;

      case 'target':
        this._initTarget(value);

        this._invalidate();

        break;

      case 'container':
        this._initContainer(value);

        this._invalidate();

        this._toggleSafariScrolling();

        break;

      case 'innerOverlay':
        this._initInnerOverlayClass();

        break;

      case 'deferRendering':
      case 'contentTemplate':
        this._contentAlreadyRendered = false;

        this._clean();

        this._invalidate();

        break;

      case 'hideTopOverlayHandler':
        this._toggleHideTopOverlayCallback(false);

        this._initHideTopOverlayHandler(args.value);

        this._toggleHideTopOverlayCallback(this.option('visible'));

        break;

      case 'closeOnTargetScroll':
        this._toggleParentsScrollSubscription(this.option('visible'));

        break;

      case 'closeOnOutsideClick':
      case 'animation':
      case 'propagateOutsideClick':
        break;

      case 'rtlEnabled':
        this._contentAlreadyRendered = false;
        this.callBase(args);
        break;

      case '_fixWrapperPosition':
        this._styleWrapperPosition();

        break;

      case 'wrapperAttr':
        this._renderWrapperAttributes();

        break;

      default:
        this.callBase(args);
    }
  },
  toggle: function toggle(showing) {
    var _this8 = this;

    showing = showing === undefined ? !this.option('visible') : showing;
    var result = new _deferred.Deferred();

    if (showing === this.option('visible')) {
      return result.resolveWith(this, [showing]).promise();
    }

    var animateDeferred = new _deferred.Deferred();
    this._animateDeferred = animateDeferred;
    this.option('visible', showing);
    animateDeferred.promise().done(function () {
      delete _this8._animateDeferred;
      result.resolveWith(_this8, [_this8.option('visible')]);
    });
    return result.promise();
  },
  $content: function $content() {
    return this._$content;
  },
  show: function show() {
    return this.toggle(true);
  },
  hide: function hide() {
    return this.toggle(false);
  },
  content: function content() {
    return (0, _element.getPublicElement)(this._$content);
  },
  repaint: function repaint() {
    if (this._contentAlreadyRendered) {
      this._renderGeometry();

      (0, _visibility_change.triggerResizeEvent)(this._$content);
    } else {
      this.callBase();
    }
  }
});
/**
* @name ui.dxOverlay
* @section utils
*/


Overlay.baseZIndex = function (zIndex) {
  return zIndexPool.base(zIndex);
};

(0, _component_registrator.default)('dxOverlay', Overlay);
var _default = Overlay;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.normalizeDataSourceOptions = exports.normalizeLoadResult = exports.mapDataRespectingGrouping = exports.normalizeStoreLoadOptionAccessorArguments = exports.isPending = exports.CANCELED_TOKEN = void 0;

var _ajax = _interopRequireDefault(__webpack_require__(80));

var _abstract_store = _interopRequireDefault(__webpack_require__(106));

var _array_store = _interopRequireDefault(__webpack_require__(84));

var _iterator = __webpack_require__(3);

var _custom_store = _interopRequireDefault(__webpack_require__(129));

var _extend = __webpack_require__(0);

var _type = __webpack_require__(1);

var _utils = _interopRequireDefault(__webpack_require__(44));

var _excluded = ["items"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var CANCELED_TOKEN = 'canceled';
exports.CANCELED_TOKEN = CANCELED_TOKEN;

var isPending = function isPending(deferred) {
  return deferred.state() === 'pending';
};

exports.isPending = isPending;

var normalizeStoreLoadOptionAccessorArguments = function normalizeStoreLoadOptionAccessorArguments(originalArguments) {
  switch (originalArguments.length) {
    case 0:
      return undefined;

    case 1:
      return originalArguments[0];
  }

  return [].slice.call(originalArguments);
};

exports.normalizeStoreLoadOptionAccessorArguments = normalizeStoreLoadOptionAccessorArguments;

var mapGroup = function mapGroup(group, level, mapper) {
  return (0, _iterator.map)(group, function (item) {
    var items = item.items,
        restItem = _objectWithoutProperties(item, _excluded);

    return _extends({}, restItem, {
      items: mapRecursive(item.items, level - 1, mapper)
    });
  });
};

var mapRecursive = function mapRecursive(items, level, mapper) {
  if (!Array.isArray(items)) return items;
  return level ? mapGroup(items, level, mapper) : (0, _iterator.map)(items, mapper);
};

var mapDataRespectingGrouping = function mapDataRespectingGrouping(items, mapper, groupInfo) {
  var level = groupInfo ? _utils.default.normalizeSortingInfo(groupInfo).length : 0;
  return mapRecursive(items, level, mapper);
};

exports.mapDataRespectingGrouping = mapDataRespectingGrouping;

var normalizeLoadResult = function normalizeLoadResult(data, extra) {
  var _data;

  if ((_data = data) !== null && _data !== void 0 && _data.data) {
    extra = data;
    data = data.data;
  }

  if (!Array.isArray(data)) {
    data = [data];
  }

  return {
    data: data,
    extra: extra
  };
};

exports.normalizeLoadResult = normalizeLoadResult;

var createCustomStoreFromLoadFunc = function createCustomStoreFromLoadFunc(options) {
  var storeConfig = {};
  (0, _iterator.each)(['useDefaultSearch', 'key', 'load', 'loadMode', 'cacheRawData', 'byKey', 'lookup', 'totalCount', 'insert', 'update', 'remove'], function () {
    storeConfig[this] = options[this];
    delete options[this];
  });
  return new _custom_store.default(storeConfig);
};

var createStoreFromConfig = function createStoreFromConfig(storeConfig) {
  var alias = storeConfig.type;
  delete storeConfig.type;
  return _abstract_store.default.create(alias, storeConfig);
};

var createCustomStoreFromUrl = function createCustomStoreFromUrl(url, normalizationOptions) {
  return new _custom_store.default({
    load: function load() {
      return _ajax.default.sendRequest({
        url: url,
        dataType: 'json'
      });
    },
    loadMode: normalizationOptions === null || normalizationOptions === void 0 ? void 0 : normalizationOptions.fromUrlLoadMode
  });
};

var normalizeDataSourceOptions = function normalizeDataSourceOptions(options, normalizationOptions) {
  var store;

  if (typeof options === 'string') {
    options = {
      paginate: false,
      store: createCustomStoreFromUrl(options, normalizationOptions)
    };
  }

  if (options === undefined) {
    options = [];
  }

  if (Array.isArray(options) || options instanceof _abstract_store.default) {
    options = {
      store: options
    };
  } else {
    options = (0, _extend.extend)({}, options);
  }

  if (options.store === undefined) {
    options.store = [];
  }

  store = options.store;

  if ('load' in options) {
    store = createCustomStoreFromLoadFunc(options);
  } else if (Array.isArray(store)) {
    store = new _array_store.default(store);
  } else if ((0, _type.isPlainObject)(store)) {
    store = createStoreFromConfig((0, _extend.extend)({}, store));
  }

  options.store = store;
  return options;
};

exports.normalizeDataSourceOptions = normalizeDataSourceOptions;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _config = _interopRequireDefault(__webpack_require__(29));

var _errors = _interopRequireDefault(__webpack_require__(24));

var _resize_callbacks = _interopRequireDefault(__webpack_require__(103));

var _component = __webpack_require__(125);

var _template_manager = __webpack_require__(382);

var _public_component = __webpack_require__(143);

var _element_data = __webpack_require__(43);

var _iterator = __webpack_require__(3);

var _extend = __webpack_require__(0);

var _element = __webpack_require__(22);

var _common = __webpack_require__(4);

var _array = __webpack_require__(12);

var _type = __webpack_require__(1);

var _window = __webpack_require__(7);

var _short = __webpack_require__(113);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var abstract = _component.Component.abstract;

var DOMComponent = _component.Component.inherit({
  _getDefaultOptions: function _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      width: undefined,
      height: undefined,
      rtlEnabled: (0, _config.default)().rtlEnabled,
      elementAttr: {},
      disabled: false,
      integrationOptions: {}
    }, this._useTemplates() ? _template_manager.TemplateManager.createDefaultOptions() : {});
  },

  /**
  * @name DOMComponent.ctor
  * @publicName ctor(element,options)
  * @param1 element:Element|JQuery
  * @param2 options:DOMComponentOptions|undefined
  * @hidden
  */
  ctor: function ctor(element, options) {
    this._customClass = null;

    this._createElement(element);

    (0, _public_component.attachInstanceToElement)(this._$element, this, this._dispose);
    this.callBase(options);
  },
  _createElement: function _createElement(element) {
    this._$element = (0, _renderer.default)(element);
  },
  _getSynchronizableOptionsForCreateComponent: function _getSynchronizableOptionsForCreateComponent() {
    return ['rtlEnabled', 'disabled', 'templatesRenderAsynchronously'];
  },
  _visibilityChanged: abstract,
  _dimensionChanged: abstract,
  _init: function _init() {
    this.callBase();

    this._attachWindowResizeCallback();

    this._initTemplateManager();
  },
  _setOptionsByDevice: function _setOptionsByDevice(instanceCustomRules) {
    this.callBase([].concat(this.constructor._classCustomRules || [], instanceCustomRules || []));
  },
  _isInitialOptionValue: function _isInitialOptionValue(name) {
    var isCustomOption = this.constructor._classCustomRules && Object.prototype.hasOwnProperty.call(this._convertRulesToOptions(this.constructor._classCustomRules), name);
    return !isCustomOption && this.callBase(name);
  },
  _attachWindowResizeCallback: function _attachWindowResizeCallback() {
    if (this._isDimensionChangeSupported()) {
      var windowResizeCallBack = this._windowResizeCallBack = this._dimensionChanged.bind(this);

      _resize_callbacks.default.add(windowResizeCallBack);
    }
  },
  _isDimensionChangeSupported: function _isDimensionChangeSupported() {
    return this._dimensionChanged !== abstract;
  },
  _renderComponent: function _renderComponent() {
    this._initMarkup();

    (0, _window.hasWindow)() && this._render();
  },
  _initMarkup: function _initMarkup() {
    var _ref = this.option() || {},
        rtlEnabled = _ref.rtlEnabled;

    this._renderElementAttributes();

    this._toggleRTLDirection(rtlEnabled);

    this._renderVisibilityChange();

    this._renderDimensions();
  },
  _render: function _render() {
    this._attachVisibilityChangeHandlers();
  },
  _renderElementAttributes: function _renderElementAttributes() {
    var _ref2 = this.option() || {},
        elementAttr = _ref2.elementAttr;

    var attributes = (0, _extend.extend)({}, elementAttr);
    var classNames = attributes.class;
    delete attributes.class;
    this.$element().attr(attributes).removeClass(this._customClass).addClass(classNames);
    this._customClass = classNames;
  },
  _renderVisibilityChange: function _renderVisibilityChange() {
    if (this._isDimensionChangeSupported()) {
      this._attachDimensionChangeHandlers();
    }

    if (this._isVisibilityChangeSupported()) {
      var $element = this.$element();
      $element.addClass('dx-visibility-change-handler');
    }
  },
  _renderDimensions: function _renderDimensions() {
    var $element = this.$element();
    var element = $element.get(0);

    var width = this._getOptionValue('width', element);

    var height = this._getOptionValue('height', element);

    if (this._isCssUpdateRequired(element, height, width)) {
      $element.css({
        width: width === null ? '' : width,
        height: height === null ? '' : height
      });
    }
  },
  _isCssUpdateRequired: function _isCssUpdateRequired(element, height, width) {
    return !!((0, _type.isDefined)(width) || (0, _type.isDefined)(height) || element.style.width || element.style.height);
  },
  _attachDimensionChangeHandlers: function _attachDimensionChangeHandlers() {
    var _this = this;

    var $el = this.$element();
    var namespace = "".concat(this.NAME, "VisibilityChange");

    _short.resize.off($el, {
      namespace: namespace
    });

    _short.resize.on($el, function () {
      return _this._dimensionChanged();
    }, {
      namespace: namespace
    });
  },
  _attachVisibilityChangeHandlers: function _attachVisibilityChangeHandlers() {
    var _this2 = this;

    if (this._isVisibilityChangeSupported()) {
      var $el = this.$element();
      var namespace = "".concat(this.NAME, "VisibilityChange");
      this._isHidden = !this._isVisible();

      _short.visibility.off($el, {
        namespace: namespace
      });

      _short.visibility.on($el, function () {
        return _this2._checkVisibilityChanged('shown');
      }, function () {
        return _this2._checkVisibilityChanged('hiding');
      }, {
        namespace: namespace
      });
    }
  },
  _isVisible: function _isVisible() {
    var $element = this.$element();
    return $element.is(':visible');
  },
  _checkVisibilityChanged: function _checkVisibilityChanged(action) {
    var isVisible = this._isVisible();

    if (isVisible) {
      if (action === 'hiding' && !this._isHidden) {
        this._visibilityChanged(false);

        this._isHidden = true;
      } else if (action === 'shown' && this._isHidden) {
        this._isHidden = false;

        this._visibilityChanged(true);
      }
    }
  },
  _isVisibilityChangeSupported: function _isVisibilityChangeSupported() {
    return this._visibilityChanged !== abstract && (0, _window.hasWindow)();
  },
  _clean: _common.noop,
  _modelByElement: function _modelByElement() {
    var _this$option = this.option(),
        modelByElement = _this$option.modelByElement;

    var $element = this.$element();
    return modelByElement ? modelByElement($element) : undefined;
  },
  _invalidate: function _invalidate() {
    if (this._isUpdateAllowed()) {
      throw _errors.default.Error('E0007');
    }

    this._requireRefresh = true;
  },
  _refresh: function _refresh() {
    this._clean();

    this._renderComponent();
  },
  _dispose: function _dispose() {
    this._templateManager && this._templateManager.dispose();
    this.callBase();

    this._clean();

    this._detachWindowResizeCallback();
  },
  _detachWindowResizeCallback: function _detachWindowResizeCallback() {
    if (this._isDimensionChangeSupported()) {
      _resize_callbacks.default.remove(this._windowResizeCallBack);
    }
  },
  _toggleRTLDirection: function _toggleRTLDirection(rtl) {
    var $element = this.$element();
    $element.toggleClass('dx-rtl', rtl);
  },
  _createComponent: function _createComponent(element, component) {
    var _this3 = this;

    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var synchronizableOptions = (0, _common.grep)(this._getSynchronizableOptionsForCreateComponent(), function (value) {
      return !(value in config);
    });

    var _this$option2 = this.option(),
        integrationOptions = _this$option2.integrationOptions;

    var _this$option3 = this.option(),
        nestedComponentOptions = _this$option3.nestedComponentOptions;

    nestedComponentOptions = nestedComponentOptions || _common.noop;
    var nestedComponentConfig = (0, _extend.extend)({
      integrationOptions: integrationOptions
    }, nestedComponentOptions(this));
    synchronizableOptions.forEach(function (optionName) {
      return nestedComponentConfig[optionName] = _this3.option(optionName);
    });

    this._extendConfig(config, nestedComponentConfig);

    var instance = void 0;

    if ((0, _type.isString)(component)) {
      var $element = (0, _renderer.default)(element)[component](config);
      instance = $element[component]('instance');
    } else if (element) {
      instance = component.getInstance(element);

      if (instance) {
        instance.option(config);
      } else {
        instance = new component(element, config);
      }
    }

    if (instance) {
      var optionChangedHandler = function optionChangedHandler(_ref3) {
        var name = _ref3.name,
            value = _ref3.value;

        if ((0, _array.inArray)(name, synchronizableOptions) >= 0) {
          instance.option(name, value);
        }
      };

      this.on('optionChanged', optionChangedHandler);
      instance.on('disposing', function () {
        return _this3.off('optionChanged', optionChangedHandler);
      });
    }

    return instance;
  },
  _extendConfig: function _extendConfig(config, extendConfig) {
    (0, _iterator.each)(extendConfig, function (key, value) {
      !Object.prototype.hasOwnProperty.call(config, key) && (config[key] = value);
    });
  },
  _defaultActionConfig: function _defaultActionConfig() {
    var $element = this.$element();

    var context = this._modelByElement($element);

    return (0, _extend.extend)(this.callBase(), {
      context: context
    });
  },

  /**
  * @pseudo Action
  * @section Utils
  * @type function
  * @default null
  * @type_function_param1 e:object
  * @type_function_param1_field1 component:this
  * @type_function_param1_field2 element:DxElement
  * @type_function_param1_field3 model:object
  **/
  _defaultActionArgs: function _defaultActionArgs() {
    var $element = this.$element();

    var model = this._modelByElement($element);

    var element = this.element();
    return (0, _extend.extend)(this.callBase(), {
      element: element,
      model: model
    });
  },
  _optionChanged: function _optionChanged(args) {
    switch (args.name) {
      case 'width':
      case 'height':
        this._renderDimensions();

        break;

      case 'rtlEnabled':
        this._invalidate();

        break;

      case 'elementAttr':
        this._renderElementAttributes();

        break;

      case 'disabled':
      case 'integrationOptions':
        break;

      default:
        this.callBase(args);
        break;
    }
  },
  _removeAttributes: function _removeAttributes(element) {
    var attrs = element.attributes;

    for (var i = attrs.length - 1; i >= 0; i--) {
      var attr = attrs[i];

      if (attr) {
        var name = attr.name;

        if (!name.indexOf('aria-') || name.indexOf('dx-') !== -1 || name === 'role' || name === 'style' || name === 'tabindex') {
          element.removeAttribute(name);
        }
      }
    }
  },
  _removeClasses: function _removeClasses(element) {
    element.className = element.className.split(' ').filter(function (cssClass) {
      return cssClass.lastIndexOf('dx-', 0) !== 0;
    }).join(' ');
  },
  _updateDOMComponent: function _updateDOMComponent(renderRequired) {
    if (renderRequired) {
      this._renderComponent();
    } else if (this._requireRefresh) {
      this._requireRefresh = false;

      this._refresh();
    }
  },
  endUpdate: function endUpdate() {
    var renderRequired = this._isInitializingRequired();

    this.callBase();
    this._isUpdateAllowed() && this._updateDOMComponent(renderRequired);
  },
  $element: function $element() {
    return this._$element;
  },
  element: function element() {
    var $element = this.$element();
    return (0, _element.getPublicElement)($element);
  },
  dispose: function dispose() {
    var element = this.$element().get(0);
    (0, _element_data.cleanDataRecursive)(element, true);
    element.textContent = '';

    this._removeAttributes(element);

    this._removeClasses(element);
  },
  resetOption: function resetOption(optionName) {
    this.callBase(optionName);

    if (optionName === 'width' || optionName === 'height') {
      var initialOption = this.initialOption(optionName);
      !(0, _type.isDefined)(initialOption) && this.$element().css(optionName, '');
    }
  },
  _getAnonymousTemplateName: function _getAnonymousTemplateName() {
    return void 0;
  },
  _initTemplateManager: function _initTemplateManager() {
    if (this._templateManager || !this._useTemplates()) return void 0;

    var _this$option4 = this.option(),
        _this$option4$integra = _this$option4.integrationOptions,
        integrationOptions = _this$option4$integra === void 0 ? {} : _this$option4$integra;

    var createTemplate = integrationOptions.createTemplate;
    this._templateManager = new _template_manager.TemplateManager(createTemplate, this._getAnonymousTemplateName());

    this._initTemplates();
  },
  _initTemplates: function _initTemplates() {
    var _this4 = this;

    var _this$_templateManage = this._templateManager.extractTemplates(this.$element()),
        templates = _this$_templateManage.templates,
        anonymousTemplateMeta = _this$_templateManage.anonymousTemplateMeta;

    var anonymousTemplate = this.option("integrationOptions.templates.".concat(anonymousTemplateMeta.name));
    templates.forEach(function (_ref4) {
      var name = _ref4.name,
          template = _ref4.template;

      _this4._options.silent("integrationOptions.templates.".concat(name), template);
    });

    if (anonymousTemplateMeta.name && !anonymousTemplate) {
      this._options.silent("integrationOptions.templates.".concat(anonymousTemplateMeta.name), anonymousTemplateMeta.template);

      this._options.silent('_hasAnonymousTemplateContent', true);
    }
  },
  _getTemplateByOption: function _getTemplateByOption(optionName) {
    return this._getTemplate(this.option(optionName));
  },
  _getTemplate: function _getTemplate(templateSource) {
    var templates = this.option('integrationOptions.templates');
    var isAsyncTemplate = this.option('templatesRenderAsynchronously');
    var skipTemplates = this.option('integrationOptions.skipTemplates');
    return this._templateManager.getTemplate(templateSource, templates, {
      isAsyncTemplate: isAsyncTemplate,
      skipTemplates: skipTemplates
    }, this);
  },
  _saveTemplate: function _saveTemplate(name, template) {
    this._setOptionWithoutOptionChange('integrationOptions.templates.' + name, this._templateManager._createTemplate(template));
  },
  _useTemplates: function _useTemplates() {
    return true;
  }
});

DOMComponent.getInstance = function (element) {
  return (0, _public_component.getInstanceByElement)((0, _renderer.default)(element), this);
};

DOMComponent.defaultOptions = function (rule) {
  this._classCustomRules = this._classCustomRules || [];

  this._classCustomRules.push(rule);
};

var _default = DOMComponent;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.focused = exports.tabbable = exports.focusable = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var focusableFn = function focusableFn(element, tabIndex) {
  if (!visible(element)) {
    return false;
  }

  var nodeName = element.nodeName.toLowerCase();
  var isTabIndexNotNaN = !isNaN(tabIndex);
  var isDisabled = element.disabled;
  var isDefaultFocus = /^(input|select|textarea|button|object|iframe)$/.test(nodeName);
  var isHyperlink = nodeName === 'a';
  var isFocusable = true;
  var isContentEditable = element.isContentEditable;

  if (isDefaultFocus || isContentEditable) {
    isFocusable = !isDisabled;
  } else {
    if (isHyperlink) {
      isFocusable = element.href || isTabIndexNotNaN;
    } else {
      isFocusable = isTabIndexNotNaN;
    }
  }

  return isFocusable;
};

function visible(element) {
  var $element = (0, _renderer.default)(element);
  return $element.is(':visible') && $element.css('visibility') !== 'hidden' && $element.parents().css('visibility') !== 'hidden';
}

var focusable = function focusable(index, element) {
  return focusableFn(element, (0, _renderer.default)(element).attr('tabIndex'));
};

exports.focusable = focusable;

var tabbable = function tabbable(index, element) {
  var tabIndex = (0, _renderer.default)(element).attr('tabIndex');
  return (isNaN(tabIndex) || tabIndex >= 0) && focusableFn(element, tabIndex);
}; // note: use this method instead of is(":focus")


exports.tabbable = tabbable;

var focused = function focused($element) {
  var element = (0, _renderer.default)($element).get(0);
  return _dom_adapter.default.getActiveElement() === element;
};

exports.focused = focused;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _iterator = __webpack_require__(3);

var _event_registrator_callbacks = _interopRequireDefault(__webpack_require__(124));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var registerEvent = function registerEvent(name, eventObject) {
  var strategy = {};

  if ('noBubble' in eventObject) {
    strategy.noBubble = eventObject.noBubble;
  }

  if ('bindType' in eventObject) {
    strategy.bindType = eventObject.bindType;
  }

  if ('delegateType' in eventObject) {
    strategy.delegateType = eventObject.delegateType;
  }

  (0, _iterator.each)(['setup', 'teardown', 'add', 'remove', 'trigger', 'handle', '_default', 'dispose'], function (_, methodName) {
    if (!eventObject[methodName]) {
      return;
    }

    strategy[methodName] = function () {
      var args = [].slice.call(arguments);
      args.unshift(this);
      return eventObject[methodName].apply(eventObject, args);
    };
  });

  _event_registrator_callbacks.default.fire(name, strategy);
};

registerEvent.callbacks = _event_registrator_callbacks.default;
var _default = registerEvent;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.TemplateBase = exports.renderedCallbacks = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _callbacks = _interopRequireDefault(__webpack_require__(28));

var _dom = __webpack_require__(35);

var _visibility_change = __webpack_require__(59);

var _errors = _interopRequireDefault(__webpack_require__(24));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var renderedCallbacks = (0, _callbacks.default)({
  syncStrategy: true
});
exports.renderedCallbacks = renderedCallbacks;

var TemplateBase = /*#__PURE__*/function () {
  function TemplateBase() {}

  var _proto = TemplateBase.prototype;

  _proto.render = function render(options) {
    options = options || {};
    var onRendered = options.onRendered;
    delete options.onRendered;

    var $result = this._renderCore(options);

    this._ensureResultInContainer($result, options.container);

    renderedCallbacks.fire($result, options.container);
    onRendered && onRendered();
    return $result;
  };

  _proto._ensureResultInContainer = function _ensureResultInContainer($result, container) {
    if (!container) {
      return;
    }

    var $container = (0, _renderer.default)(container);
    var resultInContainer = (0, _dom.contains)($container.get(0), $result.get(0));
    $container.append($result);

    if (resultInContainer) {
      return;
    }

    var resultInBody = _dom_adapter.default.getBody().contains($container.get(0));

    if (!resultInBody) {
      return;
    }

    (0, _visibility_change.triggerShownEvent)($result);
  };

  _proto._renderCore = function _renderCore() {
    throw _errors.default.Error('E0001');
  };

  return TemplateBase;
}();

exports.TemplateBase = TemplateBase;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _date = _interopRequireDefault(__webpack_require__(18));

var _utils = _interopRequireDefault(__webpack_require__(279));

var _dateAdapter = _interopRequireDefault(__webpack_require__(393));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var toMs = _date.default.dateToMilliseconds;
var MINUTES_IN_HOUR = 60;

var createUTCDateWithLocalOffset = function createUTCDateWithLocalOffset(date) {
  if (!date) {
    return null;
  }

  return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));
};

var createDateFromUTCWithLocalOffset = function createDateFromUTCWithLocalOffset(date) {
  var result = (0, _dateAdapter.default)(date);
  var timezoneOffsetBeforeInMin = result.getTimezoneOffset();
  result.addTime(result.getTimezoneOffset('minute'));
  result.subtractMinutes(timezoneOffsetBeforeInMin - result.getTimezoneOffset());
  return result.source;
};

var getTimeZones = function getTimeZones() {
  var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
  var dateInUTC = createUTCDate(date);
  return _utils.default.getDisplayedTimeZones(dateInUTC.getTime());
};

var createUTCDate = function createUTCDate(date) {
  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes()));
};

var getTimezoneOffsetChangeInMinutes = function getTimezoneOffsetChangeInMinutes(startDate, endDate, updatedStartDate, updatedEndDate) {
  return getDaylightOffset(updatedStartDate, updatedEndDate) - getDaylightOffset(startDate, endDate);
};

var getTimezoneOffsetChangeInMs = function getTimezoneOffsetChangeInMs(startDate, endDate, updatedStartDate, updatedEndDate) {
  return getTimezoneOffsetChangeInMinutes(startDate, endDate, updatedStartDate, updatedEndDate) * toMs('minute');
};

var getDaylightOffset = function getDaylightOffset(startDate, endDate) {
  return new Date(startDate).getTimezoneOffset() - new Date(endDate).getTimezoneOffset();
};

var getDaylightOffsetInMs = function getDaylightOffsetInMs(startDate, endDate) {
  return getDaylightOffset(startDate, endDate) * toMs('minute');
};

var calculateTimezoneByValue = function calculateTimezoneByValue(timezone) {
  var date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();

  // NOTE: This check could be removed. We don't support numerical timezones
  if (typeof timezone === 'string') {
    var dateUtc = createUTCDate(date);
    return _utils.default.getTimeZoneOffsetById(timezone, dateUtc.getTime());
  }

  return timezone;
};

var _getDaylightOffsetByTimezone = function _getDaylightOffsetByTimezone(startDate, endDate, timeZone) {
  return calculateTimezoneByValue(timeZone, startDate) - calculateTimezoneByValue(timeZone, endDate);
};

var getCorrectedDateByDaylightOffsets = function getCorrectedDateByDaylightOffsets(convertedOriginalStartDate, convertedDate, date, timeZone, startDateTimezone) {
  var daylightOffsetByCommonTimezone = _getDaylightOffsetByTimezone(convertedOriginalStartDate, convertedDate, timeZone);

  var daylightOffsetByAppointmentTimezone = _getDaylightOffsetByTimezone(convertedOriginalStartDate, convertedDate, startDateTimezone);

  var diff = daylightOffsetByCommonTimezone - daylightOffsetByAppointmentTimezone;
  return new Date(date.getTime() - diff * toMs('hour'));
};

var correctRecurrenceExceptionByTimezone = function correctRecurrenceExceptionByTimezone(exception, exceptionByStartDate, timeZone, startDateTimeZone) {
  var isBackConversion = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var timezoneOffset = (exception.getTimezoneOffset() - exceptionByStartDate.getTimezoneOffset()) / MINUTES_IN_HOUR;

  if (startDateTimeZone) {
    timezoneOffset = _getDaylightOffsetByTimezone(exceptionByStartDate, exception, startDateTimeZone);
  } else if (timeZone) {
    timezoneOffset = _getDaylightOffsetByTimezone(exceptionByStartDate, exception, timeZone);
  }

  return new Date(exception.getTime() + (isBackConversion ? -1 : 1) * timezoneOffset * toMs('hour'));
};

var isTimezoneChangeInDate = function isTimezoneChangeInDate(date) {
  var startDayDate = new Date(new Date(date).setHours(0, 0, 0, 0));
  var endDayDate = new Date(new Date(date).setHours(23, 59, 59, 0));
  return startDayDate.getTimezoneOffset() - endDayDate.getTimezoneOffset() !== 0;
};

var getDateWithoutTimezoneChange = function getDateWithoutTimezoneChange(date) {
  var clonedDate = new Date(date);

  if (isTimezoneChangeInDate(clonedDate)) {
    var result = new Date(clonedDate);
    return new Date(result.setDate(result.getDate() + 1));
  }

  return clonedDate;
};

var isSameAppointmentDates = function isSameAppointmentDates(startDate, endDate) {
  // NOTE: subtract 1 millisecond to avoid 00.00 time. Method should return 'true' for "2020:10:10 22:00:00" and "2020:10:11 00:00:00", for example.
  endDate = new Date(endDate.getTime() - 1);
  return _date.default.sameDate(startDate, endDate);
};

var getClientTimezoneOffset = function getClientTimezoneOffset() {
  var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
  return date.getTimezoneOffset() * 60000;
};

var isEqualLocalTimeZone = function isEqualLocalTimeZone(timeZoneName) {
  var date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();

  if (Intl) {
    var localTimeZoneName = Intl.DateTimeFormat().resolvedOptions().timeZone;

    if (localTimeZoneName === timeZoneName) {
      return true;
    }
  }

  return isEqualLocalTimeZoneByDeclaration(timeZoneName, date);
}; // TODO: Not used anywhere, if it isn't use in the future, then it must be removed


var hasDSTInLocalTimeZone = function hasDSTInLocalTimeZone() {
  var _getExtremeDates = getExtremeDates(),
      _getExtremeDates2 = _slicedToArray(_getExtremeDates, 2),
      startDate = _getExtremeDates2[0],
      endDate = _getExtremeDates2[1];

  return startDate.getTimezoneOffset() !== endDate.getTimezoneOffset();
};

var isEqualLocalTimeZoneByDeclaration = function isEqualLocalTimeZoneByDeclaration(timeZoneName, date) {
  var year = date.getFullYear();

  var getOffset = function getOffset(date) {
    return -date.getTimezoneOffset() / 60;
  };

  var getDateAndMoveHourBack = function getDateAndMoveHourBack(dateStamp) {
    return new Date(dateStamp - 3600000);
  };

  var configTuple = _utils.default.getTimeZoneDeclarationTuple(timeZoneName, year);

  var _configTuple = _slicedToArray(configTuple, 2),
      summerTime = _configTuple[0],
      winterTime = _configTuple[1];

  var noDSTInTargetTimeZone = configTuple.length === 0;

  if (noDSTInTargetTimeZone) {
    var targetTimeZoneOffset = _utils.default.getTimeZoneOffsetById(timeZoneName, date);

    var localTimeZoneOffset = getOffset(date);

    if (targetTimeZoneOffset !== localTimeZoneOffset) {
      return false;
    }

    return hasDSTInLocalTimeZone() ? false : true;
  }

  var localSummerOffset = getOffset(new Date(summerTime.date));
  var localWinterOffset = getOffset(new Date(winterTime.date));

  if (localSummerOffset !== summerTime.offset) {
    return false;
  }

  if (localSummerOffset === getOffset(getDateAndMoveHourBack(summerTime.date))) {
    return false;
  }

  if (localWinterOffset !== winterTime.offset) {
    return false;
  }

  if (localWinterOffset === getOffset(getDateAndMoveHourBack(winterTime.date))) {
    return false;
  }

  return true;
}; // TODO: Getting two dates in january or june is the standard mechanism for determining that an offset has occurred.


var getExtremeDates = function getExtremeDates() {
  var nowDate = new Date(Date.now());
  var startDate = new Date();
  var endDate = new Date();
  startDate.setFullYear(nowDate.getFullYear(), 0, 1);
  endDate.setFullYear(nowDate.getFullYear(), 6, 1);
  return [startDate, endDate];
};

var utils = {
  getDaylightOffset: getDaylightOffset,
  getDaylightOffsetInMs: getDaylightOffsetInMs,
  getTimezoneOffsetChangeInMinutes: getTimezoneOffsetChangeInMinutes,
  getTimezoneOffsetChangeInMs: getTimezoneOffsetChangeInMs,
  calculateTimezoneByValue: calculateTimezoneByValue,
  getCorrectedDateByDaylightOffsets: getCorrectedDateByDaylightOffsets,
  isSameAppointmentDates: isSameAppointmentDates,
  correctRecurrenceExceptionByTimezone: correctRecurrenceExceptionByTimezone,
  getClientTimezoneOffset: getClientTimezoneOffset,
  createUTCDateWithLocalOffset: createUTCDateWithLocalOffset,
  createDateFromUTCWithLocalOffset: createDateFromUTCWithLocalOffset,
  createUTCDate: createUTCDate,
  isTimezoneChangeInDate: isTimezoneChangeInDate,
  getDateWithoutTimezoneChange: getDateWithoutTimezoneChange,
  hasDSTInLocalTimeZone: hasDSTInLocalTimeZone,
  isEqualLocalTimeZone: isEqualLocalTimeZone,
  isEqualLocalTimeZoneByDeclaration: isEqualLocalTimeZoneByDeclaration,
  getTimeZones: getTimeZones
};
var _default = utils;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.compare = compare;

function compare(x, y, maxLevel) {
  function normalizeArg(value) {
    if (typeof value === 'string') {
      return value.split('.');
    }

    if (typeof value === 'number') {
      return [value];
    }

    return value;
  }

  x = normalizeArg(x);
  y = normalizeArg(y);
  var length = Math.max(x.length, y.length);

  if (isFinite(maxLevel)) {
    length = Math.min(length, maxLevel);
  }

  for (var i = 0; i < length; i++) {
    var xItem = parseInt(x[i] || 0, 10);
    var yItem = parseInt(y[i] || 0, 10);

    if (xItem < yItem) {
      return -1;
    }

    if (xItem > yItem) {
      return 1;
    }
  }

  return 0;
}

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.DataSource = void 0;

var _class = _interopRequireDefault(__webpack_require__(15));

var _extend = __webpack_require__(0);

var _common = __webpack_require__(4);

var _iterator = __webpack_require__(3);

var _type = __webpack_require__(1);

var _utils = _interopRequireDefault(__webpack_require__(44));

var _array_utils = __webpack_require__(88);

var _custom_store = _interopRequireDefault(__webpack_require__(129));

var _events_strategy = __webpack_require__(96);

var _errors = __webpack_require__(37);

var _array = __webpack_require__(12);

var _queue = __webpack_require__(266);

var _deferred = __webpack_require__(6);

var _operation_manager = _interopRequireDefault(__webpack_require__(411));

var _utils2 = __webpack_require__(65);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var DataSource = _class.default.inherit({
  /**
  * @name DataSource.ctor
  * @publicName ctor(url)
  * @param1 url:string
  * @hidden
  */

  /**
  * @name DataSource.ctor
  * @publicName ctor(data)
  * @param1 data:Array<any>
  * @hidden
  */

  /**
  * @name DataSource.ctor
  * @publicName ctor(store)
  * @param1 store:Store
  * @hidden
  */

  /**
  * @name DataSource.ctor
  * @publicName ctor(options)
  * @param1 options:CustomStoreOptions|DataSourceOptions
  * @hidden
  */
  ctor: function ctor(options) {
    var _this = this,
        _options$reshapeOnPus;

    options = (0, _utils2.normalizeDataSourceOptions)(options);
    this._eventsStrategy = new _events_strategy.EventsStrategy(this, {
      syncStrategy: true
    });
    /**
    * @name DataSourceOptions.store.type
    * @type Enums.DataSourceStoreType
    */

    this._store = options.store;
    this._changedTime = 0;
    var needThrottling = options.pushAggregationTimeout !== 0;

    if (needThrottling) {
      var throttlingTimeout = options.pushAggregationTimeout === undefined ? function () {
        return _this._changedTime * 5;
      } : options.pushAggregationTimeout;
      var pushDeferred;
      var lastPushWaiters;

      var throttlingPushHandler = _utils.default.throttleChanges(function (changes) {
        pushDeferred.resolve();

        var storePushPending = _deferred.when.apply(void 0, _toConsumableArray(lastPushWaiters));

        storePushPending.done(function () {
          return _this._onPush(changes);
        });
        lastPushWaiters = undefined;
        pushDeferred = undefined;
      }, throttlingTimeout);

      this._onPushHandler = function (args) {
        _this._aggregationTimeoutId = throttlingPushHandler(args.changes);

        if (!pushDeferred) {
          pushDeferred = new _deferred.Deferred();
        }

        lastPushWaiters = args.waitFor;
        args.waitFor.push(pushDeferred.promise());
      };

      this._store.on('beforePush', this._onPushHandler);
    } else {
      this._onPushHandler = function (changes) {
        return _this._onPush(changes);
      };

      this._store.on('push', this._onPushHandler);
    }

    this._storeLoadOptions = this._extractLoadOptions(options);
    this._mapFunc = options.map;
    this._postProcessFunc = options.postProcess;
    this._pageIndex = options.pageIndex !== undefined ? options.pageIndex : 0;
    this._pageSize = options.pageSize !== undefined ? options.pageSize : 20;
    this._loadingCount = 0;
    this._loadQueue = this._createLoadQueue();
    this._searchValue = 'searchValue' in options ? options.searchValue : null;
    this._searchOperation = options.searchOperation || 'contains';
    this._searchExpr = options.searchExpr;
    this._paginate = options.paginate;
    this._reshapeOnPush = (_options$reshapeOnPus = options.reshapeOnPush) !== null && _options$reshapeOnPus !== void 0 ? _options$reshapeOnPus : false;
    (0, _iterator.each)(['onChanged', 'onLoadError', 'onLoadingChanged', 'onCustomizeLoadResult', 'onCustomizeStoreLoadOptions'], function (_, optionName) {
      if (optionName in options) {
        _this.on(optionName.substr(2, 1).toLowerCase() + optionName.substr(3), options[optionName]);
      }
    });
    this._operationManager = new _operation_manager.default();

    this._init();
  },
  _init: function _init() {
    this._items = [];
    this._userData = {};
    this._totalCount = -1;
    this._isLoaded = false;

    if (!(0, _type.isDefined)(this._paginate)) {
      this._paginate = !this.group();
    }

    this._isLastPage = !this._paginate;
  },
  dispose: function dispose() {
    var _this$_delayedLoadTas;

    this._store.off('beforePush', this._onPushHandler);

    this._store.off('push', this._onPushHandler);

    this._eventsStrategy.dispose();

    clearTimeout(this._aggregationTimeoutId);
    delete this._store;
    (_this$_delayedLoadTas = this._delayedLoadTask) === null || _this$_delayedLoadTas === void 0 ? void 0 : _this$_delayedLoadTas.abort();

    this._operationManager.cancelAll();

    this._disposed = true;
  },
  _extractLoadOptions: function _extractLoadOptions(options) {
    var result = {};
    var names = ['sort', 'filter', 'select', 'group', 'requireTotalCount'];

    var customNames = this._store._customLoadOptions();

    if (customNames) {
      names = names.concat(customNames);
    }

    (0, _iterator.each)(names, function () {
      result[this] = options[this];
    });
    return result;
  },
  loadOptions: function loadOptions() {
    return this._storeLoadOptions;
  },
  items: function items() {
    return this._items;
  },
  pageIndex: function pageIndex(newIndex) {
    if (!(0, _type.isNumeric)(newIndex)) {
      return this._pageIndex;
    }

    this._pageIndex = newIndex;
    this._isLastPage = !this._paginate;
  },
  paginate: function paginate(value) {
    if (!(0, _type.isBoolean)(value)) {
      return this._paginate;
    }

    if (this._paginate !== value) {
      this._paginate = value;
      this.pageIndex(0);
    }
  },
  pageSize: function pageSize(value) {
    if (!(0, _type.isNumeric)(value)) {
      return this._pageSize;
    }

    this._pageSize = value;
  },
  isLastPage: function isLastPage() {
    return this._isLastPage;
  },
  generateStoreLoadOptionAccessor: function generateStoreLoadOptionAccessor(optionName) {
    var _this2 = this;

    return function (args) {
      var normalizedArgs = (0, _utils2.normalizeStoreLoadOptionAccessorArguments)(args);

      if (normalizedArgs === undefined) {
        return _this2._storeLoadOptions[optionName];
      }

      _this2._storeLoadOptions[optionName] = normalizedArgs;
    };
  },
  sort: function sort() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return this.generateStoreLoadOptionAccessor('sort')(args);
  },
  filter: function filter() {
    var newFilter = (0, _utils2.normalizeStoreLoadOptionAccessorArguments)(arguments);

    if (newFilter === undefined) {
      return this._storeLoadOptions.filter;
    }

    this._storeLoadOptions.filter = newFilter;
    this.pageIndex(0);
  },
  group: function group() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return this.generateStoreLoadOptionAccessor('group')(args);
  },
  select: function select() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return this.generateStoreLoadOptionAccessor('select')(args);
  },
  requireTotalCount: function requireTotalCount(value) {
    if (!(0, _type.isBoolean)(value)) {
      return this._storeLoadOptions.requireTotalCount;
    }

    this._storeLoadOptions.requireTotalCount = value;
  },
  searchValue: function searchValue(value) {
    if (arguments.length < 1) {
      return this._searchValue;
    }

    this._searchValue = value;
    this.pageIndex(0);
  },
  searchOperation: function searchOperation(op) {
    if (!(0, _type.isString)(op)) {
      return this._searchOperation;
    }

    this._searchOperation = op;
    this.pageIndex(0);
  },
  searchExpr: function searchExpr(expr) {
    var argc = arguments.length;

    if (argc === 0) {
      return this._searchExpr;
    }

    if (argc > 1) {
      expr = [].slice.call(arguments);
    }

    this._searchExpr = expr;
    this.pageIndex(0);
  },
  store: function store() {
    return this._store;
  },
  key: function key() {
    var _this$_store;

    return (_this$_store = this._store) === null || _this$_store === void 0 ? void 0 : _this$_store.key();
  },
  totalCount: function totalCount() {
    return this._totalCount;
  },
  isLoaded: function isLoaded() {
    return this._isLoaded;
  },
  isLoading: function isLoading() {
    return this._loadingCount > 0;
  },
  beginLoading: function beginLoading() {
    this._changeLoadingCount(1);
  },
  endLoading: function endLoading() {
    this._changeLoadingCount(-1);
  },
  _createLoadQueue: function _createLoadQueue() {
    return (0, _queue.create)();
  },
  _changeLoadingCount: function _changeLoadingCount(increment) {
    var oldLoading = this.isLoading();
    this._loadingCount += increment;
    var newLoading = this.isLoading();

    if (oldLoading ^ newLoading) {
      this._eventsStrategy.fireEvent('loadingChanged', [newLoading]);
    }
  },
  _scheduleLoadCallbacks: function _scheduleLoadCallbacks(deferred) {
    var _this3 = this;

    this.beginLoading();
    deferred.always(function () {
      _this3.endLoading();
    });
  },
  _scheduleFailCallbacks: function _scheduleFailCallbacks(deferred) {
    var _this4 = this;

    deferred.fail(function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      if (args[0] === _utils2.CANCELED_TOKEN) {
        return;
      }

      _this4._eventsStrategy.fireEvent('loadError', args);
    });
  },
  _fireChanged: function _fireChanged(args) {
    var date = new Date();

    this._eventsStrategy.fireEvent('changed', args);

    this._changedTime = new Date() - date;
  },
  _scheduleChangedCallbacks: function _scheduleChangedCallbacks(deferred) {
    var _this5 = this;

    deferred.done(function () {
      return _this5._fireChanged();
    });
  },
  loadSingle: function loadSingle(propName, propValue) {
    var _this6 = this;

    var d = new _deferred.Deferred();
    var key = this.key();
    var store = this._store;

    var options = this._createStoreLoadOptions();

    var handleDone = function handleDone(data) {
      if (!(0, _type.isDefined)(data) || (0, _array.isEmpty)(data)) {
        d.reject(new _errors.errors.Error('E4009'));
      } else {
        if (!Array.isArray(data)) {
          data = [data];
        }

        d.resolve(_this6._applyMapFunction(data)[0]);
      }
    };

    this._scheduleFailCallbacks(d);

    if (arguments.length < 2) {
      propValue = propName;
      propName = key;
    }

    delete options.skip;
    delete options.group;
    delete options.refresh;
    delete options.pageIndex;
    delete options.searchString;

    var shouldForceByKey = function shouldForceByKey() {
      return store instanceof _custom_store.default && !store._byKeyViaLoad();
    };

    (function () {
      // NOTE for CustomStore always using byKey for backward compatibility with "old user datasource"
      if (propName === key || shouldForceByKey()) {
        return store.byKey(propValue, options);
      }

      options.take = 1;
      options.filter = options.filter ? [options.filter, [propName, propValue]] : [propName, propValue];
      return store.load(options);
    })().fail(d.reject).done(handleDone);
    return d.promise();
  },
  load: function load() {
    var _this7 = this;

    var d = new _deferred.Deferred();

    var loadTask = function loadTask() {
      if (_this7._disposed) {
        return undefined;
      }

      if (!(0, _utils2.isPending)(d)) {
        return;
      }

      return _this7._loadFromStore(loadOperation, d);
    };

    this._scheduleLoadCallbacks(d);

    this._scheduleFailCallbacks(d);

    this._scheduleChangedCallbacks(d);

    var loadOperation = this._createLoadOperation(d);

    this._eventsStrategy.fireEvent('customizeStoreLoadOptions', [loadOperation]);

    this._loadQueue.add(function () {
      if (typeof loadOperation.delay === 'number') {
        _this7._delayedLoadTask = (0, _common.executeAsync)(loadTask, loadOperation.delay);
      } else {
        loadTask();
      }

      return d.promise();
    });

    return d.promise({
      operationId: loadOperation.operationId
    });
  },
  _onPush: function _onPush(changes) {
    var _this8 = this;

    if (this._reshapeOnPush) {
      this.load();
    } else {
      this._eventsStrategy.fireEvent('changing', [{
        changes: changes
      }]);

      var group = this.group();
      var items = this.items();
      var groupLevel = 0;
      var dataSourceChanges = this.paginate() || group ? changes.filter(function (item) {
        return item.type === 'update';
      }) : changes;

      if (group) {
        groupLevel = Array.isArray(group) ? group.length : 1;
      }

      if (this._mapFunc) {
        dataSourceChanges.forEach(function (item) {
          if (item.type === 'insert') {
            item.data = _this8._mapFunc(item.data);
          }
        });
      }

      (0, _array_utils.applyBatch)({
        keyInfo: this.store(),
        data: items,
        changes: dataSourceChanges,
        groupCount: groupLevel,
        useInsertIndex: true
      });

      this._fireChanged([{
        changes: changes
      }]);
    }
  },
  _createLoadOperation: function _createLoadOperation(deferred) {
    var _this9 = this;

    var operationId = this._operationManager.add(deferred);

    var storeLoadOptions = this._createStoreLoadOptions();

    deferred.always(function () {
      return _this9._operationManager.remove(operationId);
    });
    return {
      operationId: operationId,
      storeLoadOptions: storeLoadOptions
    };
  },
  reload: function reload() {
    var store = this.store();

    if (store instanceof _custom_store.default) {
      store.clearRawDataCache();
    }

    this._init();

    return this.load();
  },
  cancel: function cancel(operationId) {
    return this._operationManager.cancel(operationId);
  },
  cancelAll: function cancelAll() {
    return this._operationManager.cancelAll();
  },
  _addSearchOptions: function _addSearchOptions(storeLoadOptions) {
    if (this._disposed) {
      return;
    }

    if (this.store()._useDefaultSearch) {
      this._addSearchFilter(storeLoadOptions);
    } else {
      storeLoadOptions.searchOperation = this._searchOperation;
      storeLoadOptions.searchValue = this._searchValue;
      storeLoadOptions.searchExpr = this._searchExpr;
    }
  },
  _createStoreLoadOptions: function _createStoreLoadOptions() {
    var result = (0, _extend.extend)({}, this._storeLoadOptions);

    this._addSearchOptions(result);

    if (this._paginate) {
      if (this._pageSize) {
        result.skip = this._pageIndex * this._pageSize;
        result.take = this._pageSize;
      }
    }

    result.userData = this._userData;
    return result;
  },
  _addSearchFilter: function _addSearchFilter(storeLoadOptions) {
    var value = this._searchValue;
    var op = this._searchOperation;
    var selector = this._searchExpr;
    var searchFilter = [];

    if (!value) {
      return;
    }

    if (!selector) {
      selector = 'this';
    }

    if (!Array.isArray(selector)) {
      selector = [selector];
    } // TODO optimize for byKey case


    (0, _iterator.each)(selector, function (i, item) {
      if (searchFilter.length) {
        searchFilter.push('or');
      }

      searchFilter.push([item, op, value]);
    });

    if (storeLoadOptions.filter) {
      storeLoadOptions.filter = [searchFilter, storeLoadOptions.filter];
    } else {
      storeLoadOptions.filter = searchFilter;
    }
  },
  _loadFromStore: function _loadFromStore(loadOptions, pendingDeferred) {
    var _this10 = this;

    var handleSuccess = function handleSuccess(data, extra) {
      if (_this10._disposed) {
        return;
      }

      if (!(0, _utils2.isPending)(pendingDeferred)) {
        return;
      } // Process result


      var loadResult = (0, _extend.extend)((0, _utils2.normalizeLoadResult)(data, extra), loadOptions);

      _this10._eventsStrategy.fireEvent('customizeLoadResult', [loadResult]);

      (0, _deferred.when)(loadResult.data).done(function (data) {
        loadResult.data = data;

        _this10._processStoreLoadResult(loadResult, pendingDeferred);
      }).fail(pendingDeferred.reject);
    };

    if (loadOptions.data) {
      return new _deferred.Deferred().resolve(loadOptions.data).done(handleSuccess);
    }

    return this.store().load(loadOptions.storeLoadOptions).done(handleSuccess).fail(pendingDeferred.reject);
  },
  _processStoreLoadResult: function _processStoreLoadResult(loadResult, pendingDeferred) {
    var _this11 = this;

    var data = loadResult.data;
    var extra = loadResult.extra;
    var storeLoadOptions = loadResult.storeLoadOptions;

    var resolvePendingDeferred = function resolvePendingDeferred() {
      _this11._isLoaded = true;
      _this11._totalCount = isFinite(extra.totalCount) ? extra.totalCount : -1;
      return pendingDeferred.resolve(data, extra);
    };

    var proceedLoadingTotalCount = function proceedLoadingTotalCount() {
      _this11.store().totalCount(storeLoadOptions).done(function (count) {
        extra.totalCount = count;
        resolvePendingDeferred();
      }).fail(pendingDeferred.reject);
    };

    if (this._disposed) {
      return;
    } // todo: if operation is canceled there is no need to do data transformation


    data = this._applyPostProcessFunction(this._applyMapFunction(data));

    if (!(0, _type.isPlainObject)(extra)) {
      extra = {};
    }

    this._items = data;

    if (!data.length || !this._paginate || this._pageSize && data.length < this._pageSize) {
      this._isLastPage = true;
    }

    if (storeLoadOptions.requireTotalCount && !isFinite(extra.totalCount)) {
      proceedLoadingTotalCount();
    } else {
      resolvePendingDeferred();
    }
  },
  _applyMapFunction: function _applyMapFunction(data) {
    if (this._mapFunc) {
      return (0, _utils2.mapDataRespectingGrouping)(data, this._mapFunc, this.group());
    }

    return data;
  },
  _applyPostProcessFunction: function _applyPostProcessFunction(data) {
    if (this._postProcessFunc) {
      return this._postProcessFunc(data);
    }

    return data;
  },
  on: function on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);

    return this;
  },
  off: function off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);

    return this;
  }
});

exports.DataSource = DataSource;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.BindableTemplate = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _template_base = __webpack_require__(69);

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _remove_event = __webpack_require__(147);

var _type = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var watchChanges = function () {
  var globalWatch = function globalWatch(data, watchMethod, callback) {
    return watchMethod(function () {
      return data;
    }, callback);
  };

  var fieldsWatch = function fieldsWatch(data, watchMethod, fields, fieldsMap, callback) {
    var resolvedData = {};
    var missedFields = fields.slice();
    var watchHandlers = fields.map(function (name) {
      var fieldGetter = fieldsMap[name];
      return watchMethod(fieldGetter ? function () {
        return fieldGetter(data);
      } : function () {
        return data[name];
      }, function (value) {
        resolvedData[name] = value;

        if (missedFields.length) {
          var index = missedFields.indexOf(name);

          if (index >= 0) {
            missedFields.splice(index, 1);
          }
        }

        if (!missedFields.length) {
          callback(resolvedData);
        }
      });
    });
    return function () {
      watchHandlers.forEach(function (dispose) {
        return dispose();
      });
    };
  };

  return function (rawData, watchMethod, fields, fieldsMap, callback) {
    var fieldsDispose;
    var globalDispose = globalWatch(rawData, watchMethod, function (dataWithRawFields) {
      fieldsDispose && fieldsDispose();

      if ((0, _type.isPrimitive)(dataWithRawFields)) {
        callback(dataWithRawFields);
        return;
      }

      fieldsDispose = fieldsWatch(dataWithRawFields, watchMethod, fields, fieldsMap, callback);
    });
    return function () {
      fieldsDispose && fieldsDispose();
      globalDispose && globalDispose();
    };
  };
}();

var BindableTemplate = /*#__PURE__*/function (_TemplateBase) {
  _inheritsLoose(BindableTemplate, _TemplateBase);

  function BindableTemplate(render, fields, watchMethod, fieldsMap) {
    var _this;

    _this = _TemplateBase.call(this) || this;
    _this._render = render;
    _this._fields = fields;
    _this._fieldsMap = fieldsMap || {};
    _this._watchMethod = watchMethod;
    return _this;
  }

  var _proto = BindableTemplate.prototype;

  _proto._renderCore = function _renderCore(options) {
    var _this2 = this;

    var $container = (0, _renderer.default)(options.container);
    var dispose = watchChanges(options.model, this._watchMethod, this._fields, this._fieldsMap, function (data) {
      $container.empty();

      _this2._render($container, data, options.model);
    });

    _events_engine.default.on($container, _remove_event.removeEvent, dispose);

    return $container.contents();
  };

  return BindableTemplate;
}(_template_base.TemplateBase);

exports.BindableTemplate = BindableTemplate;

/***/ }),
/* 74 */
/***/ (function(module, exports) {

module.exports = window.Globalize;

/***/ }),
/* 75 */,
/* 76 */,
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.originalViewPort = originalViewPort;
exports.changeCallback = exports.value = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _ready_callbacks = _interopRequireDefault(__webpack_require__(51));

var _callbacks = _interopRequireDefault(__webpack_require__(28));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ready = _ready_callbacks.default.add;
var changeCallback = (0, _callbacks.default)();
exports.changeCallback = changeCallback;
var $originalViewPort = (0, _renderer.default)();

var value = function () {
  var $current;
  return function (element) {
    if (!arguments.length) {
      return $current;
    }

    var $element = (0, _renderer.default)(element);
    $originalViewPort = $element;
    var isNewViewportFound = !!$element.length;
    var prevViewPort = value();
    $current = isNewViewportFound ? $element : (0, _renderer.default)('body');
    changeCallback.fire(isNewViewportFound ? value() : (0, _renderer.default)(), prevViewPort);
  };
}();

exports.value = value;
ready(function () {
  value('.dx-viewport');
});

function originalViewPort() {
  return $originalViewPort;
}

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.drop = exports.leave = exports.enter = exports.end = exports.start = exports.move = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _element_data = __webpack_require__(43);

var _array = __webpack_require__(12);

var iteratorUtils = _interopRequireWildcard(__webpack_require__(3));

var _dom = __webpack_require__(35);

var _event_registrator = _interopRequireDefault(__webpack_require__(68));

var _index = __webpack_require__(8);

var _emitter = _interopRequireDefault(__webpack_require__(172));

var _emitter_registrator = _interopRequireDefault(__webpack_require__(104));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DRAG_START_EVENT = 'dxdragstart';
exports.start = DRAG_START_EVENT;
var DRAG_EVENT = 'dxdrag';
exports.move = DRAG_EVENT;
var DRAG_END_EVENT = 'dxdragend';
exports.end = DRAG_END_EVENT;
var DRAG_ENTER_EVENT = 'dxdragenter';
exports.enter = DRAG_ENTER_EVENT;
var DRAG_LEAVE_EVENT = 'dxdragleave';
exports.leave = DRAG_LEAVE_EVENT;
var DROP_EVENT = 'dxdrop';
exports.drop = DROP_EVENT;
var DX_DRAG_EVENTS_COUNT_KEY = 'dxDragEventsCount';
var knownDropTargets = [];
var knownDropTargetSelectors = [];
var knownDropTargetConfigs = [];
var dropTargetRegistration = {
  setup: function setup(element, data) {
    var knownDropTarget = (0, _array.inArray)(element, knownDropTargets) !== -1;

    if (!knownDropTarget) {
      knownDropTargets.push(element);
      knownDropTargetSelectors.push([]);
      knownDropTargetConfigs.push(data || {});
    }
  },
  add: function add(element, handleObj) {
    var index = (0, _array.inArray)(element, knownDropTargets);
    this.updateEventsCounter(element, handleObj.type, 1);
    var selector = handleObj.selector;

    if ((0, _array.inArray)(selector, knownDropTargetSelectors[index]) === -1) {
      knownDropTargetSelectors[index].push(selector);
    }
  },
  updateEventsCounter: function updateEventsCounter(element, event, value) {
    if ([DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT].indexOf(event) > -1) {
      var eventsCount = (0, _element_data.data)(element, DX_DRAG_EVENTS_COUNT_KEY) || 0;
      (0, _element_data.data)(element, DX_DRAG_EVENTS_COUNT_KEY, Math.max(0, eventsCount + value));
    }
  },
  remove: function remove(element, handleObj) {
    this.updateEventsCounter(element, handleObj.type, -1);
  },
  teardown: function teardown(element) {
    var handlersCount = (0, _element_data.data)(element, DX_DRAG_EVENTS_COUNT_KEY);

    if (!handlersCount) {
      var index = (0, _array.inArray)(element, knownDropTargets);
      knownDropTargets.splice(index, 1);
      knownDropTargetSelectors.splice(index, 1);
      knownDropTargetConfigs.splice(index, 1);
      (0, _element_data.removeData)(element, DX_DRAG_EVENTS_COUNT_KEY);
    }
  }
};
/**
* @name UI Events.dxdragenter
* @type eventType
* @type_function_param1 event:event
* @type_function_param1_field1 draggingElement:Element
* @module events/drag
*/

/**
* @name UI Events.dxdrop
* @type eventType
* @type_function_param1 event:event
* @type_function_param1_field1 draggingElement:Element
* @module events/drag
*/

/**
* @name UI Events.dxdragleave
* @type eventType
* @type_function_param1 event:event
* @type_function_param1_field1 draggingElement:Element
* @module events/drag
*/

(0, _event_registrator.default)(DRAG_ENTER_EVENT, dropTargetRegistration);
(0, _event_registrator.default)(DRAG_LEAVE_EVENT, dropTargetRegistration);
(0, _event_registrator.default)(DROP_EVENT, dropTargetRegistration);

var getItemDelegatedTargets = function getItemDelegatedTargets($element) {
  var dropTargetIndex = (0, _array.inArray)($element.get(0), knownDropTargets);
  var dropTargetSelectors = knownDropTargetSelectors[dropTargetIndex].filter(function (selector) {
    return selector;
  });
  var $delegatedTargets = $element.find(dropTargetSelectors.join(', '));

  if ((0, _array.inArray)(undefined, knownDropTargetSelectors[dropTargetIndex]) !== -1) {
    $delegatedTargets = $delegatedTargets.add($element);
  }

  return $delegatedTargets;
};

var getItemConfig = function getItemConfig($element) {
  var dropTargetIndex = (0, _array.inArray)($element.get(0), knownDropTargets);
  return knownDropTargetConfigs[dropTargetIndex];
};

var getItemPosition = function getItemPosition(dropTargetConfig, $element) {
  if (dropTargetConfig.itemPositionFunc) {
    return dropTargetConfig.itemPositionFunc($element);
  } else {
    return $element.offset();
  }
};

var getItemSize = function getItemSize(dropTargetConfig, $element) {
  if (dropTargetConfig.itemSizeFunc) {
    return dropTargetConfig.itemSizeFunc($element);
  }

  return {
    width: $element.get(0).getBoundingClientRect().width,
    height: $element.get(0).getBoundingClientRect().height
  };
};

var DragEmitter = _emitter.default.inherit({
  ctor: function ctor(element) {
    this.callBase(element);
    this.direction = 'both';
  },
  _init: function _init(e) {
    this._initEvent = e;
  },
  _start: function _start(e) {
    e = this._fireEvent(DRAG_START_EVENT, this._initEvent);
    this._maxLeftOffset = e.maxLeftOffset;
    this._maxRightOffset = e.maxRightOffset;
    this._maxTopOffset = e.maxTopOffset;
    this._maxBottomOffset = e.maxBottomOffset;
    var dropTargets = (0, _array.wrapToArray)(e.targetElements || (e.targetElements === null ? [] : knownDropTargets));
    this._dropTargets = iteratorUtils.map(dropTargets, function (element) {
      return (0, _renderer.default)(element).get(0);
    });
  },
  _move: function _move(e) {
    var eventData = (0, _index.eventData)(e);

    var dragOffset = this._calculateOffset(eventData);

    e = this._fireEvent(DRAG_EVENT, e, {
      offset: dragOffset
    });

    this._processDropTargets(e);

    if (!e._cancelPreventDefault) {
      e.preventDefault();
    }
  },
  _calculateOffset: function _calculateOffset(eventData) {
    return {
      x: this._calculateXOffset(eventData),
      y: this._calculateYOffset(eventData)
    };
  },
  _calculateXOffset: function _calculateXOffset(eventData) {
    if (this.direction !== 'vertical') {
      var offset = eventData.x - this._startEventData.x;
      return this._fitOffset(offset, this._maxLeftOffset, this._maxRightOffset);
    }

    return 0;
  },
  _calculateYOffset: function _calculateYOffset(eventData) {
    if (this.direction !== 'horizontal') {
      var offset = eventData.y - this._startEventData.y;
      return this._fitOffset(offset, this._maxTopOffset, this._maxBottomOffset);
    }

    return 0;
  },
  _fitOffset: function _fitOffset(offset, minOffset, maxOffset) {
    if (minOffset != null) {
      offset = Math.max(offset, -minOffset);
    }

    if (maxOffset != null) {
      offset = Math.min(offset, maxOffset);
    }

    return offset;
  },
  _processDropTargets: function _processDropTargets(e) {
    var target = this._findDropTarget(e);

    var sameTarget = target === this._currentDropTarget;

    if (!sameTarget) {
      this._fireDropTargetEvent(e, DRAG_LEAVE_EVENT);

      this._currentDropTarget = target;

      this._fireDropTargetEvent(e, DRAG_ENTER_EVENT);
    }
  },
  _fireDropTargetEvent: function _fireDropTargetEvent(event, eventName) {
    if (!this._currentDropTarget) {
      return;
    }

    var eventData = {
      type: eventName,
      originalEvent: event,
      draggingElement: this._$element.get(0),
      target: this._currentDropTarget
    };
    (0, _index.fireEvent)(eventData);
  },
  _findDropTarget: function _findDropTarget(e) {
    var that = this;
    var result;
    iteratorUtils.each(knownDropTargets, function (_, target) {
      if (!that._checkDropTargetActive(target)) {
        return;
      }

      var $target = (0, _renderer.default)(target);
      iteratorUtils.each(getItemDelegatedTargets($target), function (_, delegatedTarget) {
        var $delegatedTarget = (0, _renderer.default)(delegatedTarget);

        if (that._checkDropTarget(getItemConfig($target), $delegatedTarget, (0, _renderer.default)(result), e)) {
          result = delegatedTarget;
        }
      });
    });
    return result;
  },
  _checkDropTargetActive: function _checkDropTargetActive(target) {
    var active = false;
    iteratorUtils.each(this._dropTargets, function (_, activeTarget) {
      active = active || activeTarget === target || (0, _dom.contains)(activeTarget, target);
      return !active;
    });
    return active;
  },
  _checkDropTarget: function _checkDropTarget(config, $target, $prevTarget, e) {
    var isDraggingElement = $target.get(0) === (0, _renderer.default)(e.target).get(0);

    if (isDraggingElement) {
      return false;
    }

    var targetPosition = getItemPosition(config, $target);

    if (e.pageX < targetPosition.left) {
      return false;
    }

    if (e.pageY < targetPosition.top) {
      return false;
    }

    var targetSize = getItemSize(config, $target);

    if (e.pageX > targetPosition.left + targetSize.width) {
      return false;
    }

    if (e.pageY > targetPosition.top + targetSize.height) {
      return false;
    }

    if ($prevTarget.length && $prevTarget.closest($target).length) {
      return false;
    }

    if (config.checkDropTarget && !config.checkDropTarget($target, e)) {
      return false;
    }

    return $target;
  },
  _end: function _end(e) {
    var eventData = (0, _index.eventData)(e);

    this._fireEvent(DRAG_END_EVENT, e, {
      offset: this._calculateOffset(eventData)
    });

    this._fireDropTargetEvent(e, DROP_EVENT);

    delete this._currentDropTarget;
  }
});
/**
 * @name UI Events.dxdragstart
 * @type eventType
 * @type_function_param1 event:event
 * @type_function_param1_field1 cancel:boolean
 * @module events/drag
*/

/**
  * @name UI Events.dxdrag
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 offset:number
  * @type_function_param1_field2 cancel:boolean
  * @module events/drag
*/

/**
  * @name UI Events.dxdragend
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 offset:number
  * @type_function_param1_field2 cancel:boolean
  * @module events/drag
*/


(0, _emitter_registrator.default)({
  emitter: DragEmitter,
  events: [DRAG_START_EVENT, DRAG_EVENT, DRAG_END_EVENT]
});

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var callOnce = function callOnce(handler) {
  var result;

  var _wrappedHandler = function wrappedHandler() {
    result = handler.apply(this, arguments);

    _wrappedHandler = function wrappedHandler() {
      return result;
    };

    return result;
  };

  return function () {
    return _wrappedHandler.apply(this, arguments);
  };
};

var _default = callOnce;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _deferred = __webpack_require__(6);

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _http_request = _interopRequireDefault(__webpack_require__(369));

var _window = __webpack_require__(7);

var _extend = __webpack_require__(0);

var _type = __webpack_require__(1);

var _promise = _interopRequireDefault(__webpack_require__(81));

var _dependency_injector = _interopRequireDefault(__webpack_require__(55));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var window = (0, _window.getWindow)();
var SUCCESS = 'success';
var ERROR = 'error';
var TIMEOUT = 'timeout';
var NO_CONTENT = 'nocontent';
var PARSER_ERROR = 'parsererror';

var isStatusSuccess = function isStatusSuccess(status) {
  return 200 <= status && status < 300;
};

var hasContent = function hasContent(status) {
  return status !== 204;
};

var paramsConvert = function paramsConvert(params) {
  var result = [];

  for (var name in params) {
    var value = params[name];

    if (value === undefined) {
      continue;
    }

    if (value === null) {
      value = '';
    }

    if (typeof value === 'function') {
      value = value();
    }

    result.push(encodeURIComponent(name) + '=' + encodeURIComponent(value));
  }

  return result.join('&');
};

var createScript = function createScript(options) {
  var script = _dom_adapter.default.createElement('script');

  for (var name in options) {
    script[name] = options[name];
  }

  return script;
};

var removeScript = function removeScript(scriptNode) {
  scriptNode.parentNode.removeChild(scriptNode);
};

var appendToHead = function appendToHead(element) {
  return _dom_adapter.default.getHead().appendChild(element);
};

var evalScript = function evalScript(code) {
  var script = createScript({
    text: code
  });
  appendToHead(script);
  removeScript(script);
};

var evalCrossDomainScript = function evalCrossDomainScript(url) {
  var script = createScript({
    src: url
  });
  return new _promise.default(function (resolve, reject) {
    var events = {
      'load': resolve,
      'error': reject
    };

    var loadHandler = function loadHandler(e) {
      events[e.type]();
      removeScript(script);
    };

    for (var event in events) {
      _dom_adapter.default.listen(script, event, loadHandler);
    }

    appendToHead(script);
  });
};

var getAcceptHeader = function getAcceptHeader(options) {
  var dataType = options.dataType || '*';
  var scriptAccept = 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript';
  var accepts = {
    '*': '*/*',
    text: 'text/plain',
    html: 'text/html',
    xml: 'application/xml, text/xml',
    json: 'application/json, text/javascript',
    jsonp: scriptAccept,
    script: scriptAccept
  };
  (0, _extend.extendFromObject)(accepts, options.accepts, true);
  return accepts[dataType] ? accepts[dataType] + (dataType !== '*' ? ', */*; q=0.01' : '') : accepts['*'];
};

var getContentTypeHeader = function getContentTypeHeader(options) {
  var defaultContentType;

  if (options.data && !options.upload && getMethod(options) !== 'GET') {
    defaultContentType = 'application/x-www-form-urlencoded;charset=utf-8';
  }

  return options.contentType || defaultContentType;
};

var getDataFromResponse = function getDataFromResponse(xhr) {
  return xhr.responseType && xhr.responseType !== 'text' || typeof xhr.responseText !== 'string' ? xhr.response : xhr.responseText;
};

var postProcess = function postProcess(deferred, xhr, dataType) {
  var data = getDataFromResponse(xhr);

  switch (dataType) {
    case 'jsonp':
      evalScript(data);
      break;

    case 'script':
      evalScript(data);
      deferred.resolve(data, SUCCESS, xhr);
      break;

    case 'json':
      try {
        deferred.resolve(JSON.parse(data), SUCCESS, xhr);
      } catch (e) {
        deferred.reject(xhr, PARSER_ERROR, e);
      }

      break;

    default:
      deferred.resolve(data, SUCCESS, xhr);
  }
};

var isCrossDomain = function isCrossDomain(url) {
  if (!(0, _window.hasWindow)()) {
    return true;
  }

  var crossDomain = false;

  var originAnchor = _dom_adapter.default.createElement('a');

  var urlAnchor = _dom_adapter.default.createElement('a');

  originAnchor.href = window.location.href;

  try {
    urlAnchor.href = url; // NOTE: IE11
    // eslint-disable-next-line no-self-assign

    urlAnchor.href = urlAnchor.href;
    crossDomain = originAnchor.protocol + '//' + originAnchor.host !== urlAnchor.protocol + '//' + urlAnchor.host;
  } catch (e) {
    crossDomain = true;
  }

  return crossDomain;
};

var setHttpTimeout = function setHttpTimeout(timeout, xhr) {
  return timeout && setTimeout(function () {
    xhr.customStatus = TIMEOUT;
    xhr.abort();
  }, timeout);
};

var getJsonpOptions = function getJsonpOptions(options) {
  if (options.dataType === 'jsonp') {
    var random = Math.random().toString().replace(/\D/g, '');
    var callbackName = options.jsonpCallback || 'dxCallback' + Date.now() + '_' + random;
    var callbackParameter = options.jsonp || 'callback';
    options.data = options.data || {};
    options.data[callbackParameter] = callbackName;
    return callbackName;
  }
};

var getRequestOptions = function getRequestOptions(options, headers) {
  var params = options.data;
  var paramsAlreadyString = typeof params === 'string';
  var url = options.url || window.location.href;

  if (!paramsAlreadyString && !options.cache) {
    params = params || {};
    params['_'] = Date.now();
  }

  if (params && !options.upload) {
    if (!paramsAlreadyString) {
      params = paramsConvert(params);
    }

    if (getMethod(options) === 'GET') {
      if (params !== '') {
        url += (url.indexOf('?') > -1 ? '&' : '?') + params;
      }

      params = null;
    } else if (headers['Content-Type'] && headers['Content-Type'].indexOf('application/x-www-form-urlencoded') > -1) {
      params = params.replace(/%20/g, '+');
    }
  }

  return {
    url: url,
    parameters: params
  };
};

function getMethod(options) {
  return (options.method || 'GET').toUpperCase();
}

var getRequestHeaders = function getRequestHeaders(options) {
  var headers = options.headers || {};
  headers['Content-Type'] = headers['Content-Type'] || getContentTypeHeader(options);
  headers['Accept'] = headers['Accept'] || getAcceptHeader(options);

  if (!options.crossDomain && !headers['X-Requested-With']) {
    headers['X-Requested-With'] = 'XMLHttpRequest';
  }

  return headers;
};

var sendRequest = function sendRequest(options) {
  var xhr = _http_request.default.getXhr();

  var d = new _deferred.Deferred();
  var result = d.promise();
  var async = (0, _type.isDefined)(options.async) ? options.async : true;
  var dataType = options.dataType;
  var timeout = options.timeout || 0;
  var timeoutId;
  options.crossDomain = isCrossDomain(options.url);
  var needScriptEvaluation = dataType === 'jsonp' || dataType === 'script';

  if (options.cache === undefined) {
    options.cache = !needScriptEvaluation;
  }

  var callbackName = getJsonpOptions(options);
  var headers = getRequestHeaders(options);
  var requestOptions = getRequestOptions(options, headers);
  var url = requestOptions.url;
  var parameters = requestOptions.parameters;

  if (callbackName) {
    window[callbackName] = function (data) {
      d.resolve(data, SUCCESS, xhr);
    };
  }

  if (options.crossDomain && needScriptEvaluation) {
    var reject = function reject() {
      d.reject(xhr, ERROR);
    };

    var resolve = function resolve() {
      if (dataType === 'jsonp') return;
      d.resolve(null, SUCCESS, xhr);
    };

    evalCrossDomainScript(url).then(resolve, reject);
    return result;
  }

  if (options.crossDomain && !('withCredentials' in xhr)) {
    d.reject(xhr, ERROR);
    return result;
  }

  xhr.open(getMethod(options), url, async, options.username, options.password);

  if (async) {
    xhr.timeout = timeout;
    timeoutId = setHttpTimeout(timeout, xhr, d);
  }

  xhr['onreadystatechange'] = function (e) {
    if (xhr.readyState === 4) {
      clearTimeout(timeoutId);

      if (isStatusSuccess(xhr.status)) {
        if (hasContent(xhr.status)) {
          postProcess(d, xhr, dataType);
        } else {
          d.resolve(null, NO_CONTENT, xhr);
        }
      } else {
        d.reject(xhr, xhr.customStatus || ERROR);
      }
    }
  };

  if (options.upload) {
    xhr.upload['onprogress'] = options.upload['onprogress'];
    xhr.upload['onloadstart'] = options.upload['onloadstart'];
    xhr.upload['onabort'] = options.upload['onabort'];
  }

  if (options.xhrFields) {
    for (var field in options.xhrFields) {
      xhr[field] = options.xhrFields[field];
    }
  }

  if (options.responseType === 'arraybuffer') {
    xhr.responseType = options.responseType;
  }

  for (var name in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, name) && (0, _type.isDefined)(headers[name])) {
      xhr.setRequestHeader(name, headers[name]);
    }
  }

  if (options.beforeSend) {
    options.beforeSend(xhr);
  }

  xhr.send(parameters);

  result.abort = function () {
    xhr.abort();
  };

  return result;
};

var _default = (0, _dependency_injector.default)({
  sendRequest: sendRequest
});

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _deferred = __webpack_require__(6);

var _window = __webpack_require__(7);

var promise = (0, _window.hasWindow)() ? (0, _window.getWindow)().Promise : Promise;

if (!promise) {
  // NOTE: This is an incomplete Promise polyfill but it is enough for creation purposes
  promise = function promise(resolver) {
    var d = new _deferred.Deferred();
    resolver(d.resolve.bind(this), d.reject.bind(this));
    return d.promise();
  };

  promise.resolve = function (val) {
    return new _deferred.Deferred().resolve(val).promise();
  };

  promise.reject = function (val) {
    return new _deferred.Deferred().reject(val).promise();
  };

  promise.all = function (promises) {
    return _deferred.when.apply(this, promises).then(function () {
      return [].slice.call(arguments);
    });
  };
}

var _default = promise;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _type = __webpack_require__(1);

var _date = _interopRequireDefault(__webpack_require__(18));

var _number = _interopRequireDefault(__webpack_require__(46));

var _date2 = _interopRequireDefault(__webpack_require__(33));

var _dependency_injector = _interopRequireDefault(__webpack_require__(55));

__webpack_require__(112);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _dependency_injector.default)({
  format: function format(value, _format) {
    var formatIsValid = (0, _type.isString)(_format) && _format !== '' || (0, _type.isPlainObject)(_format) || (0, _type.isFunction)(_format);
    var valueIsValid = (0, _type.isNumeric)(value) || (0, _type.isDate)(value);

    if (!formatIsValid || !valueIsValid) {
      return (0, _type.isDefined)(value) ? value.toString() : '';
    }

    if ((0, _type.isFunction)(_format)) {
      return _format(value);
    }

    if ((0, _type.isString)(_format)) {
      _format = {
        type: _format
      };
    }

    if ((0, _type.isNumeric)(value)) {
      return _number.default.format(value, _format);
    }

    if ((0, _type.isDate)(value)) {
      return _date2.default.format(value, _format);
    }
  },
  getTimeFormat: function getTimeFormat(showSecond) {
    return showSecond ? 'longtime' : 'shorttime';
  },
  _normalizeFormat: function _normalizeFormat(format) {
    if (!Array.isArray(format)) {
      return format;
    }

    if (format.length === 1) {
      return format[0];
    }

    return function (date) {
      return format.map(function (formatPart) {
        return _date2.default.format(date, formatPart);
      }).join(' ');
    };
  },
  getDateFormatByDifferences: function getDateFormatByDifferences(dateDifferences, intervalFormat) {
    var resultFormat = [];
    var needSpecialSecondFormatter = intervalFormat && dateDifferences.millisecond && !(dateDifferences.year || dateDifferences.month || dateDifferences.day);

    if (needSpecialSecondFormatter) {
      var secondFormatter = function secondFormatter(date) {
        return date.getSeconds() + date.getMilliseconds() / 1000 + 's';
      };

      resultFormat.push(secondFormatter);
    } else if (dateDifferences.millisecond) {
      resultFormat.push('millisecond');
    }

    if (dateDifferences.hour || dateDifferences.minute || !needSpecialSecondFormatter && dateDifferences.second) {
      resultFormat.unshift(this.getTimeFormat(dateDifferences.second));
    }

    if (dateDifferences.year && dateDifferences.month && dateDifferences.day) {
      if (intervalFormat && intervalFormat === 'month') {
        return 'monthandyear';
      } else {
        resultFormat.unshift('shortdate');
        return this._normalizeFormat(resultFormat);
      }
    }

    if (dateDifferences.year && dateDifferences.month) {
      return 'monthandyear';
    }

    if (dateDifferences.year && dateDifferences.quarter) {
      return 'quarterandyear';
    }

    if (dateDifferences.year) {
      return 'year';
    }

    if (dateDifferences.quarter) {
      return 'quarter';
    }

    if (dateDifferences.month && dateDifferences.day) {
      if (intervalFormat) {
        var monthDayFormatter = function monthDayFormatter(date) {
          return _date2.default.getMonthNames('abbreviated')[date.getMonth()] + ' ' + _date2.default.format(date, 'day');
        };

        resultFormat.unshift(monthDayFormatter);
      } else {
        resultFormat.unshift('monthandday');
      }

      return this._normalizeFormat(resultFormat);
    }

    if (dateDifferences.month) {
      return 'month';
    }

    if (dateDifferences.day) {
      if (intervalFormat) {
        resultFormat.unshift('day');
      } else {
        var dayFormatter = function dayFormatter(date) {
          return _date2.default.format(date, 'dayofweek') + ', ' + _date2.default.format(date, 'day');
        };

        resultFormat.unshift(dayFormatter);
      }

      return this._normalizeFormat(resultFormat);
    }

    return this._normalizeFormat(resultFormat);
  },
  getDateFormatByTicks: function getDateFormatByTicks(ticks) {
    var maxDiff;
    var currentDiff;
    var i;

    if (ticks.length > 1) {
      maxDiff = _date.default.getDatesDifferences(ticks[0], ticks[1]);

      for (i = 1; i < ticks.length - 1; i++) {
        currentDiff = _date.default.getDatesDifferences(ticks[i], ticks[i + 1]);

        if (maxDiff.count < currentDiff.count) {
          maxDiff = currentDiff;
        }
      }
    } else {
      maxDiff = {
        year: true,
        month: true,
        day: true,
        hour: ticks[0].getHours() > 0,
        minute: ticks[0].getMinutes() > 0,
        second: ticks[0].getSeconds() > 0,
        millisecond: ticks[0].getMilliseconds() > 0
      };
    }

    var resultFormat = this.getDateFormatByDifferences(maxDiff);
    return resultFormat;
  },
  getDateFormatByTickInterval: function getDateFormatByTickInterval(startValue, endValue, tickInterval) {
    var dateUnitInterval;
    var dateDifferencesConverter = {
      week: 'day'
    };

    var correctDateDifferences = function correctDateDifferences(dateDifferences, tickInterval, value) {
      switch (tickInterval) {
        case 'year':
        case 'quarter':
          dateDifferences.month = value;

        /* falls through */

        case 'month':
          dateDifferences.day = value;

        /* falls through */

        case 'week':
        case 'day':
          dateDifferences.hour = value;

        /* falls through */

        case 'hour':
          dateDifferences.minute = value;

        /* falls through */

        case 'minute':
          dateDifferences.second = value;

        /* falls through */

        case 'second':
          dateDifferences.millisecond = value;
      }
    };

    var correctDifferencesByMaxDate = function correctDifferencesByMaxDate(differences, minDate, maxDate) {
      if (!maxDate.getMilliseconds() && maxDate.getSeconds()) {
        if (maxDate.getSeconds() - minDate.getSeconds() === 1) {
          differences.millisecond = true;
          differences.second = false;
        }
      } else if (!maxDate.getSeconds() && maxDate.getMinutes()) {
        if (maxDate.getMinutes() - minDate.getMinutes() === 1) {
          differences.second = true;
          differences.minute = false;
        }
      } else if (!maxDate.getMinutes() && maxDate.getHours()) {
        if (maxDate.getHours() - minDate.getHours() === 1) {
          differences.minute = true;
          differences.hour = false;
        }
      } else if (!maxDate.getHours() && maxDate.getDate() > 1) {
        if (maxDate.getDate() - minDate.getDate() === 1) {
          differences.hour = true;
          differences.day = false;
        }
      } else if (maxDate.getDate() === 1 && maxDate.getMonth()) {
        if (maxDate.getMonth() - minDate.getMonth() === 1) {
          differences.day = true;
          differences.month = false;
        }
      } else if (!maxDate.getMonth() && maxDate.getFullYear()) {
        if (maxDate.getFullYear() - minDate.getFullYear() === 1) {
          differences.month = true;
          differences.year = false;
        }
      }
    };

    tickInterval = (0, _type.isString)(tickInterval) ? tickInterval.toLowerCase() : tickInterval;

    var dateDifferences = _date.default.getDatesDifferences(startValue, endValue);

    if (startValue !== endValue) {
      correctDifferencesByMaxDate(dateDifferences, startValue > endValue ? endValue : startValue, startValue > endValue ? startValue : endValue);
    }

    dateUnitInterval = _date.default.getDateUnitInterval(dateDifferences);
    correctDateDifferences(dateDifferences, dateUnitInterval, true);
    dateUnitInterval = _date.default.getDateUnitInterval(tickInterval || 'second');
    correctDateDifferences(dateDifferences, dateUnitInterval, false);
    dateDifferences[dateDifferencesConverter[dateUnitInterval] || dateUnitInterval] = true;
    var resultFormat = this.getDateFormatByDifferences(dateDifferences);
    return resultFormat;
  }
});

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _common = __webpack_require__(4);

var _iterator = __webpack_require__(3);

var _window = __webpack_require__(7);

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _type = __webpack_require__(1);

var _extend = __webpack_require__(0);

var _position = __webpack_require__(26);

var _browser = _interopRequireDefault(__webpack_require__(32));

var _translator = __webpack_require__(34);

var _support = __webpack_require__(48);

var _devices = _interopRequireDefault(__webpack_require__(13));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var window = (0, _window.getWindow)();
var horzRe = /left|right/;
var vertRe = /top|bottom/;
var collisionRe = /fit|flip|none/;
var scaleRe = /scale\(.+?\)/;
var IS_SAFARI = _browser.default.safari;

var normalizeAlign = function normalizeAlign(raw) {
  var result = {
    h: 'center',
    v: 'center'
  };
  var pair = (0, _common.splitPair)(raw);

  if (pair) {
    (0, _iterator.each)(pair, function () {
      var w = String(this).toLowerCase();

      if (horzRe.test(w)) {
        result.h = w;
      } else if (vertRe.test(w)) {
        result.v = w;
      }
    });
  }

  return result;
};

var normalizeOffset = function normalizeOffset(raw) {
  return (0, _common.pairToObject)(raw);
};

var normalizeCollision = function normalizeCollision(raw) {
  var pair = (0, _common.splitPair)(raw);
  var h = String(pair && pair[0]).toLowerCase();
  var v = String(pair && pair[1]).toLowerCase();

  if (!collisionRe.test(h)) {
    h = 'none';
  }

  if (!collisionRe.test(v)) {
    v = h;
  }

  return {
    h: h,
    v: v
  };
};

var getAlignFactor = function getAlignFactor(align) {
  switch (align) {
    case 'center':
      return 0.5;

    case 'right':
    case 'bottom':
      return 1;

    default:
      return 0;
  }
};

var inverseAlign = function inverseAlign(align) {
  switch (align) {
    case 'left':
      return 'right';

    case 'right':
      return 'left';

    case 'top':
      return 'bottom';

    case 'bottom':
      return 'top';

    default:
      return align;
  }
};

var calculateOversize = function calculateOversize(data, bounds) {
  var oversize = 0;

  if (data.myLocation < bounds.min) {
    oversize += bounds.min - data.myLocation;
  }

  if (data.myLocation > bounds.max) {
    oversize += data.myLocation - bounds.max;
  }

  return oversize;
};

var collisionSide = function collisionSide(direction, data, bounds) {
  if (data.myLocation < bounds.min) {
    return direction === 'h' ? 'left' : 'top';
  }

  if (data.myLocation > bounds.max) {
    return direction === 'h' ? 'right' : 'bottom';
  }

  return 'none';
}; // TODO: rename?


var initMyLocation = function initMyLocation(data) {
  data.myLocation = data.atLocation + getAlignFactor(data.atAlign) * data.atSize - getAlignFactor(data.myAlign) * data.mySize + data.offset;
};

var collisionResolvers = {
  'fit': function fit(data, bounds) {
    var result = false;

    if (data.myLocation > bounds.max) {
      data.myLocation = bounds.max;
      result = true;
    }

    if (data.myLocation < bounds.min) {
      data.myLocation = bounds.min;
      result = true;
    }

    data.fit = result;
  },
  'flip': function flip(data, bounds) {
    data.flip = false;

    if (data.myAlign === 'center' && data.atAlign === 'center') {
      return;
    }

    if (data.myLocation < bounds.min || data.myLocation > bounds.max) {
      var inverseData = (0, _extend.extend)({}, data, {
        myAlign: inverseAlign(data.myAlign),
        atAlign: inverseAlign(data.atAlign),
        offset: -data.offset
      });
      initMyLocation(inverseData);
      inverseData.oversize = calculateOversize(inverseData, bounds);

      if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data.oversize > inverseData.oversize) {
        data.myLocation = inverseData.myLocation;
        data.oversize = inverseData.oversize;
        data.flip = true;
      }
    }
  },
  'flipfit': function flipfit(data, bounds) {
    this.flip(data, bounds);
    this.fit(data, bounds);
  },
  'none': function none(data) {
    data.oversize = 0;
  }
};
var scrollbarWidth;

var calculateScrollbarWidth = function calculateScrollbarWidth() {
  var $scrollDiv = (0, _renderer.default)('<div>').css({
    width: 100,
    height: 100,
    overflow: 'scroll',
    position: 'absolute',
    top: -9999
  }).appendTo((0, _renderer.default)('body'));
  var result = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;
  $scrollDiv.remove();
  scrollbarWidth = result;
};

var defaultPositionResult = {
  h: {
    location: 0,
    flip: false,
    fit: false,
    oversize: 0
  },
  v: {
    location: 0,
    flip: false,
    fit: false,
    oversize: 0
  }
};

var calculatePosition = function calculatePosition(what, options) {
  var $what = (0, _renderer.default)(what);
  var currentOffset = $what.offset();
  var result = (0, _extend.extend)(true, {}, defaultPositionResult, {
    h: {
      location: currentOffset.left
    },
    v: {
      location: currentOffset.top
    }
  });

  if (!options) {
    return result;
  }

  var my = normalizeAlign(options.my);
  var at = normalizeAlign(options.at);
  var of = (0, _renderer.default)(options.of).length && options.of || window;
  var offset = normalizeOffset(options.offset);
  var collision = normalizeCollision(options.collision);
  var boundary = options.boundary;
  var boundaryOffset = normalizeOffset(options.boundaryOffset);
  var h = {
    mySize: $what.outerWidth(),
    myAlign: my.h,
    atAlign: at.h,
    offset: offset.h,
    collision: collision.h,
    boundaryOffset: boundaryOffset.h
  };
  var v = {
    mySize: $what.outerHeight(),
    myAlign: my.v,
    atAlign: at.v,
    offset: offset.v,
    collision: collision.v,
    boundaryOffset: boundaryOffset.v
  };

  if (of.preventDefault) {
    h.atLocation = of.pageX;
    v.atLocation = of.pageY;
    h.atSize = 0;
    v.atSize = 0;
  } else {
    of = (0, _renderer.default)(of);

    if ((0, _type.isWindow)(of[0])) {
      h.atLocation = of.scrollLeft();
      v.atLocation = of.scrollTop();

      if (_devices.default.real().deviceType === 'phone' && of[0].visualViewport) {
        h.atLocation = Math.max(h.atLocation, of[0].visualViewport.offsetLeft);
        v.atLocation = Math.max(v.atLocation, of[0].visualViewport.offsetTop);
        h.atSize = of[0].visualViewport.width;
        v.atSize = of[0].visualViewport.height;
      } else {
        h.atSize = of[0].innerWidth > of[0].outerWidth ? of[0].innerWidth : of.width();
        v.atSize = of[0].innerHeight > of[0].outerHeight || IS_SAFARI ? of[0].innerHeight : of.height();
      }
    } else if (of[0].nodeType === 9) {
      h.atLocation = 0;
      v.atLocation = 0;
      h.atSize = of.width();
      v.atSize = of.height();
    } else {
      var ofRect = (0, _position.getBoundingRect)(of.get(0));
      var o = getOffsetWithoutScale(of);
      h.atLocation = o.left;
      v.atLocation = o.top;
      h.atSize = Math.max(ofRect.width, of.outerWidth());
      v.atSize = Math.max(ofRect.height, of.outerHeight());
    }
  }

  initMyLocation(h);
  initMyLocation(v);

  var bounds = function () {
    var win = (0, _renderer.default)(window);
    var windowWidth = win.width();
    var windowHeight = win.height();
    var left = win.scrollLeft();
    var top = win.scrollTop();

    var documentElement = _dom_adapter.default.getDocumentElement();

    var hZoomLevel = _support.touch ? documentElement.clientWidth / windowWidth : 1;
    var vZoomLevel = _support.touch ? documentElement.clientHeight / windowHeight : 1;

    if (scrollbarWidth === undefined) {
      calculateScrollbarWidth();
    }

    var boundaryWidth = windowWidth;
    var boundaryHeight = windowHeight;

    if (boundary) {
      var $boundary = (0, _renderer.default)(boundary);
      var boundaryPosition = $boundary.offset();
      left = boundaryPosition.left;
      top = boundaryPosition.top;
      boundaryWidth = $boundary.width();
      boundaryHeight = $boundary.height();
    }

    return {
      h: {
        min: left + h.boundaryOffset,
        max: left + boundaryWidth / hZoomLevel - h.mySize - h.boundaryOffset
      },
      v: {
        min: top + v.boundaryOffset,
        max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset
      }
    };
  }();

  h.oversize = calculateOversize(h, bounds.h);
  v.oversize = calculateOversize(v, bounds.v);
  h.collisionSide = collisionSide('h', h, bounds.h);
  v.collisionSide = collisionSide('v', v, bounds.v);

  if (collisionResolvers[h.collision]) {
    collisionResolvers[h.collision](h, bounds.h);
  }

  if (collisionResolvers[v.collision]) {
    collisionResolvers[v.collision](v, bounds.v);
  }

  var preciser = function preciser(number) {
    return options.precise ? number : Math.round(number);
  };

  (0, _extend.extend)(true, result, {
    h: {
      location: preciser(h.myLocation),
      oversize: preciser(h.oversize),
      fit: h.fit,
      flip: h.flip,
      collisionSide: h.collisionSide
    },
    v: {
      location: preciser(v.myLocation),
      oversize: preciser(v.oversize),
      fit: v.fit,
      flip: v.flip,
      collisionSide: v.collisionSide
    },
    precise: options.precise
  });
  return result;
}; // NOTE: Setting the 'element.style.transform.scale' requires the inline style when both of the conditions met:
//       - a form contains an input with the name property set to "style";
//       - a form contains a dx-validator (or other popup widget).
//       T941581


var setScaleProperty = function setScaleProperty(element, scale, transformProp, styleAttr, isEmpty) {
  var stylePropIsValid = (0, _type.isDefined)(element.style) && !_dom_adapter.default.isNode(element.style);

  if (stylePropIsValid) {
    element.style.transform = isEmpty ? transformProp.replace(scale, '') : transformProp;
  } else {
    element.setAttribute('style', isEmpty ? styleAttr.replace(scale, '') : styleAttr);
  }
};

var getOffsetWithoutScale = function getOffsetWithoutScale($startElement) {
  var _currentElement$getAt, _currentElement$style, _style$match;

  var $currentElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $startElement;
  var currentElement = $currentElement.get(0);

  if (!currentElement) {
    return $startElement.offset();
  }

  var style = ((_currentElement$getAt = currentElement.getAttribute) === null || _currentElement$getAt === void 0 ? void 0 : _currentElement$getAt.call(currentElement, 'style')) || '';
  var transform = (_currentElement$style = currentElement.style) === null || _currentElement$style === void 0 ? void 0 : _currentElement$style.transform;
  var scale = (_style$match = style.match(scaleRe)) === null || _style$match === void 0 ? void 0 : _style$match[0];
  var offset;

  if (scale) {
    setScaleProperty(currentElement, scale, transform, style, true);
    offset = getOffsetWithoutScale($startElement, $currentElement.parent());
    setScaleProperty(currentElement, scale, transform, style, false);
  } else {
    offset = getOffsetWithoutScale($startElement, $currentElement.parent());
  }

  return offset;
};

var position = function position(what, options) {
  var $what = (0, _renderer.default)(what);

  if (!options) {
    return $what.offset();
  }

  (0, _translator.resetPosition)($what, true);
  var offset = getOffsetWithoutScale($what);
  var targetPosition = options.h && options.v ? options : calculatePosition($what, options);

  var preciser = function preciser(number) {
    return options.precise ? number : Math.round(number);
  };

  (0, _translator.move)($what, {
    left: targetPosition.h.location - preciser(offset.left),
    top: targetPosition.v.location - preciser(offset.top)
  });
  return targetPosition;
};

var offset = function offset(element) {
  element = (0, _renderer.default)(element).get(0);

  if ((0, _type.isWindow)(element)) {
    return null;
  } else if (element && 'pageY' in element && 'pageX' in element) {
    return {
      top: element.pageY,
      left: element.pageX
    };
  }

  return (0, _renderer.default)(element).offset();
};

if (!position.inverseAlign) {
  position.inverseAlign = inverseAlign;
}

if (!position.normalizeAlign) {
  position.normalizeAlign = normalizeAlign;
}

var _default = {
  calculateScrollbarWidth: calculateScrollbarWidth,
  calculate: calculatePosition,
  setup: position,
  offset: offset
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _utils = _interopRequireDefault(__webpack_require__(44));

var _query = _interopRequireDefault(__webpack_require__(49));

var _errors = __webpack_require__(37);

var _abstract_store = _interopRequireDefault(__webpack_require__(106));

var _array_utils = __webpack_require__(88);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ArrayStore = _abstract_store.default.inherit({
  ctor: function ctor(options) {
    if (Array.isArray(options)) {
      options = {
        data: options
      };
    } else {
      options = options || {};
    }

    this.callBase(options);
    var initialArray = options.data;

    if (initialArray && !Array.isArray(initialArray)) {
      throw _errors.errors.Error('E4006');
    }

    this._array = initialArray || [];
  },
  createQuery: function createQuery() {
    return (0, _query.default)(this._array, {
      errorHandler: this._errorHandler
    });
  },
  _byKeyImpl: function _byKeyImpl(key) {
    var index = (0, _array_utils.indexByKey)(this, this._array, key);

    if (index === -1) {
      return _utils.default.rejectedPromise(_errors.errors.Error('E4009'));
    }

    return _utils.default.trivialPromise(this._array[index]);
  },
  _insertImpl: function _insertImpl(values) {
    return (0, _array_utils.insert)(this, this._array, values);
  },
  _pushImpl: function _pushImpl(changes) {
    (0, _array_utils.applyBatch)({
      keyInfo: this,
      data: this._array,
      changes: changes
    });
  },
  _updateImpl: function _updateImpl(key, values) {
    return (0, _array_utils.update)(this, this._array, key, values);
  },
  _removeImpl: function _removeImpl(key) {
    return (0, _array_utils.remove)(this, this._array, key);
  },
  clear: function clear() {
    this._eventsStrategy.fireEvent('modifying');

    this._array = [];

    this._eventsStrategy.fireEvent('modified');
  }
}, 'array');

var _default = ArrayStore;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _dependency_injector = _interopRequireDefault(__webpack_require__(55));

var _parent_locales = _interopRequireDefault(__webpack_require__(358));

var _parentLocale = _interopRequireDefault(__webpack_require__(359));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_LOCALE = 'en';

var _default = (0, _dependency_injector.default)({
  locale: function () {
    var currentLocale = DEFAULT_LOCALE;
    return function (locale) {
      if (!locale) {
        return currentLocale;
      }

      currentLocale = locale;
    };
  }(),
  getValueByClosestLocale: function getValueByClosestLocale(getter) {
    var locale = this.locale();
    var value = getter(locale);
    var isRootLocale;

    while (!value && !isRootLocale) {
      locale = (0, _parentLocale.default)(_parent_locales.default, locale);

      if (locale) {
        value = getter(locale);
      } else {
        isRootLocale = true;
      }
    }

    if (value === undefined && locale !== DEFAULT_LOCALE) {
      return getter(DEFAULT_LOCALE);
    }

    return value;
  }
});

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _type = __webpack_require__(1);

var tagHelper = {
  toXml: function toXml(tagName, attributes, content) {
    var result = ['<', tagName];

    for (var attributeName in attributes) {
      var attributeValue = attributes[attributeName];

      if ((0, _type.isDefined)(attributeValue)) {
        result.push(' ', attributeName, '="', attributeValue, '"');
      }
    }

    if ((0, _type.isDefined)(content) && content !== '') {
      result.push('>', content, '</', tagName, '>');
    } else {
      result.push(' />');
    }

    return result.join('');
  }
};
var _default = tagHelper;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = _default;

var _jquery = _interopRequireDefault(__webpack_require__(56));

var _config = _interopRequireDefault(__webpack_require__(29));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
var useJQuery = (0, _config.default)().useJQuery;

if (_jquery.default && useJQuery !== false) {
  (0, _config.default)({
    useJQuery: true
  });
}

function _default() {
  return _jquery.default && (0, _config.default)().useJQuery;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.applyBatch = applyBatch;
exports.createObjectWithChanges = createObjectWithChanges;
exports.update = update;
exports.insert = insert;
exports.remove = remove;
exports.indexByKey = indexByKey;
exports.applyChanges = applyChanges;

var _type = __webpack_require__(1);

var _config = _interopRequireDefault(__webpack_require__(29));

var _guid = _interopRequireDefault(__webpack_require__(36));

var _extend = __webpack_require__(0);

var _errors = __webpack_require__(37);

var _object = __webpack_require__(52);

var _data = __webpack_require__(21);

var _utils = _interopRequireDefault(__webpack_require__(44));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function hasKey(target, keyOrKeys) {
  var key;
  var keys = typeof keyOrKeys === 'string' ? keyOrKeys.split() : keyOrKeys.slice();

  while (keys.length) {
    key = keys.shift();

    if (key in target) {
      return true;
    }
  }

  return false;
}

function findItems(keyInfo, items, key, groupCount) {
  var childItems;
  var result;

  if (groupCount) {
    for (var i = 0; i < items.length; i++) {
      childItems = items[i].items || items[i].collapsedItems || [];
      result = findItems(keyInfo, childItems || [], key, groupCount - 1);

      if (result) {
        return result;
      }
    }
  } else if (indexByKey(keyInfo, items, key) >= 0) {
    return items;
  }
}

function getItems(keyInfo, items, key, groupCount) {
  if (groupCount) {
    return findItems(keyInfo, items, key, groupCount) || [];
  }

  return items;
}

function generateDataByKeyMap(keyInfo, array) {
  if (keyInfo.key() && (!array._dataByKeyMap || array._dataByKeyMapLength !== array.length)) {
    var dataByKeyMap = {};
    var arrayLength = array.length;

    for (var i = 0; i < arrayLength; i++) {
      dataByKeyMap[JSON.stringify(keyInfo.keyOf(array[i]))] = array[i];
    }

    array._dataByKeyMap = dataByKeyMap;
    array._dataByKeyMapLength = arrayLength;
  }
}

function getCacheValue(array, key) {
  if (array._dataByKeyMap) {
    return array._dataByKeyMap[JSON.stringify(key)];
  }
}

function getHasKeyCacheValue(array, key) {
  if (array._dataByKeyMap) {
    return array._dataByKeyMap[JSON.stringify(key)];
  }

  return true;
}

function setDataByKeyMapValue(array, key, data) {
  if (array._dataByKeyMap) {
    array._dataByKeyMap[JSON.stringify(key)] = data;
    array._dataByKeyMapLength += data ? 1 : -1;
  }
}

function createObjectWithChanges(target, changes) {
  var result = target ? Object.create(Object.getPrototypeOf(target)) : {};
  var targetWithoutPrototype = (0, _extend.extendFromObject)({}, target);
  (0, _object.deepExtendArraySafe)(result, targetWithoutPrototype, true, true);
  return (0, _object.deepExtendArraySafe)(result, changes, true, true);
}

function applyBatch(_ref) {
  var keyInfo = _ref.keyInfo,
      data = _ref.data,
      changes = _ref.changes,
      groupCount = _ref.groupCount,
      useInsertIndex = _ref.useInsertIndex,
      immutable = _ref.immutable,
      disableCache = _ref.disableCache,
      logError = _ref.logError;
  var resultItems = immutable === true ? _toConsumableArray(data) : data;
  changes.forEach(function (item) {
    var items = item.type === 'insert' ? resultItems : getItems(keyInfo, resultItems, item.key, groupCount);
    !disableCache && generateDataByKeyMap(keyInfo, items);

    switch (item.type) {
      case 'update':
        update(keyInfo, items, item.key, item.data, true, immutable, logError);
        break;

      case 'insert':
        insert(keyInfo, items, item.data, useInsertIndex && (0, _type.isDefined)(item.index) ? item.index : -1, true, logError);
        break;

      case 'remove':
        remove(keyInfo, items, item.key, true, logError);
        break;
    }
  });
  return resultItems;
}

function getErrorResult(isBatch, logError, errorCode) {
  return !isBatch ? _utils.default.rejectedPromise(_errors.errors.Error(errorCode)) : logError && _errors.errors.log(errorCode);
}

function applyChanges(data, changes) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _options$keyExpr = options.keyExpr,
      keyExpr = _options$keyExpr === void 0 ? 'id' : _options$keyExpr,
      _options$immutable = options.immutable,
      immutable = _options$immutable === void 0 ? true : _options$immutable;
  var keyGetter = (0, _data.compileGetter)(keyExpr);
  var keyInfo = {
    key: function key() {
      return keyExpr;
    },
    keyOf: function keyOf(obj) {
      return keyGetter(obj);
    }
  };
  return applyBatch({
    keyInfo: keyInfo,
    data: data,
    changes: changes,
    immutable: immutable,
    disableCache: true,
    logError: true
  });
}

function update(keyInfo, array, key, data, isBatch, immutable, logError) {
  var target;
  var extendComplexObject = true;
  var keyExpr = keyInfo.key();

  if (keyExpr) {
    if (hasKey(data, keyExpr) && !_utils.default.keysEqual(keyExpr, key, keyInfo.keyOf(data))) {
      return getErrorResult(isBatch, logError, 'E4017');
    }

    target = getCacheValue(array, key);

    if (!target) {
      var index = indexByKey(keyInfo, array, key);

      if (index < 0) {
        return getErrorResult(isBatch, logError, 'E4009');
      }

      target = array[index];

      if (immutable === true && (0, _type.isDefined)(target)) {
        var newTarget = createObjectWithChanges(target, data);
        array[index] = newTarget;
        return !isBatch && _utils.default.trivialPromise(newTarget, key);
      }
    }
  } else {
    target = key;
  }

  (0, _object.deepExtendArraySafe)(target, data, extendComplexObject);

  if (!isBatch) {
    if ((0, _config.default)().useLegacyStoreResult) {
      return _utils.default.trivialPromise(key, data);
    } else {
      return _utils.default.trivialPromise(target, key);
    }
  }
}

function insert(keyInfo, array, data, index, isBatch, logError) {
  var keyValue;
  var keyExpr = keyInfo.key();
  var obj = (0, _type.isPlainObject)(data) ? (0, _extend.extend)({}, data) : data;

  if (keyExpr) {
    keyValue = keyInfo.keyOf(obj);

    if (keyValue === undefined || _typeof(keyValue) === 'object' && (0, _type.isEmptyObject)(keyValue)) {
      if (Array.isArray(keyExpr)) {
        throw _errors.errors.Error('E4007');
      }

      keyValue = obj[keyExpr] = String(new _guid.default());
    } else {
      if (array[indexByKey(keyInfo, array, keyValue)] !== undefined) {
        return getErrorResult(isBatch, logError, 'E4008');
      }
    }
  } else {
    keyValue = obj;
  }

  if (index >= 0) {
    array.splice(index, 0, obj);
  } else {
    array.push(obj);
  }

  setDataByKeyMapValue(array, keyValue, obj);

  if (!isBatch) {
    return _utils.default.trivialPromise((0, _config.default)().useLegacyStoreResult ? data : obj, keyValue);
  }
}

function remove(keyInfo, array, key, isBatch, logError) {
  var index = indexByKey(keyInfo, array, key);

  if (index > -1) {
    array.splice(index, 1);
    setDataByKeyMapValue(array, key, null);
  }

  if (!isBatch) {
    return _utils.default.trivialPromise(key);
  } else if (index < 0) {
    return getErrorResult(isBatch, logError, 'E4009');
  }
}

function indexByKey(keyInfo, array, key) {
  var keyExpr = keyInfo.key();

  if (!getHasKeyCacheValue(array, key)) {
    return -1;
  }

  for (var i = 0, arrayLength = array.length; i < arrayLength; i++) {
    if (_utils.default.keysEqual(keyExpr, keyInfo.keyOf(array[i]), key)) {
      return i;
    }
  }

  return -1;
}

/***/ }),
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.setHeight = exports.setWidth = exports.parsePixelValue = exports.normalizeStyleProp = exports.stylePropPrefix = exports.styleProp = void 0;

var _inflector = __webpack_require__(41);

var _call_once = _interopRequireDefault(__webpack_require__(79));

var _type = __webpack_require__(1);

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var jsPrefixes = ['', 'Webkit', 'Moz', 'O', 'Ms'];
var cssPrefixes = {
  '': '',
  'Webkit': '-webkit-',
  'Moz': '-moz-',
  'O': '-o-',
  'ms': '-ms-'
};
var getStyles = (0, _call_once.default)(function () {
  return _dom_adapter.default.createElement('dx').style;
});

var forEachPrefixes = function forEachPrefixes(prop, callBack) {
  prop = (0, _inflector.camelize)(prop, true);
  var result;

  for (var i = 0, cssPrefixesCount = jsPrefixes.length; i < cssPrefixesCount; i++) {
    var jsPrefix = jsPrefixes[i];
    var prefixedProp = jsPrefix + prop;
    var lowerPrefixedProp = (0, _inflector.camelize)(prefixedProp);
    result = callBack(lowerPrefixedProp, jsPrefix);

    if (result === undefined) {
      result = callBack(prefixedProp, jsPrefix);
    }

    if (result !== undefined) {
      break;
    }
  }

  return result || '';
};

var styleProp = function styleProp(name) {
  if (name in getStyles()) {
    return name;
  }

  var originalName = name;
  name = name.charAt(0).toUpperCase() + name.substr(1);

  for (var i = 1; i < jsPrefixes.length; i++) {
    var prefixedProp = jsPrefixes[i].toLowerCase() + name;

    if (prefixedProp in getStyles()) {
      return prefixedProp;
    }
  }

  return originalName;
};

exports.styleProp = styleProp;

var stylePropPrefix = function stylePropPrefix(prop) {
  return forEachPrefixes(prop, function (specific, jsPrefix) {
    if (specific in getStyles()) {
      return cssPrefixes[jsPrefix];
    }
  });
};

exports.stylePropPrefix = stylePropPrefix;
var pxExceptions = ['fillOpacity', 'columnCount', 'flexGrow', 'flexShrink', 'fontWeight', 'lineHeight', 'opacity', 'zIndex', 'zoom'];

var parsePixelValue = function parsePixelValue(value) {
  if ((0, _type.isNumeric)(value)) {
    return value;
  } else if ((0, _type.isString)(value)) {
    return Number(value.replace('px', ''));
  }

  return NaN;
};

exports.parsePixelValue = parsePixelValue;

var normalizeStyleProp = function normalizeStyleProp(prop, value) {
  if ((0, _type.isNumeric)(value) && pxExceptions.indexOf(prop) === -1) {
    value += 'px';
  }

  return value;
};

exports.normalizeStyleProp = normalizeStyleProp;

var setDimensionProperty = function setDimensionProperty(elements, propertyName, value) {
  if (elements) {
    value = (0, _type.isNumeric)(value) ? value += 'px' : value;

    for (var i = 0; i < elements.length; ++i) {
      elements[i].style[propertyName] = value;
    }
  }
};

var setWidth = function setWidth(elements, value) {
  setDimensionProperty(elements, 'width', value);
};

exports.setWidth = setWidth;

var setHeight = function setHeight(elements, value) {
  setDimensionProperty(elements, 'height', value);
};

exports.setHeight = setHeight;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.EmptyTemplate = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _template_base = __webpack_require__(69);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var EmptyTemplate = /*#__PURE__*/function (_TemplateBase) {
  _inheritsLoose(EmptyTemplate, _TemplateBase);

  function EmptyTemplate() {
    return _TemplateBase.apply(this, arguments) || this;
  }

  var _proto = EmptyTemplate.prototype;

  _proto._renderCore = function _renderCore() {
    return (0, _renderer.default)();
  };

  return EmptyTemplate;
}(_template_base.TemplateBase);

exports.EmptyTemplate = EmptyTemplate;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _class = _interopRequireDefault(__webpack_require__(15));

var _extend = __webpack_require__(0);

var _array = __webpack_require__(12);

var _iterator = __webpack_require__(3);

var _events_strategy = __webpack_require__(96);

var _errors = _interopRequireDefault(__webpack_require__(24));

var _common = __webpack_require__(4);

var _type = __webpack_require__(1);

var _number = _interopRequireDefault(__webpack_require__(46));

var _message = _interopRequireDefault(__webpack_require__(10));

var _promise = _interopRequireDefault(__webpack_require__(81));

var _deferred = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// STYLE validation
var STATUS = {
  valid: 'valid',
  invalid: 'invalid',
  pending: 'pending'
};

var BaseRuleValidator = /*#__PURE__*/function () {
  function BaseRuleValidator() {
    this.NAME = 'base';
  }

  var _proto = BaseRuleValidator.prototype;

  _proto.defaultMessage = function defaultMessage(value) {
    return _message.default.getFormatter("validation-".concat(this.NAME))(value);
  };

  _proto.defaultFormattedMessage = function defaultFormattedMessage(value) {
    return _message.default.getFormatter("validation-".concat(this.NAME, "-formatted"))(value);
  };

  _proto._isValueEmpty = function _isValueEmpty(value) {
    return !rulesValidators.required.validate(value, {});
  };

  _proto.validate = function validate(value, rule) {
    var _this = this;

    var valueArray = Array.isArray(value) ? value : [value];
    var result = true;

    if (valueArray.length) {
      valueArray.every(function (itemValue) {
        result = _this._validate(itemValue, rule);
        return result;
      });
    } else {
      result = this._validate(null, rule);
    }

    return result;
  };

  return BaseRuleValidator;
}();

var RequiredRuleValidator = /*#__PURE__*/function (_BaseRuleValidator) {
  _inheritsLoose(RequiredRuleValidator, _BaseRuleValidator);

  function RequiredRuleValidator() {
    var _this2;

    _this2 = _BaseRuleValidator.call(this) || this;
    _this2.NAME = 'required';
    return _this2;
  }

  var _proto2 = RequiredRuleValidator.prototype;

  _proto2._validate = function _validate(value, rule) {
    if (!(0, _type.isDefined)(value)) return false;

    if (value === false) {
      return false;
    }

    value = String(value);

    if (rule.trim || !(0, _type.isDefined)(rule.trim)) {
      value = value.trim();
    }

    return value !== '';
  };

  return RequiredRuleValidator;
}(BaseRuleValidator);

var NumericRuleValidator = /*#__PURE__*/function (_BaseRuleValidator2) {
  _inheritsLoose(NumericRuleValidator, _BaseRuleValidator2);

  function NumericRuleValidator() {
    var _this3;

    _this3 = _BaseRuleValidator2.call(this) || this;
    _this3.NAME = 'numeric';
    return _this3;
  }

  var _proto3 = NumericRuleValidator.prototype;

  _proto3._validate = function _validate(value, rule) {
    if (rule.ignoreEmptyValue !== false && this._isValueEmpty(value)) {
      return true;
    }

    if (rule.useCultureSettings && (0, _type.isString)(value)) {
      return !isNaN(_number.default.parse(value));
    } else {
      return (0, _type.isNumeric)(value);
    }
  };

  return NumericRuleValidator;
}(BaseRuleValidator);

var RangeRuleValidator = /*#__PURE__*/function (_BaseRuleValidator3) {
  _inheritsLoose(RangeRuleValidator, _BaseRuleValidator3);

  function RangeRuleValidator() {
    var _this4;

    _this4 = _BaseRuleValidator3.call(this) || this;
    _this4.NAME = 'range';
    return _this4;
  }

  var _proto4 = RangeRuleValidator.prototype;

  _proto4._validate = function _validate(value, rule) {
    if (rule.ignoreEmptyValue !== false && this._isValueEmpty(value)) {
      return true;
    }

    var validNumber = rulesValidators['numeric'].validate(value, rule);
    var validValue = (0, _type.isDefined)(value) && value !== '';
    var number = validNumber ? parseFloat(value) : validValue && value.valueOf();
    var min = rule.min;
    var max = rule.max;

    if (!(validNumber || (0, _type.isDate)(value)) && !validValue) {
      return false;
    }

    if ((0, _type.isDefined)(min)) {
      if ((0, _type.isDefined)(max)) {
        return number >= min && number <= max;
      }

      return number >= min;
    } else {
      if ((0, _type.isDefined)(max)) {
        return number <= max;
      } else {
        throw _errors.default.Error('E0101');
      }
    }
  };

  return RangeRuleValidator;
}(BaseRuleValidator);

var StringLengthRuleValidator = /*#__PURE__*/function (_BaseRuleValidator4) {
  _inheritsLoose(StringLengthRuleValidator, _BaseRuleValidator4);

  function StringLengthRuleValidator() {
    var _this5;

    _this5 = _BaseRuleValidator4.call(this) || this;
    _this5.NAME = 'stringLength';
    return _this5;
  }

  var _proto5 = StringLengthRuleValidator.prototype;

  _proto5._validate = function _validate(value, rule) {
    var _value;

    value = String((_value = value) !== null && _value !== void 0 ? _value : '');

    if (rule.trim || !(0, _type.isDefined)(rule.trim)) {
      value = value.trim();
    }

    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {
      return true;
    }

    return rulesValidators.range.validate(value.length, (0, _extend.extend)({}, rule));
  };

  return StringLengthRuleValidator;
}(BaseRuleValidator);

var CustomRuleValidator = /*#__PURE__*/function (_BaseRuleValidator5) {
  _inheritsLoose(CustomRuleValidator, _BaseRuleValidator5);

  function CustomRuleValidator() {
    var _this6;

    _this6 = _BaseRuleValidator5.call(this) || this;
    _this6.NAME = 'custom';
    return _this6;
  }

  var _proto6 = CustomRuleValidator.prototype;

  _proto6.validate = function validate(value, rule) {
    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {
      return true;
    }

    var validator = rule.validator;
    var dataGetter = validator && (0, _type.isFunction)(validator.option) && validator.option('dataGetter');
    var extraParams = (0, _type.isFunction)(dataGetter) && dataGetter();
    var params = {
      value: value,
      validator: validator,
      rule: rule
    };

    if (extraParams) {
      (0, _extend.extend)(params, extraParams);
    }

    return rule.validationCallback(params);
  };

  return CustomRuleValidator;
}(BaseRuleValidator);

var AsyncRuleValidator = /*#__PURE__*/function (_CustomRuleValidator) {
  _inheritsLoose(AsyncRuleValidator, _CustomRuleValidator);

  function AsyncRuleValidator() {
    var _this7;

    _this7 = _CustomRuleValidator.call(this) || this;
    _this7.NAME = 'async';
    return _this7;
  }

  var _proto7 = AsyncRuleValidator.prototype;

  _proto7.validate = function validate(value, rule) {
    if (!(0, _type.isDefined)(rule.reevaluate)) {
      (0, _extend.extend)(rule, {
        reevaluate: true
      });
    }

    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {
      return true;
    }

    var validator = rule.validator;
    var dataGetter = validator && (0, _type.isFunction)(validator.option) && validator.option('dataGetter');
    var extraParams = (0, _type.isFunction)(dataGetter) && dataGetter();
    var params = {
      value: value,
      validator: validator,
      rule: rule
    };

    if (extraParams) {
      (0, _extend.extend)(params, extraParams);
    }

    var callbackResult = rule.validationCallback(params);

    if (!(0, _type.isPromise)(callbackResult)) {
      throw _errors.default.Error('E0103');
    }

    return this._getWrappedPromise((0, _deferred.fromPromise)(callbackResult).promise());
  };

  _proto7._getWrappedPromise = function _getWrappedPromise(promise) {
    var deferred = new _deferred.Deferred();
    promise.then(function (res) {
      deferred.resolve(res);
    }, function (err) {
      var res = {
        isValid: false
      };

      if ((0, _type.isDefined)(err)) {
        if ((0, _type.isString)(err)) {
          res.message = err;
        } else if ((0, _type.isObject)(err) && (0, _type.isDefined)(err.message) && (0, _type.isString)(err.message)) {
          res.message = err.message;
        }
      }

      deferred.resolve(res);
    });
    return deferred.promise();
  };

  return AsyncRuleValidator;
}(CustomRuleValidator);

var CompareRuleValidator = /*#__PURE__*/function (_BaseRuleValidator6) {
  _inheritsLoose(CompareRuleValidator, _BaseRuleValidator6);

  function CompareRuleValidator() {
    var _this8;

    _this8 = _BaseRuleValidator6.call(this) || this;
    _this8.NAME = 'compare';
    return _this8;
  }

  var _proto8 = CompareRuleValidator.prototype;

  _proto8._validate = function _validate(value, rule) {
    if (!rule.comparisonTarget) {
      throw _errors.default.Error('E0102');
    }

    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {
      return true;
    }

    (0, _extend.extend)(rule, {
      reevaluate: true
    });
    var otherValue = rule.comparisonTarget();
    var type = rule.comparisonType || '==';

    switch (type) {
      case '==':
        return value == otherValue;
      // eslint-disable-line eqeqeq

      case '!=':
        return value != otherValue;
      // eslint-disable-line eqeqeq

      case '===':
        return value === otherValue;

      case '!==':
        return value !== otherValue;

      case '>':
        return value > otherValue;

      case '>=':
        return value >= otherValue;

      case '<':
        return value < otherValue;

      case '<=':
        return value <= otherValue;
    }
  };

  return CompareRuleValidator;
}(BaseRuleValidator);

var PatternRuleValidator = /*#__PURE__*/function (_BaseRuleValidator7) {
  _inheritsLoose(PatternRuleValidator, _BaseRuleValidator7);

  function PatternRuleValidator() {
    var _this9;

    _this9 = _BaseRuleValidator7.call(this) || this;
    _this9.NAME = 'pattern';
    return _this9;
  }

  var _proto9 = PatternRuleValidator.prototype;

  _proto9._validate = function _validate(value, rule) {
    if (rule.ignoreEmptyValue !== false && this._isValueEmpty(value)) {
      return true;
    }

    var pattern = rule.pattern;

    if ((0, _type.isString)(pattern)) {
      pattern = new RegExp(pattern);
    }

    return pattern.test(value);
  };

  return PatternRuleValidator;
}(BaseRuleValidator);

var EmailRuleValidator = /*#__PURE__*/function (_BaseRuleValidator8) {
  _inheritsLoose(EmailRuleValidator, _BaseRuleValidator8);

  function EmailRuleValidator() {
    var _this10;

    _this10 = _BaseRuleValidator8.call(this) || this;
    _this10.NAME = 'email';
    return _this10;
  }

  var _proto10 = EmailRuleValidator.prototype;

  _proto10._validate = function _validate(value, rule) {
    if (rule.ignoreEmptyValue !== false && this._isValueEmpty(value)) {
      return true;
    }

    return rulesValidators.pattern.validate(value, (0, _extend.extend)({}, rule, {
      pattern: /^[\d\w._-]+@[\d\w._-]+\.[\w]+$/i
    }));
  };

  return EmailRuleValidator;
}(BaseRuleValidator);

var rulesValidators = {
  'required': new RequiredRuleValidator(),
  'numeric': new NumericRuleValidator(),
  'range': new RangeRuleValidator(),
  'stringLength': new StringLengthRuleValidator(),
  'custom': new CustomRuleValidator(),
  'async': new AsyncRuleValidator(),
  'compare': new CompareRuleValidator(),
  'pattern': new PatternRuleValidator(),
  'email': new EmailRuleValidator()
};

var GroupConfig = _class.default.inherit({
  ctor: function ctor(group) {
    this.group = group;
    this.validators = [];
    this._pendingValidators = [];
    this._onValidatorStatusChanged = this._onValidatorStatusChanged.bind(this);

    this._resetValidationInfo();

    this._eventsStrategy = new _events_strategy.EventsStrategy(this);
  },
  validate: function validate() {
    var _this11 = this;

    var result = {
      isValid: true,
      brokenRules: [],
      validators: [],
      status: STATUS.valid,
      complete: null
    };

    this._unsubscribeFromAllChangeEvents();

    this._pendingValidators = [];

    this._resetValidationInfo();

    (0, _iterator.each)(this.validators, function (_, validator) {
      var validatorResult = validator.validate();
      result.isValid = result.isValid && validatorResult.isValid;

      if (validatorResult.brokenRules) {
        result.brokenRules = result.brokenRules.concat(validatorResult.brokenRules);
      }

      result.validators.push(validator);

      if (validatorResult.status === STATUS.pending) {
        _this11._addPendingValidator(validator);
      }

      _this11._subscribeToChangeEvents(validator);
    });

    if (this._pendingValidators.length) {
      result.status = STATUS.pending;
    } else {
      result.status = result.isValid ? STATUS.valid : STATUS.invalid;

      this._unsubscribeFromAllChangeEvents();

      this._raiseValidatedEvent(result);
    }

    this._updateValidationInfo(result);

    return (0, _extend.extend)({}, this._validationInfo.result);
  },
  _subscribeToChangeEvents: function _subscribeToChangeEvents(validator) {
    validator.on('validating', this._onValidatorStatusChanged);
    validator.on('validated', this._onValidatorStatusChanged);
  },
  _unsubscribeFromChangeEvents: function _unsubscribeFromChangeEvents(validator) {
    validator.off('validating', this._onValidatorStatusChanged);
    validator.off('validated', this._onValidatorStatusChanged);
  },
  _unsubscribeFromAllChangeEvents: function _unsubscribeFromAllChangeEvents() {
    var _this12 = this;

    (0, _iterator.each)(this.validators, function (_, validator) {
      _this12._unsubscribeFromChangeEvents(validator);
    });
  },
  _updateValidationInfo: function _updateValidationInfo(result) {
    this._validationInfo.result = result;

    if (result.status !== STATUS.pending) {
      return;
    }

    if (!this._validationInfo.deferred) {
      this._validationInfo.deferred = new _deferred.Deferred();
      this._validationInfo.result.complete = this._validationInfo.deferred.promise();
    }
  },
  _addPendingValidator: function _addPendingValidator(validator) {
    var foundValidator = (0, _common.grep)(this._pendingValidators, function (val) {
      return val === validator;
    })[0];

    if (!foundValidator) {
      this._pendingValidators.push(validator);
    }
  },
  _removePendingValidator: function _removePendingValidator(validator) {
    var index = (0, _array.inArray)(validator, this._pendingValidators);

    if (index >= 0) {
      this._pendingValidators.splice(index, 1);
    }
  },
  _orderBrokenRules: function _orderBrokenRules(brokenRules) {
    var orderedRules = [];
    (0, _iterator.each)(this.validators, function (_, validator) {
      var foundRules = (0, _common.grep)(brokenRules, function (rule) {
        return rule.validator === validator;
      });

      if (foundRules.length) {
        orderedRules = orderedRules.concat(foundRules);
      }
    });
    return orderedRules;
  },
  _updateBrokenRules: function _updateBrokenRules(result) {
    if (!this._validationInfo.result) {
      return;
    }

    var brokenRules = this._validationInfo.result.brokenRules;
    var rules = (0, _common.grep)(brokenRules, function (rule) {
      return rule.validator !== result.validator;
    });

    if (result.brokenRules) {
      brokenRules = rules.concat(result.brokenRules);
    }

    this._validationInfo.result.brokenRules = this._orderBrokenRules(brokenRules);
  },
  _onValidatorStatusChanged: function _onValidatorStatusChanged(result) {
    if (result.status === STATUS.pending) {
      this._addPendingValidator(result.validator);

      return;
    }

    this._resolveIfComplete(result);
  },
  _resolveIfComplete: function _resolveIfComplete(result) {
    this._removePendingValidator(result.validator);

    this._updateBrokenRules(result);

    if (!this._pendingValidators.length) {
      this._unsubscribeFromAllChangeEvents();

      if (!this._validationInfo.result) {
        return;
      }

      this._validationInfo.result.status = this._validationInfo.result.brokenRules.length === 0 ? STATUS.valid : STATUS.invalid;
      this._validationInfo.result.isValid = this._validationInfo.result.status === STATUS.valid;
      var res = (0, _extend.extend)({}, this._validationInfo.result, {
        complete: null
      });
      var deferred = this._validationInfo.deferred;

      this._resetValidationInfo();

      this._raiseValidatedEvent(res);

      deferred && setTimeout(function () {
        deferred.resolve(res);
      });
    }
  },
  _raiseValidatedEvent: function _raiseValidatedEvent(result) {
    this._eventsStrategy.fireEvent('validated', [result]);
  },
  _resetValidationInfo: function _resetValidationInfo() {
    this._validationInfo = {
      result: null,
      deferred: null
    };
  },
  _synchronizeValidationInfo: function _synchronizeValidationInfo() {
    if (this._validationInfo.result) {
      this._validationInfo.result.validators = this.validators;
    }
  },
  removeRegisteredValidator: function removeRegisteredValidator(validator) {
    var index = (0, _array.inArray)(validator, this.validators);

    if (index > -1) {
      this.validators.splice(index, 1);

      this._synchronizeValidationInfo();

      this._resolveIfComplete({
        validator: validator
      });
    }
  },
  registerValidator: function registerValidator(validator) {
    if ((0, _array.inArray)(validator, this.validators) < 0) {
      this.validators.push(validator);

      this._synchronizeValidationInfo();
    }
  },
  reset: function reset() {
    (0, _iterator.each)(this.validators, function (_, validator) {
      validator.reset();
    });
    this._pendingValidators = [];

    this._resetValidationInfo();
  },
  on: function on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);

    return this;
  },
  off: function off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);

    return this;
  }
});

var ValidationEngine = {
  groups: [],
  getGroupConfig: function getGroupConfig(group) {
    var result = (0, _common.grep)(this.groups, function (config) {
      return config.group === group;
    });

    if (result.length) {
      return result[0];
    }
  },
  findGroup: function findGroup($element, model) {
    // try to find out if this control is child of validation group
    var $dxGroup = $element.parents('.dx-validationgroup').first();

    if ($dxGroup.length) {
      return $dxGroup.dxValidationGroup('instance');
    } // Trick to be able to securely get ViewModel instance ($data) in Knockout


    return model;
  },
  initGroups: function initGroups() {
    this.groups = [];
    this.addGroup();
  },
  addGroup: function addGroup(group) {
    var config = this.getGroupConfig(group);

    if (!config) {
      config = new GroupConfig(group);
      this.groups.push(config);
    }

    return config;
  },
  removeGroup: function removeGroup(group) {
    var config = this.getGroupConfig(group);
    var index = (0, _array.inArray)(config, this.groups);

    if (index > -1) {
      this.groups.splice(index, 1);
    }

    return config;
  },
  _setDefaultMessage: function _setDefaultMessage(info) {
    var rule = info.rule,
        validator = info.validator,
        name = info.name;

    if (!(0, _type.isDefined)(rule.message)) {
      if (validator.defaultFormattedMessage && (0, _type.isDefined)(name)) {
        rule.message = validator.defaultFormattedMessage(name);
      } else {
        rule.message = validator.defaultMessage();
      }
    }
  },
  _addBrokenRule: function _addBrokenRule(info) {
    var result = info.result,
        rule = info.rule;

    if (!result.brokenRule) {
      result.brokenRule = rule;
    }

    if (!result.brokenRules) {
      result.brokenRules = [];
    }

    result.brokenRules.push(rule);
  },
  validate: function validate(value, rules, name) {
    var _this13 = this;

    var result = {
      name: name,
      value: value,
      brokenRule: null,
      brokenRules: null,
      isValid: true,
      validationRules: rules,
      pendingRules: null,
      status: STATUS.valid,
      complete: null
    };
    var asyncRuleItems = [];
    (0, _iterator.each)(rules || [], function (_, rule) {
      var ruleValidator = rulesValidators[rule.type];
      var ruleValidationResult;

      if (ruleValidator) {
        if ((0, _type.isDefined)(rule.isValid) && rule.value === value && !rule.reevaluate) {
          if (!rule.isValid) {
            result.isValid = false;

            _this13._addBrokenRule({
              result: result,
              rule: rule
            });

            return false;
          }

          return true;
        }

        rule.value = value;

        if (rule.type === 'async') {
          asyncRuleItems.push({
            rule: rule,
            ruleValidator: ruleValidator
          });
          return true;
        }

        ruleValidationResult = ruleValidator.validate(value, rule);
        rule.isValid = ruleValidationResult;

        if (!ruleValidationResult) {
          result.isValid = false;

          _this13._setDefaultMessage({
            rule: rule,
            validator: ruleValidator,
            name: name
          });

          _this13._addBrokenRule({
            result: result,
            rule: rule
          });
        }

        if (!rule.isValid) {
          return false;
        }
      } else {
        throw _errors.default.Error('E0100');
      }
    });

    if (result.isValid && !result.brokenRules && asyncRuleItems.length) {
      result = this._validateAsyncRules({
        value: value,
        items: asyncRuleItems,
        result: result,
        name: name
      });
    }

    result.status = result.pendingRules ? STATUS.pending : result.isValid ? STATUS.valid : STATUS.invalid;
    return result;
  },
  _validateAsyncRules: function _validateAsyncRules(_ref) {
    var _this14 = this;

    var result = _ref.result,
        value = _ref.value,
        items = _ref.items,
        name = _ref.name;
    var asyncResults = [];
    (0, _iterator.each)(items, function (_, item) {
      var validateResult = item.ruleValidator.validate(value, item.rule);

      if (!(0, _type.isPromise)(validateResult)) {
        _this14._updateRuleConfig({
          rule: item.rule,
          ruleResult: _this14._getPatchedRuleResult(validateResult),
          validator: item.ruleValidator,
          name: name
        });
      } else {
        if (!result.pendingRules) {
          result.pendingRules = [];
        }

        result.pendingRules.push(item.rule);
        var asyncResult = validateResult.then(function (res) {
          var ruleResult = _this14._getPatchedRuleResult(res);

          _this14._updateRuleConfig({
            rule: item.rule,
            ruleResult: ruleResult,
            validator: item.ruleValidator,
            name: name
          });

          return ruleResult;
        });
        asyncResults.push(asyncResult);
      }
    });

    if (asyncResults.length) {
      result.complete = _promise.default.all(asyncResults).then(function (values) {
        return _this14._getAsyncRulesResult({
          result: result,
          values: values
        });
      });
    }

    return result;
  },
  _updateRuleConfig: function _updateRuleConfig(_ref2) {
    var rule = _ref2.rule,
        ruleResult = _ref2.ruleResult,
        validator = _ref2.validator,
        name = _ref2.name;
    rule.isValid = ruleResult.isValid;

    if (!ruleResult.isValid) {
      if ((0, _type.isDefined)(ruleResult.message) && (0, _type.isString)(ruleResult.message) && ruleResult.message.length) {
        rule.message = ruleResult.message;
      } else {
        this._setDefaultMessage({
          rule: rule,
          validator: validator,
          name: name
        });
      }
    }
  },
  _getPatchedRuleResult: function _getPatchedRuleResult(ruleResult) {
    var result;
    var isValid = true;

    if ((0, _type.isObject)(ruleResult)) {
      result = (0, _extend.extend)({}, ruleResult);

      if (!(0, _type.isDefined)(result.isValid)) {
        result.isValid = isValid;
      }
    } else {
      result = {
        isValid: (0, _type.isBoolean)(ruleResult) ? ruleResult : isValid
      };
    }

    return result;
  },
  _getAsyncRulesResult: function _getAsyncRulesResult(_ref3) {
    var _this15 = this;

    var values = _ref3.values,
        result = _ref3.result;
    (0, _iterator.each)(values, function (index, val) {
      if (val.isValid === false) {
        result.isValid = val.isValid;
        var rule = result.pendingRules[index];

        _this15._addBrokenRule({
          result: result,
          rule: rule
        });
      }
    });
    result.pendingRules = null;
    result.complete = null;
    result.status = result.isValid ? STATUS.valid : STATUS.invalid;
    return result;
  },
  registerValidatorInGroup: function registerValidatorInGroup(group, validator) {
    var groupConfig = ValidationEngine.addGroup(group);
    groupConfig.registerValidator.call(groupConfig, validator);
  },
  _shouldRemoveGroup: function _shouldRemoveGroup(group, validatorsInGroup) {
    var isDefaultGroup = group === undefined;
    var isValidationGroupInstance = group && group.NAME === 'dxValidationGroup';
    return !isDefaultGroup && !isValidationGroupInstance && !validatorsInGroup.length;
  },
  removeRegisteredValidator: function removeRegisteredValidator(group, validator) {
    var config = ValidationEngine.getGroupConfig(group);

    if (config) {
      config.removeRegisteredValidator.call(config, validator);
      var validatorsInGroup = config.validators;

      if (this._shouldRemoveGroup(group, validatorsInGroup)) {
        this.removeGroup(group);
      }
    }
  },
  initValidationOptions: function initValidationOptions(options) {
    var _this16 = this;

    var initedOptions = {};

    if (options) {
      var syncOptions = ['isValid', 'validationStatus', 'validationError', 'validationErrors'];
      syncOptions.forEach(function (prop) {
        if (prop in options) {
          (0, _extend.extend)(initedOptions, _this16.synchronizeValidationOptions({
            name: prop,
            value: options[prop]
          }, options));
        }
      });
    }

    return initedOptions;
  },
  synchronizeValidationOptions: function synchronizeValidationOptions(_ref4, options) {
    var name = _ref4.name,
        value = _ref4.value;

    switch (name) {
      case 'validationStatus':
        {
          var isValid = value === STATUS.valid || value === STATUS.pending;
          return options.isValid !== isValid ? {
            isValid: isValid
          } : {};
        }

      case 'isValid':
        {
          var validationStatus = options.validationStatus;
          var newStatus = validationStatus;

          if (value && validationStatus === STATUS.invalid) {
            newStatus = STATUS.valid;
          } else if (!value && validationStatus !== STATUS.invalid) {
            newStatus = STATUS.invalid;
          }

          return newStatus !== validationStatus ? {
            validationStatus: newStatus
          } : {};
        }

      case 'validationErrors':
        {
          var validationError = !value || !value.length ? null : value[0];
          return options.validationError !== validationError ? {
            validationError: validationError
          } : {};
        }

      case 'validationError':
        {
          var validationErrors = options.validationErrors;

          if (!value && validationErrors) {
            return {
              validationErrors: null
            };
          } else if (value && !validationErrors) {
            return {
              validationErrors: [value]
            };
          } else if (value && validationErrors && value !== validationErrors[0]) {
            validationErrors[0] = value;
            return {
              validationErrors: validationErrors.slice()
            };
          }
        }
    }

    return {};
  },
  validateGroup: function validateGroup(group) {
    var groupConfig = ValidationEngine.getGroupConfig(group);

    if (!groupConfig) {
      throw _errors.default.Error('E0110');
    }

    return groupConfig.validate();
  },
  resetGroup: function resetGroup(group) {
    var groupConfig = ValidationEngine.getGroupConfig(group);

    if (!groupConfig) {
      throw _errors.default.Error('E0110');
    }

    return groupConfig.reset();
  }
};
ValidationEngine.initGroups();
var _default = ValidationEngine;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _common = __webpack_require__(4);

var _extend = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _array_query = _interopRequireDefault(__webpack_require__(166));

var _utils = _interopRequireDefault(__webpack_require__(44));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function multiLevelGroup(query, groupInfo) {
  query = query.groupBy(groupInfo[0].selector);

  if (groupInfo.length > 1) {
    query = query.select(function (g) {
      return (0, _extend.extend)({}, g, {
        items: multiLevelGroup((0, _array_query.default)(g.items), groupInfo.slice(1)).toArray()
      });
    });
  }

  return query;
}

function arrangeSortingInfo(groupInfo, sortInfo) {
  var filteredGroup = [];
  (0, _iterator.each)(groupInfo, function (_, group) {
    var collision = (0, _common.grep)(sortInfo, function (sort) {
      return group.selector === sort.selector;
    });

    if (collision.length < 1) {
      filteredGroup.push(group);
    }
  });
  return filteredGroup.concat(sortInfo);
}

function queryByOptions(query, options, isCountQuery) {
  options = options || {};
  var filter = options.filter;

  if (filter) {
    query = query.filter(filter);
  }

  if (isCountQuery) {
    return query;
  }

  var sort = options.sort;
  var select = options.select;
  var group = options.group;
  var skip = options.skip;
  var take = options.take;

  if (group) {
    group = _utils.default.normalizeSortingInfo(group);
    group.keepInitialKeyOrder = !!options.group.keepInitialKeyOrder;
  }

  if (sort || group) {
    sort = _utils.default.normalizeSortingInfo(sort || []);

    if (group && !group.keepInitialKeyOrder) {
      sort = arrangeSortingInfo(group, sort);
    }

    (0, _iterator.each)(sort, function (index) {
      query = query[index ? 'thenBy' : 'sortBy'](this.selector, this.desc, this.compare);
    });
  }

  if (select) {
    query = query.select(select);
  }

  if (group) {
    query = multiLevelGroup(query, group);
  }

  if (take || skip) {
    query = query.slice(skip || 0, take);
  }

  return query;
}

var _default = {
  multiLevelGroup: multiLevelGroup,
  arrangeSortingInfo: arrangeSortingInfo,
  queryByOptions: queryByOptions
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.EventsStrategy = void 0;

var _callbacks = _interopRequireDefault(__webpack_require__(28));

var _iterator = __webpack_require__(3);

var _type = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EventsStrategy = /*#__PURE__*/function () {
  function EventsStrategy(owner) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this._events = {};
    this._owner = owner;
    this._options = options;
  }

  EventsStrategy.create = function create(owner, strategy) {
    if (strategy) {
      return (0, _type.isFunction)(strategy) ? strategy(owner) : strategy;
    } else {
      return new EventsStrategy(owner);
    }
  };

  var _proto = EventsStrategy.prototype;

  _proto.hasEvent = function hasEvent(eventName) {
    var callbacks = this._events[eventName];
    return callbacks ? callbacks.has() : false;
  };

  _proto.fireEvent = function fireEvent(eventName, eventArgs) {
    var callbacks = this._events[eventName];

    if (callbacks) {
      callbacks.fireWith(this._owner, eventArgs);
    }

    return this._owner;
  };

  _proto.on = function on(eventName, eventHandler) {
    var _this = this;

    if ((0, _type.isPlainObject)(eventName)) {
      (0, _iterator.each)(eventName, function (e, h) {
        _this.on(e, h);
      });
    } else {
      var callbacks = this._events[eventName];

      if (!callbacks) {
        callbacks = (0, _callbacks.default)({
          syncStrategy: this._options.syncStrategy
        });
        this._events[eventName] = callbacks;
      }

      var addFn = callbacks.originalAdd || callbacks.add;
      addFn.call(callbacks, eventHandler);
    }
  };

  _proto.off = function off(eventName, eventHandler) {
    var callbacks = this._events[eventName];

    if (callbacks) {
      if ((0, _type.isFunction)(eventHandler)) {
        callbacks.remove(eventHandler);
      } else {
        callbacks.empty();
      }
    }
  };

  _proto.dispose = function dispose() {
    (0, _iterator.each)(this._events, function (eventName, event) {
      event.empty();
    });
  };

  return EventsStrategy;
}();

exports.EventsStrategy = EventsStrategy;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _data_source = __webpack_require__(72);

var _extend = __webpack_require__(0);

var _utils = __webpack_require__(65);

var DATA_SOURCE_OPTIONS_METHOD = '_dataSourceOptions';
var DATA_SOURCE_CHANGED_METHOD = '_dataSourceChangedHandler';
var DATA_SOURCE_LOAD_ERROR_METHOD = '_dataSourceLoadErrorHandler';
var DATA_SOURCE_LOADING_CHANGED_METHOD = '_dataSourceLoadingChangedHandler';
var DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD = '_dataSourceFromUrlLoadMode';
var SPECIFIC_DATA_SOURCE_OPTION = '_getSpecificDataSourceOption';
var NORMALIZE_DATA_SOURCE = '_normalizeDataSource';
var DataHelperMixin = {
  postCtor: function postCtor() {
    this.on('disposing', function () {
      this._disposeDataSource();
    }.bind(this));
  },
  _refreshDataSource: function _refreshDataSource() {
    this._initDataSource();

    this._loadDataSource();
  },
  _initDataSource: function _initDataSource() {
    var dataSourceOptions = SPECIFIC_DATA_SOURCE_OPTION in this ? this[SPECIFIC_DATA_SOURCE_OPTION]() : this.option('dataSource');
    var widgetDataSourceOptions;
    var dataSourceType;

    this._disposeDataSource();

    if (dataSourceOptions) {
      if (dataSourceOptions instanceof _data_source.DataSource) {
        this._isSharedDataSource = true;
        this._dataSource = dataSourceOptions;
      } else {
        widgetDataSourceOptions = DATA_SOURCE_OPTIONS_METHOD in this ? this[DATA_SOURCE_OPTIONS_METHOD]() : {};
        dataSourceType = this._dataSourceType ? this._dataSourceType() : _data_source.DataSource;
        dataSourceOptions = (0, _utils.normalizeDataSourceOptions)(dataSourceOptions, {
          fromUrlLoadMode: DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD in this && this[DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD]()
        });
        this._dataSource = new dataSourceType((0, _extend.extend)(true, {}, widgetDataSourceOptions, dataSourceOptions));
      }

      if (NORMALIZE_DATA_SOURCE in this) {
        this._dataSource = this[NORMALIZE_DATA_SOURCE](this._dataSource);
      }

      this._addDataSourceHandlers();
    }
  },
  _addDataSourceHandlers: function _addDataSourceHandlers() {
    if (DATA_SOURCE_CHANGED_METHOD in this) {
      this._addDataSourceChangeHandler();
    }

    if (DATA_SOURCE_LOAD_ERROR_METHOD in this) {
      this._addDataSourceLoadErrorHandler();
    }

    if (DATA_SOURCE_LOADING_CHANGED_METHOD in this) {
      this._addDataSourceLoadingChangedHandler();
    }

    this._addReadyWatcher();
  },
  _addReadyWatcher: function _addReadyWatcher() {
    this._dataSource.on('loadingChanged', function (isLoading) {
      this._ready && this._ready(!isLoading);
    }.bind(this));
  },
  _addDataSourceChangeHandler: function _addDataSourceChangeHandler() {
    var dataSource = this._dataSource;

    this._proxiedDataSourceChangedHandler = function (e) {
      this[DATA_SOURCE_CHANGED_METHOD](dataSource.items(), e);
    }.bind(this);

    dataSource.on('changed', this._proxiedDataSourceChangedHandler);
  },
  _addDataSourceLoadErrorHandler: function _addDataSourceLoadErrorHandler() {
    this._proxiedDataSourceLoadErrorHandler = this[DATA_SOURCE_LOAD_ERROR_METHOD].bind(this);

    this._dataSource.on('loadError', this._proxiedDataSourceLoadErrorHandler);
  },
  _addDataSourceLoadingChangedHandler: function _addDataSourceLoadingChangedHandler() {
    this._proxiedDataSourceLoadingChangedHandler = this[DATA_SOURCE_LOADING_CHANGED_METHOD].bind(this);

    this._dataSource.on('loadingChanged', this._proxiedDataSourceLoadingChangedHandler);
  },
  _loadDataSource: function _loadDataSource() {
    if (this._dataSource) {
      var dataSource = this._dataSource;

      if (dataSource.isLoaded()) {
        this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler();
      } else {
        dataSource.load();
      }
    }
  },
  _loadSingle: function _loadSingle(key, value) {
    key = key === 'this' ? this._dataSource.key() || 'this' : key;
    return this._dataSource.loadSingle(key, value);
  },
  _isLastPage: function _isLastPage() {
    return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize;
  },
  _isDataSourceLoading: function _isDataSourceLoading() {
    return this._dataSource && this._dataSource.isLoading();
  },
  _disposeDataSource: function _disposeDataSource() {
    if (this._dataSource) {
      if (this._isSharedDataSource) {
        delete this._isSharedDataSource;
        this._proxiedDataSourceChangedHandler && this._dataSource.off('changed', this._proxiedDataSourceChangedHandler);
        this._proxiedDataSourceLoadErrorHandler && this._dataSource.off('loadError', this._proxiedDataSourceLoadErrorHandler);
        this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off('loadingChanged', this._proxiedDataSourceLoadingChangedHandler);
      } else {
        this._dataSource.dispose();
      }

      delete this._dataSource;
      delete this._proxiedDataSourceChangedHandler;
      delete this._proxiedDataSourceLoadErrorHandler;
      delete this._proxiedDataSourceLoadingChangedHandler;
    }
  },
  getDataSource: function getDataSource() {
    return this._dataSource || null;
  }
};
var _default = DataHelperMixin;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _index = __webpack_require__(8);

var _emitter = _interopRequireDefault(__webpack_require__(127));

var _emitter_registrator = _interopRequireDefault(__webpack_require__(104));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var abs = Math.abs;
var HOLD_EVENT_NAME = 'dxhold';
var HOLD_TIMEOUT = 750;
var TOUCH_BOUNDARY = 5;

var HoldEmitter = _emitter.default.inherit({
  start: function start(e) {
    this._startEventData = (0, _index.eventData)(e);

    this._startTimer(e);
  },
  _startTimer: function _startTimer(e) {
    var holdTimeout = 'timeout' in this ? this.timeout : HOLD_TIMEOUT;
    this._holdTimer = setTimeout(function () {
      this._requestAccept(e);

      this._fireEvent(HOLD_EVENT_NAME, e, {
        target: e.target
      });

      this._forgetAccept();
    }.bind(this), holdTimeout);
  },
  move: function move(e) {
    if (this._touchWasMoved(e)) {
      this._cancel(e);
    }
  },
  _touchWasMoved: function _touchWasMoved(e) {
    var delta = (0, _index.eventDelta)(this._startEventData, (0, _index.eventData)(e));
    return abs(delta.x) > TOUCH_BOUNDARY || abs(delta.y) > TOUCH_BOUNDARY;
  },
  end: function end() {
    this._stopTimer();
  },
  _stopTimer: function _stopTimer() {
    clearTimeout(this._holdTimer);
  },
  cancel: function cancel() {
    this._stopTimer();
  },
  dispose: function dispose() {
    this._stopTimer();
  }
});
/**
  * @name UI Events.dxhold
  * @type eventType
  * @type_function_param1 event:event
  * @module events/hold
*/


(0, _emitter_registrator.default)({
  emitter: HoldEmitter,
  bubble: true,
  events: [HOLD_EVENT_NAME]
});
var _default = {
  name: HOLD_EVENT_NAME
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.escapeServiceOperationParams = exports.formatFunctionInvocationUrl = exports.generateExpand = exports.generateSelect = exports.convertPrimitiveValue = exports.keyConverters = exports.serializeKey = exports.serializeValue = exports.serializePropName = exports.EdmLiteral = exports.sendRequest = void 0;

var _class = _interopRequireDefault(__webpack_require__(15));

var _extend = __webpack_require__(0);

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

var _ajax = _interopRequireDefault(__webpack_require__(80));

var _guid = _interopRequireDefault(__webpack_require__(36));

var _common = __webpack_require__(4);

var _deferred = __webpack_require__(6);

var _errors = __webpack_require__(37);

var _utils = _interopRequireDefault(__webpack_require__(44));

var _string = __webpack_require__(40);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var GUID_REGEX = /^(\{{0,1}([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\}{0,1})$/;
var VERBOSE_DATE_REGEX = /^\/Date\((-?\d+)((\+|-)?(\d+)?)\)\/$/;
var ISO8601_DATE_REGEX = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[-+]{1}\d{2}(:?)(\d{2})?)?$/; // Request processing

var JSON_VERBOSE_MIME_TYPE = 'application/json;odata=verbose';

var makeArray = function makeArray(value) {
  return (0, _type.type)(value) === 'string' ? value.split() : value;
};

var hasDot = function hasDot(x) {
  return /\./.test(x);
};

var pad = function pad(text, length, right) {
  text = String(text);

  while (text.length < length) {
    text = right ? "".concat(text, "0") : "0".concat(text);
  }

  return text;
};

var formatISO8601 = function formatISO8601(date, skipZeroTime, skipTimezone) {
  var bag = [];

  var isZeroTime = function isZeroTime() {
    return date.getHours() + date.getMinutes() + date.getSeconds() + date.getMilliseconds() < 1;
  };

  var padLeft2 = function padLeft2(text) {
    return pad(text, 2);
  };

  bag.push(date.getFullYear());
  bag.push('-');
  bag.push(padLeft2(date.getMonth() + 1));
  bag.push('-');
  bag.push(padLeft2(date.getDate()));

  if (!(skipZeroTime && isZeroTime())) {
    bag.push('T');
    bag.push(padLeft2(date.getHours()));
    bag.push(':');
    bag.push(padLeft2(date.getMinutes()));
    bag.push(':');
    bag.push(padLeft2(date.getSeconds()));

    if (date.getMilliseconds()) {
      bag.push('.');
      bag.push(pad(date.getMilliseconds(), 3));
    }

    if (!skipTimezone) {
      bag.push('Z');
    }
  }

  return bag.join('');
};

var parseISO8601 = function parseISO8601(isoString) {
  var result = new Date(new Date(0).getTimezoneOffset() * 60 * 1000);
  var chunks = isoString.replace('Z', '').split('T');
  var date = /(\d{4})-(\d{2})-(\d{2})/.exec(chunks[0]);
  var time = /(\d{2}):(\d{2}):(\d{2})\.?(\d{0,7})?/.exec(chunks[1]);
  result.setFullYear(Number(date[1]));
  result.setMonth(Number(date[2]) - 1);
  result.setDate(Number(date[3]));

  if (Array.isArray(time) && time.length) {
    result.setHours(Number(time[1]));
    result.setMinutes(Number(time[2]));
    result.setSeconds(Number(time[3]));
    var fractional = (time[4] || '').slice(0, 3);
    fractional = pad(fractional, 3, true);
    result.setMilliseconds(Number(fractional));
  }

  return result;
};

var isAbsoluteUrl = function isAbsoluteUrl(url) {
  return /^(?:[a-z]+:)?\/\//i.test(url);
};

var stripParams = function stripParams(url) {
  var index = url.indexOf('?');

  if (index > -1) {
    return url.substr(0, index);
  }

  return url;
};

var toAbsoluteUrl = function toAbsoluteUrl(basePath, relativePath) {
  var part;
  var baseParts = stripParams(basePath).split('/');
  var relativeParts = relativePath.split('/');
  baseParts.pop();

  while (relativeParts.length) {
    part = relativeParts.shift();

    if (part === '..') {
      baseParts.pop();
    } else {
      baseParts.push(part);
    }
  }

  return baseParts.join('/');
};

var param = function param(params) {
  var result = [];

  for (var name in params) {
    result.push(name + '=' + params[name]);
  }

  return result.join('&');
};

var ajaxOptionsForRequest = function ajaxOptionsForRequest(protocolVersion, request) {
  var _options$beforeSend;

  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var formatPayload = function formatPayload(payload) {
    return JSON.stringify(payload, function (key, value) {
      if (!(this[key] instanceof Date)) {
        return value;
      }

      value = formatISO8601(this[key]);

      switch (protocolVersion) {
        case 2:
          return value.substr(0, value.length - 1);

        case 3:
        case 4:
          return value;

        default:
          throw _errors.errors.Error('E4002');
      }
    });
  };

  request = (0, _extend.extend)({
    async: true,
    method: 'get',
    url: '',
    params: {},
    payload: null,
    headers: {},
    timeout: 30000
  }, request);
  (_options$beforeSend = options.beforeSend) === null || _options$beforeSend === void 0 ? void 0 : _options$beforeSend.call(options, request);
  var _request = request,
      async = _request.async,
      timeout = _request.timeout,
      headers = _request.headers;
  var _request2 = request,
      url = _request2.url,
      method = _request2.method;
  var jsonp = options.jsonp,
      withCredentials = options.withCredentials;
  method = (method || 'get').toLowerCase();
  var isGet = method === 'get';
  var useJsonp = isGet && jsonp;
  var params = (0, _extend.extend)({}, request.params);
  var ajaxData = isGet ? params : formatPayload(request.payload);
  var qs = !isGet && param(params);
  var contentType = !isGet && JSON_VERBOSE_MIME_TYPE;

  if (qs) {
    url += (url.indexOf('?') > -1 ? '&' : '?') + qs;
  }

  if (useJsonp) {
    ajaxData['$format'] = 'json';
  }

  return {
    url: url,
    data: ajaxData,
    dataType: useJsonp ? 'jsonp' : 'json',
    jsonp: useJsonp && '$callback',
    method: method,
    async: async,
    timeout: timeout,
    headers: headers,
    contentType: contentType,
    accepts: {
      json: [JSON_VERBOSE_MIME_TYPE, 'text/plain'].join()
    },
    xhrFields: {
      withCredentials: withCredentials
    }
  };
};

var sendRequest = function sendRequest(protocolVersion, request, options) {
  var deserializeDates = options.deserializeDates,
      fieldTypes = options.fieldTypes,
      countOnly = options.countOnly,
      isPaged = options.isPaged;
  var d = new _deferred.Deferred();
  var ajaxOptions = ajaxOptionsForRequest(protocolVersion, request, options);

  _ajax.default.sendRequest(ajaxOptions).always(function (obj, textStatus) {
    var transformOptions = {
      deserializeDates: deserializeDates,
      fieldTypes: fieldTypes
    };
    var tuple = interpretJsonFormat(obj, textStatus, transformOptions, ajaxOptions);
    var error = tuple.error,
        data = tuple.data,
        count = tuple.count;
    var nextUrl = tuple.nextUrl;

    if (error) {
      if (error.message !== _utils.default.XHR_ERROR_UNLOAD) {
        d.reject(error);
      }
    } else if (countOnly) {
      if (isFinite(count)) {
        d.resolve(count);
      } else {
        d.reject(new _errors.errors.Error('E4018'));
      }
    } else if (nextUrl && !isPaged) {
      if (!isAbsoluteUrl(nextUrl)) {
        nextUrl = toAbsoluteUrl(ajaxOptions.url, nextUrl);
      }

      sendRequest(protocolVersion, {
        url: nextUrl
      }, options).fail(d.reject).done(function (nextData) {
        return d.resolve(data.concat(nextData));
      });
    } else {
      var extra = isFinite(count) ? {
        totalCount: count
      } : undefined;
      d.resolve(data, extra);
    }
  });

  return d.promise();
};

exports.sendRequest = sendRequest;

var formatDotNetError = function formatDotNetError(errorObj) {
  var message;
  var currentError = errorObj;

  if ('message' in errorObj) {
    var _errorObj$message;

    message = ((_errorObj$message = errorObj.message) === null || _errorObj$message === void 0 ? void 0 : _errorObj$message.value) || errorObj.message;
  }

  while (currentError = currentError['innererror'] || currentError['internalexception']) {
    message = currentError.message;

    if (currentError['internalexception'] && message.indexOf('inner exception') === -1) {
      break;
    }
  }

  return message;
}; // TODO split: decouple HTTP errors from OData errors


var errorFromResponse = function errorFromResponse(obj, textStatus, ajaxOptions) {
  var _response, _response2, _response3, _response4;

  if (textStatus === 'nocontent') {
    return null; // workaround for http://bugs.jquery.com/ticket/13292
  }

  var message = 'Unknown error';
  var response = obj;
  var httpStatus = 200;
  var errorData = {
    requestOptions: ajaxOptions
  };

  if (textStatus !== 'success') {
    var status = obj.status,
        responseText = obj.responseText;
    httpStatus = status;
    message = _utils.default.errorMessageFromXhr(obj, textStatus);

    try {
      response = JSON.parse(responseText);
    } catch (x) {}
  }

  var errorObj = ((_response = response) === null || _response === void 0 ? void 0 : _response.then) || ((_response2 = response) === null || _response2 === void 0 ? void 0 : _response2.error) || ((_response3 = response) === null || _response3 === void 0 ? void 0 : _response3['odata.error']) || ((_response4 = response) === null || _response4 === void 0 ? void 0 : _response4['@odata.error']); // NOTE: $.Deferred rejected and response contain error message
  // NOTE: $.Deferred resolved with odata error

  if (errorObj) {
    message = formatDotNetError(errorObj) || message;
    errorData.errorDetails = errorObj;

    if (httpStatus === 200) {
      httpStatus = 500;
    }

    var customCode = Number(errorObj.code);

    if (isFinite(customCode) && customCode >= 400) {
      httpStatus = customCode;
    }
  }

  if (httpStatus >= 400 || httpStatus === 0) {
    errorData.httpStatus = httpStatus;
    return (0, _extend.extend)(Error(message), errorData);
  }

  return null;
};

var interpretJsonFormat = function interpretJsonFormat(obj, textStatus, transformOptions, ajaxOptions) {
  var error = errorFromResponse(obj, textStatus, ajaxOptions);

  if (error) {
    return {
      error: error
    };
  }

  if (!(0, _type.isPlainObject)(obj)) {
    return {
      data: obj
    };
  }

  var value = 'd' in obj && (Array.isArray(obj.d) || (0, _type.isObject)(obj.d)) ? interpretVerboseJsonFormat(obj, textStatus) : interpretLightJsonFormat(obj, textStatus);
  transformTypes(value, transformOptions);
  return value;
};

var interpretVerboseJsonFormat = function interpretVerboseJsonFormat(_ref) {
  var _data$results;

  var data = _ref.d;

  if (!(0, _type.isDefined)(data)) {
    return {
      error: Error('Malformed or unsupported JSON response received')
    };
  }

  return {
    data: (_data$results = data.results) !== null && _data$results !== void 0 ? _data$results : data,
    nextUrl: data.__next,
    count: parseInt(data.__count, 10)
  };
};

var interpretLightJsonFormat = function interpretLightJsonFormat(obj) {
  var _obj$value;

  return {
    data: (_obj$value = obj.value) !== null && _obj$value !== void 0 ? _obj$value : obj,
    nextUrl: obj['@odata.nextLink'],
    count: parseInt(obj['@odata.count'], 10)
  };
}; // Serialization and parsing


var EdmLiteral = _class.default.inherit({
  /**
  * @name EdmLiteral.ctor
  * @publicName ctor(value)
  * @param1 value:string
  */
  ctor: function ctor(value) {
    this._value = value;
  },
  valueOf: function valueOf() {
    return this._value;
  }
});

exports.EdmLiteral = EdmLiteral;

var transformTypes = function transformTypes(obj) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _iterator.each)(obj, function (key, value) {
    if (value !== null && _typeof(value) === 'object') {
      if ('results' in value) {
        obj[key] = value.results;
      }

      transformTypes(obj[key], options);
    } else if (typeof value === 'string') {
      var fieldTypes = options.fieldTypes,
          deserializeDates = options.deserializeDates;
      var canBeGuid = !fieldTypes || fieldTypes[key] !== 'String';

      if (canBeGuid && GUID_REGEX.test(value)) {
        obj[key] = new _guid.default(value);
      }

      if (deserializeDates !== false) {
        if (value.match(VERBOSE_DATE_REGEX)) {
          var date = new Date(Number(RegExp.$1) + RegExp.$2 * 60 * 1000);
          obj[key] = new Date(date.valueOf() + date.getTimezoneOffset() * 60 * 1000);
        } else if (ISO8601_DATE_REGEX.test(value)) {
          obj[key] = new Date(parseISO8601(obj[key]).valueOf());
        }
      }
    }
  });
};

var serializeDate = function serializeDate(date) {
  return "datetime'".concat(formatISO8601(date, true, true), "'");
};

var serializeString = function serializeString(value) {
  return "'".concat(value.replace(/'/g, '\'\''), "'");
};

var serializePropName = function serializePropName(propName) {
  return propName instanceof EdmLiteral ? propName.valueOf() : propName.replace(/\./g, '/');
};

exports.serializePropName = serializePropName;

var serializeValueV4 = function serializeValueV4(value) {
  if (value instanceof Date) {
    return formatISO8601(value, false, false);
  }

  if (value instanceof _guid.default) {
    return value.valueOf();
  }

  if (Array.isArray(value)) {
    return "[".concat(value.map(function (item) {
      return serializeValueV4(item);
    }).join(','), "]");
  }

  return serializeValueV2(value);
};

var serializeValueV2 = function serializeValueV2(value) {
  if (value instanceof Date) {
    return serializeDate(value);
  }

  if (value instanceof _guid.default) {
    return "guid'".concat(value, "'");
  }

  if (value instanceof EdmLiteral) {
    return value.valueOf();
  }

  if (typeof value === 'string') {
    return serializeString(value);
  }

  return String(value);
};

var serializeValue = function serializeValue(value, protocolVersion) {
  switch (protocolVersion) {
    case 2:
    case 3:
      return serializeValueV2(value);

    case 4:
      return serializeValueV4(value);

    default:
      throw _errors.errors.Error('E4002');
  }
};

exports.serializeValue = serializeValue;

var serializeKey = function serializeKey(key, protocolVersion) {
  if ((0, _type.isPlainObject)(key)) {
    var parts = [];
    (0, _iterator.each)(key, function (k, v) {
      return parts.push("".concat(serializePropName(k), "=").concat(serializeValue(v, protocolVersion)));
    });
    return parts.join();
  }

  return serializeValue(key, protocolVersion);
};

exports.serializeKey = serializeKey;
var keyConverters = {
  String: function String(value) {
    return "".concat(value);
  },
  Int32: function Int32(value) {
    return Math.floor(value);
  },
  Int64: function Int64(value) {
    return value instanceof EdmLiteral ? value : new EdmLiteral("".concat(value, "L"));
  },
  Guid: function Guid(value) {
    return value instanceof _guid.default ? value : new _guid.default(value);
  },
  Boolean: function Boolean(value) {
    return !!value;
  },
  Single: function Single(value) {
    return value instanceof EdmLiteral ? value : new EdmLiteral(value + 'f');
  },
  Decimal: function Decimal(value) {
    return value instanceof EdmLiteral ? value : new EdmLiteral(value + 'm');
  }
};
exports.keyConverters = keyConverters;

var convertPrimitiveValue = function convertPrimitiveValue(type, value) {
  if (value === null) return null;
  var converter = keyConverters[type];

  if (!converter) {
    throw _errors.errors.Error('E4014', type);
  }

  return converter(value);
};

exports.convertPrimitiveValue = convertPrimitiveValue;

var generateSelect = function generateSelect(oDataVersion, select) {
  if (!select) {
    return;
  }

  return oDataVersion < 4 ? serializePropName(select.join()) : (0, _common.grep)(select, hasDot, true).join();
};

exports.generateSelect = generateSelect;

var formatCore = function formatCore(hash) {
  var result = '';
  var selectValue = [];
  var expandValue = [];
  (0, _iterator.each)(hash, function (key, value) {
    if (Array.isArray(value)) {
      [].push.apply(selectValue, value);
    }

    if ((0, _type.isPlainObject)(value)) {
      expandValue.push("".concat(key).concat(formatCore(value)));
    }
  });

  if (selectValue.length || expandValue.length) {
    result += '(';

    if (selectValue.length) {
      result += "$select=".concat((0, _iterator.map)(selectValue, serializePropName).join());
    }

    if (expandValue.length) {
      if (selectValue.length) {
        result += ';';
      }

      result += "$expand=".concat((0, _iterator.map)(expandValue, serializePropName).join());
    }

    result += ')';
  }

  return result;
};

var format = function format(hash) {
  var result = [];
  (0, _iterator.each)(hash, function (key, value) {
    return result.push("".concat(key).concat(formatCore(value)));
  });
  return result.join();
};

var parseCore = function parseCore(exprParts, root, stepper) {
  var result = stepper(root, exprParts.shift(), exprParts);

  if (result === false) {
    return;
  }

  parseCore(exprParts, result, stepper);
};

var parseTree = function parseTree(exprs, root, stepper) {
  return (0, _iterator.each)(exprs, function (_, x) {
    return parseCore(x.split('.'), root, stepper);
  });
};

var generatorV2 = function generatorV2(expand, select) {
  var hash = {};

  if (expand) {
    (0, _iterator.each)(makeArray(expand), function () {
      hash[serializePropName(this)] = 1;
    });
  }

  if (select) {
    (0, _iterator.each)(makeArray(select), function () {
      var path = this.split('.');

      if (path.length < 2) {
        return;
      }

      path.pop();
      hash[serializePropName(path.join('.'))] = 1;
    });
  }

  return (0, _iterator.map)(hash, function (_, v) {
    return v;
  }).join();
};

var generatorV4 = function generatorV4(expand, select) {
  var hash = {};

  if (expand || select) {
    if (expand) {
      parseTree(makeArray(expand), hash, function (node, key, path) {
        node[key] = node[key] || {};
        return !path.length ? false : node[key];
      });
    }

    if (select) {
      parseTree((0, _common.grep)(makeArray(select), hasDot), hash, function (node, key, path) {
        if (!path.length) {
          node[key] = node[key] || [];
          node[key].push(key);
          return false;
        }

        return node[key] = node[key] || {};
      });
    }

    return format(hash);
  }
};

var generateExpand = function generateExpand(oDataVersion, expand, select) {
  return oDataVersion < 4 ? generatorV2(expand, select) : generatorV4(expand, select);
};

exports.generateExpand = generateExpand;

var formatFunctionInvocationUrl = function formatFunctionInvocationUrl(baseUrl, args) {
  return (0, _string.format)('{0}({1})', baseUrl, (0, _iterator.map)(args || {}, function (value, key) {
    return (0, _string.format)('{0}={1}', key, value);
  }).join(','));
};

exports.formatFunctionInvocationUrl = formatFunctionInvocationUrl;

var escapeServiceOperationParams = function escapeServiceOperationParams(params, version) {
  if (!params) {
    return params;
  } // From WCF Data Services docs:
  // The type of each parameter must be a primitive type.
  // Any data of a non-primitive type must be serialized and passed into a string parameter


  var result = {};
  (0, _iterator.each)(params, function (k, v) {
    result[k] = serializeValue(v, version);
  });
  return result;
};

exports.escapeServiceOperationParams = escapeServiceOperationParams;

/***/ }),
/* 100 */,
/* 101 */,
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;
var standardColorNames = {
  'aliceblue': 'f0f8ff',
  'antiquewhite': 'faebd7',
  'aqua': '00ffff',
  'aquamarine': '7fffd4',
  'azure': 'f0ffff',
  'beige': 'f5f5dc',
  'bisque': 'ffe4c4',
  'black': '000000',
  'blanchedalmond': 'ffebcd',
  'blue': '0000ff',
  'blueviolet': '8a2be2',
  'brown': 'a52a2a',
  'burlywood': 'deb887',
  'cadetblue': '5f9ea0',
  'chartreuse': '7fff00',
  'chocolate': 'd2691e',
  'coral': 'ff7f50',
  'cornflowerblue': '6495ed',
  'cornsilk': 'fff8dc',
  'crimson': 'dc143c',
  'cyan': '00ffff',
  'darkblue': '00008b',
  'darkcyan': '008b8b',
  'darkgoldenrod': 'b8860b',
  'darkgray': 'a9a9a9',
  'darkgreen': '006400',
  'darkkhaki': 'bdb76b',
  'darkmagenta': '8b008b',
  'darkolivegreen': '556b2f',
  'darkorange': 'ff8c00',
  'darkorchid': '9932cc',
  'darkred': '8b0000',
  'darksalmon': 'e9967a',
  'darkseagreen': '8fbc8f',
  'darkslateblue': '483d8b',
  'darkslategray': '2f4f4f',
  'darkturquoise': '00ced1',
  'darkviolet': '9400d3',
  'deeppink': 'ff1493',
  'deepskyblue': '00bfff',
  'dimgray': '696969',
  'dodgerblue': '1e90ff',
  'feldspar': 'd19275',
  'firebrick': 'b22222',
  'floralwhite': 'fffaf0',
  'forestgreen': '228b22',
  'fuchsia': 'ff00ff',
  'gainsboro': 'dcdcdc',
  'ghostwhite': 'f8f8ff',
  'gold': 'ffd700',
  'goldenrod': 'daa520',
  'gray': '808080',
  'green': '008000',
  'greenyellow': 'adff2f',
  'honeydew': 'f0fff0',
  'hotpink': 'ff69b4',
  'indianred': 'cd5c5c',
  'indigo': '4b0082',
  'ivory': 'fffff0',
  'khaki': 'f0e68c',
  'lavender': 'e6e6fa',
  'lavenderblush': 'fff0f5',
  'lawngreen': '7cfc00',
  'lemonchiffon': 'fffacd',
  'lightblue': 'add8e6',
  'lightcoral': 'f08080',
  'lightcyan': 'e0ffff',
  'lightgoldenrodyellow': 'fafad2',
  'lightgrey': 'd3d3d3',
  'lightgreen': '90ee90',
  'lightpink': 'ffb6c1',
  'lightsalmon': 'ffa07a',
  'lightseagreen': '20b2aa',
  'lightskyblue': '87cefa',
  'lightslateblue': '8470ff',
  'lightslategray': '778899',
  'lightsteelblue': 'b0c4de',
  'lightyellow': 'ffffe0',
  'lime': '00ff00',
  'limegreen': '32cd32',
  'linen': 'faf0e6',
  'magenta': 'ff00ff',
  'maroon': '800000',
  'mediumaquamarine': '66cdaa',
  'mediumblue': '0000cd',
  'mediumorchid': 'ba55d3',
  'mediumpurple': '9370d8',
  'mediumseagreen': '3cb371',
  'mediumslateblue': '7b68ee',
  'mediumspringgreen': '00fa9a',
  'mediumturquoise': '48d1cc',
  'mediumvioletred': 'c71585',
  'midnightblue': '191970',
  'mintcream': 'f5fffa',
  'mistyrose': 'ffe4e1',
  'moccasin': 'ffe4b5',
  'navajowhite': 'ffdead',
  'navy': '000080',
  'oldlace': 'fdf5e6',
  'olive': '808000',
  'olivedrab': '6b8e23',
  'orange': 'ffa500',
  'orangered': 'ff4500',
  'orchid': 'da70d6',
  'palegoldenrod': 'eee8aa',
  'palegreen': '98fb98',
  'paleturquoise': 'afeeee',
  'palevioletred': 'd87093',
  'papayawhip': 'ffefd5',
  'peachpuff': 'ffdab9',
  'peru': 'cd853f',
  'pink': 'ffc0cb',
  'plum': 'dda0dd',
  'powderblue': 'b0e0e6',
  'purple': '800080',
  'rebeccapurple': '663399',
  'red': 'ff0000',
  'rosybrown': 'bc8f8f',
  'royalblue': '4169e1',
  'saddlebrown': '8b4513',
  'salmon': 'fa8072',
  'sandybrown': 'f4a460',
  'seagreen': '2e8b57',
  'seashell': 'fff5ee',
  'sienna': 'a0522d',
  'silver': 'c0c0c0',
  'skyblue': '87ceeb',
  'slateblue': '6a5acd',
  'slategray': '708090',
  'snow': 'fffafa',
  'springgreen': '00ff7f',
  'steelblue': '4682b4',
  'tan': 'd2b48c',
  'teal': '008080',
  'thistle': 'd8bfd8',
  'tomato': 'ff6347',
  'turquoise': '40e0d0',
  'violet': 'ee82ee',
  'violetred': 'd02090',
  'wheat': 'f5deb3',
  'white': 'ffffff',
  'whitesmoke': 'f5f5f5',
  'yellow': 'ffff00',
  'yellowgreen': '9acd32'
}; // array of color definition objects

var standardColorTypes = [{
  re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
  process: function process(colorString) {
    return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10)];
  }
}, {
  re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*\.*\d+)\)$/,
  process: function process(colorString) {
    return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10), parseFloat(colorString[4])];
  }
}, {
  re: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/,
  process: function process(colorString) {
    return [parseInt(colorString[1], 16), parseInt(colorString[2], 16), parseInt(colorString[3], 16)];
  }
}, {
  re: /^#([a-f0-9]{1})([a-f0-9]{1})([a-f0-9]{1})$/,
  process: function process(colorString) {
    return [parseInt(colorString[1] + colorString[1], 16), parseInt(colorString[2] + colorString[2], 16), parseInt(colorString[3] + colorString[3], 16)];
  }
}, {
  re: /^hsv\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
  process: function process(colorString) {
    var h = parseInt(colorString[1], 10);
    var s = parseInt(colorString[2], 10);
    var v = parseInt(colorString[3], 10);
    var rgb = hsvToRgb(h, s, v);
    return [rgb[0], rgb[1], rgb[2], 1, [h, s, v]];
  }
}, {
  re: /^hsl\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
  process: function process(colorString) {
    var h = parseInt(colorString[1], 10);
    var s = parseInt(colorString[2], 10);
    var l = parseInt(colorString[3], 10);
    var rgb = hslToRgb(h, s, l);
    return [rgb[0], rgb[1], rgb[2], 1, null, [h, s, l]];
  }
}];
var _round = Math.round;

function Color(value) {
  this.baseColor = value;
  var color;

  if (value) {
    color = String(value).toLowerCase().replace(/ /g, '');
    color = standardColorNames[color] ? '#' + standardColorNames[color] : color;
    color = parseColor(color);
  }

  if (!color) {
    this.colorIsInvalid = true;
  }

  color = color || {};
  this.r = normalize(color[0]);
  this.g = normalize(color[1]);
  this.b = normalize(color[2]);
  this.a = normalize(color[3], 1, 1);

  if (color[4]) {
    this.hsv = {
      h: color[4][0],
      s: color[4][1],
      v: color[4][2]
    };
  } else {
    this.hsv = toHsvFromRgb(this.r, this.g, this.b);
  }

  if (color[5]) {
    this.hsl = {
      h: color[5][0],
      s: color[5][1],
      l: color[5][2]
    };
  } else {
    this.hsl = toHslFromRgb(this.r, this.g, this.b);
  }
}

function parseColor(color) {
  if (color === 'transparent') {
    return [0, 0, 0, 0];
  }

  var i = 0;
  var ii = standardColorTypes.length;
  var str;

  for (; i < ii; ++i) {
    str = standardColorTypes[i].re.exec(color);

    if (str) {
      return standardColorTypes[i].process(str);
    }
  }

  return null;
}

function normalize(colorComponent, def, max) {
  def = def || 0;
  max = max || 255;
  return colorComponent < 0 || isNaN(colorComponent) ? def : colorComponent > max ? max : colorComponent;
}

function toHexFromRgb(r, g, b) {
  return '#' + (0X01000000 | r << 16 | g << 8 | b).toString(16).slice(1);
}

function toHsvFromRgb(r, g, b) {
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var delta = max - min;
  var H;
  var S;
  var V = max;
  S = max === 0 ? 0 : 1 - min / max;

  if (max === min) {
    H = 0;
  } else {
    switch (max) {
      case r:
        H = 60 * ((g - b) / delta);

        if (g < b) {
          H = H + 360;
        }

        break;

      case g:
        H = 60 * ((b - r) / delta) + 120;
        break;

      case b:
        H = 60 * ((r - g) / delta) + 240;
        break;
    }
  }

  S *= 100;
  V *= 100 / 255;
  return {
    h: Math.round(H),
    s: Math.round(S),
    v: Math.round(V)
  };
}

function hsvToRgb(h, s, v) {
  var index = Math.floor(h % 360 / 60);
  var vMin = (100 - s) * v / 100;
  var a = (v - vMin) * (h % 60 / 60);
  var vInc = vMin + a;
  var vDec = v - a;
  var r;
  var g;
  var b;

  switch (index) {
    /* eslint-disable no-multi-spaces */
    case 0:
      r = v;
      g = vInc;
      b = vMin;
      break;

    case 1:
      r = vDec;
      g = v;
      b = vMin;
      break;

    case 2:
      r = vMin;
      g = v;
      b = vInc;
      break;

    case 3:
      r = vMin;
      g = vDec;
      b = v;
      break;

    case 4:
      r = vInc;
      g = vMin;
      b = v;
      break;

    case 5:
      r = v;
      g = vMin;
      b = vDec;
      break;

    /* eslint-enable no-multi-spaces */
  }

  return [Math.round(r * 2.55), Math.round(g * 2.55), Math.round(b * 2.55)];
}

function calculateHue(r, g, b, delta) {
  var max = Math.max(r, g, b);

  switch (max) {
    case r:
      return (g - b) / delta + (g < b ? 6 : 0);

    case g:
      return (b - r) / delta + 2;

    case b:
      return (r - g) / delta + 4;
  }
}

function toHslFromRgb(r, g, b) {
  r = convertTo01Bounds(r, 255);
  g = convertTo01Bounds(g, 255);
  b = convertTo01Bounds(b, 255);
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var maxMinSum = max + min;
  var h;
  var s;
  var l = maxMinSum / 2;

  if (max === min) {
    h = s = 0;
  } else {
    var delta = max - min;

    if (l > 0.5) {
      s = delta / (2 - maxMinSum);
    } else {
      s = delta / maxMinSum;
    }

    h = calculateHue(r, g, b, delta);
    h /= 6;
  }

  return {
    h: _round(h * 360),
    s: _round(s * 100),
    l: _round(l * 100)
  };
}

function makeColorTint(colorPart, h) {
  var colorTint = h;

  if (colorPart === 'r') {
    colorTint = h + 1 / 3;
  }

  if (colorPart === 'b') {
    colorTint = h - 1 / 3;
  }

  return colorTint;
}

function modifyColorTint(colorTint) {
  if (colorTint < 0) {
    colorTint += 1;
  }

  if (colorTint > 1) {
    colorTint -= 1;
  }

  return colorTint;
}

function hueToRgb(p, q, colorTint) {
  colorTint = modifyColorTint(colorTint);

  if (colorTint < 1 / 6) {
    return p + (q - p) * 6 * colorTint;
  }

  if (colorTint < 1 / 2) {
    return q;
  }

  if (colorTint < 2 / 3) {
    return p + (q - p) * (2 / 3 - colorTint) * 6;
  }

  return p;
}

function hslToRgb(h, s, l) {
  var r;
  var g;
  var b;
  h = convertTo01Bounds(h, 360);
  s = convertTo01Bounds(s, 100);
  l = convertTo01Bounds(l, 100);

  if (s === 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hueToRgb(p, q, makeColorTint('r', h));
    g = hueToRgb(p, q, makeColorTint('g', h));
    b = hueToRgb(p, q, makeColorTint('b', h));
  }

  return [_round(r * 255), _round(g * 255), _round(b * 255)];
}

function convertTo01Bounds(n, max) {
  n = Math.min(max, Math.max(0, parseFloat(n)));

  if (Math.abs(n - max) < 0.000001) {
    return 1;
  }

  return n % max / parseFloat(max);
}

function isIntegerBetweenMinAndMax(number, min, max) {
  min = min || 0;
  max = max || 255;

  if (number % 1 !== 0 || number < min || number > max || typeof number !== 'number' || isNaN(number)) {
    return false;
  }

  return true;
}

Color.prototype = {
  constructor: Color,
  highlight: function highlight(step) {
    step = step || 10;
    return this.alter(step).toHex();
  },
  darken: function darken(step) {
    step = step || 10;
    return this.alter(-step).toHex();
  },
  alter: function alter(step) {
    var result = new Color();
    result.r = normalize(this.r + step);
    result.g = normalize(this.g + step);
    result.b = normalize(this.b + step);
    return result;
  },
  blend: function blend(blendColor, opacity) {
    var other = blendColor instanceof Color ? blendColor : new Color(blendColor);
    var result = new Color();
    result.r = normalize(_round(this.r * (1 - opacity) + other.r * opacity));
    result.g = normalize(_round(this.g * (1 - opacity) + other.g * opacity));
    result.b = normalize(_round(this.b * (1 - opacity) + other.b * opacity));
    return result;
  },
  toHex: function toHex() {
    return toHexFromRgb(this.r, this.g, this.b);
  },
  getPureColor: function getPureColor() {
    var rgb = hsvToRgb(this.hsv.h, 100, 100);
    return new Color('rgb(' + rgb.join(',') + ')');
  },
  isValidHex: function isValidHex(hex) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
  },
  isValidRGB: function isValidRGB(r, g, b) {
    if (!isIntegerBetweenMinAndMax(r) || !isIntegerBetweenMinAndMax(g) || !isIntegerBetweenMinAndMax(b)) {
      return false;
    }

    return true;
  },
  isValidAlpha: function isValidAlpha(a) {
    if (isNaN(a) || a < 0 || a > 1 || typeof a !== 'number') {
      return false;
    }

    return true;
  },
  colorIsInvalid: false,
  fromHSL: function fromHSL(hsl) {
    var color = new Color();
    var rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
    color.r = rgb[0];
    color.g = rgb[1];
    color.b = rgb[2];
    return color;
  }
};
var _default = Color;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _window = __webpack_require__(7);

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _callbacks = _interopRequireDefault(__webpack_require__(28));

var _ready_callbacks = _interopRequireDefault(__webpack_require__(51));

var _call_once = _interopRequireDefault(__webpack_require__(79));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var resizeCallbacks = function () {
  var prevSize;
  var callbacks = (0, _callbacks.default)();
  var originalCallbacksAdd = callbacks.add;
  var originalCallbacksRemove = callbacks.remove;

  if (!(0, _window.hasWindow)()) {
    return callbacks;
  }

  var formatSize = function formatSize() {
    var window = (0, _window.getWindow)();
    return {
      width: window.innerWidth,
      height: window.innerHeight
    };
  };

  var handleResize = function handleResize() {
    var now = formatSize();

    if (now.width === prevSize.width && now.height === prevSize.height) {
      return;
    }

    var changedDimension;

    if (now.width === prevSize.width) {
      changedDimension = 'height';
    }

    if (now.height === prevSize.height) {
      changedDimension = 'width';
    }

    prevSize = now;
    callbacks.fire(changedDimension);
  };

  var setPrevSize = (0, _call_once.default)(function () {
    prevSize = formatSize();
  });
  var removeListener;

  callbacks.add = function () {
    var result = originalCallbacksAdd.apply(callbacks, arguments);
    setPrevSize();

    _ready_callbacks.default.add(function () {
      if (!removeListener && callbacks.has()) {
        removeListener = _dom_adapter.default.listen((0, _window.getWindow)(), 'resize', handleResize);
      }
    });

    return result;
  };

  callbacks.remove = function () {
    var result = originalCallbacksRemove.apply(callbacks, arguments);

    if (!callbacks.has() && removeListener) {
      removeListener();
      removeListener = undefined;
    }

    return result;
  };

  return callbacks;
}();

var _default = resizeCallbacks;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _ready_callbacks = _interopRequireDefault(__webpack_require__(51));

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _element_data = __webpack_require__(43);

var _class = _interopRequireDefault(__webpack_require__(15));

var _extend = __webpack_require__(0);

var _array = __webpack_require__(12);

var _iterator = __webpack_require__(3);

var _event_registrator = _interopRequireDefault(__webpack_require__(68));

var _index = __webpack_require__(8);

var _pointer = _interopRequireDefault(__webpack_require__(25));

var _wheel = __webpack_require__(149);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MANAGER_EVENT = 'dxEventManager';
var EMITTER_DATA = 'dxEmitter';

var EventManager = _class.default.inherit({
  ctor: function ctor() {
    this._attachHandlers();

    this.reset();
    this._proxiedCancelHandler = this._cancelHandler.bind(this);
    this._proxiedAcceptHandler = this._acceptHandler.bind(this);
  },
  _attachHandlers: function _attachHandlers() {
    _ready_callbacks.default.add(function () {
      var document = _dom_adapter.default.getDocument();

      _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)(_pointer.default.down, MANAGER_EVENT), this._pointerDownHandler.bind(this));

      _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)(_pointer.default.move, MANAGER_EVENT), this._pointerMoveHandler.bind(this));

      _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)([_pointer.default.up, _pointer.default.cancel].join(' '), MANAGER_EVENT), this._pointerUpHandler.bind(this));

      _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)(_wheel.name, MANAGER_EVENT), this._mouseWheelHandler.bind(this));
    }.bind(this));
  },
  _eachEmitter: function _eachEmitter(callback) {
    var activeEmitters = this._activeEmitters || [];
    var i = 0;

    while (activeEmitters.length > i) {
      var emitter = activeEmitters[i];

      if (callback(emitter) === false) {
        break;
      }

      if (activeEmitters[i] === emitter) {
        i++;
      }
    }
  },
  _applyToEmitters: function _applyToEmitters(method, arg) {
    this._eachEmitter(function (emitter) {
      emitter[method].call(emitter, arg);
    });
  },
  reset: function reset() {
    this._eachEmitter(this._proxiedCancelHandler);

    this._activeEmitters = [];
  },
  resetEmitter: function resetEmitter(emitter) {
    this._proxiedCancelHandler(emitter);
  },
  _pointerDownHandler: function _pointerDownHandler(e) {
    if ((0, _index.isMouseEvent)(e) && e.which > 1) {
      return;
    }

    this._updateEmitters(e);
  },
  _updateEmitters: function _updateEmitters(e) {
    if (!this._isSetChanged(e)) {
      return;
    }

    this._cleanEmitters(e);

    this._fetchEmitters(e);
  },
  _isSetChanged: function _isSetChanged(e) {
    var currentSet = this._closestEmitter(e);

    var previousSet = this._emittersSet || [];
    var setChanged = currentSet.length !== previousSet.length;
    (0, _iterator.each)(currentSet, function (index, emitter) {
      setChanged = setChanged || previousSet[index] !== emitter;
      return !setChanged;
    });
    this._emittersSet = currentSet;
    return setChanged;
  },
  _closestEmitter: function _closestEmitter(e) {
    var that = this;
    var result = [];
    var $element = (0, _renderer.default)(e.target);

    function handleEmitter(_, emitter) {
      if (!!emitter && emitter.validatePointers(e) && emitter.validate(e)) {
        emitter.addCancelCallback(that._proxiedCancelHandler);
        emitter.addAcceptCallback(that._proxiedAcceptHandler);
        result.push(emitter);
      }
    }

    while ($element.length) {
      var emitters = (0, _element_data.data)($element.get(0), EMITTER_DATA) || [];
      (0, _iterator.each)(emitters, handleEmitter);
      $element = $element.parent();
    }

    return result;
  },
  _acceptHandler: function _acceptHandler(acceptedEmitter, e) {
    var that = this;

    this._eachEmitter(function (emitter) {
      if (emitter !== acceptedEmitter) {
        that._cancelEmitter(emitter, e);
      }
    });
  },
  _cancelHandler: function _cancelHandler(canceledEmitter, e) {
    this._cancelEmitter(canceledEmitter, e);
  },
  _cancelEmitter: function _cancelEmitter(emitter, e) {
    var activeEmitters = this._activeEmitters;

    if (e) {
      emitter.cancel(e);
    } else {
      emitter.reset();
    }

    emitter.removeCancelCallback();
    emitter.removeAcceptCallback();
    var emitterIndex = (0, _array.inArray)(emitter, activeEmitters);

    if (emitterIndex > -1) {
      activeEmitters.splice(emitterIndex, 1);
    }
  },
  _cleanEmitters: function _cleanEmitters(e) {
    this._applyToEmitters('end', e);

    this.reset(e);
  },
  _fetchEmitters: function _fetchEmitters(e) {
    this._activeEmitters = this._emittersSet.slice();

    this._applyToEmitters('start', e);
  },
  _pointerMoveHandler: function _pointerMoveHandler(e) {
    this._applyToEmitters('move', e);
  },
  _pointerUpHandler: function _pointerUpHandler(e) {
    this._updateEmitters(e);
  },
  _mouseWheelHandler: function _mouseWheelHandler(e) {
    if (!this._allowInterruptionByMouseWheel()) {
      return;
    }

    e.pointers = [null];

    this._pointerDownHandler(e);

    this._adjustWheelEvent(e);

    this._pointerMoveHandler(e);

    e.pointers = [];

    this._pointerUpHandler(e);
  },
  _allowInterruptionByMouseWheel: function _allowInterruptionByMouseWheel() {
    var allowInterruption = true;

    this._eachEmitter(function (emitter) {
      allowInterruption = emitter.allowInterruptionByMouseWheel() && allowInterruption;
      return allowInterruption;
    });

    return allowInterruption;
  },
  _adjustWheelEvent: function _adjustWheelEvent(e) {
    var closestGestureEmitter = null;

    this._eachEmitter(function (emitter) {
      if (!emitter.gesture) {
        return;
      }

      var direction = emitter.getDirection(e);

      if (direction !== 'horizontal' && !e.shiftKey || direction !== 'vertical' && e.shiftKey) {
        closestGestureEmitter = emitter;
        return false;
      }
    });

    if (!closestGestureEmitter) {
      return;
    }

    var direction = closestGestureEmitter.getDirection(e);
    var verticalGestureDirection = direction === 'both' && !e.shiftKey || direction === 'vertical';
    var prop = verticalGestureDirection ? 'pageY' : 'pageX';
    e[prop] += e.delta;
  },
  isActive: function isActive(element) {
    var result = false;

    this._eachEmitter(function (emitter) {
      result = result || emitter.getElement().is(element);
    });

    return result;
  }
});

var eventManager = new EventManager();
var EMITTER_SUBSCRIPTION_DATA = 'dxEmitterSubscription';

var registerEmitter = function registerEmitter(emitterConfig) {
  var emitterClass = emitterConfig.emitter;
  var emitterName = emitterConfig.events[0];
  var emitterEvents = emitterConfig.events;
  (0, _iterator.each)(emitterEvents, function (_, eventName) {
    (0, _event_registrator.default)(eventName, {
      noBubble: !emitterConfig.bubble,
      setup: function setup(element) {
        var subscriptions = (0, _element_data.data)(element, EMITTER_SUBSCRIPTION_DATA) || {};
        var emitters = (0, _element_data.data)(element, EMITTER_DATA) || {};
        var emitter = emitters[emitterName] || new emitterClass(element);
        subscriptions[eventName] = true;
        emitters[emitterName] = emitter;
        (0, _element_data.data)(element, EMITTER_DATA, emitters);
        (0, _element_data.data)(element, EMITTER_SUBSCRIPTION_DATA, subscriptions);
      },
      add: function add(element, handleObj) {
        var emitters = (0, _element_data.data)(element, EMITTER_DATA);
        var emitter = emitters[emitterName];
        emitter.configure((0, _extend.extend)({
          delegateSelector: handleObj.selector
        }, handleObj.data), handleObj.type);
      },
      teardown: function teardown(element) {
        var subscriptions = (0, _element_data.data)(element, EMITTER_SUBSCRIPTION_DATA);
        var emitters = (0, _element_data.data)(element, EMITTER_DATA);
        var emitter = emitters[emitterName];
        delete subscriptions[eventName];
        var disposeEmitter = true;
        (0, _iterator.each)(emitterEvents, function (_, eventName) {
          disposeEmitter = disposeEmitter && !subscriptions[eventName];
          return disposeEmitter;
        });

        if (disposeEmitter) {
          if (eventManager.isActive(element)) {
            eventManager.resetEmitter(emitter);
          }

          emitter && emitter.dispose();
          delete emitters[emitterName];
        }
      }
    });
  });
};

var _default = registerEmitter;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _console = __webpack_require__(111);

var _dependency_injector = _interopRequireDefault(__webpack_require__(55));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _dependency_injector.default)({
  isWrapped: function isWrapped() {
    return false;
  },
  isWritableWrapped: function isWritableWrapped() {
    return false;
  },
  wrap: function wrap(value) {
    return value;
  },
  unwrap: function unwrap(value) {
    return value;
  },
  assign: function assign() {
    _console.logger.error('Method \'assign\' should not be used for not wrapped variables. Use \'isWrapped\' method for ensuring.');
  }
});

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _class = _interopRequireDefault(__webpack_require__(15));

var _events_strategy = __webpack_require__(96);

var _iterator = __webpack_require__(3);

var _errors = __webpack_require__(37);

var _utils = _interopRequireDefault(__webpack_require__(44));

var _data = __webpack_require__(21);

var _store_helper = _interopRequireDefault(__webpack_require__(95));

var _deferred = __webpack_require__(6);

var _common = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var abstract = _class.default.abstract;
var queryByOptions = _store_helper.default.queryByOptions;
var storeImpl = {};

var Store = _class.default.inherit({
  ctor: function ctor(options) {
    var that = this;
    options = options || {};
    this._eventsStrategy = new _events_strategy.EventsStrategy(this);
    (0, _iterator.each)(['onLoaded', 'onLoading', 'onInserted', 'onInserting', 'onUpdated', 'onUpdating', 'onPush', 'onRemoved', 'onRemoving', 'onModified', 'onModifying'], function (_, optionName) {
      if (optionName in options) {
        that.on(optionName.slice(2).toLowerCase(), options[optionName]);
      }
    });
    this._key = options.key;
    this._errorHandler = options.errorHandler;
    this._useDefaultSearch = true;
  },
  _customLoadOptions: function _customLoadOptions() {
    return null;
  },
  key: function key() {
    return this._key;
  },
  keyOf: function keyOf(obj) {
    if (!this._keyGetter) {
      this._keyGetter = (0, _data.compileGetter)(this.key());
    }

    return this._keyGetter(obj);
  },
  _requireKey: function _requireKey() {
    if (!this.key()) {
      throw _errors.errors.Error('E4005');
    }
  },
  load: function load(options) {
    var that = this;
    options = options || {};

    this._eventsStrategy.fireEvent('loading', [options]);

    return this._withLock(this._loadImpl(options)).done(function (result) {
      that._eventsStrategy.fireEvent('loaded', [result, options]);
    });
  },
  _loadImpl: function _loadImpl(options) {
    return queryByOptions(this.createQuery(options), options).enumerate();
  },
  _withLock: function _withLock(task) {
    var result = new _deferred.Deferred();
    task.done(function () {
      var that = this;
      var args = arguments;

      _utils.default.processRequestResultLock.promise().done(function () {
        result.resolveWith(that, args);
      });
    }).fail(function () {
      result.rejectWith(this, arguments);
    });
    return result;
  },
  createQuery: abstract,
  totalCount: function totalCount(options) {
    return this._totalCountImpl(options);
  },
  _totalCountImpl: function _totalCountImpl(options) {
    return queryByOptions(this.createQuery(options), options, true).count();
  },
  byKey: function byKey(key, extraOptions) {
    return this._addFailHandlers(this._withLock(this._byKeyImpl(key, extraOptions)));
  },
  _byKeyImpl: abstract,
  insert: function insert(values) {
    var that = this;

    that._eventsStrategy.fireEvent('modifying');

    that._eventsStrategy.fireEvent('inserting', [values]);

    return that._addFailHandlers(that._insertImpl(values).done(function (callbackValues, callbackKey) {
      that._eventsStrategy.fireEvent('inserted', [callbackValues, callbackKey]);

      that._eventsStrategy.fireEvent('modified');
    }));
  },
  _insertImpl: abstract,
  update: function update(key, values) {
    var that = this;

    that._eventsStrategy.fireEvent('modifying');

    that._eventsStrategy.fireEvent('updating', [key, values]);

    return that._addFailHandlers(that._updateImpl(key, values).done(function () {
      that._eventsStrategy.fireEvent('updated', [key, values]);

      that._eventsStrategy.fireEvent('modified');
    }));
  },
  _updateImpl: abstract,
  push: function push(changes) {
    var _this = this;

    var beforePushArgs = {
      changes: changes,
      waitFor: []
    };

    this._eventsStrategy.fireEvent('beforePush', [beforePushArgs]);

    _deferred.when.apply(void 0, _toConsumableArray(beforePushArgs.waitFor)).done(function () {
      _this._pushImpl(changes);

      _this._eventsStrategy.fireEvent('push', [changes]);
    });
  },
  _pushImpl: _common.noop,
  remove: function remove(key) {
    var that = this;

    that._eventsStrategy.fireEvent('modifying');

    that._eventsStrategy.fireEvent('removing', [key]);

    return that._addFailHandlers(that._removeImpl(key).done(function (callbackKey) {
      that._eventsStrategy.fireEvent('removed', [callbackKey]);

      that._eventsStrategy.fireEvent('modified');
    }));
  },
  _removeImpl: abstract,
  _addFailHandlers: function _addFailHandlers(deferred) {
    return deferred.fail(this._errorHandler).fail(_errors.handleError);
  },
  on: function on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);

    return this;
  },
  off: function off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);

    return this;
  }
});

Store.create = function (alias, options) {
  if (!(alias in storeImpl)) {
    throw _errors.errors.Error('E4020', alias);
  }

  return new storeImpl[alias](options);
};

Store.registerClass = function (type, alias) {
  if (alias) {
    storeImpl[alias] = type;
  }

  return type;
};

Store.inherit = function (inheritor) {
  return function (members, alias) {
    var type = inheritor.apply(this, [members]);
    Store.registerClass(type, alias);
    return type;
  };
}(Store.inherit);

var _default = Store;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.debug = exports.logger = void 0;

var _type = __webpack_require__(1);

/* global console */

/* eslint no-console: off */
var noop = function noop() {};

var getConsoleMethod = function getConsoleMethod(method) {
  if (typeof console === 'undefined' || !(0, _type.isFunction)(console[method])) {
    return noop;
  }

  return console[method].bind(console);
};

var logger = {
  info: getConsoleMethod('info'),
  warn: getConsoleMethod('warn'),
  error: getConsoleMethod('error')
};
exports.logger = logger;

var debug = function () {
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }

  function assertParam(parameter, message) {
    assert(parameter !== null && parameter !== undefined, message);
  }

  return {
    assert: assert,
    assertParam: assertParam
  };
}();

exports.debug = debug;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _extend = __webpack_require__(0);

var _default = {
  _formatNumberCore: function _formatNumberCore(value, format, formatConfig) {
    if (format === 'currency') {
      formatConfig.precision = formatConfig.precision || 0;
      var result = this.format(value, (0, _extend.extend)({}, formatConfig, {
        type: 'fixedpoint'
      }));
      var currencyPart = this.getCurrencySymbol().symbol.replace(/\$/g, '$$$$');
      result = result.replace(/^(\D*)(\d.*)/, '$1' + currencyPart + '$2');
      return result;
    }

    return this.callBase.apply(this, arguments);
  },
  getCurrencySymbol: function getCurrencySymbol() {
    return {
      symbol: '$'
    };
  },
  getOpenXmlCurrencyFormat: function getOpenXmlCurrencyFormat() {
    return '$#,##0{0}_);\\($#,##0{0}\\)';
  }
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.keyboard = exports.dxPointerUp = exports.dxPointerDown = exports.keyDown = exports.dxScrollCancel = exports.dxScrollStop = exports.dxScrollEnd = exports.dxScrollMove = exports.dxScrollStart = exports.dxScrollInit = exports.click = exports.dxClick = exports.focus = exports.visibility = exports.hover = exports.resize = exports.active = void 0;

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _keyboard_processor = _interopRequireDefault(__webpack_require__(385));

var _index = __webpack_require__(8);

var _pointer = _interopRequireDefault(__webpack_require__(25));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function addNamespace(event, namespace) {
  return namespace ? (0, _index.addNamespace)(event, namespace) : event;
}

function executeAction(action, args) {
  return typeof action === 'function' ? action(args) : action.execute(args);
}

var active = {
  on: function on($el, active, inactive, opts) {
    var selector = opts.selector,
        showTimeout = opts.showTimeout,
        hideTimeout = opts.hideTimeout,
        namespace = opts.namespace;

    _events_engine.default.on($el, addNamespace('dxactive', namespace), selector, {
      timeout: showTimeout
    }, function (event) {
      return executeAction(active, {
        event: event,
        element: event.currentTarget
      });
    });

    _events_engine.default.on($el, addNamespace('dxinactive', namespace), selector, {
      timeout: hideTimeout
    }, function (event) {
      return executeAction(inactive, {
        event: event,
        element: event.currentTarget
      });
    });
  },
  off: function off($el, _ref) {
    var namespace = _ref.namespace,
        selector = _ref.selector;

    _events_engine.default.off($el, addNamespace('dxactive', namespace), selector);

    _events_engine.default.off($el, addNamespace('dxinactive', namespace), selector);
  }
};
exports.active = active;
var resize = {
  on: function on($el, resize) {
    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        namespace = _ref2.namespace;

    _events_engine.default.on($el, addNamespace('dxresize', namespace), resize);
  },
  off: function off($el) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        namespace = _ref3.namespace;

    _events_engine.default.off($el, addNamespace('dxresize', namespace));
  }
};
exports.resize = resize;
var hover = {
  on: function on($el, start, end, _ref4) {
    var selector = _ref4.selector,
        namespace = _ref4.namespace;

    _events_engine.default.on($el, addNamespace('dxhoverend', namespace), selector, function (event) {
      return end(event);
    });

    _events_engine.default.on($el, addNamespace('dxhoverstart', namespace), selector, function (event) {
      return executeAction(start, {
        element: event.target,
        event: event
      });
    });
  },
  off: function off($el, _ref5) {
    var selector = _ref5.selector,
        namespace = _ref5.namespace;

    _events_engine.default.off($el, addNamespace('dxhoverstart', namespace), selector);

    _events_engine.default.off($el, addNamespace('dxhoverend', namespace), selector);
  }
};
exports.hover = hover;
var visibility = {
  on: function on($el, shown, hiding, _ref6) {
    var namespace = _ref6.namespace;

    _events_engine.default.on($el, addNamespace('dxhiding', namespace), hiding);

    _events_engine.default.on($el, addNamespace('dxshown', namespace), shown);
  },
  off: function off($el, _ref7) {
    var namespace = _ref7.namespace;

    _events_engine.default.off($el, addNamespace('dxhiding', namespace));

    _events_engine.default.off($el, addNamespace('dxshown', namespace));
  }
};
exports.visibility = visibility;
var focus = {
  on: function on($el, focusIn, focusOut, _ref8) {
    var namespace = _ref8.namespace,
        isFocusable = _ref8.isFocusable;

    _events_engine.default.on($el, addNamespace('focusin', namespace), focusIn);

    _events_engine.default.on($el, addNamespace('focusout', namespace), focusOut);

    if (_dom_adapter.default.hasDocumentProperty('onbeforeactivate')) {
      _events_engine.default.on($el, addNamespace('beforeactivate', namespace), function (e) {
        return isFocusable(null, e.target) || e.preventDefault();
      });
    }
  },
  off: function off($el, _ref9) {
    var namespace = _ref9.namespace;

    _events_engine.default.off($el, addNamespace('focusin', namespace));

    _events_engine.default.off($el, addNamespace('focusout', namespace));

    if (_dom_adapter.default.hasDocumentProperty('onbeforeactivate')) {
      _events_engine.default.off($el, addNamespace('beforeactivate', namespace));
    }
  },
  trigger: function trigger($el) {
    return _events_engine.default.trigger($el, 'focus');
  }
};
exports.focus = focus;
var dxClick = {
  on: function on($el, click) {
    var _ref10 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        namespace = _ref10.namespace;

    _events_engine.default.on($el, addNamespace('dxclick', namespace), click);
  },
  off: function off($el) {
    var _ref11 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        namespace = _ref11.namespace;

    _events_engine.default.off($el, addNamespace('dxclick', namespace));
  }
};
exports.dxClick = dxClick;
var click = {
  on: function on($el, click) {
    var _ref12 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        namespace = _ref12.namespace;

    _events_engine.default.on($el, addNamespace('click', namespace), click);
  },
  off: function off($el) {
    var _ref13 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        namespace = _ref13.namespace;

    _events_engine.default.off($el, addNamespace('click', namespace));
  }
};
exports.click = click;
var dxScrollInit = {
  on: function on($el, onInit, eventData) {
    var _ref14 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        namespace = _ref14.namespace;

    _events_engine.default.on($el, addNamespace('dxscrollinit', namespace), eventData, onInit);
  },
  off: function off($el) {
    var _ref15 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        namespace = _ref15.namespace;

    _events_engine.default.off($el, addNamespace('dxscrollinit', namespace));
  }
};
exports.dxScrollInit = dxScrollInit;
var dxScrollStart = {
  on: function on($el, onStart) {
    var _ref16 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        namespace = _ref16.namespace;

    _events_engine.default.on($el, addNamespace('dxscrollstart', namespace), onStart);
  },
  off: function off($el) {
    var _ref17 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        namespace = _ref17.namespace;

    _events_engine.default.off($el, addNamespace('dxscrollstart', namespace));
  }
};
exports.dxScrollStart = dxScrollStart;
var dxScrollMove = {
  on: function on($el, onScroll) {
    var _ref18 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        namespace = _ref18.namespace;

    _events_engine.default.on($el, addNamespace('dxscroll', namespace), onScroll);
  },
  off: function off($el) {
    var _ref19 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        namespace = _ref19.namespace;

    _events_engine.default.off($el, addNamespace('dxscroll', namespace));
  }
};
exports.dxScrollMove = dxScrollMove;
var dxScrollEnd = {
  on: function on($el, onEnd) {
    var _ref20 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        namespace = _ref20.namespace;

    _events_engine.default.on($el, addNamespace('dxscrollend', namespace), onEnd);
  },
  off: function off($el) {
    var _ref21 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        namespace = _ref21.namespace;

    _events_engine.default.off($el, addNamespace('dxscrollend', namespace));
  }
};
exports.dxScrollEnd = dxScrollEnd;
var dxScrollStop = {
  on: function on($el, onStop) {
    var _ref22 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        namespace = _ref22.namespace;

    _events_engine.default.on($el, addNamespace('dxscrollstop', namespace), onStop);
  },
  off: function off($el) {
    var _ref23 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        namespace = _ref23.namespace;

    _events_engine.default.off($el, addNamespace('dxscrollstop', namespace));
  }
};
exports.dxScrollStop = dxScrollStop;
var dxScrollCancel = {
  on: function on($el, onCancel) {
    var _ref24 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        namespace = _ref24.namespace;

    _events_engine.default.on($el, addNamespace('dxscrollcancel', namespace), onCancel);
  },
  off: function off($el) {
    var _ref25 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        namespace = _ref25.namespace;

    _events_engine.default.off($el, addNamespace('dxscrollcancel', namespace));
  }
};
exports.dxScrollCancel = dxScrollCancel;
var keyDown = {
  on: function on($el, onKeyDown) {
    var _ref26 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        namespace = _ref26.namespace;

    _events_engine.default.on($el, addNamespace('keydown', namespace), onKeyDown);
  },
  off: function off($el) {
    var _ref27 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        namespace = _ref27.namespace;

    _events_engine.default.off($el, addNamespace('keydown', namespace));
  }
};
exports.keyDown = keyDown;
var dxPointerDown = {
  on: function on($el, onPointerDown) {
    var _ref28 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        namespace = _ref28.namespace;

    _events_engine.default.on($el, addNamespace(_pointer.default.down, namespace), onPointerDown);
  },
  off: function off($el) {
    var _ref29 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        namespace = _ref29.namespace;

    _events_engine.default.off($el, addNamespace(_pointer.default.down, namespace));
  }
};
exports.dxPointerDown = dxPointerDown;
var dxPointerUp = {
  on: function on($el, onPointerUp) {
    var _ref30 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        namespace = _ref30.namespace;

    _events_engine.default.on($el, addNamespace(_pointer.default.up, namespace), onPointerUp);
  },
  off: function off($el) {
    var _ref31 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        namespace = _ref31.namespace;

    _events_engine.default.off($el, addNamespace(_pointer.default.up, namespace));
  }
};
exports.dxPointerUp = dxPointerUp;
var index = 0;
var keyboardProcessors = {};

var generateListenerId = function generateListenerId() {
  return "keyboardProcessorId".concat(index++);
};

var keyboard = {
  on: function on(element, focusTarget, handler) {
    var listenerId = generateListenerId();
    keyboardProcessors[listenerId] = new _keyboard_processor.default({
      element: element,
      focusTarget: focusTarget,
      handler: handler
    });
    return listenerId;
  },
  off: function off(listenerId) {
    if (listenerId && keyboardProcessors[listenerId]) {
      keyboardProcessors[listenerId].dispose();
      delete keyboardProcessors[listenerId];
    }
  },
  // NOTE: For tests
  _getProcessor: function _getProcessor(listenerId) {
    return keyboardProcessors[listenerId];
  }
};
exports.keyboard = keyboard;

/***/ }),
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.plugin = exports.ExportMenu = exports.combineMarkups = exports.exportWidgets = exports.getMarkup = exports.exportFromMarkup = void 0;

var _extend = __webpack_require__(0);

var _window = __webpack_require__(7);

var _utils = __webpack_require__(14);

var _exporter = __webpack_require__(192);

var _message = _interopRequireDefault(__webpack_require__(10));

var _type = __webpack_require__(1);

var _themes = __webpack_require__(57);

var _hover = __webpack_require__(145);

var _pointer = _interopRequireDefault(__webpack_require__(25));

var _console = __webpack_require__(111);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var pointerActions = [_pointer.default.down, _pointer.default.move].join(' ');
var BUTTON_SIZE = 35;
var ICON_COORDS = [[9, 12, 26, 12, 26, 14, 9, 14], [9, 17, 26, 17, 26, 19, 9, 19], [9, 22, 26, 22, 26, 24, 9, 24]];
var LIST_PADDING_TOP = 4;
var LIST_WIDTH = 120;
var VERTICAL_TEXT_MARGIN = 8;
var HORIZONTAL_TEXT_MARGIN = 15;
var MENU_ITEM_HEIGHT = 30;
var LIST_STROKE_WIDTH = 1;
var MARGIN = 10;
var SHADOW_OFFSET = 2;
var SHADOW_BLUR = 3;
var DEFAULT_EXPORT_FORMAT = 'PNG';
var ALLOWED_IMAGE_FORMATS = [DEFAULT_EXPORT_FORMAT, 'JPEG', 'GIF'];
var ALLOWED_EXTRA_FORMATS = ['PDF', 'SVG'];
var EXPORT_CSS_CLASS = 'dx-export-menu';
var EXPORT_DATA_KEY = 'export-element-type';
var FORMAT_DATA_KEY = 'export-element-format';
var GET_COLOR_REGEX = /data-backgroundcolor="([^"]*)"/;

function getValidFormats() {
  var imageFormats = _exporter.image.testFormats(ALLOWED_IMAGE_FORMATS);

  return {
    unsupported: imageFormats.unsupported,
    supported: imageFormats.supported.concat(ALLOWED_EXTRA_FORMATS)
  };
}

function validateFormat(format, incidentOccurred, validFormats) {
  validFormats = validFormats || getValidFormats();
  format = String(format).toUpperCase();

  if (validFormats.supported.indexOf(format) !== -1) {
    return format;
  }

  if (validFormats.unsupported.indexOf(format) !== -1) {
    incidentOccurred && incidentOccurred('W2108', [format]);
  }
}

function getCreatorFunc(format) {
  if (format === 'SVG') {
    return _exporter.svg.getData;
  } else if (format === 'PDF') {
    return _exporter.pdf.getData;
  } else {
    return _exporter.image.getData;
  }
}

function _print(imageSrc, options) {
  var document = (0, _window.getWindow)().document;
  var iFrame = document.createElement('iframe');
  iFrame.onload = setPrint(imageSrc, options);
  iFrame.style.position = 'fixed';
  iFrame.style.width = '0';
  iFrame.style.height = '0';
  iFrame.style.right = '0';
  iFrame.style.bottom = '0';
  document.body.appendChild(iFrame);
}

function setPrint(imageSrc, options) {
  return function () {
    var _this = this;

    var window = this.contentWindow;
    var img = window.document.createElement('img');
    window.document.body.appendChild(img);

    var removeFrame = function removeFrame() {
      _this.parentElement.removeChild(_this);
    };

    img.addEventListener('load', function () {
      window.focus();
      window.print();
    });
    img.addEventListener('error', removeFrame);
    window.addEventListener('afterprint', function () {
      // T933486
      setTimeout(removeFrame, 0); // timeout needed for FF
    });
    img.src = imageSrc;
  };
}

function getItemAttributes(options, type, itemIndex) {
  var x = BUTTON_SIZE - LIST_WIDTH;
  var y = BUTTON_SIZE + LIST_PADDING_TOP + LIST_STROKE_WIDTH + itemIndex * MENU_ITEM_HEIGHT;
  var attr = {
    rect: {
      width: LIST_WIDTH - LIST_STROKE_WIDTH * 2,
      height: MENU_ITEM_HEIGHT,
      x: x + LIST_STROKE_WIDTH,
      y: y
    },
    text: {
      x: x + (options.rtl ? LIST_WIDTH - HORIZONTAL_TEXT_MARGIN : HORIZONTAL_TEXT_MARGIN),
      y: y + MENU_ITEM_HEIGHT - VERTICAL_TEXT_MARGIN
    }
  };

  if (type === 'printing') {
    attr.separator = {
      stroke: options.button.default.borderColor,
      'stroke-width': LIST_STROKE_WIDTH,
      cursor: 'pointer',
      sharp: 'v',
      d: 'M ' + x + ' ' + (y + MENU_ITEM_HEIGHT - LIST_STROKE_WIDTH) + ' ' + 'L ' + (x + LIST_WIDTH) + ' ' + (y + MENU_ITEM_HEIGHT - LIST_STROKE_WIDTH)
    };
  }

  return attr;
}

function createMenuItem(renderer, options, settings) {
  var itemData = {};
  var type = settings.type;
  var format = settings.format;
  var attr = getItemAttributes(options, type, settings.itemIndex);
  var fontStyle = (0, _utils.patchFontOptions)(options.font);
  fontStyle['pointer-events'] = 'none';
  var menuItem = renderer.g().attr({
    'class': EXPORT_CSS_CLASS + '-list-item'
  });
  itemData[EXPORT_DATA_KEY] = type;

  if (format) {
    itemData[FORMAT_DATA_KEY] = format;
  }

  var rect = renderer.rect();
  rect.attr(attr.rect).css({
    cursor: 'pointer',
    'pointer-events': 'all'
  }).data(itemData);
  rect.on(_hover.start + '.export', function () {
    return rect.attr({
      fill: options.button.hover.backgroundColor
    });
  }).on(_hover.end + '.export', function () {
    return rect.attr({
      fill: null
    });
  });
  rect.append(menuItem);
  var text = renderer.text(settings.text).css(fontStyle).attr(attr.text).append(menuItem);

  if (type === 'printing') {
    renderer.path(null, 'line').attr(attr.separator).append(menuItem);
  }

  return {
    g: menuItem,
    rect: rect,
    resetState: function resetState() {
      return rect.attr({
        fill: null
      });
    },
    fixPosition: function fixPosition() {
      var textBBox = text.getBBox();
      text.move(attr.text.x - textBBox.x - (options.rtl ? textBBox.width : 0));
    }
  };
}

function createMenuItems(renderer, options) {
  var items = [];

  if (options.printingEnabled) {
    items.push(createMenuItem(renderer, options, {
      type: 'printing',
      text: _message.default.format('vizExport-printingButtonText'),
      itemIndex: items.length
    }));
  }

  items = options.formats.reduce(function (r, format) {
    r.push(createMenuItem(renderer, options, {
      type: 'exporting',
      text: _message.default.getFormatter('vizExport-exportButtonText')(format),
      format: format,
      itemIndex: r.length
    }));
    return r;
  }, items);
  return items;
}

function getBackgroundColorFromMarkup(markup) {
  var parsedMarkup = GET_COLOR_REGEX.exec(markup);
  return parsedMarkup === null || parsedMarkup === void 0 ? void 0 : parsedMarkup[1];
}

var exportFromMarkup = function exportFromMarkup(markup, options) {
  options.format = validateFormat(options.format) || DEFAULT_EXPORT_FORMAT;
  options.fileName = options.fileName || 'file';
  options.exportingAction = options.onExporting;
  options.exportedAction = options.onExported;
  options.fileSavingAction = options.onFileSaving;
  options.margin = (0, _type.isDefined)(options.margin) ? options.margin : MARGIN;
  options.backgroundColor = (0, _type.isDefined)(options.backgroundColor) ? options.backgroundColor : getBackgroundColorFromMarkup(markup) || (0, _themes.getTheme)().backgroundColor;
  (0, _exporter.export)(markup, options, getCreatorFunc(options.format));
};

exports.exportFromMarkup = exportFromMarkup;

var getMarkup = function getMarkup(widgets) {
  return combineMarkups(widgets).markup;
};

exports.getMarkup = getMarkup;

var exportWidgets = function exportWidgets(widgets, options) {
  options = options || {};
  var markupInfo = combineMarkups(widgets, {
    gridLayout: options.gridLayout,
    verticalAlignment: options.verticalAlignment,
    horizontalAlignment: options.horizontalAlignment
  });
  options.width = markupInfo.width;
  options.height = markupInfo.height;
  exportFromMarkup(markupInfo.markup, options);
};

exports.exportWidgets = exportWidgets;

var combineMarkups = function combineMarkups(widgets) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!Array.isArray(widgets)) {
    widgets = [[widgets]];
  } else if (!Array.isArray(widgets[0])) {
    widgets = widgets.map(function (item) {
      return [item];
    });
  }

  var compactView = !options.gridLayout;
  var exportItems = widgets.reduce(function (r, row, rowIndex) {
    var rowInfo = row.reduce(function (r, item, colIndex) {
      var size = item.getSize();
      var backgroundColor = item.option('backgroundColor') || (0, _themes.getTheme)(item.option('theme')).backgroundColor;
      backgroundColor && r.backgroundColors.indexOf(backgroundColor) === -1 && r.backgroundColors.push(backgroundColor);
      r.hOffset = r.width;
      r.width += size.width;
      r.height = Math.max(r.height, size.height);
      r.itemWidth = Math.max(r.itemWidth, size.width);
      r.items.push({
        markup: item.svg(),
        width: size.width,
        height: size.height,
        c: colIndex,
        r: rowIndex,
        hOffset: r.hOffset
      });
      return r;
    }, {
      items: [],
      height: 0,
      itemWidth: 0,
      hOffset: 0,
      width: 0,
      backgroundColors: r.backgroundColors
    });
    r.rowOffsets.push(r.totalHeight);
    r.rowHeights.push(rowInfo.height);
    r.totalHeight += rowInfo.height;
    r.items = r.items.concat(rowInfo.items);
    r.itemWidth = Math.max(r.itemWidth, rowInfo.itemWidth);
    r.maxItemLen = Math.max(r.maxItemLen, rowInfo.items.length);
    r.totalWidth = compactView ? Math.max(r.totalWidth, rowInfo.width) : r.maxItemLen * r.itemWidth;
    return r;
  }, {
    items: [],
    rowOffsets: [],
    rowHeights: [],
    itemWidth: 0,
    totalHeight: 0,
    maxItemLen: 0,
    totalWidth: 0,
    backgroundColors: []
  });
  var backgroundColor = "data-backgroundcolor=\"".concat(exportItems.backgroundColors.length === 1 ? exportItems.backgroundColors[0] : '', "\" ");

  var getVOffset = function getVOffset(item) {
    var align = options.verticalAlignment;
    var dy = exportItems.rowHeights[item.r] - item.height;
    return exportItems.rowOffsets[item.r] + (align === 'bottom' ? dy : align === 'center' ? dy / 2 : 0);
  };

  var getHOffset = function getHOffset(item) {
    if (compactView) {
      return item.hOffset;
    }

    var align = options.horizontalAlignment;
    var colWidth = exportItems.itemWidth;
    var dx = colWidth - item.width;
    return item.c * colWidth + (align === 'right' ? dx : align === 'center' ? dx / 2 : 0);
  };

  var totalHeight = exportItems.totalHeight;
  var totalWidth = exportItems.totalWidth;
  return {
    markup: '<svg ' + backgroundColor + 'height="' + totalHeight + '" width="' + totalWidth + '" version="1.1" xmlns="http://www.w3.org/2000/svg">' + exportItems.items.map(function (item) {
      return "<g transform=\"translate(".concat(getHOffset(item), ",").concat(getVOffset(item), ")\">").concat(item.markup, "</g>");
    }).join('') + '</svg>',
    width: totalWidth,
    height: totalHeight
  };
};

exports.combineMarkups = combineMarkups;

var ExportMenu = function ExportMenu(params) {
  var renderer = this._renderer = params.renderer;
  this._incidentOccurred = params.incidentOccurred;
  this._exportTo = params.exportTo;
  this._print = params.print;
  this._shadow = renderer.shadowFilter('-50%', '-50%', '200%', '200%', SHADOW_OFFSET, 6, SHADOW_BLUR);

  this._shadow.attr({
    opacity: 0.8
  });

  this._group = renderer.g().attr({
    'class': EXPORT_CSS_CLASS,
    'hidden-for-export': true
  }).linkOn(renderer.root, {
    name: 'export-menu',
    after: 'peripheral'
  });
  this._buttonGroup = renderer.g().attr({
    'class': EXPORT_CSS_CLASS + '-button'
  }).append(this._group);
  this._listGroup = renderer.g().attr({
    'class': EXPORT_CSS_CLASS + '-list'
  }).append(this._group);
  this._overlay = renderer.rect(-LIST_WIDTH + BUTTON_SIZE, BUTTON_SIZE + LIST_PADDING_TOP, LIST_WIDTH, 0);

  this._overlay.attr({
    'stroke-width': LIST_STROKE_WIDTH,
    cursor: 'pointer',
    rx: 4,
    ry: 4,
    filter: this._shadow.id
  });

  this._overlay.data({
    'export-element-type': 'list'
  });

  this.validFormats = getValidFormats();

  this._subscribeEvents();
};

exports.ExportMenu = ExportMenu;
(0, _extend.extend)(ExportMenu.prototype, {
  getLayoutOptions: function getLayoutOptions() {
    if (this._hiddenDueToLayout) {
      return {
        width: 0,
        height: 0,
        cutSide: 'vertical',
        cutLayoutSide: 'top'
      };
    }

    var bBox = this._buttonGroup.getBBox();

    bBox.cutSide = 'vertical';
    bBox.cutLayoutSide = 'top';
    bBox.height += MARGIN;
    bBox.position = {
      vertical: 'top',
      horizontal: 'right'
    };
    bBox.verticalAlignment = 'top';
    bBox.horizontalAlignment = 'right';
    return bBox;
  },
  shift: function shift(_, y) {
    this._group.attr({
      translateY: this._group.attr('translateY') + y
    });
  },
  draw: function draw(width, height, canvas) {
    this._group.move(width - BUTTON_SIZE - SHADOW_OFFSET - SHADOW_BLUR + canvas.left, Math.floor(height / 2 - BUTTON_SIZE / 2));

    var layoutOptions = this.getLayoutOptions();

    if (layoutOptions.width > width || layoutOptions.height > height) {
      this.freeSpace();
    }

    return this;
  },
  show: function show() {
    this._group.linkAppend();
  },
  hide: function hide() {
    this._group.linkRemove();
  },
  setOptions: function setOptions(options) {
    var _this2 = this;

    this._options = options;

    if (options.formats) {
      options.formats = options.formats.reduce(function (r, format) {
        format = validateFormat(format, _this2._incidentOccurred, _this2.validFormats);
        format && r.push(format);
        return r;
      }, []);
    } else {
      options.formats = this.validFormats.supported.slice();
    }

    options.printingEnabled = options.printingEnabled === undefined ? true : options.printingEnabled;

    if (options.enabled && (options.formats.length || options.printingEnabled)) {
      this.show();

      this._updateButton();

      this._updateList();

      this._hideList();
    } else {
      this.hide();
    }
  },
  dispose: function dispose() {
    this._unsubscribeEvents();

    this._group.linkRemove().linkOff();

    this._group.dispose();

    this._shadow.dispose();
  },
  // BaseWidget_layout_implementation
  layoutOptions: function layoutOptions() {
    return this._options.enabled && {
      horizontalAlignment: 'right',
      verticalAlignment: 'top',
      weak: true
    };
  },
  measure: function measure() {
    this._fillSpace();

    var margin = this._options.button.margin;
    return [BUTTON_SIZE + margin.left + margin.right, BUTTON_SIZE + margin.top + margin.bottom];
  },
  move: function move(rect) {
    var margin = this._options.button.margin;

    this._group.attr({
      translateX: Math.round(rect[0]) + margin.left,
      translateY: Math.round(rect[1]) + margin.top
    });
  },
  _fillSpace: function _fillSpace() {
    this._hiddenDueToLayout = false;
    this.show();
  },
  freeSpace: function freeSpace() {
    this._incidentOccurred('W2107');

    this._hiddenDueToLayout = true;
    this.hide();
  },
  // BaseWidget_layout_implementation
  _hideList: function _hideList() {
    this._listGroup.remove();

    this._listShown = false;

    this._setButtonState('default');

    this._menuItems.forEach(function (item) {
      return item.resetState();
    });
  },
  _showList: function _showList() {
    this._listGroup.append(this._group);

    this._listShown = true;

    this._menuItems.forEach(function (item) {
      return item.fixPosition();
    });
  },
  _setButtonState: function _setButtonState(state) {
    var style = this._options.button[state];

    this._button.attr({
      stroke: style.borderColor,
      fill: style.backgroundColor
    });

    this._icon.attr({
      fill: style.color
    });
  },
  _subscribeEvents: function _subscribeEvents() {
    var _this3 = this;

    this._renderer.root.on(_pointer.default.up + '.export', function (e) {
      var elementType = e.target[EXPORT_DATA_KEY];

      if (!elementType) {
        if (_this3._button) {
          _this3._hideList();
        }

        return;
      }

      if (elementType === 'button') {
        if (_this3._listShown) {
          _this3._setButtonState('default');

          _this3._hideList();
        } else {
          _this3._setButtonState('focus');

          _this3._showList();
        }
      } else if (elementType === 'printing') {
        _this3._print();

        _this3._hideList();
      } else if (elementType === 'exporting') {
        _this3._exportTo(e.target[FORMAT_DATA_KEY]);

        _this3._hideList();
      }
    });

    this._listGroup.on(pointerActions, function (e) {
      return e.stopPropagation();
    });

    this._buttonGroup.on(_pointer.default.enter, function () {
      return _this3._setButtonState('hover');
    });

    this._buttonGroup.on(_pointer.default.leave, function () {
      return _this3._setButtonState(_this3._listShown ? 'focus' : 'default');
    });

    this._buttonGroup.on(_pointer.default.down + '.export', function () {
      return _this3._setButtonState('active');
    });
  },
  _unsubscribeEvents: function _unsubscribeEvents() {
    this._renderer.root.off('.export');

    this._listGroup.off();

    this._buttonGroup.off();
  },
  _updateButton: function _updateButton() {
    var renderer = this._renderer;
    var options = this._options;
    var exportData = {
      'export-element-type': 'button'
    };

    if (!this._button) {
      this._button = renderer.rect(0, 0, BUTTON_SIZE, BUTTON_SIZE).append(this._buttonGroup);

      this._button.attr({
        rx: 4,
        ry: 4,
        fill: options.button.default.backgroundColor,
        stroke: options.button.default.borderColor,
        'stroke-width': 1,
        cursor: 'pointer'
      });

      this._button.data(exportData);

      this._icon = renderer.path(ICON_COORDS).append(this._buttonGroup);

      this._icon.attr({
        fill: options.button.default.color,
        cursor: 'pointer'
      });

      this._icon.data(exportData);

      this._buttonGroup.setTitle(_message.default.format('vizExport-titleMenuText'));
    }
  },
  _updateList: function _updateList() {
    var options = this._options;
    var buttonDefault = options.button.default;
    var listGroup = this._listGroup;
    var items = createMenuItems(this._renderer, options);

    this._shadow.attr({
      color: options.shadowColor
    });

    this._overlay.attr({
      height: items.length * MENU_ITEM_HEIGHT + LIST_STROKE_WIDTH * 2,
      fill: buttonDefault.backgroundColor,
      stroke: buttonDefault.borderColor
    });

    listGroup.clear();

    this._overlay.append(listGroup);

    items.forEach(function (item) {
      return item.g.append(listGroup);
    });
    this._menuItems = items;
  }
}); // BaseWidget.js

function getExportOptions(widget, exportOptions, fileName, format) {
  if (format || exportOptions.format) {
    format = validateFormat(format || exportOptions.format, widget._incidentOccurred);
  }

  return {
    format: format || DEFAULT_EXPORT_FORMAT,
    fileName: fileName || exportOptions.fileName || 'file',
    proxyUrl: exportOptions.proxyUrl,
    backgroundColor: exportOptions.backgroundColor,
    width: widget._canvas.width,
    height: widget._canvas.height,
    margin: exportOptions.margin,
    svgToCanvas: exportOptions.svgToCanvas,
    forceProxy: exportOptions.forceProxy,
    exportingAction: widget._createActionByOption('onExporting'),
    exportedAction: widget._createActionByOption('onExported'),
    fileSavingAction: widget._createActionByOption('onFileSaving')
  };
}

var plugin = {
  name: 'export',
  init: function init() {
    var _this4 = this;

    this._exportMenu = new ExportMenu({
      renderer: this._renderer,
      incidentOccurred: this._incidentOccurred,
      print: function print() {
        return _this4.print();
      },
      exportTo: function exportTo(format) {
        return _this4.exportTo(undefined, format);
      }
    });

    this._layout.add(this._exportMenu);
  },
  dispose: function dispose() {
    this._exportMenu.dispose();
  },
  members: {
    _getExportMenuOptions: function _getExportMenuOptions() {
      return (0, _extend.extend)({}, this._getOption('export'), {
        rtl: this._getOption('rtlEnabled', true)
      });
    },
    _disablePointerEvents: function _disablePointerEvents() {
      var pointerEventsValue = this._renderer.root.attr('pointer-events');

      this._renderer.root.attr({
        'pointer-events': 'none'
      });

      return pointerEventsValue;
    },
    exportTo: function exportTo(fileName, format) {
      var _this5 = this;

      var menu = this._exportMenu;
      var options = getExportOptions(this, this._getOption('export') || {}, fileName, format);
      menu && menu.hide();

      var pointerEventsValue = this._disablePointerEvents();

      var promise = (0, _exporter.export)(this._renderer.root.element, options, getCreatorFunc(options.format)).fail(_console.logger.error).always(function () {
        _this5._renderer.root.attr({
          'pointer-events': pointerEventsValue
        });
      });
      menu && menu.show();
      return promise;
    },
    print: function print() {
      var _this6 = this;

      var menu = this._exportMenu;
      var options = getExportOptions(this, this._getOption('export') || {});
      options.exportingAction = null;
      options.exportedAction = null;
      options.margin = 0;
      options.format = 'PNG';
      options.forceProxy = true;

      options.fileSavingAction = function (eventArgs) {
        _print("data:image/png;base64,".concat(eventArgs.data), {
          __test: options.__test
        });

        eventArgs.cancel = true;
      };

      var pointerEventsValue = this._disablePointerEvents();

      menu && menu.hide();
      var promise = (0, _exporter.export)(this._renderer.root.element, options, getCreatorFunc(options.format)).fail(_console.logger.error).always(function () {
        _this6._renderer.root.attr({
          'pointer-events': pointerEventsValue
        });
      });
      menu && menu.show();
      return promise;
    }
  },
  customize: function customize(constructor) {
    var proto = constructor.prototype;
    constructor.addChange({
      code: 'EXPORT',
      handler: function handler() {
        this._exportMenu.setOptions(this._getExportMenuOptions());

        this._change(['LAYOUT']);
      },
      isThemeDependent: true,
      isOptionChange: true,
      option: 'export'
    }); // TODO: Event options change processing either should be done by the eventTrigger or shouldn't be done at all

    proto._optionChangesMap.onExporting = 'EXPORT';
    proto._optionChangesMap.onExported = 'EXPORT';
    proto._optionChangesMap.onFileSaving = 'EXPORT';
  },
  fontFields: ['export.font']
};
exports.plugin = plugin;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _common = __webpack_require__(4);

var _window = __webpack_require__(7);

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

var _resize_callbacks = _interopRequireDefault(__webpack_require__(103));

var _extend = __webpack_require__(0);

var _base_theme_manager = __webpack_require__(343);

var _dom_component = _interopRequireDefault(__webpack_require__(66));

var _helpers = __webpack_require__(184);

var _utils = __webpack_require__(14);

var _errors_warnings = _interopRequireDefault(__webpack_require__(586));

var _renderer2 = __webpack_require__(183);

var _layout = _interopRequireDefault(__webpack_require__(1042));

var _devices = _interopRequireDefault(__webpack_require__(13));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _deferred = __webpack_require__(6);

var _base_widget = __webpack_require__(1043);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _floor = Math.floor;
var _log = _errors_warnings.default.log;
var OPTION_RTL_ENABLED = 'rtlEnabled';
var SIZED_ELEMENT_CLASS = 'dx-sized-element';
var _option = _dom_component.default.prototype.option;

function getTrue() {
  return true;
}

function getFalse() {
  return false;
}

function areCanvasesDifferent(canvas1, canvas2) {
  return !(canvas1.width === canvas2.width && canvas1.height === canvas2.height && canvas1.left === canvas2.left && canvas1.top === canvas2.top && canvas1.right === canvas2.right && canvas1.bottom === canvas2.bottom);
}

function defaultOnIncidentOccurred(e) {
  if (!e.component._eventsStrategy.hasEvent('incidentOccurred')) {
    _log.apply(null, [e.target.id].concat(e.target.args || []));
  }
}

function pickPositiveValue(values) {
  return values.reduce(function (result, value) {
    return value > 0 && !result ? value : result;
  }, 0);
} // TODO - Changes handling
// * Provide more validation - something like
//     _changes: [{
//         code: "THEME",
//         options: ["theme"],
//         type: "option",
//         handler: function () {
//             this._setThemeAndRtl();
//         }
//     }, {
//         code: "CONTAINER_SIZE",
//         options: ["size", "option"],
//         type: "layout",
//         handler: function () {
//             this._updateSize();
//         }
//     }]


var getEmptyComponent = function getEmptyComponent() {
  var emptyComponentConfig = {
    _initTemplates: function _initTemplates() {},
    ctor: function ctor(element, options) {
      this.callBase(element, options);

      var sizedElement = _dom_adapter.default.createElement('div');

      var width = options && (0, _type.isNumeric)(options.width) ? options.width + 'px' : '100%';
      var height = options && (0, _type.isNumeric)(options.height) ? options.height + 'px' : this._getDefaultSize().height + 'px';

      _dom_adapter.default.setStyle(sizedElement, 'width', width);

      _dom_adapter.default.setStyle(sizedElement, 'height', height);

      _dom_adapter.default.setClass(sizedElement, SIZED_ELEMENT_CLASS);

      _dom_adapter.default.insertElement(element, sizedElement);
    }
  };

  var EmptyComponent = _dom_component.default.inherit(emptyComponentConfig);

  var originalInherit = EmptyComponent.inherit;

  EmptyComponent.inherit = function (config) {
    for (var field in config) {
      if ((0, _type.isFunction)(config[field]) && field.substr(0, 1) !== '_' && field !== 'option' || field === '_dispose' || field === '_optionChanged') {
        config[field] = _common.noop;
      }
    }

    return originalInherit.call(this, config);
  };

  return EmptyComponent;
};

function callForEach(functions) {
  functions.forEach(function (c) {
    return c();
  });
}

var isServerSide = !(0, _window.hasWindow)();

function sizeIsValid(value) {
  return (0, _type.isDefined)(value) && value > 0;
}

var baseWidget = isServerSide ? getEmptyComponent() : _dom_component.default.inherit({
  _eventsMap: {
    'onIncidentOccurred': {
      name: 'incidentOccurred'
    },
    'onDrawn': {
      name: 'drawn'
    }
  },
  _getDefaultOptions: function _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      onIncidentOccurred: defaultOnIncidentOccurred
    });
  },
  _useLinks: true,
  _init: function _init() {
    var that = this;

    that._$element.children('.' + SIZED_ELEMENT_CLASS).remove();

    that.callBase.apply(that, arguments);
    that._changesLocker = 0;
    that._optionChangedLocker = 0;
    that._asyncFirstDrawing = true;
    that._changes = (0, _helpers.changes)();

    that._suspendChanges();

    that._themeManager = that._createThemeManager();

    that._themeManager.setCallback(function () {
      that._requestChange(that._themeDependentChanges);
    });

    that._renderElementAttributes();

    that._initRenderer(); // Shouldn't "_useLinks" be passed to the renderer instead of doing 3 checks here?


    var linkTarget = that._useLinks && that._renderer.root; // There is an implicit relation between `_useLinks` and `loading indicator` - it uses links
    // Though this relation is not ensured in code we will immediately know when it is broken - `loading indicator` will break on construction

    linkTarget && linkTarget.enableLinks().virtualLink('core').virtualLink('peripheral');

    that._renderVisibilityChange();

    that._attachVisibilityChangeHandlers();

    that._toggleParentsScrollSubscription(this._isVisible());

    that._initEventTrigger();

    that._incidentOccurred = (0, _base_widget.createIncidentOccurred)(that.NAME, that._eventTrigger);
    that._layout = new _layout.default(); // Such solution is used only to avoid writing lots of "after" for all core elements in all widgets
    // May be later a proper solution would be found

    linkTarget && linkTarget.linkAfter('core');

    that._initPlugins();

    that._initCore();

    linkTarget && linkTarget.linkAfter();

    that._change(that._initialChanges);
  },
  _createThemeManager: function _createThemeManager() {
    return new _base_theme_manager.BaseThemeManager(this._getThemeManagerOptions());
  },
  _getThemeManagerOptions: function _getThemeManagerOptions() {
    return {
      themeSection: this._themeSection,
      fontFields: this._fontFields
    };
  },
  _initialChanges: ['LAYOUT', 'RESIZE_HANDLER', 'THEME', 'DISABLED'],
  _initPlugins: function _initPlugins() {
    var that = this;
    (0, _iterator.each)(that._plugins, function (_, plugin) {
      plugin.init.call(that);
    });
  },
  _disposePlugins: function _disposePlugins() {
    var that = this;
    (0, _iterator.each)(that._plugins.slice().reverse(), function (_, plugin) {
      plugin.dispose.call(that);
    });
  },
  _change: function _change(codes) {
    this._changes.add(codes);
  },
  _suspendChanges: function _suspendChanges() {
    ++this._changesLocker;
  },
  _resumeChanges: function _resumeChanges() {
    var that = this;

    if (--that._changesLocker === 0 && that._changes.count() > 0 && !that._applyingChanges) {
      that._renderer.lock();

      that._applyingChanges = true;

      that._applyChanges();

      that._changes.reset();

      that._applyingChanges = false;

      that._changesApplied();

      that._renderer.unlock();

      if (that._optionsQueue) {
        that._applyQueuedOptions();
      }

      that.resolveItemsDeferred(that._legend ? [that._legend] : []);
      that._optionChangedLocker++;

      that._notify();

      that._optionChangedLocker--;
    }
  },
  resolveItemsDeferred: function resolveItemsDeferred(items) {
    this._resolveDeferred(this._getTemplatesItems(items));
  },
  _collectTemplatesFromItems: function _collectTemplatesFromItems(items) {
    return items.reduce(function (prev, i) {
      return {
        items: prev.items.concat(i.getTemplatesDef()),
        groups: prev.groups.concat(i.getTemplatesGroups())
      };
    }, {
      items: [],
      groups: []
    });
  },
  _getTemplatesItems: function _getTemplatesItems(items) {
    var elements = this._collectTemplatesFromItems(items);

    var extraItems = this._getExtraTemplatesItems();

    return {
      items: extraItems.items.concat(elements.items),
      groups: extraItems.groups.concat(elements.groups),
      launchRequest: [extraItems.launchRequest],
      doneRequest: [extraItems.doneRequest]
    };
  },
  _getExtraTemplatesItems: function _getExtraTemplatesItems() {
    return {
      items: [],
      groups: [],
      launchRequest: function launchRequest() {},
      doneRequest: function doneRequest() {}
    };
  },
  _resolveDeferred: function _resolveDeferred(_ref) {
    var items = _ref.items,
        launchRequest = _ref.launchRequest,
        doneRequest = _ref.doneRequest,
        groups = _ref.groups;
    var that = this;

    that._setGroupsVisibility(groups, 'hidden');

    if (that._changesApplying) {
      that._changesApplying = false;
      callForEach(doneRequest);
      return;
    }

    var syncRendering = true;

    _deferred.when.apply(that, items).done(function () {
      if (syncRendering) {
        that._setGroupsVisibility(groups, 'visible');

        return;
      }

      callForEach(launchRequest);
      that._changesApplying = true;
      var changes = ['LAYOUT', 'FULL_RENDER'];

      if (that._asyncFirstDrawing) {
        changes.push('FORCE_FIRST_DRAWING');
        that._asyncFirstDrawing = false;
      } else {
        changes.push('FORCE_DRAWING');
      }

      that._requestChange(changes);

      that._setGroupsVisibility(groups, 'visible');
    });

    syncRendering = false;
  },
  _setGroupsVisibility: function _setGroupsVisibility(groups, visibility) {
    groups.forEach(function (g) {
      return g.attr({
        visibility: visibility
      });
    });
  },
  _applyQueuedOptions: function _applyQueuedOptions() {
    var that = this;
    var queue = that._optionsQueue;
    that._optionsQueue = null;
    that.beginUpdate();
    (0, _iterator.each)(queue, function (_, action) {
      action();
    });
    that.endUpdate();
  },
  _requestChange: function _requestChange(codes) {
    this._suspendChanges();

    this._change(codes);

    this._resumeChanges();
  },
  _applyChanges: function _applyChanges() {
    var that = this;
    var changes = that._changes;
    var order = that._totalChangesOrder;
    var i;
    var ii = order.length;

    for (i = 0; i < ii; ++i) {
      if (changes.has(order[i])) {
        that['_change_' + order[i]]();
      }
    }
  },
  _optionChangesOrder: ['EVENTS', 'THEME', 'RENDERER', 'RESIZE_HANDLER'],
  _layoutChangesOrder: ['ELEMENT_ATTR', 'CONTAINER_SIZE', 'LAYOUT'],
  _customChangesOrder: ['DISABLED'],
  _change_EVENTS: function _change_EVENTS() {
    this._eventTrigger.applyChanges();
  },
  _change_THEME: function _change_THEME() {
    this._setThemeAndRtl();
  },
  _change_RENDERER: function _change_RENDERER() {
    this._setRendererOptions();
  },
  _change_RESIZE_HANDLER: function _change_RESIZE_HANDLER() {
    this._setupResizeHandler();
  },
  _change_ELEMENT_ATTR: function _change_ELEMENT_ATTR() {
    this._renderElementAttributes();

    this._change(['CONTAINER_SIZE']);
  },
  _change_CONTAINER_SIZE: function _change_CONTAINER_SIZE() {
    this._updateSize();
  },
  _change_LAYOUT: function _change_LAYOUT() {
    this._setContentSize();
  },
  _change_DISABLED: function _change_DISABLED() {
    var renderer = this._renderer;
    var root = renderer.root;

    if (this.option('disabled')) {
      this._initDisabledState = root.attr('pointer-events');
      root.attr({
        'pointer-events': 'none',
        filter: renderer.getGrayScaleFilter().id
      });
    } else {
      if (root.attr('pointer-events') === 'none') {
        root.attr({
          'pointer-events': (0, _type.isDefined)(this._initDisabledState) ? this._initDisabledState : null,
          'filter': null
        });
      }
    }
  },
  _themeDependentChanges: ['RENDERER'],
  _initRenderer: function _initRenderer() {
    var that = this; // Canvas is calculated before the renderer is created in order to capture actual size of the container

    that._canvas = that._calculateCanvas();
    that._renderer = new _renderer2.Renderer({
      cssClass: that._rootClassPrefix + ' ' + that._rootClass,
      pathModified: that.option('pathModified'),
      container: that._$element[0]
    });

    that._renderer.resize(that._canvas.width, that._canvas.height);
  },
  _disposeRenderer: function _disposeRenderer() {
    this._renderer.dispose();
  },
  _getAnimationOptions: _common.noop,
  render: function render() {
    this._requestChange(['CONTAINER_SIZE']);

    var visible = this._isVisible();

    this._toggleParentsScrollSubscription(visible);

    !visible && this._stopCurrentHandling();
  },
  _toggleParentsScrollSubscription: function _toggleParentsScrollSubscription(subscribe) {
    var $parents = (0, _renderer.default)(this._renderer.root.element).parents();
    var scrollEvents = 'scroll.viz_widgets';

    if (_devices.default.real().platform === 'generic') {
      $parents = $parents.add((0, _window.getWindow)());
    }

    this._proxiedTargetParentsScrollHandler = this._proxiedTargetParentsScrollHandler || function () {
      this._stopCurrentHandling();
    }.bind(this);

    _events_engine.default.off((0, _renderer.default)().add(this._$prevRootParents), scrollEvents, this._proxiedTargetParentsScrollHandler);

    if (subscribe) {
      _events_engine.default.on($parents, scrollEvents, this._proxiedTargetParentsScrollHandler);

      this._$prevRootParents = $parents;
    }
  },
  _stopCurrentHandling: _common.noop,
  _dispose: function _dispose() {
    var that = this;
    that.callBase.apply(that, arguments);

    that._toggleParentsScrollSubscription(false);

    that._removeResizeHandler();

    that._layout.dispose();

    that._eventTrigger.dispose();

    that._disposeCore();

    that._disposePlugins();

    that._disposeRenderer();

    that._themeManager.dispose();

    that._themeManager = that._renderer = that._eventTrigger = null;
  },
  _initEventTrigger: function _initEventTrigger() {
    var that = this;
    that._eventTrigger = (0, _base_widget.createEventTrigger)(that._eventsMap, function (name) {
      return that._createActionByOption(name);
    });
  },
  _calculateCanvas: function _calculateCanvas() {
    var that = this;
    var size = that.option('size') || {};
    var margin = that.option('margin') || {};
    var defaultCanvas = that._getDefaultSize() || {};

    var getSizeOfSide = function getSizeOfSide(size, side) {
      if (sizeIsValid(size[side]) || !(0, _window.hasWindow)()) {
        return 0;
      }

      var elementSize = that._$element[side]();

      return elementSize <= 1 ? 0 : elementSize;
    };

    var elementWidth = getSizeOfSide(size, 'width');
    var elementHeight = getSizeOfSide(size, 'height');
    var canvas = {
      width: size.width <= 0 ? 0 : _floor(pickPositiveValue([size.width, elementWidth, defaultCanvas.width])),
      height: size.height <= 0 ? 0 : _floor(pickPositiveValue([size.height, elementHeight, defaultCanvas.height])),
      left: pickPositiveValue([margin.left, defaultCanvas.left]),
      top: pickPositiveValue([margin.top, defaultCanvas.top]),
      right: pickPositiveValue([margin.right, defaultCanvas.right]),
      bottom: pickPositiveValue([margin.bottom, defaultCanvas.bottom])
    }; // This for backward compatibility - widget was not rendered when canvas is empty.
    // Now it will be rendered but because of "width" and "height" of the root both set to 0 it will not be visible.

    if (canvas.width - canvas.left - canvas.right <= 0 || canvas.height - canvas.top - canvas.bottom <= 0) {
      canvas = {
        width: 0,
        height: 0
      };
    }

    return canvas;
  },
  _updateSize: function _updateSize() {
    var that = this;

    var canvas = that._calculateCanvas();

    that._renderer.fixPlacement();

    if (areCanvasesDifferent(that._canvas, canvas) || that.__forceRender
    /* for charts */
    ) {
        that._canvas = canvas;

        that._recreateSizeDependentObjects(true);

        that._renderer.resize(canvas.width, canvas.height);

        that._change(['LAYOUT']);
      }
  },
  _recreateSizeDependentObjects: _common.noop,
  _getMinSize: function _getMinSize() {
    return [0, 0];
  },
  _getAlignmentRect: _common.noop,
  _setContentSize: function _setContentSize() {
    var canvas = this._canvas;
    var layout = this._layout;
    var rect = canvas.width > 0 && canvas.height > 0 ? [canvas.left, canvas.top, canvas.width - canvas.right, canvas.height - canvas.bottom] : [0, 0, 0, 0];
    rect = layout.forward(rect, this._getMinSize());
    var nextRect = this._applySize(rect) || rect;
    layout.backward(nextRect, this._getAlignmentRect() || nextRect);
  },
  _getOption: function _getOption(name, isScalar) {
    var theme = this._themeManager.theme(name);

    var option = this.option(name);
    return isScalar ? option !== undefined ? option : theme : (0, _extend.extend)(true, {}, theme, option);
  },
  _setupResizeHandler: function _setupResizeHandler() {
    var that = this;
    var redrawOnResize = (0, _utils.parseScalar)(this._getOption('redrawOnResize', true), true);

    if (that._resizeHandler) {
      that._removeResizeHandler();
    }

    that._resizeHandler = (0, _base_widget.createResizeHandler)(function () {
      if (redrawOnResize) {
        that._requestChange(['CONTAINER_SIZE']);
      } else {
        that._renderer.fixPlacement();
      }
    });

    _resize_callbacks.default.add(that._resizeHandler);
  },
  _removeResizeHandler: function _removeResizeHandler() {
    if (this._resizeHandler) {
      _resize_callbacks.default.remove(this._resizeHandler);

      this._resizeHandler.dispose();

      this._resizeHandler = null;
    }
  },
  // This is actually added only to make loading indicator pluggable. This is bad but much better than entire loading indicator in BaseWidget.
  _onBeginUpdate: _common.noop,
  beginUpdate: function beginUpdate() {
    var that = this; // The "_initialized" flag is checked because first time "beginUpdate" is called in the constructor.

    if (that._initialized && that._isUpdateAllowed()) {
      that._onBeginUpdate();

      that._suspendChanges();
    }

    that.callBase.apply(that, arguments);
    return that;
  },
  endUpdate: function endUpdate() {
    this.callBase();
    this._isUpdateAllowed() && this._resumeChanges();
    return this;
  },
  option: function option(name) {
    var that = this; // NOTE: `undefined` has to be returned because base option setter returns `undefined`.
    // `argument.length` and `isObject` checks are copypaste from Component.

    if (that._initialized && that._applyingChanges && (arguments.length > 1 || (0, _type.isObject)(name))) {
      that._optionsQueue = that._optionsQueue || [];

      that._optionsQueue.push(that._getActionForUpdating(arguments));
    } else {
      return _option.apply(that, arguments);
    }
  },
  _getActionForUpdating: function _getActionForUpdating(args) {
    var that = this;
    return function () {
      _option.apply(that, args);
    };
  },
  // For quite a long time the following method were abstract (from the Component perspective).
  // Now they are not but that basic functionality is not required here.
  _clean: _common.noop,
  _render: _common.noop,
  _optionChanged: function _optionChanged(arg) {
    var that = this;

    if (that._optionChangedLocker) {
      return;
    }

    var partialChanges = that.getPartialChangeOptionsName(arg);
    var changes = [];

    if (partialChanges.length > 0) {
      partialChanges.forEach(function (pc) {
        return changes.push(that._partialOptionChangesMap[pc]);
      });
    } else {
      changes.push(that._optionChangesMap[arg.name]);
    }

    changes = changes.filter(function (c) {
      return !!c;
    });

    if (that._eventTrigger.change(arg.name)) {
      that._change(['EVENTS']);
    } else if (changes.length > 0) {
      that._change(changes);
    } else {
      that.callBase.apply(that, arguments);
    }
  },
  _notify: _common.noop,
  _changesApplied: _common.noop,
  _optionChangesMap: {
    size: 'CONTAINER_SIZE',
    margin: 'CONTAINER_SIZE',
    redrawOnResize: 'RESIZE_HANDLER',
    theme: 'THEME',
    rtlEnabled: 'THEME',
    encodeHtml: 'THEME',
    elementAttr: 'ELEMENT_ATTR',
    disabled: 'DISABLED'
  },
  _partialOptionChangesMap: {},
  _partialOptionChangesPath: {},
  getPartialChangeOptionsName: function getPartialChangeOptionsName(changedOption) {
    var that = this;
    var fullName = changedOption.fullName;
    var sections = fullName.split(/[.]/);
    var name = changedOption.name;
    var value = changedOption.value;
    var options = this._partialOptionChangesPath[name];
    var partialChangeOptionsName = [];

    if (options) {
      if (options === true) {
        partialChangeOptionsName.push(name);
      } else {
        options.forEach(function (op) {
          fullName.indexOf(op) >= 0 && partialChangeOptionsName.push(op);
        });

        if (sections.length === 1) {
          if ((0, _type.type)(value) === 'object') {
            that._addOptionsNameForPartialUpdate(value, options, partialChangeOptionsName);
          } else if ((0, _type.type)(value) === 'array') {
            if (value.length > 0 && value.every(function (item) {
              return that._checkOptionsForPartialUpdate(item, options);
            })) {
              value.forEach(function (item) {
                return that._addOptionsNameForPartialUpdate(item, options, partialChangeOptionsName);
              });
            }
          }
        }
      }
    }

    return partialChangeOptionsName.filter(function (value, index, self) {
      return self.indexOf(value) === index;
    });
  },
  _checkOptionsForPartialUpdate: function _checkOptionsForPartialUpdate(optionObject, options) {
    return !Object.keys(optionObject).some(function (key) {
      return options.indexOf(key) === -1;
    });
  },
  _addOptionsNameForPartialUpdate: function _addOptionsNameForPartialUpdate(optionObject, options, partialChangeOptionsName) {
    var optionKeys = Object.keys(optionObject);

    if (this._checkOptionsForPartialUpdate(optionObject, options)) {
      optionKeys.forEach(function (key) {
        return options.indexOf(key) > -1 && partialChangeOptionsName.push(key);
      });
    }
  },
  _visibilityChanged: function _visibilityChanged() {
    this.render();
  },
  _setThemeAndRtl: function _setThemeAndRtl() {
    this._themeManager.setTheme(this.option('theme'), this.option(OPTION_RTL_ENABLED));
  },
  _getRendererOptions: function _getRendererOptions() {
    return {
      rtl: this.option(OPTION_RTL_ENABLED),
      encodeHtml: this.option('encodeHtml'),
      animation: this._getAnimationOptions()
    };
  },
  _setRendererOptions: function _setRendererOptions() {
    this._renderer.setOptions(this._getRendererOptions());
  },
  svg: function svg() {
    return this._renderer.svg();
  },
  getSize: function getSize() {
    var canvas = this._canvas || {};
    return {
      width: canvas.width,
      height: canvas.height
    };
  },
  isReady: getFalse,
  _dataIsReady: getTrue,
  _resetIsReady: function _resetIsReady() {
    this.isReady = getFalse;
  },
  _drawn: function _drawn() {
    var that = this;
    that.isReady = getFalse;

    if (that._dataIsReady()) {
      that._renderer.onEndAnimation(function () {
        that.isReady = getTrue;
      });
    }

    that._eventTrigger('drawn', {});
  }
});
var _default = baseWidget;
exports.default = _default;
(0, _helpers.replaceInherit)(baseWidget);
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _common = __webpack_require__(352);

var _node = _interopRequireDefault(__webpack_require__(211));

var _tiling = __webpack_require__(187);

var _colorizing = __webpack_require__(246);

var _utils = __webpack_require__(14);

var _common2 = __webpack_require__(4);

var _base_widget = _interopRequireDefault(__webpack_require__(119));

__webpack_require__(609);

__webpack_require__(611);

var _component_registrator = _interopRequireDefault(__webpack_require__(9));

var _data_source = __webpack_require__(186);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _max = Math.max;
var directions = {
  'lefttoprightbottom': [+1, +1],
  'leftbottomrighttop': [+1, -1],
  'righttopleftbottom': [-1, +1],
  'rightbottomlefttop': [-1, -1]
}; // At least one algorithm is required.

(0, _tiling.setDefaultAlgorithm)('squarified'); // By design discrete colorizing is used by default.

(0, _colorizing.setDefaultColorizer)('discrete');

function pickPositiveInteger(val) {
  return val > 0 ? Math.round(val) : 0;
}

var dxTreeMap = _base_widget.default.inherit({
  _handlers: {
    beginBuildNodes: _common2.noop,
    buildNode: _common2.noop,
    endBuildNodes: _common2.noop,
    setTrackerData: _common2.noop,
    calculateState: function calculateState(options) {
      return (0, _common.buildRectAppearance)(options);
    }
  },
  _rootClass: 'dxtm-tree-map',
  _rootClassPrefix: 'dxtm',
  _getDefaultSize: function _getDefaultSize() {
    return {
      width: 400,
      height: 400
    };
  },
  _themeSection: 'treeMap',
  _fontFields: ['tile.label.font', 'group.label.font'],
  _init: function _init() {
    var that = this;
    that._rectOffsets = {};
    that._handlers = Object.create(that._handlers);
    that._context = {
      suspend: function suspend() {
        if (!that._applyingChanges) {
          that._suspendChanges();
        }
      },
      resume: function resume() {
        if (!that._applyingChanges) {
          that._resumeChanges();
        }
      },
      change: function change(codes) {
        that._change(codes);
      },
      settings: [{}, {}],
      calculateState: that._handlers.calculateState,
      calculateLabelState: _common.buildTextAppearance
    };
    that._root = that._topNode = {
      nodes: []
    };
    that.callBase.apply(that, arguments);
  },
  _initialChanges: ['DATA_SOURCE'],
  _initCore: function _initCore() {
    var that = this;
    var renderer = that._renderer;

    that._createProxyType();

    that._tilesGroup = renderer.g().linkOn(renderer.root, 'tiles').linkAppend();
    that._labelsGroup = renderer.g().linkOn(renderer.root, 'labels').linkAppend();
  },
  _createProxyType: _common2.noop,
  _disposeCore: function _disposeCore() {
    var that = this;
    that._filter && that._filter.dispose();

    that._labelsGroup.linkOff();

    that._tilesGroup.linkOff();
  },
  _applySize: function _applySize(rect) {
    this._tilingRect = rect.slice();

    this._change(['TILING']);
  },
  _optionChangesMap: {
    dataSource: 'DATA_SOURCE',
    valueField: 'NODES_CREATE',
    childrenField: 'NODES_CREATE',
    colorField: 'TILES',
    colorizer: 'TILES',
    labelField: 'LABELS',
    tile: 'TILE_SETTINGS',
    group: 'GROUP_SETTINGS',
    maxDepth: 'MAX_DEPTH',
    layoutAlgorithm: 'TILING',
    layoutDirection: 'TILING'
  },
  _themeDependentChanges: ['TILE_SETTINGS', 'GROUP_SETTINGS', 'MAX_DEPTH'],
  _changeDataSource: function _changeDataSource() {
    var that = this;
    that._isDataExpected = that._isSyncData = true;

    that._updateDataSource();

    that._isSyncData = false;

    if (that._isDataExpected) {
      that._suspendChanges();
    }
  },
  _dataSourceChangedHandler: function _dataSourceChangedHandler() {
    var that = this;

    if (that._isDataExpected) {
      that._isDataExpected = false;

      that._change(['NODES_CREATE']);

      if (!that._isSyncData) {
        that._resumeChanges();
      }
    } else {
      that._requestChange(['NODES_CREATE']);
    }
  },
  _optionChangesOrder: ['DATA_SOURCE', 'TILE_SETTINGS', 'GROUP_SETTINGS', 'MAX_DEPTH'],
  _change_DATA_SOURCE: function _change_DATA_SOURCE() {
    this._changeDataSource();
  },
  _change_TILE_SETTINGS: function _change_TILE_SETTINGS() {
    this._changeTileSettings();
  },
  _change_GROUP_SETTINGS: function _change_GROUP_SETTINGS() {
    this._changeGroupSettings();
  },
  _change_MAX_DEPTH: function _change_MAX_DEPTH() {
    this._changeMaxDepth();
  },
  _customChangesOrder: ['NODES_CREATE', 'NODES_RESET', 'TILES', 'LABELS', 'TILING', 'LABELS_LAYOUT'],
  _change_NODES_CREATE: function _change_NODES_CREATE() {
    this._buildNodes();
  },
  _change_NODES_RESET: function _change_NODES_RESET() {
    this._resetNodes();
  },
  _change_TILES: function _change_TILES() {
    this._applyTilesAppearance();
  },
  _change_LABELS: function _change_LABELS() {
    this._applyLabelsAppearance();
  },
  _change_TILING: function _change_TILING() {
    this._performTiling();
  },
  _change_LABELS_LAYOUT: function _change_LABELS_LAYOUT() {
    this._performLabelsLayout();
  },
  _applyChanges: function _applyChanges() {
    var that = this;
    that.callBase.apply(that, arguments); // This looks dirty.

    if (!that._isDataExpected) {
      that._drawn();
    } // Looks dirty but let it stay so until there is only one such case.


    that._context.forceReset = false;
  },
  _buildNodes: function _buildNodes() {
    var that = this;
    var root = that._root = that._topNode = new _node.default();
    root._id = 0;
    root.parent = {};
    root.data = {};
    root.level = root.index = -1;
    root.ctx = that._context;
    root.label = null;
    that._nodes = [root];

    that._handlers.beginBuildNodes();

    var processedData = that._processDataSourceItems(that._dataSourceItems() || []);

    traverseDataItems(root, processedData.items, 0, {
      itemsField: !processedData.isPlain && that._getOption('childrenField', true) || 'items',
      valueField: that._getOption('valueField', true) || 'value',
      buildNode: that._handlers.buildNode,
      ctx: that._context,
      nodes: that._nodes
    });

    that._onNodesCreated();

    that._handlers.endBuildNodes();

    that._change(['NODES_RESET']);
  },
  _onNodesCreated: _common2.noop,
  _processDataSourceItems: function _processDataSourceItems(items) {
    return {
      items: items,
      isPlain: false
    };
  },
  _changeTileSettings: function _changeTileSettings() {
    var that = this;

    var options = that._getOption('tile');

    var offsets = that._rectOffsets;
    var borderWidth = pickPositiveInteger(options.border.width);
    var edgeOffset = borderWidth / 2;
    var innerOffset = borderWidth & 1 ? 0.5 : 0;
    var labelOptions = options.label;
    var settings = that._context.settings[0];

    that._change(['TILES', 'LABELS']);

    settings.state = that._handlers.calculateState(options); // TODO: There should be some way (option) to prevent filter creation

    that._filter = that._filter || that._renderer.shadowFilter('-50%', '-50%', '200%', '200%');

    that._filter.attr(labelOptions.shadow);

    that._calculateLabelSettings(settings, labelOptions, that._filter.id);

    if (offsets.tileEdge !== edgeOffset || offsets.tileInner !== innerOffset) {
      offsets.tileEdge = edgeOffset;
      offsets.tileInner = innerOffset;

      that._change(['TILING']);
    }
  },
  _changeGroupSettings: function _changeGroupSettings() {
    var that = this;

    var options = that._getOption('group');

    var labelOptions = options.label;
    var offsets = that._rectOffsets;
    var borderWidth = pickPositiveInteger(options.border.width);
    var edgeOffset = borderWidth / 2;
    var innerOffset = borderWidth & 1 ? 0.5 : 0;
    var headerHeight = 0;
    var groupPadding = pickPositiveInteger(options.padding);
    var settings = that._context.settings[1];

    that._change(['TILES', 'LABELS']);

    settings.state = that._handlers.calculateState(options);

    that._calculateLabelSettings(settings, labelOptions);

    if (options.headerHeight >= 0) {
      headerHeight = pickPositiveInteger(options.headerHeight);
    } else {
      headerHeight = settings.labelParams.height + 2 * pickPositiveInteger(labelOptions.paddingTopBottom);
    }

    if (that._headerHeight !== headerHeight) {
      that._headerHeight = headerHeight;

      that._change(['TILING']);
    }

    if (that._groupPadding !== groupPadding) {
      that._groupPadding = groupPadding;

      that._change(['TILING']);
    }

    if (offsets.headerEdge !== edgeOffset || offsets.headerInner !== innerOffset) {
      offsets.headerEdge = edgeOffset;
      offsets.headerInner = innerOffset;

      that._change(['TILING']);
    }
  },
  _calculateLabelSettings: function _calculateLabelSettings(settings, options, filter) {
    var bBox = this._getTextBBox(options.font);

    var paddingLeftRight = pickPositiveInteger(options.paddingLeftRight);
    var paddingTopBottom = pickPositiveInteger(options.paddingTopBottom);

    var tileLabelOptions = this._getOption('tile.label');

    var groupLabelOptions = this._getOption('group.label');

    settings.labelState = (0, _common.buildTextAppearance)(options, filter);
    settings.labelState.visible = !('visible' in options) || !!options.visible;
    settings.labelParams = {
      height: bBox.height,
      rtlEnabled: this._getOption('rtlEnabled', true),
      paddingTopBottom: paddingTopBottom,
      paddingLeftRight: paddingLeftRight,
      tileLabelWordWrap: tileLabelOptions.wordWrap,
      tileLabelOverflow: tileLabelOptions.textOverflow,
      groupLabelOverflow: groupLabelOptions.textOverflow
    };
  },
  _changeMaxDepth: function _changeMaxDepth() {
    var maxDepth = this._getOption('maxDepth', true);

    maxDepth = maxDepth >= 1 ? Math.round(maxDepth) : Infinity;

    if (this._maxDepth !== maxDepth) {
      this._maxDepth = maxDepth;

      this._change(['NODES_RESET']);
    }
  },
  _resetNodes: function _resetNodes() {
    var that = this;

    that._tilesGroup.clear();

    that._renderer.initHatching();

    that._context.forceReset = true;
    that._context.minLevel = that._topNode.level + 1;
    that._context.maxLevel = that._context.minLevel + that._maxDepth - 1;

    that._change(['TILES', 'LABELS', 'TILING']);
  },
  _processNodes: function _processNodes(context, process) {
    processNodes(context, this._topNode, process);
  },
  _applyTilesAppearance: function _applyTilesAppearance() {
    var that = this; // Passing *themeManager* looks dirty but is excused by necessity of palettes (and default palette specifically).
    // Passing *topNode* looks awfully dirty and is performed only because of discrete group colorizing.
    // Aforementioned colorizing requires breadth-first tree traversal and nodes processing is performed in a depth-first order.
    // TODO: Find a way to stop passing *topNode*

    var colorizer = (0, _colorizing.getColorizer)(that._getOption('colorizer'), that._themeManager, that._topNode);

    that._processNodes({
      renderer: that._renderer,
      group: that._tilesGroup,
      setTrackerData: that._handlers.setTrackerData,
      colorField: that._getOption('colorField', true) || 'color',
      getColor: colorizer
    }, processTileAppearance);
  },
  _applyLabelsAppearance: function _applyLabelsAppearance() {
    var that = this;

    that._labelsGroup.clear();

    that._processNodes({
      renderer: that._renderer,
      group: that._labelsGroup,
      setTrackerData: that._handlers.setTrackerData,
      labelField: that._getOption('labelField', true) || 'name'
    }, processLabelAppearance); // Actually that is strange - for example if just "font.color" is changed then there is no need to layout labels.
    // But for <text> element can change its size because of rather many reasons - so for simplicity layout is always performed.


    that._change(['LABELS_LAYOUT']);
  },
  _performTiling: function _performTiling() {
    var that = this;
    var context = {
      algorithm: (0, _tiling.getAlgorithm)(that._getOption('layoutAlgorithm', true)),
      directions: directions[String(that._getOption('layoutDirection', true)).toLowerCase()] || directions['lefttoprightbottom'],
      headerHeight: that._headerHeight,
      groupPadding: that._groupPadding,
      rectOffsets: that._rectOffsets
    };
    that._topNode.innerRect = that._tilingRect;
    calculateRects(context, that._topNode);

    that._processNodes(context, processTiling);

    that._change(['LABELS_LAYOUT']);

    that._onTilingPerformed();
  },
  _onTilingPerformed: _common2.noop,
  _performLabelsLayout: function _performLabelsLayout() {
    this._processNodes(null, processLabelsLayout);
  },
  _getTextBBox: function _getTextBBox(fontOptions) {
    var renderer = this._renderer;
    var text = this._textForCalculations || renderer.text('0', 0, 0);
    this._textForCalculations = text;
    text.css((0, _utils.patchFontOptions)(fontOptions)).append(renderer.root);
    var bBox = text.getBBox();
    text.remove();
    return bBox;
  }
});

function traverseDataItems(root, dataItems, level, params) {
  var nodes = [];
  var allNodes = params.nodes;
  var node;
  var i;
  var ii = dataItems.length;
  var dataItem;
  var totalValue = 0;
  var items;

  for (i = 0; i < ii; ++i) {
    var _items;

    dataItem = dataItems[i];
    node = new _node.default();
    node._id = allNodes.length;
    node.ctx = params.ctx;
    node.parent = root;
    node.level = level;
    node.index = nodes.length;
    node.data = dataItem;
    params.buildNode(node);
    allNodes.push(node);
    nodes.push(node);
    items = dataItem[params.itemsField];

    if ((_items = items) !== null && _items !== void 0 && _items.length) {
      traverseDataItems(node, items, level + 1, params);
    }

    if (dataItem[params.valueField] > 0) {
      node.value = Number(dataItem[params.valueField]);
    }

    totalValue += node.value;
  }

  root.nodes = nodes;
  root.value = totalValue;
}

function processNodes(context, root, process) {
  var nodes = root.nodes;
  var node;
  var i;
  var ii = nodes.length;

  for (i = 0; i < ii; ++i) {
    node = nodes[i];
    process(context, node);

    if (node.isNode()) {
      processNodes(context, node, process);
    }
  }
}

var createTile = [createLeaf, createGroup];

function processTileAppearance(context, node) {
  node.color = node.data[context.colorField] || context.getColor(node) || node.parent.color;
  node.updateStyles();
  node.tile = !node.ctx.forceReset && node.tile || createTile[Number(node.isNode())](context, node);
  node.applyState();
}

function createLeaf(context, node) {
  var tile = context.renderer.simpleRect().append(context.group);
  context.setTrackerData(node, tile);
  return tile;
}

function createGroup(context, node) {
  var outer = context.renderer.simpleRect().append(context.group);
  var inner = context.renderer.simpleRect().append(context.group);
  context.setTrackerData(node, inner);
  return {
    outer: outer,
    inner: inner
  };
}

function processLabelAppearance(context, node) {
  node.updateLabelStyle();

  if (node.labelState.visible) {
    createLabel(context, node, node.labelState, node.labelParams);
  }
}

function createLabel(context, currentNode, settings, params) {
  var textData = currentNode.data[context.labelField];
  currentNode.label = textData ? String(textData) : null;
  textData = currentNode.customLabel || currentNode.label;

  if (textData) {
    currentNode.text = context.renderer.text(textData).attr(settings.attr).css(settings.css).append(context.group);
    context.setTrackerData(currentNode, currentNode.text);
  }
}

var emptyRect = [0, 0, 0, 0];

function calculateRects(context, root) {
  var nodes = root.nodes;
  var items = [];
  var rects = [];
  var sum = 0;
  var i;
  var ii = items.length = rects.length = nodes.length;

  for (i = 0; i < ii; ++i) {
    sum += nodes[i].value;
    items[i] = {
      value: nodes[i].value,
      i: i
    };
  }

  if (sum > 0) {
    context.algorithm({
      items: items.slice(),
      sum: sum,
      rect: root.innerRect.slice(),
      isRotated: nodes[0].level & 1,
      directions: context.directions
    });
  }

  for (i = 0; i < ii; ++i) {
    rects[i] = items[i].rect || emptyRect;
  }

  root.rects = rects;
}

function processTiling(context, node) {
  var rect = node.parent.rects[node.index];
  var rectOffsets = context.rectOffsets;
  var headerHeight;

  if (node.isNode()) {
    setRectAttrs(node.tile.outer, buildTileRect(rect, node.parent.innerRect, rectOffsets.headerEdge, rectOffsets.headerInner));
    rect = marginateRect(rect, context.groupPadding);
    headerHeight = Math.min(context.headerHeight, rect[3] - rect[1]);
    node.rect = [rect[0], rect[1], rect[2], rect[1] + headerHeight];
    setRectAttrs(node.tile.inner, marginateRect(node.rect, rectOffsets.headerEdge));
    rect[1] += headerHeight;
    node.innerRect = rect;
    calculateRects(context, node);
  } else {
    node.rect = rect;
    setRectAttrs(node.tile, buildTileRect(rect, node.parent.innerRect, rectOffsets.tileEdge, rectOffsets.tileInner));
  }
}

function marginateRect(rect, margin) {
  return [rect[0] + margin, rect[1] + margin, rect[2] - margin, rect[3] - margin];
}

function buildTileRect(rect, outer, edgeOffset, innerOffset) {
  return [rect[0] + (rect[0] === outer[0] ? edgeOffset : +innerOffset), rect[1] + (rect[1] === outer[1] ? edgeOffset : +innerOffset), rect[2] - (rect[2] === outer[2] ? edgeOffset : -innerOffset), rect[3] - (rect[3] === outer[3] ? edgeOffset : -innerOffset)];
}

function setRectAttrs(element, rect) {
  element.attr({
    x: rect[0],
    y: rect[1],
    width: _max(rect[2] - rect[0], 0),
    height: _max(rect[3] - rect[1], 0)
  });
}

function processLabelsLayout(context, node) {
  if (node.text && node.labelState.visible) {
    layoutTextNode(node, node.labelParams);
  }
}

function layoutTextNode(node, params) {
  var rect = node.rect;
  var text = node.text;
  var bBox = text.getBBox();
  var paddingLeftRight = params.paddingLeftRight;
  var paddingTopBottom = params.paddingTopBottom;
  var effectiveWidth = rect[2] - rect[0] - 2 * paddingLeftRight;
  text.setMaxSize(effectiveWidth, rect[3] - rect[1] - paddingTopBottom, node.isNode() ? {
    textOverflow: params.groupLabelOverflow,
    wordWrap: 'none'
  } : {
    textOverflow: params.tileLabelOverflow,
    wordWrap: params.tileLabelWordWrap,
    hideOverflowEllipsis: true
  });
  text.move(params.rtlEnabled ? rect[2] - paddingLeftRight - bBox.x - bBox.width : rect[0] + paddingLeftRight - bBox.x, rect[1] + paddingTopBottom - bBox.y);
}

(0, _component_registrator.default)('dxTreeMap', dxTreeMap);
var _default = dxTreeMap; // PLUGINS_SECTION

exports.default = _default;
dxTreeMap.addPlugin(_data_source.plugin);
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _window = __webpack_require__(7);

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Action = /*#__PURE__*/function () {
  function Action(action, config) {
    config = config || {};
    this._action = action;
    this._context = config.context || (0, _window.getWindow)();
    this._beforeExecute = config.beforeExecute;
    this._afterExecute = config.afterExecute;
    this._component = config.component;
    this._validatingTargetName = config.validatingTargetName;
    var excludeValidators = this._excludeValidators = {};

    if (config.excludeValidators) {
      for (var i = 0; i < config.excludeValidators.length; i++) {
        excludeValidators[config.excludeValidators[i]] = true;
      }
    }
  }

  var _proto = Action.prototype;

  _proto.execute = function execute() {
    var e = {
      action: this._action,
      args: Array.prototype.slice.call(arguments),
      context: this._context,
      component: this._component,
      validatingTargetName: this._validatingTargetName,
      cancel: false,
      handled: false
    };
    var beforeExecute = this._beforeExecute;
    var afterExecute = this._afterExecute;
    var argsBag = e.args[0] || {};

    if (!this._validateAction(e)) {
      return;
    }

    beforeExecute === null || beforeExecute === void 0 ? void 0 : beforeExecute.call(this._context, e);

    if (e.cancel) {
      return;
    }

    var result = this._executeAction(e);

    if (argsBag.cancel) {
      return;
    }

    afterExecute === null || afterExecute === void 0 ? void 0 : afterExecute.call(this._context, e);
    return result;
  };

  _proto._validateAction = function _validateAction(e) {
    var excludeValidators = this._excludeValidators;
    var executors = Action.executors;

    for (var name in executors) {
      if (!excludeValidators[name]) {
        var _executor$validate;

        var executor = executors[name];
        (_executor$validate = executor.validate) === null || _executor$validate === void 0 ? void 0 : _executor$validate.call(executor, e);

        if (e.cancel) {
          return false;
        }
      }
    }

    return true;
  };

  _proto._executeAction = function _executeAction(e) {
    var result;
    var executors = Action.executors;

    for (var name in executors) {
      var _executor$execute;

      var executor = executors[name];
      (_executor$execute = executor.execute) === null || _executor$execute === void 0 ? void 0 : _executor$execute.call(executor, e);

      if (e.handled) {
        result = e.result;
        break;
      }
    }

    return result;
  };

  Action.registerExecutor = function registerExecutor(name, executor) {
    if ((0, _type.isPlainObject)(name)) {
      (0, _iterator.each)(name, Action.registerExecutor);
      return;
    }

    Action.executors[name] = executor;
  };

  Action.unregisterExecutor = function unregisterExecutor() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _iterator.each)(args, function () {
      delete Action.executors[this];
    });
  };

  return Action;
}();

exports.default = Action;
Action.executors = {};

var createValidatorByTargetElement = function createValidatorByTargetElement(condition) {
  return function (e) {
    if (!e.args.length) {
      return;
    }

    var args = e.args[0];
    var element = args[e.validatingTargetName] || args.element;

    if (element && condition((0, _renderer.default)(element))) {
      e.cancel = true;
    }
  };
};

Action.registerExecutor({
  'disabled': {
    validate: createValidatorByTargetElement(function ($target) {
      return $target.is('.dx-state-disabled, .dx-state-disabled *');
    })
  },
  'readOnly': {
    validate: createValidatorByTargetElement(function ($target) {
      return $target.is('.dx-state-readonly, .dx-state-readonly *:not(.dx-state-independent)');
    })
  },
  'undefined': {
    execute: function execute(e) {
      if (!e.action) {
        e.result = undefined;
        e.handled = true;
      }
    }
  },
  'func': {
    execute: function execute(e) {
      if ((0, _type.isFunction)(e.action)) {
        e.result = e.action.call(e.context, e.args[0]);
        e.handled = true;
      }
    }
  }
});
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.requestAnimationFrame = requestAnimationFrame;
exports.cancelAnimationFrame = cancelAnimationFrame;

var _window = __webpack_require__(7);

var _call_once = _interopRequireDefault(__webpack_require__(79));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var window = (0, _window.hasWindow)() ? (0, _window.getWindow)() : {};
var FRAME_ANIMATION_STEP_TIME = 1000 / 60;

var request = function request(callback) {
  return setTimeout(callback, FRAME_ANIMATION_STEP_TIME);
};

var cancel = function cancel(requestID) {
  clearTimeout(requestID);
};

var setAnimationFrameMethods = (0, _call_once.default)(function () {
  var nativeRequest = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
  var nativeCancel = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;

  if (nativeRequest && nativeCancel) {
    request = nativeRequest;
    cancel = nativeCancel;
  }

  if (nativeRequest && !nativeCancel) {
    // NOTE: https://code.google.com/p/android/issues/detail?id=66243
    var canceledRequests = {};

    request = function request(callback) {
      var requestId = nativeRequest.call(window, function () {
        try {
          if (requestId in canceledRequests) {
            return;
          }

          callback.apply(this, arguments);
        } finally {
          delete canceledRequests[requestId];
        }
      });
      return requestId;
    };

    cancel = function cancel(requestId) {
      canceledRequests[requestId] = true;
    };
  }
});

function requestAnimationFrame() {
  setAnimationFrameMethods();
  return request.apply(window, arguments);
}

function cancelAnimationFrame() {
  setAnimationFrameMethods();
  cancel.apply(window, arguments);
}

/***/ }),
/* 123 */,
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _memorized_callbacks = _interopRequireDefault(__webpack_require__(194));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = new _memorized_callbacks.default();

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Component = void 0;

var _config = _interopRequireDefault(__webpack_require__(29));

var _extend = __webpack_require__(0);

var _index = __webpack_require__(354);

var _utils = __webpack_require__(126);

var _class = _interopRequireDefault(__webpack_require__(15));

var _action = _interopRequireDefault(__webpack_require__(121));

var _errors = _interopRequireDefault(__webpack_require__(24));

var _callbacks = _interopRequireDefault(__webpack_require__(28));

var _events_strategy = __webpack_require__(96);

var _public_component = __webpack_require__(143);

var _postponed_operations = __webpack_require__(381);

var _type = __webpack_require__(1);

var _common = __webpack_require__(4);

var _data = __webpack_require__(21);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getEventName = function getEventName(actionName) {
  return actionName.charAt(2).toLowerCase() + actionName.substr(3);
};

var isInnerOption = function isInnerOption(optionName) {
  return optionName.indexOf('_', 0) === 0;
};

var Component = _class.default.inherit({
  _setDeprecatedOptions: function _setDeprecatedOptions() {
    this._deprecatedOptions = {};
  },
  _getDeprecatedOptions: function _getDeprecatedOptions() {
    return this._deprecatedOptions;
  },
  _getDefaultOptions: function _getDefaultOptions() {
    return {
      onInitialized: null,
      onOptionChanged: null,
      onDisposing: null,
      defaultOptionsRules: null
    };
  },
  _defaultOptionsRules: function _defaultOptionsRules() {
    return [];
  },
  _setOptionsByDevice: function _setOptionsByDevice(rules) {
    this._options.applyRules(rules);
  },
  _convertRulesToOptions: function _convertRulesToOptions(rules) {
    return (0, _utils.convertRulesToOptions)(rules);
  },
  _isInitialOptionValue: function _isInitialOptionValue(name) {
    return this._options.isInitial(name);
  },
  _setOptionsByReference: function _setOptionsByReference() {
    this._optionsByReference = {};
  },
  _getOptionsByReference: function _getOptionsByReference() {
    return this._optionsByReference;
  },

  /**
  * @name Component.ctor
  * @publicName ctor(options)
  * @param1 options:ComponentOptions|undefined
  * @hidden
  */
  ctor: function ctor() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _optionChangedCallbacks = options._optionChangedCallbacks,
        _disposingCallbacks = options._disposingCallbacks;
    this.NAME = (0, _public_component.name)(this.constructor);
    this._eventsStrategy = _events_strategy.EventsStrategy.create(this, options.eventsStrategy);
    this._updateLockCount = 0;
    this._optionChangedCallbacks = _optionChangedCallbacks || (0, _callbacks.default)();
    this._disposingCallbacks = _disposingCallbacks || (0, _callbacks.default)();
    this.postponedOperations = new _postponed_operations.PostponedOperations();

    this._createOptions(options);
  },
  _createOptions: function _createOptions(options) {
    var _this = this;

    this.beginUpdate();

    try {
      this._setOptionsByReference();

      this._setDeprecatedOptions();

      this._options = new _index.Options(this._getDefaultOptions(), this._getDefaultOptions(), this._getOptionsByReference(), this._getDeprecatedOptions());

      this._options.onChanging(function (name, previousValue, value) {
        return _this._initialized && _this._optionChanging(name, previousValue, value);
      });

      this._options.onDeprecated(function (option, info) {
        return _this._logDeprecatedOptionWarning(option, info);
      });

      this._options.onChanged(function (name, value, previousValue) {
        return _this._notifyOptionChanged(name, value, previousValue);
      });

      this._options.onStartChange(function () {
        return _this.beginUpdate();
      });

      this._options.onEndChange(function () {
        return _this.endUpdate();
      });

      this._options.addRules(this._defaultOptionsRules());

      if (options && options.onInitializing) {
        options.onInitializing.apply(this, [options]);
      }

      this._setOptionsByDevice(options.defaultOptionsRules);

      this._initOptions(options);
    } finally {
      this.endUpdate();
    }
  },
  _initOptions: function _initOptions(options) {
    this.option(options);
  },
  _init: function _init() {
    var _this2 = this;

    this._createOptionChangedAction();

    this.on('disposing', function (args) {
      _this2._disposingCallbacks.fireWith(_this2, [args]);
    });
  },
  _logDeprecatedOptionWarning: function _logDeprecatedOptionWarning(option, info) {
    var message = info.message || "Use the '".concat(info.alias, "' option instead");

    _errors.default.log('W0001', this.NAME, option, info.since, message);
  },
  _logDeprecatedComponentWarning: function _logDeprecatedComponentWarning(since, alias) {
    _errors.default.log('W0000', this.NAME, since, "Use the '".concat(alias, "' widget instead"));
  },
  _createOptionChangedAction: function _createOptionChangedAction() {
    this._optionChangedAction = this._createActionByOption('onOptionChanged', {
      excludeValidators: ['disabled', 'readOnly']
    });
  },
  _createDisposingAction: function _createDisposingAction() {
    this._disposingAction = this._createActionByOption('onDisposing', {
      excludeValidators: ['disabled', 'readOnly']
    });
  },
  _optionChanged: function _optionChanged(args) {
    switch (args.name) {
      case 'onDisposing':
      case 'onInitialized':
        break;

      case 'onOptionChanged':
        this._createOptionChangedAction();

        break;

      case 'defaultOptionsRules':
        break;
    }
  },
  _dispose: function _dispose() {
    this._optionChangedCallbacks.empty();

    this._createDisposingAction();

    this._disposingAction();

    this._eventsStrategy.dispose();

    this._options.dispose();

    this._disposed = true;
  },
  _lockUpdate: function _lockUpdate() {
    this._updateLockCount++;
  },
  _unlockUpdate: function _unlockUpdate() {
    this._updateLockCount = Math.max(this._updateLockCount - 1, 0);
  },
  // TODO: remake as getter after ES6 refactor
  _isUpdateAllowed: function _isUpdateAllowed() {
    return this._updateLockCount === 0;
  },
  // TODO: remake as getter after ES6 refactor
  _isInitializingRequired: function _isInitializingRequired() {
    return !this._initializing && !this._initialized;
  },
  _commitUpdate: function _commitUpdate() {
    this.postponedOperations.callPostponedOperations();
    this._isInitializingRequired() && this._initializeComponent();
  },
  _initializeComponent: function _initializeComponent() {
    this._initializing = true;

    try {
      this._init();
    } finally {
      this._initializing = false;

      this._lockUpdate();

      this._createActionByOption('onInitialized', {
        excludeValidators: ['disabled', 'readOnly']
      })();

      this._unlockUpdate();

      this._initialized = true;
    }
  },
  instance: function instance() {
    return this;
  },
  beginUpdate: function beginUpdate() {
    this._lockUpdate();
  },
  endUpdate: function endUpdate() {
    this._unlockUpdate();

    this._isUpdateAllowed() && this._commitUpdate();
  },
  _optionChanging: _common.noop,
  _notifyOptionChanged: function _notifyOptionChanged(option, value, previousValue) {
    if (this._initialized) {
      var optionNames = [option].concat(this._options.getAliasesByName(option));

      for (var i = 0; i < optionNames.length; i++) {
        var name = optionNames[i];
        var args = {
          name: (0, _data.getPathParts)(name)[0],
          fullName: name,
          value: value,
          previousValue: previousValue
        };

        if (!isInnerOption(name)) {
          this._optionChangedCallbacks.fireWith(this, [(0, _extend.extend)(this._defaultActionArgs(), args)]);

          this._optionChangedAction((0, _extend.extend)({}, args));
        }

        if (!this._disposed && this._cancelOptionChange !== name) {
          this._optionChanged(args);
        }
      }
    }
  },
  initialOption: function initialOption(name) {
    return this._options.initial(name);
  },
  _defaultActionConfig: function _defaultActionConfig() {
    return {
      context: this,
      component: this
    };
  },
  _defaultActionArgs: function _defaultActionArgs() {
    return {
      component: this
    };
  },
  _createAction: function _createAction(actionSource, config) {
    var _this3 = this;

    var action;
    return function (e) {
      if (!(0, _type.isDefined)(e)) {
        e = {};
      }

      if (!(0, _type.isPlainObject)(e)) {
        e = {
          actionValue: e
        };
      }

      action = action || new _action.default(actionSource, (0, _extend.extend)(config, _this3._defaultActionConfig()));
      return action.execute.call(action, (0, _extend.extend)(e, _this3._defaultActionArgs()));
    };
  },
  _createActionByOption: function _createActionByOption(optionName, config) {
    var _this4 = this;

    var action;
    var eventName;
    var actionFunc;

    var result = function result() {
      if (!eventName) {
        config = config || {};

        if (typeof optionName !== 'string') {
          throw _errors.default.Error('E0008');
        }

        if (optionName.indexOf('on') === 0) {
          eventName = getEventName(optionName);
        }

        actionFunc = _this4.option(optionName);
      }

      if (!action && !actionFunc && !config.beforeExecute && !config.afterExecute && !_this4._eventsStrategy.hasEvent(eventName)) {
        return;
      }

      if (!action) {
        var beforeExecute = config.beforeExecute;

        config.beforeExecute = function () {
          for (var _len2 = arguments.length, props = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            props[_key2] = arguments[_key2];
          }

          beforeExecute && beforeExecute.apply(_this4, props);

          _this4._eventsStrategy.fireEvent(eventName, props[0].args);
        };

        action = _this4._createAction(actionFunc, config);
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if ((0, _config.default)().wrapActionsBeforeExecute) {
        var beforeActionExecute = _this4.option('beforeActionExecute') || _common.noop;

        var wrappedAction = beforeActionExecute(_this4, action, config) || action;
        return wrappedAction.apply(_this4, args);
      }

      return action.apply(_this4, args);
    };

    if ((0, _config.default)().wrapActionsBeforeExecute) {
      return result;
    }

    var onActionCreated = this.option('onActionCreated') || _common.noop;

    return onActionCreated(this, result, config) || result;
  },
  on: function on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);

    return this;
  },
  off: function off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);

    return this;
  },
  hasActionSubscription: function hasActionSubscription(actionName) {
    return !!this._options.silent(actionName) || this._eventsStrategy.hasEvent(getEventName(actionName));
  },
  isOptionDeprecated: function isOptionDeprecated(name) {
    return this._options.isDeprecated(name);
  },
  _setOptionWithoutOptionChange: function _setOptionWithoutOptionChange(name, value) {
    this._cancelOptionChange = name;
    this.option(name, value);
    this._cancelOptionChange = false;
  },
  _getOptionValue: function _getOptionValue(name, context) {
    var value = this.option(name);

    if ((0, _type.isFunction)(value)) {
      return value.bind(context)();
    }

    return value;
  },
  option: function option() {
    var _this$_options;

    return (_this$_options = this._options).option.apply(_this$_options, arguments);
  },
  resetOption: function resetOption(name) {
    this.beginUpdate();

    this._options.reset(name);

    this.endUpdate();
  }
});
/**
 * @name Component
 * @module core/component
 * @export Component
 * @namespace DevExpress
 * @hidden
 * @wrappable
 */


exports.Component = Component;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.createDefaultOptionRules = exports.getNestedOptionValue = exports.getParentName = exports.getFieldName = exports.deviceMatch = exports.normalizeOptions = exports.convertRulesToOptions = void 0;

var _devices = _interopRequireDefault(__webpack_require__(13));

var _type = __webpack_require__(1);

var _common = __webpack_require__(4);

var _extend = __webpack_require__(0);

var _data = __webpack_require__(21);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var cachedGetters = {};

var convertRulesToOptions = function convertRulesToOptions(rules) {
  var currentDevice = _devices.default.current();

  return rules.reduce(function (options, _ref) {
    var device = _ref.device,
        ruleOptions = _ref.options;
    var deviceFilter = device || {};
    var match = (0, _type.isFunction)(deviceFilter) ? deviceFilter(currentDevice) : deviceMatch(currentDevice, deviceFilter);

    if (match) {
      (0, _extend.extend)(true, options, ruleOptions);
    }

    return options;
  }, {});
};

exports.convertRulesToOptions = convertRulesToOptions;

var normalizeOptions = function normalizeOptions(options, value) {
  return typeof options !== 'string' ? options : _defineProperty({}, options, value);
};

exports.normalizeOptions = normalizeOptions;

var deviceMatch = function deviceMatch(device, filter) {
  return (0, _type.isEmptyObject)(filter) || (0, _common.findBestMatches)(device, [filter]).length > 0;
};

exports.deviceMatch = deviceMatch;

var getFieldName = function getFieldName(fullName) {
  return fullName.substr(fullName.lastIndexOf('.') + 1);
};

exports.getFieldName = getFieldName;

var getParentName = function getParentName(fullName) {
  return fullName.substr(0, fullName.lastIndexOf('.'));
};

exports.getParentName = getParentName;

var getNestedOptionValue = function getNestedOptionValue(optionsObject, name) {
  cachedGetters[name] = cachedGetters[name] || (0, _data.compileGetter)(name);
  return cachedGetters[name](optionsObject, {
    functionsAsIs: true
  });
};

exports.getNestedOptionValue = getNestedOptionValue;

var createDefaultOptionRules = function createDefaultOptionRules() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return options;
};

exports.createDefaultOptionRules = createDefaultOptionRules;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _common = __webpack_require__(4);

var _class = _interopRequireDefault(__webpack_require__(15));

var _callbacks = _interopRequireDefault(__webpack_require__(28));

var _extend = __webpack_require__(0);

var _index = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Emitter = _class.default.inherit({
  ctor: function ctor(element) {
    this._$element = (0, _renderer.default)(element);
    this._cancelCallback = (0, _callbacks.default)();
    this._acceptCallback = (0, _callbacks.default)();
  },
  getElement: function getElement() {
    return this._$element;
  },
  validate: function validate(e) {
    return !(0, _index.isDxMouseWheelEvent)(e);
  },
  validatePointers: function validatePointers(e) {
    return (0, _index.hasTouches)(e) === 1;
  },
  allowInterruptionByMouseWheel: function allowInterruptionByMouseWheel() {
    return true;
  },
  configure: function configure(data) {
    (0, _extend.extend)(this, data);
  },
  addCancelCallback: function addCancelCallback(callback) {
    this._cancelCallback.add(callback);
  },
  removeCancelCallback: function removeCancelCallback() {
    this._cancelCallback.empty();
  },
  _cancel: function _cancel(e) {
    this._cancelCallback.fire(this, e);
  },
  addAcceptCallback: function addAcceptCallback(callback) {
    this._acceptCallback.add(callback);
  },
  removeAcceptCallback: function removeAcceptCallback() {
    this._acceptCallback.empty();
  },
  _accept: function _accept(e) {
    this._acceptCallback.fire(this, e);
  },
  _requestAccept: function _requestAccept(e) {
    this._acceptRequestEvent = e;
  },
  _forgetAccept: function _forgetAccept() {
    this._accept(this._acceptRequestEvent);

    this._acceptRequestEvent = null;
  },
  start: _common.noop,
  move: _common.noop,
  end: _common.noop,
  cancel: _common.noop,
  reset: function reset() {
    if (this._acceptRequestEvent) {
      this._accept(this._acceptRequestEvent);
    }
  },
  _fireEvent: function _fireEvent(eventName, e, params) {
    var eventData = (0, _extend.extend)({
      type: eventName,
      originalEvent: e,
      target: this._getEmitterTarget(e),
      delegateTarget: this.getElement().get(0)
    }, params);
    e = (0, _index.fireEvent)(eventData);

    if (e.cancel) {
      this._cancel(e);
    }

    return e;
  },
  _getEmitterTarget: function _getEmitterTarget(e) {
    return (this.delegateSelector ? (0, _renderer.default)(e.target).closest(this.delegateSelector) : this.getElement()).get(0);
  },
  dispose: _common.noop
});

var _default = Emitter;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 128 */
/***/ (function(module, exports) {

module.exports = window.angular;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _utils = _interopRequireDefault(__webpack_require__(44));

var _array_utils = __webpack_require__(88);

var _type = __webpack_require__(1);

var _config = _interopRequireDefault(__webpack_require__(29));

var _errors = __webpack_require__(37);

var _abstract_store = _interopRequireDefault(__webpack_require__(106));

var _array_query = _interopRequireDefault(__webpack_require__(166));

var _store_helper = _interopRequireDefault(__webpack_require__(95));

var _deferred = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TOTAL_COUNT = 'totalCount';
var LOAD = 'load';
var BY_KEY = 'byKey';
var INSERT = 'insert';
var UPDATE = 'update';
var REMOVE = 'remove';

function isPromise(obj) {
  return obj && (0, _type.isFunction)(obj.then);
}

function trivialPromise(value) {
  return new _deferred.Deferred().resolve(value).promise();
}

function ensureRequiredFuncOption(name, obj) {
  if (!(0, _type.isFunction)(obj)) {
    throw _errors.errors.Error('E4011', name);
  }
}

function throwInvalidUserFuncResult(name) {
  throw _errors.errors.Error('E4012', name);
}

function createUserFuncFailureHandler(pendingDeferred) {
  function errorMessageFromXhr(promiseArguments) {
    var xhr = promiseArguments[0];
    var textStatus = promiseArguments[1];

    if (!xhr || !xhr.getResponseHeader) {
      return null;
    }

    return _utils.default.errorMessageFromXhr(xhr, textStatus);
  }

  return function (arg) {
    var error;

    if (arg instanceof Error) {
      error = arg;
    } else {
      error = new Error(errorMessageFromXhr(arguments) || arg && String(arg) || 'Unknown error');
    }

    if (error.message !== _utils.default.XHR_ERROR_UNLOAD) {
      pendingDeferred.reject(error);
    }
  };
}

function invokeUserLoad(store, options) {
  var userFunc = store._loadFunc;
  var userResult;
  ensureRequiredFuncOption(LOAD, userFunc);
  userResult = userFunc.apply(store, [options]);

  if (Array.isArray(userResult)) {
    userResult = trivialPromise(userResult);
  } else if (userResult === null || userResult === undefined) {
    userResult = trivialPromise([]);
  } else {
    if (!isPromise(userResult)) {
      throwInvalidUserFuncResult(LOAD);
    }
  }

  return (0, _deferred.fromPromise)(userResult);
}

function invokeUserTotalCountFunc(store, options) {
  var userFunc = store._totalCountFunc;
  var userResult;

  if (!(0, _type.isFunction)(userFunc)) {
    throw _errors.errors.Error('E4021');
  }

  userResult = userFunc.apply(store, [options]);

  if (!isPromise(userResult)) {
    userResult = Number(userResult);

    if (!isFinite(userResult)) {
      throwInvalidUserFuncResult(TOTAL_COUNT);
    }

    userResult = trivialPromise(userResult);
  }

  return (0, _deferred.fromPromise)(userResult);
}

function invokeUserByKeyFunc(store, key, extraOptions) {
  var userFunc = store._byKeyFunc;
  var userResult;
  ensureRequiredFuncOption(BY_KEY, userFunc);
  userResult = userFunc.apply(store, [key, extraOptions]);

  if (!isPromise(userResult)) {
    userResult = trivialPromise(userResult);
  }

  return (0, _deferred.fromPromise)(userResult);
}

function runRawLoad(pendingDeferred, store, userFuncOptions, continuation) {
  if (store.__rawData) {
    continuation(store.__rawData);
  } else {
    var loadPromise = store.__rawDataPromise || invokeUserLoad(store, userFuncOptions);

    if (store._cacheRawData) {
      store.__rawDataPromise = loadPromise;
    }

    loadPromise.always(function () {
      delete store.__rawDataPromise;
    }).done(function (rawData) {
      if (store._cacheRawData) {
        store.__rawData = rawData;
      }

      continuation(rawData);
    }).fail(createUserFuncFailureHandler(pendingDeferred));
  }
}

function runRawLoadWithQuery(pendingDeferred, store, options, countOnly) {
  options = options || {};
  var userFuncOptions = {};

  if ('userData' in options) {
    userFuncOptions.userData = options.userData;
  }

  runRawLoad(pendingDeferred, store, userFuncOptions, function (rawData) {
    var rawDataQuery = (0, _array_query.default)(rawData, {
      errorHandler: store._errorHandler
    });
    var itemsQuery;
    var totalCountQuery;
    var waitList = [];
    var items;
    var totalCount;

    if (!countOnly) {
      itemsQuery = _store_helper.default.queryByOptions(rawDataQuery, options);

      if (itemsQuery === rawDataQuery) {
        items = rawData.slice(0);
      } else {
        waitList.push(itemsQuery.enumerate().done(function (asyncResult) {
          items = asyncResult;
        }));
      }
    }

    if (options.requireTotalCount || countOnly) {
      totalCountQuery = _store_helper.default.queryByOptions(rawDataQuery, options, true);

      if (totalCountQuery === rawDataQuery) {
        totalCount = rawData.length;
      } else {
        waitList.push(totalCountQuery.count().done(function (asyncResult) {
          totalCount = asyncResult;
        }));
      }
    }

    _deferred.when.apply(_renderer.default, waitList).done(function () {
      if (countOnly) {
        pendingDeferred.resolve(totalCount);
      } else if (options.requireTotalCount) {
        pendingDeferred.resolve(items, {
          totalCount: totalCount
        });
      } else {
        pendingDeferred.resolve(items);
      }
    }).fail(function (x) {
      pendingDeferred.reject(x);
    });
  });
}

function runRawLoadWithKey(pendingDeferred, store, key) {
  runRawLoad(pendingDeferred, store, {}, function (rawData) {
    var keyExpr = store.key();
    var item;

    for (var i = 0, len = rawData.length; i < len; i++) {
      item = rawData[i];

      if (_utils.default.keysEqual(keyExpr, store.keyOf(rawData[i]), key)) {
        pendingDeferred.resolve(item);
        return;
      }
    }

    pendingDeferred.reject(_errors.errors.Error('E4009'));
  });
}

var CustomStore = _abstract_store.default.inherit({
  ctor: function ctor(options) {
    options = options || {};
    this.callBase(options);
    this._useDefaultSearch = !!options.useDefaultSearch || options.loadMode === 'raw';
    this._loadMode = options.loadMode;
    this._cacheRawData = options.cacheRawData !== false;
    this._loadFunc = options[LOAD];
    this._totalCountFunc = options[TOTAL_COUNT];
    this._byKeyFunc = options[BY_KEY];
    this._insertFunc = options[INSERT];
    this._updateFunc = options[UPDATE];
    this._removeFunc = options[REMOVE];
  },
  createQuery: function createQuery() {
    throw _errors.errors.Error('E4010');
  },
  clearRawDataCache: function clearRawDataCache() {
    delete this.__rawData;
  },
  _totalCountImpl: function _totalCountImpl(options) {
    var d = new _deferred.Deferred();

    if (this._loadMode === 'raw' && !this._totalCountFunc) {
      runRawLoadWithQuery(d, this, options, true);
    } else {
      invokeUserTotalCountFunc(this, options).done(function (count) {
        d.resolve(Number(count));
      }).fail(createUserFuncFailureHandler(d));
      d = this._addFailHandlers(d);
    }

    return d.promise();
  },
  _pushImpl: function _pushImpl(changes) {
    if (this.__rawData) {
      (0, _array_utils.applyBatch)({
        keyInfo: this,
        data: this.__rawData,
        changes: changes
      });
    }
  },
  _loadImpl: function _loadImpl(options) {
    var d = new _deferred.Deferred();

    if (this._loadMode === 'raw') {
      runRawLoadWithQuery(d, this, options, false);
    } else {
      invokeUserLoad(this, options).done(function (data, extra) {
        d.resolve(data, extra);
      }).fail(createUserFuncFailureHandler(d));
      d = this._addFailHandlers(d);
    }

    return d.promise();
  },
  _byKeyImpl: function _byKeyImpl(key, extraOptions) {
    var d = new _deferred.Deferred();

    if (this._byKeyViaLoad()) {
      this._requireKey();

      runRawLoadWithKey(d, this, key);
    } else {
      invokeUserByKeyFunc(this, key, extraOptions).done(function (obj) {
        d.resolve(obj);
      }).fail(createUserFuncFailureHandler(d));
    }

    return d.promise();
  },
  _byKeyViaLoad: function _byKeyViaLoad() {
    return this._loadMode === 'raw' && !this._byKeyFunc;
  },
  _insertImpl: function _insertImpl(values) {
    var that = this;
    var userFunc = that._insertFunc;
    var userResult;
    var d = new _deferred.Deferred();
    ensureRequiredFuncOption(INSERT, userFunc);
    userResult = userFunc.apply(that, [values]); // should return key or data

    if (!isPromise(userResult)) {
      userResult = trivialPromise(userResult);
    }

    (0, _deferred.fromPromise)(userResult).done(function (serverResponse) {
      if ((0, _config.default)().useLegacyStoreResult) {
        d.resolve(values, serverResponse);
      } else {
        d.resolve(serverResponse || values, that.keyOf(serverResponse));
      }
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  },
  _updateImpl: function _updateImpl(key, values) {
    var userFunc = this._updateFunc;
    var userResult;
    var d = new _deferred.Deferred();
    ensureRequiredFuncOption(UPDATE, userFunc);
    userResult = userFunc.apply(this, [key, values]);

    if (!isPromise(userResult)) {
      userResult = trivialPromise(userResult);
    }

    (0, _deferred.fromPromise)(userResult).done(function (serverResponse) {
      if ((0, _config.default)().useLegacyStoreResult) {
        d.resolve(key, values);
      } else {
        d.resolve(serverResponse || values, key);
      }
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  },
  _removeImpl: function _removeImpl(key) {
    var userFunc = this._removeFunc;
    var userResult;
    var d = new _deferred.Deferred();
    ensureRequiredFuncOption(REMOVE, userFunc);
    userResult = userFunc.apply(this, [key]);

    if (!isPromise(userResult)) {
      userResult = trivialPromise();
    }

    (0, _deferred.fromPromise)(userResult).done(function () {
      d.resolve(key);
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  }
});

var _default = CustomStore;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _globalize = _interopRequireDefault(__webpack_require__(74));

var _core = _interopRequireDefault(__webpack_require__(85));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
if (_globalize.default && _globalize.default.load) {
  var likelySubtags = {
    'supplemental': {
      'version': {
        '_cldrVersion': '28',
        '_unicodeVersion': '8.0.0',
        '_number': '$Revision: 11965 $'
      },
      'likelySubtags': {
        'en': 'en-Latn-US',
        'de': 'de-Latn-DE',
        'ru': 'ru-Cyrl-RU',
        'ja': 'ja-Jpan-JP'
      }
    }
  };

  if (!_globalize.default.locale()) {
    _globalize.default.load(likelySubtags);

    _globalize.default.locale('en');
  }

  _core.default.inject({
    locale: function locale(_locale) {
      if (!_locale) {
        return _globalize.default.locale().locale;
      }

      _globalize.default.locale(_locale);
    }
  });
}

/***/ }),
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.plugin = exports.Title = void 0;

var _type = __webpack_require__(1);

var _extend = __webpack_require__(0);

var _utils = __webpack_require__(14);

var _layout_element = __webpack_require__(344);

var _Number = Number;
var parseHorizontalAlignment = (0, _utils.enumParser)(['left', 'center', 'right']);
var parseVerticalAlignment = (0, _utils.enumParser)(['top', 'bottom']);
var DEFAULT_MARGIN = 10;

function hasText(text) {
  return !!(text && String(text).length > 0);
}

function processTitleLength(elem, text, width, options, placeholderSize) {
  if (elem.attr({
    text: text
  }).setMaxSize(width, placeholderSize, options).textChanged) {
    elem.setTitle(text);
  }
}

function pickMarginValue(value) {
  return value >= 0 ? _Number(value) : DEFAULT_MARGIN;
}

function validateMargin(margin) {
  var result;

  if (margin >= 0) {
    result = {
      left: _Number(margin),
      top: _Number(margin),
      right: _Number(margin),
      bottom: _Number(margin)
    };
  } else {
    margin = margin || {};
    result = {
      left: pickMarginValue(margin.left),
      top: pickMarginValue(margin.top),
      right: pickMarginValue(margin.right),
      bottom: pickMarginValue(margin.bottom)
    };
  }

  return result;
}

function checkRect(rect, boundingRect) {
  return rect[2] - rect[0] < boundingRect.width || rect[3] - rect[1] < boundingRect.height;
}

var Title = function Title(params) {
  this._params = params;
  this._group = params.renderer.g().attr({
    'class': params.cssClass
  }).linkOn(params.root || params.renderer.root, 'title');
  this._hasText = false;
}; // There is no normal inheritance from LayoutElement because it is actually a container of methods rather than a class.


exports.Title = Title;
(0, _extend.extend)(Title.prototype, _layout_element.LayoutElement.prototype, {
  dispose: function dispose() {
    var that = this;

    that._group.linkRemove();

    that._group.linkOff();

    if (that._titleElement) {
      that._clipRect.dispose();

      that._titleElement = that._subtitleElement = that._clipRect = null;
    }

    that._params = that._group = that._options = null;
  },
  _updateOptions: function _updateOptions(options) {
    this._options = options;
    this._options.horizontalAlignment = parseHorizontalAlignment(options.horizontalAlignment, 'center');
    this._options.verticalAlignment = parseVerticalAlignment(options.verticalAlignment, 'top');
    this._options.margin = validateMargin(options.margin);
  },
  _updateStructure: function _updateStructure() {
    var that = this;
    var renderer = that._params.renderer;
    var group = that._group;
    var options = that._options;
    var align = options.horizontalAlignment; // Looks like the following "laziness" is only to avoid unnecessary DOM content creation -
    // for example when widget is created without "title" option.

    if (!that._titleElement) {
      that._titleElement = renderer.text().append(group);
      that._subtitleElement = renderer.text();
      that._clipRect = renderer.clipRect();
      group.attr({
        'clip-path': that._clipRect.id
      });
    }

    that._titleElement.attr({
      align: align,
      'class': options.cssClass
    });

    that._subtitleElement.attr({
      align: align,
      'class': options.subtitle.cssClass
    });

    group.linkAppend();
    hasText(options.subtitle.text) ? that._subtitleElement.append(group) : that._subtitleElement.remove();
  },
  _updateTexts: function _updateTexts() {
    var that = this;
    var options = that._options;
    var subtitleOptions = options.subtitle;
    var titleElement = that._titleElement;
    var subtitleElement = that._subtitleElement;
    var testText = 'A';
    var titleBox;
    titleElement.attr({
      text: testText,
      y: 0
    }).css((0, _utils.patchFontOptions)(options.font));
    titleBox = titleElement.getBBox(); // for multiline text

    that._baseLineCorrection = titleBox.height + titleBox.y;
    titleElement.attr({
      text: options.text
    });
    titleBox = titleElement.getBBox();
    var y = -titleBox.y;
    titleElement.attr({
      y: y
    });

    if (hasText(subtitleOptions.text)) {
      subtitleElement.attr({
        text: subtitleOptions.text,
        y: 0
      }).css((0, _utils.patchFontOptions)(subtitleOptions.font));
    }
  },
  _shiftSubtitle: function _shiftSubtitle() {
    var that = this;

    var titleBox = that._titleElement.getBBox();

    var element = that._subtitleElement;
    var offset = that._options.subtitle.offset;
    element.move(0, titleBox.y + titleBox.height - element.getBBox().y - offset);
  },
  _updateBoundingRectAlignment: function _updateBoundingRectAlignment() {
    var boundingRect = this._boundingRect;
    var options = this._options;
    boundingRect.verticalAlignment = options.verticalAlignment;
    boundingRect.horizontalAlignment = options.horizontalAlignment;
    boundingRect.cutLayoutSide = options.verticalAlignment;
    boundingRect.cutSide = 'vertical';
    boundingRect.position = {
      horizontal: options.horizontalAlignment,
      vertical: options.verticalAlignment
    };
  },
  hasText: function hasText() {
    return this._hasText;
  },
  update: function update(themeOptions, userOptions) {
    var that = this;
    var options = (0, _extend.extend)(true, {}, themeOptions, processTitleOptions(userOptions));

    var _hasText = hasText(options.text);

    var isLayoutChanged = _hasText || _hasText !== that._hasText;
    that._baseLineCorrection = 0;

    that._updateOptions(options);

    that._boundingRect = {};

    if (_hasText) {
      that._updateStructure();

      that._updateTexts();
    } else {
      that._group.linkRemove();
    }

    that._updateBoundingRect();

    that._updateBoundingRectAlignment();

    that._hasText = _hasText;
    return isLayoutChanged;
  },
  draw: function draw(width, height) {
    var that = this;

    if (that._hasText) {
      that._group.linkAppend();

      that._correctTitleLength(width);

      if (that._group.getBBox().height > height) {
        this.freeSpace();
      }
    }

    return that;
  },
  _correctTitleLength: function _correctTitleLength(width) {
    var that = this;
    var options = that._options;
    var margin = options.margin;
    var maxWidth = width - margin.left - margin.right;
    var placeholderSize = options.placeholderSize;
    processTitleLength(that._titleElement, options.text, maxWidth, options, placeholderSize);

    if (that._subtitleElement) {
      if (_Number(placeholderSize) > 0) {
        placeholderSize -= that._titleElement.getBBox().height;
      }

      processTitleLength(that._subtitleElement, options.subtitle.text, maxWidth, options.subtitle, placeholderSize);

      that._shiftSubtitle();
    }

    that._updateBoundingRect();

    var _this$getCorrectedLay = this.getCorrectedLayoutOptions(),
        x = _this$getCorrectedLay.x,
        y = _this$getCorrectedLay.y,
        height = _this$getCorrectedLay.height;

    this._clipRect.attr({
      x: x,
      y: y,
      width: width,
      height: height
    });
  },
  getLayoutOptions: function getLayoutOptions() {
    return this._boundingRect || null;
  },
  shift: function shift(x, y) {
    var that = this;
    var box = that.getLayoutOptions();

    that._group.move(x - box.x, y - box.y);

    return that;
  },
  _updateBoundingRect: function _updateBoundingRect() {
    var that = this;
    var options = that._options;
    var margin = options.margin;
    var boundingRect = that._boundingRect;
    var box = that._hasText ? that._group.getBBox() : {
      width: 0,
      height: 0,
      x: 0,
      y: 0,
      isEmpty: true
    };

    if (!box.isEmpty) {
      box.height += margin.top + margin.bottom - that._baseLineCorrection;
      box.width += margin.left + margin.right;
      box.x -= margin.left;
      box.y += that._baseLineCorrection - margin.top;
    }

    if (options.placeholderSize > 0) {
      box.height = options.placeholderSize;
    }

    boundingRect.height = box.height;
    boundingRect.width = box.width;
    boundingRect.x = box.x;
    boundingRect.y = box.y;
  },
  getCorrectedLayoutOptions: function getCorrectedLayoutOptions() {
    var srcBox = this.getLayoutOptions();
    var correction = this._baseLineCorrection;
    return (0, _extend.extend)({}, srcBox, {
      y: srcBox.y - correction,
      height: srcBox.height + correction
    });
  },
  // BaseWidget_layout_implementation
  layoutOptions: function layoutOptions() {
    if (!this._hasText) {
      return null;
    }

    return {
      horizontalAlignment: this._boundingRect.horizontalAlignment,
      verticalAlignment: this._boundingRect.verticalAlignment,
      priority: 0
    };
  },
  measure: function measure(size) {
    this.draw(size[0], size[1]);
    return [this._boundingRect.width, this._boundingRect.height];
  },
  move: function move(rect, fitRect) {
    var boundingRect = this._boundingRect;

    if (checkRect(rect, boundingRect)) {
      this.shift(fitRect[0], fitRect[1]);
    } else {
      this.shift(Math.round(rect[0]), Math.round(rect[1]));
    }
  },
  freeSpace: function freeSpace() {
    var that = this;

    that._params.incidentOccurred('W2103');

    that._group.linkRemove();

    that._boundingRect.width = that._boundingRect.height = 0;
  },
  getOptions: function getOptions() {
    return this._options;
  },
  changeLink: function changeLink(root) {
    this._group.linkRemove();

    this._group.linkOn(root, 'title');
  } // BaseWidget_layout_implementation

});

function processTitleOptions(options) {
  var newOptions = (0, _type.isString)(options) ? {
    text: options
  } : options || {};
  newOptions.subtitle = (0, _type.isString)(newOptions.subtitle) ? {
    text: newOptions.subtitle
  } : newOptions.subtitle || {};
  return newOptions;
}

var plugin = {
  name: 'title',
  init: function init() {
    var that = this; // "exports" is used for testing purposes.

    that._title = new Title({
      renderer: that._renderer,
      cssClass: that._rootClassPrefix + '-title',
      incidentOccurred: that._incidentOccurred
    });

    that._layout.add(that._title);
  },
  dispose: function dispose() {
    this._title.dispose();

    this._title = null;
  },
  customize: function customize(constructor) {
    constructor.addChange({
      code: 'TITLE',
      handler: function handler() {
        if (this._title.update(this._themeManager.theme('title'), this.option('title'))) {
          this._change(['LAYOUT']);
        }
      },
      isThemeDependent: true,
      option: 'title',
      isOptionChange: true
    });
  },
  fontFields: ['title.font', 'title.subtitle.font']
};
exports.plugin = plugin;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.polar = exports.chart = void 0;

var _extend3 = __webpack_require__(0);

var _array = __webpack_require__(12);

var _iterator = __webpack_require__(3);

var _range_data_calculator = _interopRequireDefault(__webpack_require__(241));

var _type = __webpack_require__(1);

var _utils = __webpack_require__(14);

var _common = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var math = Math;
var _abs = math.abs;
var _sqrt = math.sqrt;
var _max = math.max;
var DEFAULT_TRACKER_WIDTH = 12;
var DEFAULT_DURATION = 400;
var HIGH_ERROR = 'highError';
var LOW_ERROR = 'lowError';
var VARIANCE = 'variance';
var STANDARD_DEVIATION = 'stddeviation';
var STANDARD_ERROR = 'stderror';
var PERCENT = 'percent';
var FIXED = 'fixed';
var UNDEFINED = 'undefined';
var DISCRETE = 'discrete';
var LOGARITHMIC = 'logarithmic';
var DATETIME = 'datetime';
var chart = {};
exports.chart = chart;
var polar = {};
exports.polar = polar;

function sum(array) {
  var result = 0;
  (0, _iterator.each)(array, function (_, value) {
    result += value;
  });
  return result;
}

function isErrorBarTypeCorrect(type) {
  // TODO why UNDEFINED is here
  // return inArray(type, [FIXED, PERCENT, VARIANCE, STANDARD_DEVIATION, STANDARD_ERROR, UNDEFINED]) !== -1;
  return (0, _array.inArray)(type, [FIXED, PERCENT, VARIANCE, STANDARD_DEVIATION, STANDARD_ERROR]) !== -1;
}

function variance(array, expectedValue) {
  return sum((0, _utils.map)(array, function (value) {
    return (value - expectedValue) * (value - expectedValue);
  })) / array.length;
}

function calculateAvgErrorBars(result, data, series) {
  var errorBarsOptions = series.getOptions().valueErrorBar;
  var valueField = series.getValueFields()[0];
  var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;
  var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;

  if (series.areErrorBarsVisible() && errorBarsOptions.type === undefined) {
    var fusionData = data.reduce(function (result, item) {
      if ((0, _type.isDefined)(item[lowValueField])) {
        result[0] += item[valueField] - item[lowValueField];
        result[1]++;
      }

      if ((0, _type.isDefined)(item[highValueField])) {
        result[2] += item[highValueField] - item[valueField];
        result[3]++;
      }

      return result;
    }, [0, 0, 0, 0]);

    if (fusionData[1]) {
      result[lowValueField] = result[valueField] - fusionData[0] / fusionData[1];
    }

    if (fusionData[2]) {
      result[highValueField] = result[valueField] + fusionData[2] / fusionData[3];
    }
  }

  return result;
}

function calculateSumErrorBars(result, data, series) {
  var errorBarsOptions = series.getOptions().valueErrorBar;
  var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;
  var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;

  if (series.areErrorBarsVisible() && errorBarsOptions.type === undefined) {
    result[lowValueField] = 0;
    result[highValueField] = 0;
    result = data.reduce(function (result, item) {
      result[lowValueField] += item[lowValueField];
      result[highValueField] += item[highValueField];
      return result;
    }, result);
  }

  return result;
}

function getMinMaxAggregator(compare) {
  return function (_ref, series) {
    var intervalStart = _ref.intervalStart,
        intervalEnd = _ref.intervalEnd,
        data = _ref.data;
    var valueField = series.getValueFields()[0];
    var targetData = data[0];
    targetData = data.reduce(function (result, item) {
      var value = item[valueField];

      if (result[valueField] === null) {
        result = item;
      }

      if (value !== null && compare(value, result[valueField])) {
        return item;
      }

      return result;
    }, targetData);
    return (0, _extend3.extend)({}, targetData, _defineProperty({}, series.getArgumentField(), series._getIntervalCenter(intervalStart, intervalEnd)));
  };
}

function checkFields(data, fieldsToCheck, skippedFields) {
  var allFieldsIsValid = true;

  for (var field in fieldsToCheck) {
    var isArgument = field === 'argument';

    if (isArgument || field === 'size' ? !(0, _type.isDefined)(data[field]) : data[field] === undefined) {
      var selector = fieldsToCheck[field];

      if (!isArgument) {
        skippedFields[selector] = (skippedFields[selector] || 0) + 1;
      }

      allFieldsIsValid = false;
    }
  }

  return allFieldsIsValid;
}

var baseScatterMethods = {
  _defaultDuration: DEFAULT_DURATION,
  _defaultTrackerWidth: DEFAULT_TRACKER_WIDTH,
  _applyStyle: _common.noop,
  _updateOptions: _common.noop,
  _parseStyle: _common.noop,
  _prepareSegment: _common.noop,
  _drawSegment: _common.noop,
  _appendInGroup: function _appendInGroup() {
    this._group.append(this._extGroups.seriesGroup);
  },
  _createLegendState: function _createLegendState(styleOptions, defaultColor) {
    return {
      fill: styleOptions.color || defaultColor,
      hatching: styleOptions.hatching ? (0, _extend3.extend)({}, styleOptions.hatching, {
        direction: 'right'
      }) : undefined
    };
  },
  _applyElementsClipRect: function _applyElementsClipRect(settings) {
    settings['clip-path'] = this._paneClipRectID;
  },
  _applyMarkerClipRect: function _applyMarkerClipRect(settings) {
    settings['clip-path'] = this._forceClipping ? this._paneClipRectID : null;
  },
  _createGroup: function _createGroup(groupName, parent, target, settings) {
    var group = parent[groupName] = parent[groupName] || this._renderer.g();

    target && group.append(target);
    settings && group.attr(settings);
  },
  _applyClearingSettings: function _applyClearingSettings(settings) {
    settings.opacity = null;
    settings.scale = null;

    if (this._options.rotated) {
      settings.translateX = null;
    } else {
      settings.translateY = null;
    }
  },
  _createGroups: function _createGroups() {
    var that = this;

    that._createGroup('_markersGroup', that, that._group);

    that._createGroup('_labelsGroup', that);
  },
  _setMarkerGroupSettings: function _setMarkerGroupSettings() {
    var that = this;

    var settings = that._createPointStyles(that._getMarkerGroupOptions()).normal;

    settings['class'] = 'dxc-markers';
    settings.opacity = 1; // T172577

    that._applyMarkerClipRect(settings);

    that._markersGroup.attr(settings);
  },
  getVisibleArea: function getVisibleArea() {
    return this._visibleArea;
  },
  areErrorBarsVisible: function areErrorBarsVisible() {
    var errorBarOptions = this._options.valueErrorBar;
    return errorBarOptions && this._errorBarsEnabled() && errorBarOptions.displayMode !== 'none' && (isErrorBarTypeCorrect((0, _utils.normalizeEnum)(errorBarOptions.type)) || (0, _type.isDefined)(errorBarOptions.lowValueField) || (0, _type.isDefined)(errorBarOptions.highValueField));
  },
  groupPointsByCoords: function groupPointsByCoords(rotated) {
    var cat = [];
    (0, _iterator.each)(this.getVisiblePoints(), function (_, p) {
      var pointCoord = parseInt(rotated ? p.vy : p.vx);

      if (!cat[pointCoord]) {
        cat[pointCoord] = p;
      } else {
        Array.isArray(cat[pointCoord]) ? cat[pointCoord].push(p) : cat[pointCoord] = [cat[pointCoord], p];
      }
    });
    return cat;
  },
  _createErrorBarGroup: function _createErrorBarGroup(animationEnabled) {
    var that = this;
    var errorBarOptions = that._options.valueErrorBar;
    var settings;

    if (that.areErrorBarsVisible()) {
      settings = {
        'class': 'dxc-error-bars',
        stroke: errorBarOptions.color,
        'stroke-width': errorBarOptions.lineWidth,
        opacity: animationEnabled ? 0.001 : errorBarOptions.opacity || 1,
        'stroke-linecap': 'square',
        sharp: true,
        'clip-path': that._forceClipping ? that._paneClipRectID : that._widePaneClipRectID
      };

      that._createGroup('_errorBarGroup', that, that._group, settings);
    }
  },
  _setGroupsSettings: function _setGroupsSettings(animationEnabled) {
    var that = this;

    that._setMarkerGroupSettings();

    that._setLabelGroupSettings(animationEnabled);

    that._createErrorBarGroup(animationEnabled);
  },
  _getCreatingPointOptions: function _getCreatingPointOptions() {
    var that = this;
    var defaultPointOptions;
    var creatingPointOptions = that._predefinedPointOptions;
    var normalStyle;

    if (!creatingPointOptions) {
      defaultPointOptions = that._getPointOptions();
      that._predefinedPointOptions = creatingPointOptions = (0, _extend3.extend)(true, {
        styles: {}
      }, defaultPointOptions);
      normalStyle = defaultPointOptions.styles && defaultPointOptions.styles.normal || {};
      creatingPointOptions.styles = creatingPointOptions.styles || {};
      creatingPointOptions.styles.normal = {
        'stroke-width': normalStyle['stroke-width'],
        r: normalStyle.r,
        opacity: normalStyle.opacity
      };
    }

    return creatingPointOptions;
  },
  _getPointOptions: function _getPointOptions() {
    return this._parsePointOptions(this._preparePointOptions(), this._options.label);
  },
  _getOptionsForPoint: function _getOptionsForPoint() {
    return this._options.point;
  },
  _parsePointStyle: function _parsePointStyle(style, defaultColor, defaultBorderColor, defaultSize) {
    var border = style.border || {};
    var sizeValue = style.size !== undefined ? style.size : defaultSize;
    return {
      fill: style.color || defaultColor,
      stroke: border.color || defaultBorderColor,
      'stroke-width': border.visible ? border.width : 0,
      r: sizeValue / 2 + (border.visible && sizeValue !== 0 ? ~~(border.width / 2) || 0 : 0)
    };
  },
  _createPointStyles: function _createPointStyles(pointOptions) {
    var that = this;
    var mainPointColor = pointOptions.color || that._options.mainSeriesColor;
    var containerColor = that._options.containerBackgroundColor;

    var normalStyle = that._parsePointStyle(pointOptions, mainPointColor, mainPointColor);

    normalStyle.visibility = pointOptions.visible ? 'visible' : 'hidden';
    return {
      normal: normalStyle,
      hover: that._parsePointStyle(pointOptions.hoverStyle, containerColor, mainPointColor, pointOptions.size),
      selection: that._parsePointStyle(pointOptions.selectionStyle, containerColor, mainPointColor, pointOptions.size)
    };
  },
  _checkData: function _checkData(data, skippedFields, fieldsToCheck) {
    fieldsToCheck = fieldsToCheck || {
      value: this.getValueFields()[0]
    };
    fieldsToCheck.argument = this.getArgumentField();
    return checkFields(data, fieldsToCheck, skippedFields || {}) && data.value === data.value;
  },
  getArgumentRangeInitialValue: function getArgumentRangeInitialValue() {
    var points = this.getPoints();

    if (this.useAggregation() && points.length) {
      var _points$0$aggregation, _points$aggregationIn;

      return {
        min: (_points$0$aggregation = points[0].aggregationInfo) === null || _points$0$aggregation === void 0 ? void 0 : _points$0$aggregation.intervalStart,
        max: (_points$aggregationIn = points[points.length - 1].aggregationInfo) === null || _points$aggregationIn === void 0 ? void 0 : _points$aggregationIn.intervalEnd
      };
    }

    return undefined;
  },
  getValueRangeInitialValue: function getValueRangeInitialValue() {
    return undefined;
  },
  _getRangeData: function _getRangeData() {
    return _range_data_calculator.default.getRangeData(this);
  },
  _getPointDataSelector: function _getPointDataSelector() {
    var _this = this;

    var valueField = this.getValueFields()[0];
    var argumentField = this.getArgumentField();
    var tagField = this.getTagField();
    var areErrorBarsVisible = this.areErrorBarsVisible();
    var lowValueField;
    var highValueField;

    if (areErrorBarsVisible) {
      var errorBarOptions = this._options.valueErrorBar;
      lowValueField = errorBarOptions.lowValueField || LOW_ERROR;
      highValueField = errorBarOptions.highValueField || HIGH_ERROR;
    }

    return function (data) {
      var pointData = {
        value: _this._processEmptyValue(data[valueField]),
        argument: data[argumentField],
        tag: data[tagField],
        data: data
      };

      if (areErrorBarsVisible) {
        pointData.lowError = data[lowValueField];
        pointData.highError = data[highValueField];
      }

      return pointData;
    };
  },
  _errorBarsEnabled: function _errorBarsEnabled() {
    return this.valueAxisType !== DISCRETE && this.valueAxisType !== LOGARITHMIC && this.valueType !== DATETIME;
  },
  _drawPoint: function _drawPoint(options) {
    var point = options.point;

    if (point.isInVisibleArea()) {
      point.clearVisibility();
      point.draw(this._renderer, options.groups, options.hasAnimation, options.firstDrawing);

      this._drawnPoints.push(point);
    } else {
      point.setInvisibility();
    }
  },
  _animateComplete: function _animateComplete() {
    var that = this;
    var animationSettings = {
      duration: that._defaultDuration
    };
    that._labelsGroup && that._labelsGroup.animate({
      opacity: 1
    }, animationSettings);
    that._errorBarGroup && that._errorBarGroup.animate({
      opacity: that._options.valueErrorBar.opacity || 1
    }, animationSettings);
  },
  _animate: function _animate() {
    var that = this;
    var lastPointIndex = that._drawnPoints.length - 1;
    (0, _iterator.each)(that._drawnPoints || [], function (i, p) {
      p.animate(i === lastPointIndex ? function () {
        that._animateComplete();
      } : undefined, {
        translateX: p.x,
        translateY: p.y
      });
    });
  },
  _getIntervalCenter: function _getIntervalCenter(intervalStart, intervalEnd) {
    var argAxis = this.getArgumentAxis();
    return argAxis.getOptions().type !== 'discrete' ? argAxis.getVisualRangeCenter({
      minVisible: intervalStart,
      maxVisible: intervalEnd
    }, true) : intervalStart;
  },
  _defaultAggregator: 'avg',
  _aggregators: {
    avg: function avg(_ref2, series) {
      var _calculateAvgErrorBar;

      var data = _ref2.data,
          intervalStart = _ref2.intervalStart,
          intervalEnd = _ref2.intervalEnd;

      if (!data.length) {
        return;
      }

      var valueField = series.getValueFields()[0];
      var aggregationResult = data.reduce(function (result, item) {
        var value = item[valueField];

        if ((0, _type.isDefined)(value)) {
          result[0] += value;
          result[1]++;
        } else if (value === null) {
          result[2]++;
        }

        return result;
      }, [0, 0, 0]);
      return calculateAvgErrorBars((_calculateAvgErrorBar = {}, _defineProperty(_calculateAvgErrorBar, valueField, aggregationResult[2] === data.length ? null : aggregationResult[0] / aggregationResult[1]), _defineProperty(_calculateAvgErrorBar, series.getArgumentField(), series._getIntervalCenter(intervalStart, intervalEnd)), _calculateAvgErrorBar), data, series);
    },
    sum: function sum(_ref3, series) {
      var _calculateSumErrorBar;

      var intervalStart = _ref3.intervalStart,
          intervalEnd = _ref3.intervalEnd,
          data = _ref3.data;

      if (!data.length) {
        return;
      }

      var valueField = series.getValueFields()[0];
      var aggregationResult = data.reduce(function (result, item) {
        var value = item[valueField];

        if (value !== undefined) {
          result[0] += value;
        }

        if (value === null) {
          result[1]++;
        } else if (value === undefined) {
          result[2]++;
        }

        return result;
      }, [0, 0, 0]);
      var value = aggregationResult[0];

      if (aggregationResult[1] === data.length) {
        value = null;
      }

      if (aggregationResult[2] === data.length) {
        return;
      }

      return calculateSumErrorBars((_calculateSumErrorBar = {}, _defineProperty(_calculateSumErrorBar, valueField, value), _defineProperty(_calculateSumErrorBar, series.getArgumentField(), series._getIntervalCenter(intervalStart, intervalEnd)), _calculateSumErrorBar), data, series);
    },
    count: function count(_ref4, series) {
      var _ref5;

      var data = _ref4.data,
          intervalStart = _ref4.intervalStart,
          intervalEnd = _ref4.intervalEnd;
      var valueField = series.getValueFields()[0];
      return _ref5 = {}, _defineProperty(_ref5, series.getArgumentField(), series._getIntervalCenter(intervalStart, intervalEnd)), _defineProperty(_ref5, valueField, data.filter(function (i) {
        return i[valueField] !== undefined;
      }).length), _ref5;
    },
    min: getMinMaxAggregator(function (a, b) {
      return a < b;
    }),
    max: getMinMaxAggregator(function (a, b) {
      return a > b;
    })
  },
  _endUpdateData: function _endUpdateData() {
    delete this._predefinedPointOptions;
  },
  getArgumentField: function getArgumentField() {
    return this._options.argumentField || 'arg';
  },
  getValueFields: function getValueFields() {
    var options = this._options;
    var errorBarsOptions = options.valueErrorBar;
    var valueFields = [options.valueField || 'val'];
    var lowValueField;
    var highValueField;

    if (errorBarsOptions) {
      lowValueField = errorBarsOptions.lowValueField;
      highValueField = errorBarsOptions.highValueField;
      (0, _type.isString)(lowValueField) && valueFields.push(lowValueField);
      (0, _type.isString)(highValueField) && valueFields.push(highValueField);
    }

    return valueFields;
  },
  _calculateErrorBars: function _calculateErrorBars(data) {
    if (!this.areErrorBarsVisible()) {
      return;
    }

    var that = this;
    var options = that._options;
    var errorBarsOptions = options.valueErrorBar;
    var errorBarType = (0, _utils.normalizeEnum)(errorBarsOptions.type);
    var floatErrorValue = parseFloat(errorBarsOptions.value);
    var valueField = that.getValueFields()[0];
    var value;
    var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;
    var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;
    var valueArray;
    var valueArrayLength;
    var meanValue;
    var processDataItem;

    var addSubError = function addSubError(_i, item) {
      value = item.value;
      item.lowError = value - floatErrorValue;
      item.highError = value + floatErrorValue;
    };

    switch (errorBarType) {
      case FIXED:
        processDataItem = addSubError;
        break;

      case PERCENT:
        processDataItem = function processDataItem(_, item) {
          value = item.value;
          var error = value * floatErrorValue / 100;
          item.lowError = value - error;
          item.highError = value + error;
        };

        break;

      case UNDEFINED:
        // TODO: rework this
        processDataItem = function processDataItem(_, item) {
          item.lowError = item.data[lowValueField];
          item.highError = item.data[highValueField];
        };

        break;

      default:
        valueArray = (0, _utils.map)(data, function (item) {
          return (0, _type.isDefined)(item.data[valueField]) ? item.data[valueField] : null;
        });
        valueArrayLength = valueArray.length;
        floatErrorValue = floatErrorValue || 1;

        switch (errorBarType) {
          case VARIANCE:
            floatErrorValue = variance(valueArray, sum(valueArray) / valueArrayLength) * floatErrorValue;
            processDataItem = addSubError;
            break;

          case STANDARD_DEVIATION:
            meanValue = sum(valueArray) / valueArrayLength;
            floatErrorValue = _sqrt(variance(valueArray, meanValue)) * floatErrorValue;

            processDataItem = function processDataItem(_, item) {
              item.lowError = meanValue - floatErrorValue;
              item.highError = meanValue + floatErrorValue;
            };

            break;

          case STANDARD_ERROR:
            floatErrorValue = _sqrt(variance(valueArray, sum(valueArray) / valueArrayLength) / valueArrayLength) * floatErrorValue;
            processDataItem = addSubError;
            break;
        }

    }

    processDataItem && (0, _iterator.each)(data, processDataItem);
  },
  _patchMarginOptions: function _patchMarginOptions(options) {
    var pointOptions = this._getCreatingPointOptions();

    var styles = pointOptions.styles;
    var maxSize = [styles.normal, styles.hover, styles.selection].reduce(function (max, style) {
      return _max(max, style.r * 2 + style['stroke-width']);
    }, 0);
    options.size = pointOptions.visible ? maxSize : 0;
    options.sizePointNormalState = pointOptions.visible ? styles.normal.r * 2 + styles.normal['stroke-width'] : 2;
    return options;
  },
  usePointsToDefineAutoHiding: function usePointsToDefineAutoHiding() {
    return true;
  }
};
exports.chart = chart = (0, _extend3.extend)({}, baseScatterMethods, {
  drawTrackers: function drawTrackers() {
    var that = this;
    var trackers;
    var trackersGroup;
    var segments = that._segments || [];
    var rotated = that._options.rotated;

    if (!that.isVisible()) {
      return;
    }

    if (segments.length) {
      trackers = that._trackers = that._trackers || [];
      trackersGroup = that._trackersGroup = (that._trackersGroup || that._renderer.g().attr({
        fill: 'gray',
        opacity: 0.001,
        stroke: 'gray',
        'class': 'dxc-trackers'
      })).attr({
        'clip-path': this._paneClipRectID || null
      }).append(that._group);
      (0, _iterator.each)(segments, function (i, segment) {
        if (!trackers[i]) {
          trackers[i] = that._drawTrackerElement(segment).data({
            'chart-data-series': that
          }).append(trackersGroup);
        } else {
          that._updateTrackerElement(segment, trackers[i]);
        }
      });
    }

    that._trackersTranslator = that.groupPointsByCoords(rotated);
  },
  _checkAxisVisibleAreaCoord: function _checkAxisVisibleAreaCoord(isArgument, coord) {
    var axis = isArgument ? this.getArgumentAxis() : this.getValueAxis();
    var visibleArea = axis.getVisibleArea();
    return (0, _type.isDefined)(coord) && visibleArea[0] <= coord && visibleArea[1] >= coord;
  },
  checkSeriesViewportCoord: function checkSeriesViewportCoord(axis, coord) {
    return this.getPoints().length && this.isVisible();
  },
  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {
    var oppositeCoord = null;
    var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;
    var coordName = !isOpposite ? 'vx' : 'vy';
    var oppositeCoordName = !isOpposite ? 'vy' : 'vx';
    var points = this.getVisiblePoints();

    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      var tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : undefined;

      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
        oppositeCoord = tmpCoord;
        break;
      }
    }

    return oppositeCoord;
  },
  _getNearestPoints: function _getNearestPoints(point, nextPoint) {
    return [point, nextPoint];
  },
  _getBezierPoints: function _getBezierPoints() {
    return [];
  },
  _getNearestPointsByCoord: function _getNearestPointsByCoord(coord, isArgument) {
    var that = this;
    var rotated = that.getOptions().rotated;
    var isOpposite = !isArgument && !rotated || isArgument && rotated;
    var coordName = isOpposite ? 'vy' : 'vx';
    var allPoints = that.getPoints();

    var bezierPoints = that._getBezierPoints();

    var nearestPoints = [];

    if (allPoints.length > 1) {
      allPoints.forEach(function (point, i) {
        var nextPoint = allPoints[i + 1];

        if (nextPoint && (point[coordName] <= coord && nextPoint[coordName] >= coord || point[coordName] >= coord && nextPoint[coordName] <= coord)) {
          nearestPoints.push(that._getNearestPoints(point, nextPoint, bezierPoints));
        }
      });
    } else {
      nearestPoints.push([allPoints[0], allPoints[0]]);
    }

    return nearestPoints;
  },
  getNeighborPoint: function getNeighborPoint(x, y) {
    var pCoord = this._options.rotated ? y : x;
    var nCoord = pCoord;
    var cat = this._trackersTranslator;
    var point = null;
    var minDistance;
    var oppositeCoord = this._options.rotated ? x : y;
    var oppositeCoordName = this._options.rotated ? 'vx' : 'vy';

    if (this.isVisible() && cat) {
      point = cat[pCoord];

      do {
        point = cat[nCoord] || cat[pCoord];
        pCoord--;
        nCoord++;
      } while ((pCoord >= 0 || nCoord < cat.length) && !point);

      if (Array.isArray(point)) {
        minDistance = _abs(point[0][oppositeCoordName] - oppositeCoord);
        (0, _iterator.each)(point, function (i, p) {
          var distance = _abs(p[oppositeCoordName] - oppositeCoord);

          if (minDistance >= distance) {
            minDistance = distance;
            point = p;
          }
        });
      }
    }

    return point;
  },
  _applyVisibleArea: function _applyVisibleArea() {
    var that = this;
    var rotated = that._options.rotated;
    var visibleX = (rotated ? that.getValueAxis() : that.getArgumentAxis()).getVisibleArea();
    var visibleY = (rotated ? that.getArgumentAxis() : that.getValueAxis()).getVisibleArea();
    that._visibleArea = {
      minX: visibleX[0],
      maxX: visibleX[1],
      minY: visibleY[0],
      maxY: visibleY[1]
    };
  },
  getPointCenterByArg: function getPointCenterByArg(arg) {
    var point = this.getPointsByArg(arg)[0];
    return point ? point.getCenterCoord() : undefined;
  }
});
exports.polar = polar = (0, _extend3.extend)({}, baseScatterMethods, {
  drawTrackers: function drawTrackers() {
    chart.drawTrackers.call(this);
    var cat = this._trackersTranslator;
    var index;

    if (!this.isVisible()) {
      return;
    }

    (0, _iterator.each)(cat, function (i, category) {
      if (category) {
        index = i;
        return false;
      }
    });
    cat[index + 360] = cat[index];
  },
  getNeighborPoint: function getNeighborPoint(x, y) {
    var pos = (0, _utils.convertXYToPolar)(this.getValueAxis().getCenter(), x, y);
    return chart.getNeighborPoint.call(this, pos.phi, pos.r);
  },
  _applyVisibleArea: function _applyVisibleArea() {
    var that = this;
    var canvas = that.getValueAxis().getCanvas();
    that._visibleArea = {
      minX: canvas.left,
      maxX: canvas.width - canvas.right,
      minY: canvas.top,
      maxY: canvas.height - canvas.bottom
    };
  },
  getSeriesPairCoord: function getSeriesPairCoord(params, isArgument) {
    var coords = null;
    var paramName = isArgument ? 'argument' : 'radius';
    var points = this.getVisiblePoints();

    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      var tmpPoint = (0, _type.isDefined)(p[paramName]) && (0, _type.isDefined)(params[paramName]) && p[paramName].valueOf() === params[paramName].valueOf() ? {
        x: p.x,
        y: p.y
      } : undefined;

      if ((0, _type.isDefined)(tmpPoint)) {
        coords = tmpPoint;
        break;
      }
    }

    return coords;
  }
});

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.plugin = exports.Tooltip = void 0;

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _window = __webpack_require__(7);

var _inflector = __webpack_require__(41);

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _renderer2 = __webpack_require__(183);

var _type = __webpack_require__(1);

var _extend = __webpack_require__(0);

var _utils = __webpack_require__(14);

var _format_helper = _interopRequireDefault(__webpack_require__(82));

var _plaque = __webpack_require__(592);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var format = _format_helper.default.format;
var mathCeil = Math.ceil;
var mathMax = Math.max;
var mathMin = Math.min;
var window = (0, _window.getWindow)();
var DEFAULT_HTML_GROUP_WIDTH = 3000;

function hideElement($element) {
  $element.css({
    left: '-9999px'
  }).detach();
}

function getSpecialFormatOptions(options, specialFormat) {
  var result = options;

  switch (specialFormat) {
    case 'argument':
      result = {
        format: options.argumentFormat
      };
      break;

    case 'percent':
      result = {
        format: {
          type: 'percent',
          precision: options.format && options.format.percentPrecision
        }
      };
      break;
  }

  return result;
}

var Tooltip = function Tooltip(params) {
  var that = this;
  var renderer;
  that._eventTrigger = params.eventTrigger;
  that._widgetRoot = params.widgetRoot;
  that._widget = params.widget;
  that._wrapper = (0, _renderer.default)('<div>').css({
    position: 'absolute',
    overflow: 'hidden',
    'pointerEvents': 'none'
  }) // T265557, T447623
  .addClass(params.cssClass);
  that._renderer = renderer = new _renderer2.Renderer({
    pathModified: params.pathModified,
    container: that._wrapper[0]
  });
  var root = renderer.root;
  root.attr({
    'pointer-events': 'none'
  }); // svg text

  that._text = renderer.text(undefined, 0, 0); // html text

  that._textGroupHtml = (0, _renderer.default)('<div>').css({
    position: 'absolute',
    padding: 0,
    margin: 0,
    border: '0px solid transparent'
  }).appendTo(that._wrapper);
  that._textHtml = (0, _renderer.default)('<div>').css({
    position: 'relative',
    display: 'inline-block',
    padding: 0,
    margin: 0,
    border: '0px solid transparent'
  }).appendTo(that._textGroupHtml);
};

exports.Tooltip = Tooltip;
Tooltip.prototype = {
  constructor: Tooltip,
  dispose: function dispose() {
    this._wrapper.remove();

    this._renderer.dispose();

    this._options = this._widgetRoot = null;
  },
  _getContainer: function _getContainer() {
    var options = this._options;
    var container = (0, _renderer.default)(this._widgetRoot).closest(options.container);

    if (container.length === 0) {
      container = (0, _renderer.default)(options.container);
    }

    return (container.length ? container : (0, _renderer.default)('body')).get(0);
  },
  setTemplate: function setTemplate(contentTemplate) {
    var that = this;
    that._template = contentTemplate ? that._widget._getTemplate(contentTemplate) : null;
  },
  setOptions: function setOptions(options) {
    var _this = this;

    options = options || {};
    var that = this;
    that._options = options;
    that._textFontStyles = (0, _utils.patchFontOptions)(options.font);
    that._textFontStyles.color = that._textFontStyles.fill;

    that._wrapper.css({
      'zIndex': options.zIndex
    });

    that._customizeTooltip = options.customizeTooltip;
    var textGroupHtml = that._textGroupHtml;
    var textHtml = that._textHtml;

    if (this.plaque) {
      this.plaque.clear();
    }

    this.setTemplate(options.contentTemplate);
    var pointerEvents = options.interactive ? 'auto' : 'none';

    if (options.interactive) {
      this._renderer.root.css({
        '-ms-user-select': 'auto',
        '-moz-user-select': 'auto',
        '-webkit-user-select': 'auto'
      });
    }

    var drawTooltip = function drawTooltip(_ref) {
      var group = _ref.group,
          onRender = _ref.onRender,
          eventData = _ref.eventData,
          isMoving = _ref.isMoving,
          _ref$templateCallback = _ref.templateCallback,
          templateCallback = _ref$templateCallback === void 0 ? function () {} : _ref$templateCallback;
      var state = that._state;

      if (!isMoving) {
        var template = that._template;
        var useTemplate = template && !state.formatObject.skipTemplate;

        if (state.html || useTemplate) {
          textGroupHtml.css({
            color: state.textColor,
            width: DEFAULT_HTML_GROUP_WIDTH,
            'pointerEvents': pointerEvents
          });

          if (useTemplate) {
            template.render({
              model: state.formatObject,
              container: textHtml,
              onRendered: function onRendered() {
                state.html = textHtml.html();

                if (textHtml.width() === 0 && textHtml.height() === 0) {
                  _this.plaque.clear();

                  templateCallback(false);
                  return;
                }

                onRender();

                that._riseEvents(eventData);

                that._moveWrapper();

                that.plaque.customizeCloud({
                  fill: state.color,
                  stroke: state.borderColor,
                  'pointer-events': pointerEvents
                });
                templateCallback(true);
              }
            });
            return;
          } else {
            that._text.attr({
              text: ''
            });

            textHtml.html(state.html);
          }
        } else {
          that._text.css({
            fill: state.textColor
          }).attr({
            text: state.text,
            class: options.cssClass,
            'pointer-events': pointerEvents
          }).append(group.attr({
            align: options.textAlignment
          }));
        }

        that._riseEvents(eventData);

        that.plaque.customizeCloud({
          fill: state.color,
          stroke: state.borderColor,
          'pointer-events': pointerEvents
        });
      }

      onRender();

      that._moveWrapper();

      return true;
    };

    this.plaque = new _plaque.Plaque({
      opacity: that._options.opacity,
      color: that._options.color,
      border: that._options.border,
      paddingLeftRight: that._options.paddingLeftRight,
      paddingTopBottom: that._options.paddingTopBottom,
      arrowLength: that._options.arrowLength,
      arrowWidth: 20,
      shadow: that._options.shadow,
      cornerRadius: that._options.cornerRadius
    }, that, that._renderer.root, drawTooltip, true, function (tooltip, g) {
      var state = tooltip._state;

      if (state.html) {
        var bBox;
        var getComputedStyle = window.getComputedStyle;

        if (getComputedStyle) {
          // IE9 compatibility (T298249)
          bBox = getComputedStyle(textHtml.get(0));
          bBox = {
            x: 0,
            y: 0,
            width: mathCeil(parseFloat(bBox.width)),
            height: mathCeil(parseFloat(bBox.height))
          };
        } else {
          bBox = textHtml.get(0).getBoundingClientRect();
          bBox = {
            x: 0,
            y: 0,
            width: mathCeil(bBox.width ? bBox.width : bBox.right - bBox.left),
            height: mathCeil(bBox.height ? bBox.height : bBox.bottom - bBox.top)
          };
        }

        return bBox;
      }

      return g.getBBox();
    }, function (tooltip, g, x, y) {
      var state = tooltip._state;

      if (state.html) {
        that._textGroupHtml.css({
          left: x,
          top: y
        });
      } else {
        g.move(x, y);
      }
    });
    return that;
  },
  _riseEvents: function _riseEvents(eventData) {
    // trigger event
    // The *onTooltipHidden* is triggered outside the *hide* method because of the cases when *show* is called to determine if tooltip will be visible or not (when target is changed) -
    // *hide* can neither be called before that *show* - because if tooltip is determined to hide it requires some timeout before actually hiding
    // nor after that *show* - because it is either too early to hide (because of timeout) or wrong (because tooltip has already been shown for new target)
    // It is only inside the *show* where it is known weather *onTooltipHidden* is required or not
    // This functionality can be simplified when we get rid of timeouts for tooltip
    var that = this;
    that._eventData && that._eventTrigger('tooltipHidden', that._eventData);
    that._eventData = eventData;

    that._eventTrigger('tooltipShown', that._eventData);
  },
  setRendererOptions: function setRendererOptions(options) {
    this._renderer.setOptions(options);

    this._textGroupHtml.css({
      direction: options.rtl ? 'rtl' : 'ltr'
    });

    return this;
  },
  update: function update(options) {
    var that = this;
    that.setOptions(options); // The following is because after update (on widget refresh) tooltip must be hidden

    hideElement(that._wrapper); // text area

    var normalizedCSS = {};

    for (var name in that._textFontStyles) {
      normalizedCSS[(0, _inflector.camelize)(name)] = that._textFontStyles[name];
    }

    that._textGroupHtml.css(normalizedCSS);

    that._text.css(that._textFontStyles);

    that._eventData = null;
    return that;
  },
  _prepare: function _prepare(formatObject, state) {
    var customizeTooltip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._customizeTooltip;
    var options = this._options;
    var customize = {};

    if ((0, _type.isFunction)(customizeTooltip)) {
      customize = customizeTooltip.call(formatObject, formatObject);
      customize = (0, _type.isPlainObject)(customize) ? customize : {};

      if ('text' in customize) {
        state.text = (0, _type.isDefined)(customize.text) ? String(customize.text) : '';
      }

      if ('html' in customize) {
        state.html = (0, _type.isDefined)(customize.html) ? String(customize.html) : '';
      }
    }

    if (!('text' in state) && !('html' in state)) {
      state.text = formatObject.valueText || formatObject.description || '';
    }

    state.color = customize.color || options.color;
    state.borderColor = customize.borderColor || (options.border || {}).color;
    state.textColor = customize.fontColor || (this._textFontStyles || {}).color;
    return !!state.text || !!state.html || !!this._template;
  },
  show: function show(formatObject, params, eventData, customizeTooltip, templateCallback) {
    var that = this;

    if (that._options.forceEvents) {
      // for Blazor charts
      eventData.x = params.x;
      eventData.y = params.y - params.offset;

      that._riseEvents(eventData);

      return true;
    }

    var state = {
      formatObject: formatObject,
      eventData: eventData,
      templateCallback: templateCallback
    };

    if (!that._prepare(formatObject, state, customizeTooltip)) {
      return false;
    }

    that._state = state;

    that._wrapper.appendTo(that._getContainer());

    that._clear();

    var parameters = (0, _extend.extend)({}, that._options, {
      canvas: that._getCanvas()
    }, state, {
      x: params.x,
      y: params.y,
      offset: params.offset
    });
    return this.plaque.clear().draw(parameters);
  },
  isCursorOnTooltip: function isCursorOnTooltip(x, y) {
    if (this._options.interactive && this.isEnabled()) {
      var box = this.plaque.getBBox();
      return x > box.x && x < box.x + box.width && y > box.y && y < box.y + box.height;
    }

    return false;
  },
  hide: function hide() {
    var that = this;
    hideElement(that._wrapper); // trigger event

    if (that._eventData) {
      that._eventTrigger('tooltipHidden', that._eventData);

      that._clear();

      that._eventData = null;
    }
  },
  _clear: function _clear() {
    this._textHtml.empty();
  },
  move: function move(x, y, offset) {
    this.plaque.draw({
      x: x,
      y: y,
      offset: offset,
      canvas: this._getCanvas(),
      isMoving: true
    });
  },
  _moveWrapper: function _moveWrapper() {
    var that = this;
    var plaqueBBox = this.plaque.getBBox();

    that._renderer.resize(plaqueBBox.width, plaqueBBox.height); // move wrapper


    var offset = that._wrapper.css({
      left: 0,
      top: 0
    }).offset();

    var left = plaqueBBox.x;
    var top = plaqueBBox.y;

    that._wrapper.css({
      left: left - offset.left,
      top: top - offset.top
    });

    this.plaque.moveRoot(-left, -top);

    if (this._state.html) {
      that._textHtml.css({
        left: -left,
        top: -top
      });

      that._textGroupHtml.css({
        width: mathCeil(that._textHtml.width())
      });
    }
  },
  formatValue: function formatValue(value, _specialFormat) {
    var options = _specialFormat ? getSpecialFormatOptions(this._options, _specialFormat) : this._options;
    return format(value, options.format);
  },
  getLocation: function getLocation() {
    return (0, _utils.normalizeEnum)(this._options.location);
  },
  isEnabled: function isEnabled() {
    return !!this._options.enabled || !!this._options.forceEvents; // for Blazor charts
  },
  isShared: function isShared() {
    return !!this._options.shared;
  },
  _getCanvas: function _getCanvas() {
    var container = this._getContainer();

    var containerBox = container.getBoundingClientRect();

    var html = _dom_adapter.default.getDocumentElement();

    var document = _dom_adapter.default.getDocument();

    var left = window.pageXOffset || html.scrollLeft || 0;
    var top = window.pageYOffset || html.scrollTop || 0;
    var box = {
      left: left,
      top: top,
      width: mathMax(html.clientWidth, document.body.clientWidth) + left,
      height: mathMax(document.body.scrollHeight, html.scrollHeight, document.body.offsetHeight, html.offsetHeight, document.body.clientHeight, html.clientHeight),
      right: 0,
      bottom: 0
    };

    if (container !== _dom_adapter.default.getBody()) {
      left = mathMax(box.left, box.left + containerBox.left);
      top = mathMax(box.top, box.top + containerBox.top);
      box.width = mathMin(containerBox.width, box.width) + left + box.left;
      box.height = mathMin(containerBox.height, box.height) + top + box.top;
      box.left = left;
      box.top = top;
    }

    return box;
  }
};
var plugin = {
  name: 'tooltip',
  init: function init() {
    this._initTooltip();
  },
  dispose: function dispose() {
    this._disposeTooltip();
  },
  members: {
    // The method exists only to be overridden in sparklines.
    _initTooltip: function _initTooltip() {
      // "exports" is used for testing purposes.
      this._tooltip = new Tooltip({
        cssClass: this._rootClassPrefix + '-tooltip',
        eventTrigger: this._eventTrigger,
        pathModified: this.option('pathModified'),
        widgetRoot: this.element(),
        widget: this
      });
    },
    // The method exists only to be overridden in sparklines.
    _disposeTooltip: function _disposeTooltip() {
      this._tooltip.dispose();

      this._tooltip = null;
    },
    // The method exists only to be overridden in sparklines.
    _setTooltipRendererOptions: function _setTooltipRendererOptions() {
      this._tooltip.setRendererOptions(this._getRendererOptions());
    },
    // The method exists only to be overridden in sparklines and gauges.
    _setTooltipOptions: function _setTooltipOptions() {
      this._tooltip.update(this._getOption('tooltip'));
    }
  },
  extenders: {
    _stopCurrentHandling: function _stopCurrentHandling() {
      this._tooltip && this._tooltip.hide();
    }
  },
  customize: function customize(constructor) {
    var proto = constructor.prototype;
    proto._eventsMap.onTooltipShown = {
      name: 'tooltipShown'
    };
    proto._eventsMap.onTooltipHidden = {
      name: 'tooltipHidden'
    };
    constructor.addChange({
      code: 'TOOLTIP_RENDERER',
      handler: function handler() {
        this._setTooltipRendererOptions();
      },
      isThemeDependent: true,
      isOptionChange: true
    });
    constructor.addChange({
      code: 'TOOLTIP',
      handler: function handler() {
        this._setTooltipOptions();
      },
      isThemeDependent: true,
      isOptionChange: true,
      option: 'tooltip'
    });
  },
  fontFields: ['tooltip.font']
};
exports.plugin = plugin;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Range = void 0;

var _type = __webpack_require__(1);

var _extend = __webpack_require__(0);

var _utils = __webpack_require__(14);

var _isDefined = _type.isDefined;
var _isDate = _type.isDate;
var _isFunction = _type.isFunction;
var minSelector = 'min';
var maxSelector = 'max';
var minVisibleSelector = 'minVisible';
var maxVisibleSelector = 'maxVisible';
var baseSelector = 'base';
var axisTypeSelector = 'axisType';

function otherLessThan(thisValue, otherValue) {
  return otherValue < thisValue;
}

function otherGreaterThan(thisValue, otherValue) {
  return otherValue > thisValue;
}

function compareAndReplace(thisValue, otherValue, setValue, compare) {
  var otherValueDefined = _isDefined(otherValue);

  if (_isDefined(thisValue)) {
    if (otherValueDefined && compare(thisValue, otherValue)) {
      setValue(otherValue);
    }
  } else if (otherValueDefined) {
    setValue(otherValue);
  }
}

var Range = function Range(range) {
  range && (0, _extend.extend)(this, range);
};

exports.Range = Range;
var _Range = Range;
_Range.prototype = {
  constructor: _Range,
  addRange: function addRange(otherRange) {
    var that = this;
    var categories = that.categories;
    var otherCategories = otherRange.categories;
    var isDiscrete = that[axisTypeSelector] === 'discrete';

    var compareAndReplaceByField = function compareAndReplaceByField(field, compare) {
      compareAndReplace(that[field], otherRange[field], function (value) {
        that[field] = value;
      }, compare);
    };

    var controlValuesByVisibleBounds = function controlValuesByVisibleBounds(valueField, visibleValueField, compare) {
      compareAndReplace(that[valueField], that[visibleValueField], function (value) {
        _isDefined(that[valueField]) && (that[valueField] = value);
      }, compare);
    };

    var checkField = function checkField(field) {
      that[field] = that[field] || otherRange[field];
    };

    checkField('invert');
    checkField(axisTypeSelector);
    checkField('dataType');
    checkField('isSpacedMargin');

    if (that[axisTypeSelector] === 'logarithmic') {
      checkField(baseSelector);
    } else {
      that[baseSelector] = undefined;
    }

    compareAndReplaceByField(minSelector, otherLessThan);
    compareAndReplaceByField(maxSelector, otherGreaterThan);

    if (isDiscrete) {
      checkField(minVisibleSelector);
      checkField(maxVisibleSelector);
    } else {
      compareAndReplaceByField(minVisibleSelector, otherLessThan);
      compareAndReplaceByField(maxVisibleSelector, otherGreaterThan);
    }

    compareAndReplaceByField('interval', otherLessThan);

    if (!isDiscrete) {
      controlValuesByVisibleBounds(minSelector, minVisibleSelector, otherLessThan);
      controlValuesByVisibleBounds(minSelector, maxVisibleSelector, otherLessThan);
      controlValuesByVisibleBounds(maxSelector, maxVisibleSelector, otherGreaterThan);
      controlValuesByVisibleBounds(maxSelector, minVisibleSelector, otherGreaterThan);
    }

    if (categories === undefined) {
      that.categories = otherCategories;
    } else {
      that.categories = otherCategories ? (0, _utils.unique)(categories.concat(otherCategories)) : categories;
    }

    if (that[axisTypeSelector] === 'logarithmic') {
      checkField('allowNegatives');
      compareAndReplaceByField('linearThreshold', otherLessThan);
    }

    return that;
  },
  isEmpty: function isEmpty() {
    return (!_isDefined(this[minSelector]) || !_isDefined(this[maxSelector])) && (!this.categories || this.categories.length === 0);
  },
  correctValueZeroLevel: function correctValueZeroLevel() {
    var that = this;

    if (that[axisTypeSelector] === 'logarithmic' || _isDate(that[maxSelector]) || _isDate(that[minSelector])) {
      return that;
    }

    function setZeroLevel(min, max) {
      that[min] < 0 && that[max] < 0 && (that[max] = 0);
      that[min] > 0 && that[max] > 0 && (that[min] = 0);
    }

    setZeroLevel(minSelector, maxSelector);
    setZeroLevel(minVisibleSelector, maxVisibleSelector);
    return that;
  },
  sortCategories: function sortCategories(sort) {
    if (sort === false || !this.categories) {
      return;
    }

    if (Array.isArray(sort)) {
      var sortValues = sort.map(function (item) {
        return item.valueOf();
      });
      var filteredSeriesCategories = this.categories.filter(function (item) {
        return sortValues.indexOf(item.valueOf()) === -1;
      });
      this.categories = sort.concat(filteredSeriesCategories);
    } else {
      var notAFunction = !_isFunction(sort);

      if (notAFunction && this.dataType !== 'string') {
        sort = function sort(a, b) {
          return a.valueOf() - b.valueOf();
        };
      } else if (notAFunction) {
        sort = false;
      }

      sort && this.categories.sort(sort);
    }
  }
};

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = _default;

var _extend = __webpack_require__(0);

var _console = __webpack_require__(111);

var _string = __webpack_require__(40);

var _version = __webpack_require__(169);

/* eslint-disable import/no-commonjs */
var ERROR_URL = 'http://js.devexpress.com/error/' + _version.version.split('.').slice(0, 2).join('_') + '/';

function _default(baseErrors, errors) {
  var exports = {
    ERROR_MESSAGES: (0, _extend.extend)(errors, baseErrors),
    Error: function Error() {
      return makeError([].slice.call(arguments));
    },
    log: function log(id) {
      var method = 'log';

      if (/^E\d+$/.test(id)) {
        method = 'error';
      } else if (/^W\d+$/.test(id)) {
        method = 'warn';
      }

      _console.logger[method](method === 'log' ? id : combineMessage([].slice.call(arguments)));
    }
  };

  function combineMessage(args) {
    var id = args[0];
    args = args.slice(1);
    return formatMessage(id, formatDetails(id, args));
  }

  function formatDetails(id, args) {
    args = [exports.ERROR_MESSAGES[id]].concat(args);
    return _string.format.apply(this, args).replace(/\.*\s*?$/, '');
  }

  function formatMessage(id, details) {
    return _string.format.apply(this, ['{0} - {1}. See:\n{2}', id, details, getErrorUrl(id)]);
  }

  function makeError(args) {
    var id = args[0];
    args = args.slice(1);
    var details = formatDetails(id, args);
    var url = getErrorUrl(id);
    var message = formatMessage(id, details);
    return (0, _extend.extend)(new Error(message), {
      __id: id,
      __details: details,
      url: url
    });
  }

  function getErrorUrl(id) {
    return ERROR_URL + id;
  }

  return exports;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.attachInstanceToElement = attachInstanceToElement;
exports.getInstanceByElement = getInstanceByElement;
exports.name = void 0;

var _element_data = __webpack_require__(43);

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _weak_map = _interopRequireDefault(__webpack_require__(193));

var _type = __webpack_require__(1);

var _remove_event = __webpack_require__(147);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var COMPONENT_NAMES_DATA_KEY = 'dxComponents';
var ANONYMOUS_COMPONENT_DATA_KEY = 'dxPrivateComponent';
var componentNames = new _weak_map.default();
var nextAnonymousComponent = 0;

var getName = function getName(componentClass, newName) {
  if ((0, _type.isDefined)(newName)) {
    componentNames.set(componentClass, newName);
    return;
  }

  if (!componentNames.has(componentClass)) {
    var generatedName = ANONYMOUS_COMPONENT_DATA_KEY + nextAnonymousComponent++;
    componentNames.set(componentClass, generatedName);
    return generatedName;
  }

  return componentNames.get(componentClass);
};

exports.name = getName;

function attachInstanceToElement($element, componentInstance, disposeFn) {
  var data = (0, _element_data.data)($element.get(0));
  var name = getName(componentInstance.constructor);
  data[name] = componentInstance;

  if (disposeFn) {
    _events_engine.default.one($element, _remove_event.removeEvent, function () {
      disposeFn.call(componentInstance);
    });
  }

  if (!data[COMPONENT_NAMES_DATA_KEY]) {
    data[COMPONENT_NAMES_DATA_KEY] = [];
  }

  data[COMPONENT_NAMES_DATA_KEY].push(name);
}

function getInstanceByElement($element, componentClass) {
  var name = getName(componentClass);
  return (0, _element_data.data)($element.get(0), name);
}

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _memorized_callbacks = _interopRequireDefault(__webpack_require__(194));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = new _memorized_callbacks.default();

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.end = exports.start = void 0;

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _element_data = __webpack_require__(43);

var _class = _interopRequireDefault(__webpack_require__(15));

var _devices = _interopRequireDefault(__webpack_require__(13));

var _event_registrator = _interopRequireDefault(__webpack_require__(68));

var _index = __webpack_require__(8);

var _pointer = _interopRequireDefault(__webpack_require__(25));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HOVERSTART_NAMESPACE = 'dxHoverStart';
var HOVERSTART = 'dxhoverstart';
exports.start = HOVERSTART;
var POINTERENTER_NAMESPACED_EVENT_NAME = (0, _index.addNamespace)(_pointer.default.enter, HOVERSTART_NAMESPACE);
var HOVEREND_NAMESPACE = 'dxHoverEnd';
var HOVEREND = 'dxhoverend';
exports.end = HOVEREND;
var POINTERLEAVE_NAMESPACED_EVENT_NAME = (0, _index.addNamespace)(_pointer.default.leave, HOVEREND_NAMESPACE);

var Hover = _class.default.inherit({
  noBubble: true,
  ctor: function ctor() {
    this._handlerArrayKeyPath = this._eventNamespace + '_HandlerStore';
  },
  setup: function setup(element) {
    (0, _element_data.data)(element, this._handlerArrayKeyPath, {});
  },
  add: function add(element, handleObj) {
    var that = this;

    var handler = function handler(e) {
      that._handler(e);
    };

    _events_engine.default.on(element, this._originalEventName, handleObj.selector, handler);

    (0, _element_data.data)(element, this._handlerArrayKeyPath)[handleObj.guid] = handler;
  },
  _handler: function _handler(e) {
    if ((0, _index.isTouchEvent)(e) || _devices.default.isSimulator()) {
      return;
    }

    (0, _index.fireEvent)({
      type: this._eventName,
      originalEvent: e,
      delegateTarget: e.delegateTarget
    });
  },
  remove: function remove(element, handleObj) {
    var handler = (0, _element_data.data)(element, this._handlerArrayKeyPath)[handleObj.guid];

    _events_engine.default.off(element, this._originalEventName, handleObj.selector, handler);
  },
  teardown: function teardown(element) {
    (0, _element_data.removeData)(element, this._handlerArrayKeyPath);
  }
});

var HoverStart = Hover.inherit({
  ctor: function ctor() {
    this._eventNamespace = HOVERSTART_NAMESPACE;
    this._eventName = HOVERSTART;
    this._originalEventName = POINTERENTER_NAMESPACED_EVENT_NAME;
    this.callBase();
  },
  _handler: function _handler(e) {
    var pointers = e.pointers || [];

    if (!pointers.length) {
      this.callBase(e);
    }
  }
});
var HoverEnd = Hover.inherit({
  ctor: function ctor() {
    this._eventNamespace = HOVEREND_NAMESPACE;
    this._eventName = HOVEREND;
    this._originalEventName = POINTERLEAVE_NAMESPACED_EVENT_NAME;
    this.callBase();
  }
});
/**
 * @name UI Events.dxhoverstart
 * @type eventType
 * @type_function_param1 event:event
 * @module events/hover
*/

/**
 * @name UI Events.dxhoverend
 * @type eventType
 * @type_function_param1 event:event
 * @module events/hover
*/

(0, _event_registrator.default)(HOVERSTART, new HoverStart());
(0, _event_registrator.default)(HOVEREND, new HoverEnd());

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint-disable import/no-commonjs */
var windowUtils = __webpack_require__(7);

var window = windowUtils.getWindow();
var DevExpress = window.DevExpress = window.DevExpress || {};

var errors = DevExpress.errors = __webpack_require__(24);

if (DevExpress._DEVEXTREME_BUNDLE_INITIALIZED) {
  throw errors.Error('E0024');
}

DevExpress._DEVEXTREME_BUNDLE_INITIALIZED = true;
DevExpress.clientExporter = __webpack_require__(192);
DevExpress.excelExporter = __webpack_require__(371);
DevExpress.pdfExporter = __webpack_require__(377);
DevExpress.VERSION = __webpack_require__(169).version;
DevExpress.Class = __webpack_require__(15);
DevExpress.DOMComponent = __webpack_require__(66);
DevExpress.Component = __webpack_require__(125).Component;
DevExpress.registerComponent = __webpack_require__(9);
DevExpress.devices = __webpack_require__(13);
DevExpress.Color = __webpack_require__(102);

var animationFrame = __webpack_require__(122);
/**
 * @name utils
 * @namespace DevExpress
 */


DevExpress.utils = {};
DevExpress.utils.requestAnimationFrame = animationFrame.requestAnimationFrame;
DevExpress.utils.cancelAnimationFrame = animationFrame.cancelAnimationFrame;
DevExpress.utils.initMobileViewport = __webpack_require__(389).initMobileViewport;
DevExpress.utils.getTimeZones = __webpack_require__(390).getTimeZones; // TODO: MODULARITY: Remove this

DevExpress.utils.extendFromObject = __webpack_require__(0).extendFromObject;
DevExpress.utils.triggerShownEvent = __webpack_require__(59).triggerShownEvent;
DevExpress.utils.triggerHidingEvent = __webpack_require__(59).triggerHidingEvent;
DevExpress.utils.resetActiveElement = __webpack_require__(35).resetActiveElement;
DevExpress.utils.findBestMatches = __webpack_require__(4).findBestMatches;
DevExpress.createQueue = __webpack_require__(266).create;
DevExpress.utils.dom = __webpack_require__(35);
DevExpress.utils.common = __webpack_require__(4);
DevExpress.utils.date = __webpack_require__(18);
DevExpress.utils.browser = __webpack_require__(32);
DevExpress.utils.inflector = __webpack_require__(41);
DevExpress.utils.iterator = __webpack_require__(3);
DevExpress.utils.readyCallbacks = __webpack_require__(51);
DevExpress.utils.resizeCallbacks = __webpack_require__(103);
DevExpress.utils.console = __webpack_require__(111);
DevExpress.utils.string = __webpack_require__(40);
DevExpress.utils.support = __webpack_require__(48);
DevExpress.utils.ajax = __webpack_require__(80);
DevExpress.viewPort = __webpack_require__(77).value;
DevExpress.hideTopOverlay = __webpack_require__(394);
DevExpress.formatHelper = __webpack_require__(82);
DevExpress.config = __webpack_require__(29);
DevExpress.animationPresets = __webpack_require__(197).presets;
DevExpress.fx = __webpack_require__(45);
DevExpress.TransitionExecutor = __webpack_require__(280).TransitionExecutor;
DevExpress.AnimationPresetCollection = __webpack_require__(197).PresetCollection;
DevExpress.events = __webpack_require__(281);
DevExpress.events.click = __webpack_require__(23);
DevExpress.events.utils = __webpack_require__(8);
DevExpress.events.GestureEmitter = __webpack_require__(172);
DevExpress.localization = __webpack_require__(396);
DevExpress.templateRendered = __webpack_require__(69).renderedCallbacks;
DevExpress.setTemplateEngine = __webpack_require__(171).setTemplateEngine;
module.exports = DevExpress;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.removeEvent = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _element_data = __webpack_require__(43);

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _event_registrator = _interopRequireDefault(__webpack_require__(68));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var removeEvent = 'dxremove';
exports.removeEvent = removeEvent;
var eventPropName = 'dxRemoveEvent';
/**
  * @name UI Events.dxremove
  * @type eventType
  * @type_function_param1 event:event
  * @module events/remove
*/

(0, _element_data.beforeCleanData)(function (elements) {
  elements = [].slice.call(elements);

  for (var i = 0; i < elements.length; i++) {
    var $element = (0, _renderer.default)(elements[i]);

    if ($element.prop(eventPropName)) {
      $element[0][eventPropName] = null;

      _events_engine.default.triggerHandler($element, removeEvent);
    }
  }
});
(0, _event_registrator.default)(removeEvent, {
  noBubble: true,
  setup: function setup(element) {
    (0, _renderer.default)(element).prop(eventPropName, true);
  }
});

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.FunctionTemplate = void 0;

var _template_base = __webpack_require__(69);

var _dom = __webpack_require__(35);

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var FunctionTemplate = /*#__PURE__*/function (_TemplateBase) {
  _inheritsLoose(FunctionTemplate, _TemplateBase);

  function FunctionTemplate(render) {
    var _this;

    _this = _TemplateBase.call(this) || this;
    _this._render = render;
    return _this;
  }

  var _proto = FunctionTemplate.prototype;

  _proto._renderCore = function _renderCore(options) {
    return (0, _dom.normalizeTemplateElement)(this._render(options));
  };

  return FunctionTemplate;
}(_template_base.TemplateBase);

exports.FunctionTemplate = FunctionTemplate;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.name = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _event_registrator = _interopRequireDefault(__webpack_require__(68));

var _index = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EVENT_NAME = 'dxmousewheel';
exports.name = EVENT_NAME;
var EVENT_NAMESPACE = 'dxWheel';
var NATIVE_EVENT_NAME = 'wheel';
var PIXEL_MODE = 0;
var DELTA_MUTLIPLIER = 30;
var wheel = {
  setup: function setup(element) {
    var $element = (0, _renderer.default)(element);

    _events_engine.default.on($element, (0, _index.addNamespace)(NATIVE_EVENT_NAME, EVENT_NAMESPACE), wheel._wheelHandler.bind(wheel));
  },
  teardown: function teardown(element) {
    _events_engine.default.off(element, ".".concat(EVENT_NAMESPACE));
  },
  _wheelHandler: function _wheelHandler(e) {
    var _e$originalEvent = e.originalEvent,
        deltaMode = _e$originalEvent.deltaMode,
        deltaY = _e$originalEvent.deltaY,
        deltaX = _e$originalEvent.deltaX,
        deltaZ = _e$originalEvent.deltaZ;
    (0, _index.fireEvent)({
      type: EVENT_NAME,
      originalEvent: e,
      delta: this._normalizeDelta(deltaY, deltaMode),
      deltaX: deltaX,
      deltaY: deltaY,
      deltaZ: deltaZ,
      deltaMode: deltaMode,
      pointerType: 'mouse'
    });
    e.stopPropagation();
  },
  _normalizeDelta: function _normalizeDelta(delta) {
    var deltaMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PIXEL_MODE;

    if (deltaMode === PIXEL_MODE) {
      return -delta;
    } else {
      // Use multiplier to get rough delta value in px for the LINE or PAGE mode
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1392460
      return -DELTA_MUTLIPLIER * delta;
    }
  }
};
(0, _event_registrator.default)(EVENT_NAME, wheel);

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.inactive = exports.active = exports.lock = void 0;

var _class = _interopRequireDefault(__webpack_require__(15));

var _common = __webpack_require__(4);

var _dom = __webpack_require__(35);

var _devices = _interopRequireDefault(__webpack_require__(13));

var _index = __webpack_require__(8);

var _pointer = _interopRequireDefault(__webpack_require__(25));

var _emitter = _interopRequireDefault(__webpack_require__(127));

var _emitter_registrator = _interopRequireDefault(__webpack_require__(104));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ACTIVE_EVENT_NAME = 'dxactive';
exports.active = ACTIVE_EVENT_NAME;
var INACTIVE_EVENT_NAME = 'dxinactive';
exports.inactive = INACTIVE_EVENT_NAME;
var ACTIVE_TIMEOUT = 30;
var INACTIVE_TIMEOUT = 400;

var FeedbackEvent = _class.default.inherit({
  ctor: function ctor(timeout, fire) {
    this._timeout = timeout;
    this._fire = fire;
  },
  start: function start() {
    var that = this;

    this._schedule(function () {
      that.force();
    });
  },
  _schedule: function _schedule(fn) {
    this.stop();
    this._timer = setTimeout(fn, this._timeout);
  },
  stop: function stop() {
    clearTimeout(this._timer);
  },
  force: function force() {
    if (this._fired) {
      return;
    }

    this.stop();

    this._fire();

    this._fired = true;
  },
  fired: function fired() {
    return this._fired;
  }
});

var activeFeedback;

var FeedbackEmitter = _emitter.default.inherit({
  ctor: function ctor() {
    this.callBase.apply(this, arguments);
    this._active = new FeedbackEvent(0, _common.noop);
    this._inactive = new FeedbackEvent(0, _common.noop);
  },
  configure: function configure(data, eventName) {
    switch (eventName) {
      case ACTIVE_EVENT_NAME:
        data.activeTimeout = data.timeout;
        break;

      case INACTIVE_EVENT_NAME:
        data.inactiveTimeout = data.timeout;
        break;
    }

    this.callBase(data);
  },
  start: function start(e) {
    if (activeFeedback) {
      var activeChildExists = (0, _dom.contains)(this.getElement().get(0), activeFeedback.getElement().get(0));
      var childJustActivated = !activeFeedback._active.fired();

      if (activeChildExists && childJustActivated) {
        this._cancel();

        return;
      }

      activeFeedback._inactive.force();
    }

    activeFeedback = this;

    this._initEvents(e);

    this._active.start();
  },
  _initEvents: function _initEvents(e) {
    var that = this;

    var eventTarget = this._getEmitterTarget(e);

    var mouseEvent = (0, _index.isMouseEvent)(e);

    var isSimulator = _devices.default.isSimulator();

    var deferFeedback = isSimulator || !mouseEvent;
    var activeTimeout = (0, _common.ensureDefined)(this.activeTimeout, ACTIVE_TIMEOUT);
    var inactiveTimeout = (0, _common.ensureDefined)(this.inactiveTimeout, INACTIVE_TIMEOUT);
    this._active = new FeedbackEvent(deferFeedback ? activeTimeout : 0, function () {
      that._fireEvent(ACTIVE_EVENT_NAME, e, {
        target: eventTarget
      });
    });
    this._inactive = new FeedbackEvent(deferFeedback ? inactiveTimeout : 0, function () {
      that._fireEvent(INACTIVE_EVENT_NAME, e, {
        target: eventTarget
      });

      activeFeedback = null;
    });
  },
  cancel: function cancel(e) {
    this.end(e);
  },
  end: function end(e) {
    var skipTimers = e.type !== _pointer.default.up;

    if (skipTimers) {
      this._active.stop();
    } else {
      this._active.force();
    }

    this._inactive.start();

    if (skipTimers) {
      this._inactive.force();
    }
  },
  dispose: function dispose() {
    this._active.stop();

    this._inactive.stop();

    if (activeFeedback === this) {
      activeFeedback = null;
    }

    this.callBase();
  },
  lockInactive: function lockInactive() {
    this._active.force();

    this._inactive.stop();

    activeFeedback = null;

    this._cancel();

    return this._inactive.force.bind(this._inactive);
  }
});

FeedbackEmitter.lock = function (deferred) {
  var lockInactive = activeFeedback ? activeFeedback.lockInactive() : _common.noop;
  deferred.done(lockInactive);
};

(0, _emitter_registrator.default)({
  emitter: FeedbackEmitter,
  events: [ACTIVE_EVENT_NAME, INACTIVE_EVENT_NAME]
});
var lock = FeedbackEmitter.lock;
exports.lock = lock;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _class = _interopRequireDefault(__webpack_require__(15));

var _iterator = __webpack_require__(3);

var _public_component = __webpack_require__(143);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var INVISIBLE_STATE_CLASS = 'dx-state-invisible';
var DISABLED_STATE_CLASS = 'dx-state-disabled';
var ITEM_CONTENT_PLACEHOLDER_CLASS = 'dx-item-content-placeholder';

var forcibleWatcher = function forcibleWatcher(watchMethod, fn, callback) {
  var filteredCallback = function () {
    var oldValue;
    return function (value) {
      if (oldValue !== value) {
        callback(value, oldValue);
        oldValue = value;
      }
    };
  }();

  return {
    dispose: watchMethod(fn, filteredCallback),
    force: function force() {
      filteredCallback(fn());
    }
  };
};

var CollectionItem = _class.default.inherit({
  ctor: function ctor($element, options, rawData) {
    this._$element = $element;
    this._options = options;
    this._rawData = rawData;
    (0, _public_component.attachInstanceToElement)($element, this, this._dispose);

    this._render();
  },
  _render: function _render() {
    var $placeholder = (0, _renderer.default)('<div>').addClass(ITEM_CONTENT_PLACEHOLDER_CLASS);

    this._$element.append($placeholder);

    this._watchers = [];

    this._renderWatchers();
  },
  _renderWatchers: function _renderWatchers() {
    this._startWatcher('disabled', this._renderDisabled.bind(this));

    this._startWatcher('visible', this._renderVisible.bind(this));
  },
  _startWatcher: function _startWatcher(field, render) {
    var rawData = this._rawData;

    var exprGetter = this._options.fieldGetter(field);

    var watcher = forcibleWatcher(this._options.watchMethod(), function () {
      return exprGetter(rawData);
    }, function (value, oldValue) {
      this._dirty = true;
      render(value, oldValue);
    }.bind(this));

    this._watchers.push(watcher);
  },
  setDataField: function setDataField() {
    this._dirty = false;
    (0, _iterator.each)(this._watchers, function (_, watcher) {
      watcher.force();
    });

    if (this._dirty) {
      return true;
    }
  },
  _renderDisabled: function _renderDisabled(value, oldValue) {
    this._$element.toggleClass(DISABLED_STATE_CLASS, !!value);

    this._updateOwnerFocus(value);
  },
  _updateOwnerFocus: function _updateOwnerFocus(isDisabled) {
    var ownerComponent = this._options.owner;

    if (ownerComponent && isDisabled) {
      ownerComponent._resetItemFocus(this._$element);
    }
  },
  _renderVisible: function _renderVisible(value, oldValue) {
    this._$element.toggleClass(INVISIBLE_STATE_CLASS, value !== undefined && !value);
  },
  _dispose: function _dispose() {
    (0, _iterator.each)(this._watchers, function (_, watcher) {
      watcher.dispose();
    });
  }
});

CollectionItem.getInstance = function ($element) {
  return (0, _public_component.getInstanceByElement)($element, this);
};

var _default = CollectionItem;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.name = void 0;

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _dom = __webpack_require__(35);

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _class = _interopRequireDefault(__webpack_require__(15));

var _event_registrator = _interopRequireDefault(__webpack_require__(68));

var _click = __webpack_require__(23);

var _index = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DBLCLICK_EVENT_NAME = 'dxdblclick';
exports.name = DBLCLICK_EVENT_NAME;
var DBLCLICK_NAMESPACE = 'dxDblClick';
var NAMESPACED_CLICK_EVENT = (0, _index.addNamespace)(_click.name, DBLCLICK_NAMESPACE);
var DBLCLICK_TIMEOUT = 300;

var DblClick = _class.default.inherit({
  ctor: function ctor() {
    this._handlerCount = 0;

    this._forgetLastClick();
  },
  _forgetLastClick: function _forgetLastClick() {
    this._firstClickTarget = null;
    this._lastClickTimeStamp = -DBLCLICK_TIMEOUT;
  },
  add: function add() {
    if (this._handlerCount <= 0) {
      _events_engine.default.on(_dom_adapter.default.getDocument(), NAMESPACED_CLICK_EVENT, this._clickHandler.bind(this));
    }

    this._handlerCount++;
  },
  _clickHandler: function _clickHandler(e) {
    var timeStamp = e.timeStamp || Date.now();
    var timeBetweenClicks = timeStamp - this._lastClickTimeStamp; // NOTE: jQuery sets `timeStamp = Date.now()` for the triggered events, but
    // in the real event timeStamp is the number of milliseconds elapsed from the
    // beginning of the current document's lifetime till the event was created
    // (https://developer.mozilla.org/en-US/docs/Web/API/Event/timeStamp).

    var isSimulated = timeBetweenClicks < 0;
    var isDouble = !isSimulated && timeBetweenClicks < DBLCLICK_TIMEOUT;

    if (isDouble) {
      (0, _index.fireEvent)({
        type: DBLCLICK_EVENT_NAME,
        target: (0, _dom.closestCommonParent)(this._firstClickTarget, e.target),
        originalEvent: e
      });

      this._forgetLastClick();
    } else {
      this._firstClickTarget = e.target;
      this._lastClickTimeStamp = timeStamp;
    }
  },
  remove: function remove() {
    this._handlerCount--;

    if (this._handlerCount <= 0) {
      this._forgetLastClick();

      _events_engine.default.off(_dom_adapter.default.getDocument(), NAMESPACED_CLICK_EVENT);
    }
  }
});

(0, _event_registrator.default)(DBLCLICK_EVENT_NAME, new DblClick());

/***/ }),
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;
var _default = {
  events: {
    'mouseover': 'mouseover',
    'mouseout': 'mouseout',
    'mousemove': 'mousemove',
    'touchstart': 'touchstart',
    'touchmove': 'touchmove',
    'touchend': 'touchend',
    'mousedown': 'mousedown',
    'mouseup': 'mouseup',
    click: 'click',
    selectSeries: 'selectseries',
    deselectSeries: 'deselectseries',
    selectPoint: 'selectpoint',
    deselectPoint: 'deselectpoint',
    showPointTooltip: 'showpointtooltip',
    hidePointTooltip: 'hidepointtooltip'
  },
  states: {
    hover: 'hover',
    normal: 'normal',
    selection: 'selection',
    normalMark: 0,
    hoverMark: 1,
    selectedMark: 2,
    applyHover: 'applyHover',
    applySelected: 'applySelected',
    resetItem: 'resetItem'
  },
  radialLabelIndent: 30,
  pieLabelSpacing: 10,
  pieSeriesSpacing: 4
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _extend2 = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _common = __webpack_require__(4);

var _window = __webpack_require__(7);

var _label = __webpack_require__(348);

var _type = __webpack_require__(1);

var _utils = __webpack_require__(14);

var window = (0, _window.getWindow)();
var _extend = _extend2.extend;
var _math = Math;
var _round = _math.round;
var _floor = _math.floor;
var _ceil = _math.ceil;
var DEFAULT_IMAGE_WIDTH = 20;
var DEFAULT_IMAGE_HEIGHT = 20;
var LABEL_OFFSET = 10;
var CANVAS_POSITION_DEFAULT = 'canvas_position_default';

function getSquareMarkerCoords(radius) {
  return [-radius, -radius, radius, -radius, radius, radius, -radius, radius, -radius, -radius];
}

function getPolygonMarkerCoords(radius) {
  var r = _ceil(radius); // T100386


  return [-r, 0, 0, -r, r, 0, 0, r, -r, 0];
}

function getCrossMarkerCoords(radius) {
  var r = _ceil(radius); // T100386


  var floorHalfRadius = _floor(r / 2);

  var ceilHalfRadius = _ceil(r / 2);

  return [-r, -floorHalfRadius, -floorHalfRadius, -r, 0, -ceilHalfRadius, floorHalfRadius, -r, r, -floorHalfRadius, ceilHalfRadius, 0, r, floorHalfRadius, floorHalfRadius, r, 0, ceilHalfRadius, -floorHalfRadius, r, -r, floorHalfRadius, -ceilHalfRadius, 0];
}

function getTriangleDownMarkerCoords(radius) {
  return [-radius, -radius, radius, -radius, 0, radius, -radius, -radius];
}

function getTriangleUpMarkerCoords(radius) {
  return [-radius, radius, radius, radius, 0, -radius, -radius, radius];
}

var _default = {
  deleteLabel: function deleteLabel() {
    this._label.dispose();

    this._label = null;
  },
  _hasGraphic: function _hasGraphic() {
    return this.graphic;
  },
  clearVisibility: function clearVisibility() {
    var that = this;
    var graphic = that.graphic;

    if (graphic && graphic.attr('visibility')) {
      graphic.attr({
        visibility: null
      });
    }
  },
  isVisible: function isVisible() {
    return this.inVisibleArea && this.series.isVisible();
  },
  setInvisibility: function setInvisibility() {
    var that = this;
    var graphic = that.graphic;

    if (graphic && graphic.attr('visibility') !== 'hidden') {
      graphic.attr({
        visibility: 'hidden'
      });
    }

    that._errorBar && that._errorBar.attr({
      visibility: 'hidden'
    });

    that._label.draw(false);
  },
  clearMarker: function clearMarker() {
    var graphic = this.graphic;
    graphic && graphic.attr(this._emptySettings);
  },
  _createLabel: function _createLabel() {
    this._label = new _label.Label({
      renderer: this.series._renderer,
      labelsGroup: this.series._labelsGroup,
      point: this
    });
  },
  _updateLabelData: function _updateLabelData() {
    this._label.setData(this._getLabelFormatObject());
  },
  _updateLabelOptions: function _updateLabelOptions() {
    !this._label && this._createLabel();

    this._label.setOptions(this._options.label);
  },
  _checkImage: function _checkImage(image) {
    return (0, _type.isDefined)(image) && (typeof image === 'string' || (0, _type.isDefined)(image.url));
  },
  _fillStyle: function _fillStyle() {
    this._styles = this._options.styles;
  },
  _checkSymbol: function _checkSymbol(oldOptions, newOptions) {
    var oldSymbol = oldOptions.symbol;
    var newSymbol = newOptions.symbol;
    var symbolChanged = oldSymbol === 'circle' && newSymbol !== 'circle' || oldSymbol !== 'circle' && newSymbol === 'circle';

    var imageChanged = this._checkImage(oldOptions.image) !== this._checkImage(newOptions.image);

    return !!(symbolChanged || imageChanged);
  },
  _populatePointShape: function _populatePointShape(symbol, radius) {
    switch (symbol) {
      case 'square':
        return getSquareMarkerCoords(radius);

      case 'polygon':
        return getPolygonMarkerCoords(radius);

      case 'triangle':
      case 'triangleDown':
        return getTriangleDownMarkerCoords(radius);

      case 'triangleUp':
        return getTriangleUpMarkerCoords(radius);

      case 'cross':
        return getCrossMarkerCoords(radius);
    }
  },
  hasCoords: function hasCoords() {
    return this.x !== null && this.y !== null;
  },
  correctValue: function correctValue(correction) {
    var that = this;
    var axis = that.series.getValueAxis();

    if (that.hasValue()) {
      that.value = that.properValue = axis.validateUnit(that.initialValue.valueOf() + correction.valueOf());
      that.minValue = axis.validateUnit(correction);
    }
  },
  resetCorrection: function resetCorrection() {
    this.value = this.properValue = this.initialValue;
    this.minValue = CANVAS_POSITION_DEFAULT;
  },
  resetValue: function resetValue() {
    var that = this;

    if (that.hasValue()) {
      that.value = that.properValue = that.initialValue = 0;
      that.minValue = 0;

      that._label.setDataField('value', that.value);
    }
  },
  _getTranslates: function _getTranslates(animationEnabled) {
    var translateX = this.x;
    var translateY = this.y;

    if (animationEnabled) {
      if (this._options.rotated) {
        translateX = this.defaultX;
      } else {
        translateY = this.defaultY;
      }
    }

    return {
      x: translateX,
      y: translateY
    };
  },
  _createImageMarker: function _createImageMarker(renderer, settings, options) {
    var width = options.width || DEFAULT_IMAGE_WIDTH;
    var height = options.height || DEFAULT_IMAGE_HEIGHT;
    return renderer.image(-_round(width * 0.5), -_round(height * 0.5), width, height, options.url ? options.url.toString() : options.toString(), 'center').attr({
      translateX: settings.translateX,
      translateY: settings.translateY,
      visibility: settings.visibility
    });
  },
  _createSymbolMarker: function _createSymbolMarker(renderer, pointSettings) {
    var marker;
    var symbol = this._options.symbol;

    if (symbol === 'circle') {
      delete pointSettings.points;
      marker = renderer.circle().attr(pointSettings);
    } else if (symbol === 'square' || symbol === 'polygon' || symbol === 'triangle' || symbol === 'triangleDown' || symbol === 'triangleUp' || symbol === 'cross') {
      marker = renderer.path([], 'area').attr(pointSettings).sharp();
    }

    return marker;
  },
  _createMarker: function _createMarker(renderer, group, image, settings) {
    var that = this;
    var marker = that._checkImage(image) ? that._createImageMarker(renderer, settings, image) : that._createSymbolMarker(renderer, settings);

    if (marker) {
      marker.data({
        'chart-data-point': that
      }).append(group);
    }

    return marker;
  },
  _getSymbolBBox: function _getSymbolBBox(x, y, r) {
    return {
      x: x - r,
      y: y - r,
      width: r * 2,
      height: r * 2
    };
  },
  _getImageBBox: function _getImageBBox(x, y) {
    var image = this._options.image;
    var width = image.width || DEFAULT_IMAGE_WIDTH;
    var height = image.height || DEFAULT_IMAGE_HEIGHT;
    return {
      x: x - _round(width / 2),
      y: y - _round(height / 2),
      width: width,
      height: height
    };
  },
  _getGraphicBBox: function _getGraphicBBox() {
    var that = this;
    var options = that._options;
    var x = that.x;
    var y = that.y;
    var bBox;

    if (options.visible) {
      bBox = that._checkImage(options.image) ? that._getImageBBox(x, y) : that._getSymbolBBox(x, y, options.styles.normal.r);
    } else {
      bBox = {
        x: x,
        y: y,
        width: 0,
        height: 0
      };
    }

    return bBox;
  },
  hideInsideLabel: _common.noop,
  _getShiftLabelCoords: function _getShiftLabelCoords(label) {
    var coord = this._addLabelAlignmentAndOffset(label, this._getLabelCoords(label));

    return this._checkLabelPosition(label, coord);
  },
  _drawLabel: function _drawLabel() {
    var that = this;

    var customVisibility = that._getCustomLabelVisibility();

    var label = that._label;
    var isVisible = that._showForZeroValues() && that.hasValue() && customVisibility !== false && (that.series.getLabelVisibility() || customVisibility);
    label.draw(!!isVisible);
  },
  correctLabelPosition: function correctLabelPosition(label) {
    var that = this;

    var coord = that._getShiftLabelCoords(label);

    if (!that.hideInsideLabel(label, coord)) {
      label.setFigureToDrawConnector(that._getLabelConnector(label.pointPosition));
      label.shift(_round(coord.x), _round(coord.y));
    }
  },
  _showForZeroValues: function _showForZeroValues() {
    return true;
  },
  _getLabelConnector: function _getLabelConnector(pointPosition) {
    var bBox = this._getGraphicBBox(pointPosition);

    var w2 = bBox.width / 2;
    var h2 = bBox.height / 2; // This is to make label connector end at the center of point; "width" and "height" are required by the path building algorithm
    // TODO: When path building algorithm is updated remove "width" and "height"

    return {
      x: bBox.x + w2,
      y: bBox.y + h2,
      r: this._options.visible ? Math.max(w2, h2) : 0
    };
  },
  _getPositionFromLocation: function _getPositionFromLocation() {
    return {
      x: this.x,
      y: this.y
    };
  },
  _isPointInVisibleArea: function _isPointInVisibleArea(visibleArea, graphicBBox) {
    return visibleArea.minX <= graphicBBox.x + graphicBBox.width && visibleArea.maxX >= graphicBBox.x && visibleArea.minY <= graphicBBox.y + graphicBBox.height && visibleArea.maxY >= graphicBBox.y;
  },
  _checkLabelPosition: function _checkLabelPosition(label, coord) {
    var that = this;

    var visibleArea = that._getVisibleArea();

    var labelBBox = label.getBoundingRect();

    var graphicBBox = that._getGraphicBBox(label.pointPosition);

    var fullGraphicBBox = that._getGraphicBBox();

    var isInside = label.getLayoutOptions().position === 'inside';
    var offset = LABEL_OFFSET;

    if (that._isPointInVisibleArea(visibleArea, fullGraphicBBox)) {
      if (!that._options.rotated) {
        if (visibleArea.minX > coord.x) {
          coord.x = visibleArea.minX;
        }

        if (visibleArea.maxX < coord.x + labelBBox.width) {
          coord.x = visibleArea.maxX - labelBBox.width;
        }

        if (visibleArea.minY > coord.y) {
          coord.y = isInside ? visibleArea.minY : graphicBBox.y + graphicBBox.height + offset;
        }

        if (visibleArea.maxY < coord.y + labelBBox.height) {
          coord.y = isInside ? visibleArea.maxY - labelBBox.height : graphicBBox.y - labelBBox.height - offset;
        }
      } else {
        if (visibleArea.minX > coord.x) {
          coord.x = isInside ? visibleArea.minX : graphicBBox.x + graphicBBox.width + offset;
        }

        if (visibleArea.maxX < coord.x + labelBBox.width) {
          coord.x = isInside ? visibleArea.maxX - labelBBox.width : graphicBBox.x - offset - labelBBox.width;
        }

        if (visibleArea.minY > coord.y) {
          coord.y = visibleArea.minY;
        }

        if (visibleArea.maxY < coord.y + labelBBox.height) {
          coord.y = visibleArea.maxY - labelBBox.height;
        }
      }
    }

    return coord;
  },
  _addLabelAlignmentAndOffset: function _addLabelAlignmentAndOffset(label, coord) {
    var labelBBox = label.getBoundingRect();
    var labelOptions = label.getLayoutOptions();

    if (!this._options.rotated) {
      if (labelOptions.alignment === 'left') {
        coord.x += labelBBox.width / 2;
      } else if (labelOptions.alignment === 'right') {
        coord.x -= labelBBox.width / 2;
      }
    }

    coord.x += labelOptions.horizontalOffset;
    coord.y += labelOptions.verticalOffset;
    return coord;
  },
  _getLabelCoords: function _getLabelCoords(label) {
    return this._getLabelCoordOfPosition(label, this._getLabelPosition(label.pointPosition));
  },
  _getLabelCoordOfPosition: function _getLabelCoordOfPosition(label, position) {
    var that = this;
    var labelBBox = label.getBoundingRect();

    var graphicBBox = that._getGraphicBBox(label.pointPosition);

    var offset = LABEL_OFFSET;
    var centerY = graphicBBox.height / 2 - labelBBox.height / 2;
    var centerX = graphicBBox.width / 2 - labelBBox.width / 2;
    var x = graphicBBox.x;
    var y = graphicBBox.y;

    switch (position) {
      case 'left':
        x -= labelBBox.width + offset;
        y += centerY;
        break;

      case 'right':
        x += graphicBBox.width + offset;
        y += centerY;
        break;

      case 'top':
        x += centerX;
        y -= labelBBox.height + offset;
        break;

      case 'bottom':
        x += centerX;
        y += graphicBBox.height + offset;
        break;

      case 'inside':
        x += centerX;
        y += centerY;
        break;
    }

    return {
      x: x,
      y: y
    };
  },
  _drawMarker: function _drawMarker(renderer, group, animationEnabled) {
    var that = this;
    var options = that._options;

    var translates = that._getTranslates(animationEnabled);

    var style = that._getStyle();

    that.graphic = that._createMarker(renderer, group, options.image, _extend({
      translateX: translates.x,
      translateY: translates.y,
      points: that._populatePointShape(options.symbol, style.r)
    }, style));
  },
  _getErrorBarSettings: function _getErrorBarSettings() {
    return {
      visibility: 'visible'
    };
  },
  _getErrorBarBaseEdgeLength: function _getErrorBarBaseEdgeLength() {
    return this.getPointRadius() * 2;
  },
  _drawErrorBar: function _drawErrorBar(renderer, group) {
    if (!this._options.errorBars) {
      return;
    }

    var that = this;
    var options = that._options;
    var errorBarOptions = options.errorBars;
    var points = [];
    var settings;
    var pos = that._errorBarPos;
    var high = that._highErrorCoord;
    var low = that._lowErrorCoord;
    var displayMode = (0, _utils.normalizeEnum)(errorBarOptions.displayMode);
    var isHighDisplayMode = displayMode === 'high';
    var isLowDisplayMode = displayMode === 'low';
    var highErrorOnly = (isHighDisplayMode || !(0, _type.isDefined)(low)) && (0, _type.isDefined)(high) && !isLowDisplayMode;
    var lowErrorOnly = (isLowDisplayMode || !(0, _type.isDefined)(high)) && (0, _type.isDefined)(low) && !isHighDisplayMode;
    var edgeLength = errorBarOptions.edgeLength;

    if (edgeLength <= 1 && edgeLength > 0) {
      edgeLength = this._getErrorBarBaseEdgeLength() * errorBarOptions.edgeLength;
    }

    edgeLength = _floor(parseInt(edgeLength) / 2);
    highErrorOnly && (low = that._baseErrorBarPos);
    lowErrorOnly && (high = that._baseErrorBarPos);

    if (displayMode !== 'none' && (0, _type.isDefined)(high) && (0, _type.isDefined)(low) && (0, _type.isDefined)(pos)) {
      !lowErrorOnly && points.push([pos - edgeLength, high, pos + edgeLength, high]);
      points.push([pos, high, pos, low]);
      !highErrorOnly && points.push([pos + edgeLength, low, pos - edgeLength, low]);
      options.rotated && (0, _iterator.each)(points, function (_, p) {
        p.reverse();
      });
      settings = that._getErrorBarSettings(errorBarOptions);

      if (!that._errorBar) {
        that._errorBar = renderer.path(points, 'line').attr(settings).append(group);
      } else {
        settings.points = points;

        that._errorBar.attr(settings);
      }
    } else {
      that._errorBar && that._errorBar.attr({
        visibility: 'hidden'
      });
    }
  },
  getTooltipParams: function getTooltipParams() {
    var that = this;
    var graphic = that.graphic;
    return {
      x: that.x,
      y: that.y,
      offset: graphic ? graphic.getBBox().height / 2 : 0
    };
  },
  setPercentValue: function setPercentValue(absTotal, total, leftHoleTotal, rightHoleTotal) {
    var that = this;
    var valuePercent = that.value / absTotal || 0;
    var minValuePercent = that.minValue / absTotal || 0;
    var percent = valuePercent - minValuePercent;

    that._label.setDataField('percent', percent);

    that._label.setDataField('total', total);

    if (that.series.isFullStackedSeries() && that.hasValue()) {
      if (that.leftHole) {
        that.leftHole /= absTotal - leftHoleTotal;
        that.minLeftHole /= absTotal - leftHoleTotal;
      }

      if (that.rightHole) {
        that.rightHole /= absTotal - rightHoleTotal;
        that.minRightHole /= absTotal - rightHoleTotal;
      }

      that.value = that.properValue = valuePercent;
      that.minValue = !minValuePercent ? that.minValue : minValuePercent;
    }
  },
  _storeTrackerR: function _storeTrackerR() {
    var that = this;
    var navigator = window.navigator;
    var r = that._options.styles.normal.r;
    var minTrackerSize = (0, _window.hasProperty)('ontouchstart') || navigator.msPointerEnabled && navigator.msMaxTouchPoints || navigator.pointerEnabled && navigator.maxTouchPoints ? 20 : 6;
    that._options.trackerR = r < minTrackerSize ? minTrackerSize : r;
    return that._options.trackerR;
  },
  _translateErrorBars: function _translateErrorBars() {
    var that = this;
    var options = that._options;
    var rotated = options.rotated;
    var errorBars = options.errorBars;

    var translator = that._getValTranslator();

    if (!errorBars) {
      return;
    }

    (0, _type.isDefined)(that.lowError) && (that._lowErrorCoord = translator.translate(that.lowError));
    (0, _type.isDefined)(that.highError) && (that._highErrorCoord = translator.translate(that.highError));
    that._errorBarPos = _floor(rotated ? that.vy : that.vx);
    that._baseErrorBarPos = errorBars.type === 'stdDeviation' ? that._lowErrorCoord + (that._highErrorCoord - that._lowErrorCoord) / 2 : rotated ? that.vx : that.vy;
  },
  _translate: function _translate() {
    var that = this;

    var valTranslator = that._getValTranslator();

    var argTranslator = that._getArgTranslator();

    if (that._options.rotated) {
      that.vx = that.x = valTranslator.translate(that.value);
      that.vy = that.y = argTranslator.translate(that.argument);
      that.minX = valTranslator.translate(that.minValue);
      that.defaultX = valTranslator.translate(CANVAS_POSITION_DEFAULT);
    } else {
      that.vy = that.y = valTranslator.translate(that.value);
      that.vx = that.x = argTranslator.translate(that.argument);
      that.minY = valTranslator.translate(that.minValue);
      that.defaultY = valTranslator.translate(CANVAS_POSITION_DEFAULT);
    }

    that._translateErrorBars();

    that._calculateVisibility(that.x, that.y);
  },
  _updateData: function _updateData(data) {
    var that = this;
    that.value = that.properValue = that.initialValue = that.originalValue = data.value;
    that.minValue = that.initialMinValue = that.originalMinValue = (0, _type.isDefined)(data.minValue) ? data.minValue : CANVAS_POSITION_DEFAULT;
  },
  _getImageSettings: function _getImageSettings(image) {
    return {
      href: image.url || image.toString(),
      width: image.width || DEFAULT_IMAGE_WIDTH,
      height: image.height || DEFAULT_IMAGE_HEIGHT
    };
  },
  getCrosshairData: function getCrosshairData() {
    var that = this;
    var r = that._options.rotated;
    var value = that.properValue;
    var argument = that.argument;
    return {
      x: that.vx,
      y: that.vy,
      xValue: r ? value : argument,
      yValue: r ? argument : value,
      axis: that.series.axis
    };
  },
  getPointRadius: function getPointRadius() {
    var style = this._getStyle();

    var options = this._options;
    var r = style.r;
    var extraSpace;
    var symbol = options.symbol;
    var isSquare = symbol === 'square';
    var isTriangle = symbol === 'triangle' || symbol === 'triangleDown' || symbol === 'triangleUp';

    if (options.visible && !options.image && r) {
      extraSpace = style['stroke-width'] / 2;
      return (isSquare || isTriangle ? 1.4 * r : r) + extraSpace;
    }

    return 0;
  },
  _updateMarker: function _updateMarker(animationEnabled, style) {
    var that = this;
    var options = that._options;
    var settings;
    var image = options.image;
    var visibility = !that.isVisible() ? {
      visibility: 'hidden'
    } : {};

    if (that._checkImage(image)) {
      settings = _extend({}, {
        visibility: style.visibility
      }, visibility, that._getImageSettings(image));
    } else {
      settings = _extend({}, style, visibility, {
        points: that._populatePointShape(options.symbol, style.r)
      });
    }

    if (!animationEnabled) {
      settings.translateX = that.x;
      settings.translateY = that.y;
    }

    that.graphic.attr(settings).sharp();
  },
  _getLabelFormatObject: function _getLabelFormatObject() {
    var that = this;
    return {
      argument: that.initialArgument,
      value: that.initialValue,
      originalArgument: that.originalArgument,
      originalValue: that.originalValue,
      seriesName: that.series.name,
      lowErrorValue: that.lowError,
      highErrorValue: that.highError,
      point: that
    };
  },
  _getLabelPosition: function _getLabelPosition() {
    var rotated = this._options.rotated;

    if (this.initialValue > 0) {
      return rotated ? 'right' : 'top';
    } else {
      return rotated ? 'left' : 'bottom';
    }
  },
  _getFormatObject: function _getFormatObject(tooltip) {
    var that = this;

    var labelFormatObject = that._label.getData();

    return _extend({}, labelFormatObject, {
      argumentText: tooltip.formatValue(that.initialArgument, 'argument'),
      valueText: tooltip.formatValue(that.initialValue)
    }, (0, _type.isDefined)(labelFormatObject.percent) ? {
      percentText: tooltip.formatValue(labelFormatObject.percent, 'percent')
    } : {}, (0, _type.isDefined)(labelFormatObject.total) ? {
      totalText: tooltip.formatValue(labelFormatObject.total)
    } : {});
  },
  getMarkerVisibility: function getMarkerVisibility() {
    return this._options.visible;
  },
  coordsIn: function coordsIn(x, y) {
    var trackerRadius = this._storeTrackerR();

    return x >= this.x - trackerRadius && x <= this.x + trackerRadius && y >= this.y - trackerRadius && y <= this.y + trackerRadius;
  },
  getMinValue: function getMinValue(noErrorBar) {
    var errorBarOptions = this._options.errorBars;

    if (errorBarOptions && !noErrorBar) {
      var displayMode = errorBarOptions.displayMode;
      var lowValue = displayMode !== 'high' && (0, _type.isDefined)(this.lowError) ? this.lowError : this.value;
      var highValue = displayMode !== 'low' && (0, _type.isDefined)(this.highError) ? this.highError : this.value;
      return lowValue < highValue ? lowValue : highValue;
    } else {
      return this.value;
    }
  },
  getMaxValue: function getMaxValue(noErrorBar) {
    var errorBarOptions = this._options.errorBars;

    if (errorBarOptions && !noErrorBar) {
      var displayMode = errorBarOptions.displayMode;
      var lowValue = displayMode !== 'high' && (0, _type.isDefined)(this.lowError) ? this.lowError : this.value;
      var highValue = displayMode !== 'low' && (0, _type.isDefined)(this.highError) ? this.highError : this.value;
      return lowValue > highValue ? lowValue : highValue;
    } else {
      return this.value;
    }
  }
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.plugin = exports.LoadingIndicator = void 0;

var _utils = __webpack_require__(14);

var STATE_HIDDEN = 0;
var STATE_SHOWN = 1;
var ANIMATION_EASING = 'linear';
var ANIMATION_DURATION = 400;
var LOADING_INDICATOR_READY = 'loadingIndicatorReady';

var LoadingIndicator = function LoadingIndicator(parameters) {
  var that = this;
  var renderer = parameters.renderer;
  that._group = renderer.g().attr({
    'class': 'dx-loading-indicator'
  }).linkOn(renderer.root, {
    name: 'loading-indicator',
    after: 'peripheral'
  });
  that._rect = renderer.rect().attr({
    opacity: 0
  }).append(that._group);
  that._text = renderer.text().attr({
    align: 'center'
  }).append(that._group);

  that._createStates(parameters.eventTrigger, that._group, renderer.root, parameters.notify);
};

exports.LoadingIndicator = LoadingIndicator;
LoadingIndicator.prototype = {
  constructor: LoadingIndicator,
  _createStates: function _createStates(eventTrigger, group, root, notify) {
    var that = this;
    that._states = [{
      opacity: 0,
      start: function start() {
        notify(false);
      },
      complete: function complete() {
        group.linkRemove();
        root.css({
          'pointer-events': ''
        });
        eventTrigger(LOADING_INDICATOR_READY);
      }
    }, {
      opacity: 0.85,
      start: function start() {
        group.linkAppend();
        root.css({
          'pointer-events': 'none'
        });
        notify(true);
      },
      complete: function complete() {
        eventTrigger(LOADING_INDICATOR_READY);
      }
    }];
    that._state = STATE_HIDDEN;
  },
  setSize: function setSize(size) {
    var width = size.width;
    var height = size.height;

    this._rect.attr({
      width: width,
      height: height
    });

    this._text.attr({
      x: width / 2,
      y: height / 2
    });
  },
  setOptions: function setOptions(options) {
    this._rect.attr({
      fill: options.backgroundColor
    });

    this._text.css((0, _utils.patchFontOptions)(options.font)).attr({
      text: options.text,
      'class': options.cssClass
    });

    this[options.show ? 'show' : 'hide']();
  },
  dispose: function dispose() {
    var that = this;

    that._group.linkRemove().linkOff();

    that._group = that._rect = that._text = that._states = null;
  },
  _transit: function _transit(stateId) {
    var that = this;
    var state;

    if (that._state !== stateId) {
      that._state = stateId;
      that._isHiding = false;
      state = that._states[stateId];

      that._rect.stopAnimation().animate({
        opacity: state.opacity
      }, {
        complete: state.complete,
        easing: ANIMATION_EASING,
        duration: ANIMATION_DURATION,
        unstoppable: true // T261694

      });

      that._noHiding = true;
      state.start();
      that._noHiding = false;
    }
  },
  show: function show() {
    this._transit(STATE_SHOWN);
  },
  hide: function hide() {
    this._transit(STATE_HIDDEN);
  },
  scheduleHiding: function scheduleHiding() {
    if (!this._noHiding) {
      this._isHiding = true;
    }
  },
  fulfillHiding: function fulfillHiding() {
    if (this._isHiding) {
      this.hide();
    }
  }
};
var plugin = {
  name: 'loading_indicator',
  init: function init() {
    var that = this; // "exports" is used for testing purposes.

    that._loadingIndicator = new LoadingIndicator({
      eventTrigger: that._eventTrigger,
      renderer: that._renderer,
      notify: notify
    });

    that._scheduleLoadingIndicatorHiding();

    function notify(state) {
      // This flag is used to suppress redundant `_optionChanged` notifications caused by the mechanism that synchronizes the `loadingIndicator.show` option and the loading indicator visibility
      that._skipLoadingIndicatorOptions = true;
      that.option('loadingIndicator', {
        show: state
      });
      that._skipLoadingIndicatorOptions = false;

      if (state) {
        that._stopCurrentHandling();
      }
    }
  },
  dispose: function dispose() {
    this._loadingIndicator.dispose();

    this._loadingIndicator = null;
  },
  members: {
    _scheduleLoadingIndicatorHiding: function _scheduleLoadingIndicatorHiding() {
      this._loadingIndicator.scheduleHiding();
    },
    _fulfillLoadingIndicatorHiding: function _fulfillLoadingIndicatorHiding() {
      this._loadingIndicator.fulfillHiding();
    },
    showLoadingIndicator: function showLoadingIndicator() {
      this._loadingIndicator.show();
    },
    hideLoadingIndicator: function hideLoadingIndicator() {
      this._loadingIndicator.hide();
    },
    _onBeginUpdate: function _onBeginUpdate() {
      if (!this._optionChangedLocker) {
        this._scheduleLoadingIndicatorHiding();
      }
    }
  },
  extenders: {
    _dataSourceLoadingChangedHandler: function _dataSourceLoadingChangedHandler(isLoading) {
      if (isLoading && (this._options.silent('loadingIndicator') || {}).enabled) {
        this._loadingIndicator.show();
      }
    },
    _setContentSize: function _setContentSize() {
      this._loadingIndicator.setSize(this._canvas);
    },
    endUpdate: function endUpdate() {
      if (this._initialized && this._dataIsReady()) {
        this._fulfillLoadingIndicatorHiding();
      }
    }
  },
  customize: function customize(constructor) {
    var proto = constructor.prototype; // Of course this looks dirty - but cleaning it is another task. For now it has been just extracted from BaseWidget with minimal changes.

    if (proto._dataSourceChangedHandler) {
      var _dataSourceChangedHandler = proto._dataSourceChangedHandler;

      proto._dataSourceChangedHandler = function () {
        this._scheduleLoadingIndicatorHiding();

        _dataSourceChangedHandler.apply(this, arguments);
      };
    }

    constructor.addChange({
      code: 'LOADING_INDICATOR',
      handler: function handler() {
        if (!this._skipLoadingIndicatorOptions) {
          this._loadingIndicator.setOptions(this._getOption('loadingIndicator'));
        }

        this._scheduleLoadingIndicatorHiding();
      },
      isThemeDependent: true,
      option: 'loadingIndicator',
      isOptionChange: true
    });
    proto._eventsMap.onLoadingIndicatorReady = {
      name: 'loadingIndicatorReady'
    };
    var _drawn = proto._drawn;

    proto._drawn = function () {
      _drawn.apply(this, arguments);

      if (this._dataIsReady()) {
        this._fulfillLoadingIndicatorHiding();
      }
    };
  },
  fontFields: ['loadingIndicator.font']
};
exports.plugin = plugin;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.ChildDefaultTemplate = void 0;

var _template_base = __webpack_require__(69);

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ChildDefaultTemplate = /*#__PURE__*/function (_TemplateBase) {
  _inheritsLoose(ChildDefaultTemplate, _TemplateBase);

  function ChildDefaultTemplate(name) {
    var _this;

    _this = _TemplateBase.call(this) || this;
    _this.name = name;
    return _this;
  }

  return ChildDefaultTemplate;
}(_template_base.TemplateBase);

exports.ChildDefaultTemplate = ChildDefaultTemplate;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _browser = _interopRequireDefault(__webpack_require__(32));

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _class = _interopRequireDefault(__webpack_require__(15));

var _index = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var POINTER_EVENTS_NAMESPACE = 'dxPointerEvents';

var BaseStrategy = _class.default.inherit({
  ctor: function ctor(eventName, originalEvents) {
    this._eventName = eventName;
    this._originalEvents = (0, _index.addNamespace)(originalEvents, POINTER_EVENTS_NAMESPACE);
    this._handlerCount = 0;
    this.noBubble = this._isNoBubble();
  },
  _isNoBubble: function _isNoBubble() {
    var eventName = this._eventName;
    return eventName === 'dxpointerenter' || eventName === 'dxpointerleave';
  },
  _handler: function _handler(e) {
    var delegateTarget = this._getDelegateTarget(e);

    return this._fireEvent({
      type: this._eventName,
      pointerType: e.pointerType || (0, _index.eventSource)(e),
      originalEvent: e,
      delegateTarget: delegateTarget,
      // NOTE: TimeStamp normalization (FF bug #238041) (T277118)
      timeStamp: _browser.default.mozilla ? new Date().getTime() : e.timeStamp
    });
  },
  _getDelegateTarget: function _getDelegateTarget(e) {
    var delegateTarget;

    if (this.noBubble) {
      delegateTarget = e.delegateTarget;
    }

    return delegateTarget;
  },
  _fireEvent: function _fireEvent(args) {
    return (0, _index.fireEvent)(args);
  },
  _setSelector: function _setSelector(handleObj) {
    this._selector = this.noBubble && handleObj ? handleObj.selector : null;
  },
  _getSelector: function _getSelector() {
    return this._selector;
  },
  setup: function setup() {
    return true;
  },
  add: function add(element, handleObj) {
    if (this._handlerCount <= 0 || this.noBubble) {
      element = this.noBubble ? element : _dom_adapter.default.getDocument();

      this._setSelector(handleObj);

      var that = this;

      _events_engine.default.on(element, this._originalEvents, this._getSelector(), function (e) {
        that._handler(e);
      });
    }

    if (!this.noBubble) {
      this._handlerCount++;
    }
  },
  remove: function remove(handleObj) {
    this._setSelector(handleObj);

    if (!this.noBubble) {
      this._handlerCount--;
    }
  },
  teardown: function teardown(element) {
    if (this._handlerCount && !this.noBubble) {
      return;
    }

    element = this.noBubble ? element : _dom_adapter.default.getDocument();

    if (this._originalEvents !== '.' + POINTER_EVENTS_NAMESPACE) {
      _events_engine.default.off(element, this._originalEvents, this._getSelector());
    }
  },
  dispose: function dispose(element) {
    element = this.noBubble ? element : _dom_adapter.default.getDocument();

    _events_engine.default.off(element, this._originalEvents);
  }
});

var _default = BaseStrategy;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _class = _interopRequireDefault(__webpack_require__(15));

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

var _data = __webpack_require__(21);

var _deferred = __webpack_require__(6);

var _errors = __webpack_require__(37);

var _utils = _interopRequireDefault(__webpack_require__(44));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Iterator = _class.default.inherit({
  toArray: function toArray() {
    var result = [];
    this.reset();

    while (this.next()) {
      result.push(this.current());
    }

    return result;
  },
  countable: function countable() {
    return false;
  }
});

var ArrayIterator = Iterator.inherit({
  ctor: function ctor(array) {
    this.array = array;
    this.index = -1;
  },
  next: function next() {
    if (this.index + 1 < this.array.length) {
      this.index++;
      return true;
    }

    return false;
  },
  current: function current() {
    return this.array[this.index];
  },
  reset: function reset() {
    this.index = -1;
  },
  toArray: function toArray() {
    return this.array.slice(0);
  },
  countable: function countable() {
    return true;
  },
  count: function count() {
    return this.array.length;
  }
});
var WrappedIterator = Iterator.inherit({
  ctor: function ctor(iter) {
    this.iter = iter;
  },
  next: function next() {
    return this.iter.next();
  },
  current: function current() {
    return this.iter.current();
  },
  reset: function reset() {
    return this.iter.reset();
  }
});
var MapIterator = WrappedIterator.inherit({
  ctor: function ctor(iter, mapper) {
    this.callBase(iter);
    this.index = -1;
    this.mapper = mapper;
  },
  current: function current() {
    return this.mapper(this.callBase(), this.index);
  },
  next: function next() {
    var hasNext = this.callBase();

    if (hasNext) {
      this.index++;
    }

    return hasNext;
  }
});

var defaultCompare = function defaultCompare(xValue, yValue) {
  xValue = (0, _data.toComparable)(xValue);
  yValue = (0, _data.toComparable)(yValue);

  if (xValue === null && yValue !== null) {
    return -1;
  }

  if (xValue !== null && yValue === null) {
    return 1;
  }

  if (xValue === undefined && yValue !== undefined) {
    return 1;
  }

  if (xValue !== undefined && yValue === undefined) {
    return -1;
  }

  if (xValue < yValue) {
    return -1;
  }

  if (xValue > yValue) {
    return 1;
  }

  return 0;
};

var SortIterator = Iterator.inherit({
  ctor: function ctor(iter, getter, desc, compare) {
    if (!(iter instanceof MapIterator)) {
      iter = new MapIterator(iter, this._wrap);
    }

    this.iter = iter;
    this.rules = [{
      getter: getter,
      desc: desc,
      compare: compare
    }];
  },
  thenBy: function thenBy(getter, desc, compare) {
    var result = new SortIterator(this.sortedIter || this.iter, getter, desc, compare);

    if (!this.sortedIter) {
      result.rules = this.rules.concat(result.rules);
    }

    return result;
  },
  next: function next() {
    this._ensureSorted();

    return this.sortedIter.next();
  },
  current: function current() {
    this._ensureSorted();

    return this.sortedIter.current();
  },
  reset: function reset() {
    delete this.sortedIter;
  },
  countable: function countable() {
    return this.sortedIter || this.iter.countable();
  },
  count: function count() {
    if (this.sortedIter) {
      return this.sortedIter.count();
    }

    return this.iter.count();
  },
  _ensureSorted: function _ensureSorted() {
    var that = this;

    if (that.sortedIter) {
      return;
    }

    (0, _iterator.each)(that.rules, function () {
      this.getter = (0, _data.compileGetter)(this.getter);
    });
    that.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort(function (x, y) {
      return that._compare(x, y);
    })), that._unwrap);
  },
  _wrap: function _wrap(record, index) {
    return {
      index: index,
      value: record
    };
  },
  _unwrap: function _unwrap(wrappedItem) {
    return wrappedItem.value;
  },
  _compare: function _compare(x, y) {
    var xIndex = x.index;
    var yIndex = y.index;
    x = x.value;
    y = y.value;

    if (x === y) {
      return xIndex - yIndex;
    }

    for (var i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {
      var rule = this.rules[i];
      var xValue = rule.getter(x);
      var yValue = rule.getter(y);
      var compare = rule.compare || defaultCompare;
      var compareResult = compare(xValue, yValue);

      if (compareResult) {
        return rule.desc ? -compareResult : compareResult;
      }
    }

    return xIndex - yIndex;
  }
});

var compileCriteria = function () {
  var compileGroup = function compileGroup(crit) {
    var ops = [];
    var isConjunctiveOperator = false;
    var isConjunctiveNextOperator = false;
    (0, _iterator.each)(crit, function () {
      if (Array.isArray(this) || (0, _type.isFunction)(this)) {
        if (ops.length > 1 && isConjunctiveOperator !== isConjunctiveNextOperator) {
          throw new _errors.errors.Error('E4019');
        }

        ops.push(compileCriteria(this));
        isConjunctiveOperator = isConjunctiveNextOperator;
        isConjunctiveNextOperator = true;
      } else {
        isConjunctiveNextOperator = _utils.default.isConjunctiveOperator(this);
      }
    });
    return function (d) {
      var result = isConjunctiveOperator;

      for (var i = 0; i < ops.length; i++) {
        if (ops[i](d) !== isConjunctiveOperator) {
          result = !isConjunctiveOperator;
          break;
        }
      }

      return result;
    };
  };

  var toString = function toString(value) {
    return (0, _type.isDefined)(value) ? value.toString() : '';
  };

  var compileBinary = function compileBinary(crit) {
    crit = _utils.default.normalizeBinaryCriterion(crit);
    var getter = (0, _data.compileGetter)(crit[0]);
    var op = crit[1];
    var value = crit[2];
    value = (0, _data.toComparable)(value);

    switch (op.toLowerCase()) {
      case '=':
        return compileEquals(getter, value);

      case '<>':
        return compileEquals(getter, value, true);

      case '>':
        return function (obj) {
          return (0, _data.toComparable)(getter(obj)) > value;
        };

      case '<':
        return function (obj) {
          return (0, _data.toComparable)(getter(obj)) < value;
        };

      case '>=':
        return function (obj) {
          return (0, _data.toComparable)(getter(obj)) >= value;
        };

      case '<=':
        return function (obj) {
          return (0, _data.toComparable)(getter(obj)) <= value;
        };

      case 'startswith':
        return function (obj) {
          return (0, _data.toComparable)(toString(getter(obj))).indexOf(value) === 0;
        };

      case 'endswith':
        return function (obj) {
          var getterValue = (0, _data.toComparable)(toString(getter(obj)));
          var searchValue = toString(value);

          if (getterValue.length < searchValue.length) {
            return false;
          }

          var index = getterValue.lastIndexOf(value);
          return index !== -1 && index === getterValue.length - value.length;
        };

      case 'contains':
        return function (obj) {
          return (0, _data.toComparable)(toString(getter(obj))).indexOf(value) > -1;
        };

      case 'notcontains':
        return function (obj) {
          return (0, _data.toComparable)(toString(getter(obj))).indexOf(value) === -1;
        };
    }

    throw _errors.errors.Error('E4003', op);
  };

  function compileEquals(getter, value, negate) {
    return function (obj) {
      obj = (0, _data.toComparable)(getter(obj)); // eslint-disable-next-line eqeqeq

      var result = useStrictComparison(value) ? obj === value : obj == value;

      if (negate) {
        result = !result;
      }

      return result;
    };
  }

  function useStrictComparison(value) {
    return value === '' || value === 0 || value === false;
  }

  function compileUnary(crit) {
    var op = crit[0];
    var criteria = compileCriteria(crit[1]);

    if (op === '!') {
      return function (obj) {
        return !criteria(obj);
      };
    }

    throw _errors.errors.Error('E4003', op);
  }

  return function (crit) {
    if ((0, _type.isFunction)(crit)) {
      return crit;
    }

    if (_utils.default.isGroupCriterion(crit)) {
      return compileGroup(crit);
    }

    if (_utils.default.isUnaryOperation(crit)) {
      return compileUnary(crit);
    }

    return compileBinary(crit);
  };
}();

var FilterIterator = WrappedIterator.inherit({
  ctor: function ctor(iter, criteria) {
    this.callBase(iter);
    this.criteria = compileCriteria(criteria);
  },
  next: function next() {
    while (this.iter.next()) {
      if (this.criteria(this.current())) {
        return true;
      }
    }

    return false;
  }
});
var GroupIterator = Iterator.inherit({
  ctor: function ctor(iter, getter) {
    this.iter = iter;
    this.getter = getter;
  },
  next: function next() {
    this._ensureGrouped();

    return this.groupedIter.next();
  },
  current: function current() {
    this._ensureGrouped();

    return this.groupedIter.current();
  },
  reset: function reset() {
    delete this.groupedIter;
  },
  countable: function countable() {
    return !!this.groupedIter;
  },
  count: function count() {
    return this.groupedIter.count();
  },
  _ensureGrouped: function _ensureGrouped() {
    if (this.groupedIter) {
      return;
    }

    var hash = {};
    var keys = [];
    var iter = this.iter;
    var getter = (0, _data.compileGetter)(this.getter);
    iter.reset();

    while (iter.next()) {
      var current = iter.current();
      var key = getter(current);

      if (key in hash) {
        hash[key].push(current);
      } else {
        hash[key] = [current];
        keys.push(key);
      }
    }

    this.groupedIter = new ArrayIterator((0, _iterator.map)(keys, function (key) {
      return {
        key: key,
        items: hash[key]
      };
    }));
  }
});
var SelectIterator = WrappedIterator.inherit({
  ctor: function ctor(iter, getter) {
    this.callBase(iter);
    this.getter = (0, _data.compileGetter)(getter);
  },
  current: function current() {
    return this.getter(this.callBase());
  },
  countable: function countable() {
    return this.iter.countable();
  },
  count: function count() {
    return this.iter.count();
  }
});
var SliceIterator = WrappedIterator.inherit({
  ctor: function ctor(iter, skip, take) {
    this.callBase(iter);
    this.skip = Math.max(0, skip);
    this.take = Math.max(0, take);
    this.pos = 0;
  },
  next: function next() {
    if (this.pos >= this.skip + this.take) {
      return false;
    }

    while (this.pos < this.skip && this.iter.next()) {
      this.pos++;
    }

    this.pos++;
    return this.iter.next();
  },
  reset: function reset() {
    this.callBase();
    this.pos = 0;
  },
  countable: function countable() {
    return this.iter.countable();
  },
  count: function count() {
    return Math.min(this.iter.count() - this.skip, this.take);
  }
});

var arrayQueryImpl = function arrayQueryImpl(iter, queryOptions) {
  queryOptions = queryOptions || {};

  if (!(iter instanceof Iterator)) {
    iter = new ArrayIterator(iter);
  }

  var handleError = function handleError(error) {
    var handler = queryOptions.errorHandler;

    if (handler) {
      handler(error);
    }

    (0, _errors.handleError)(error);
  };

  var aggregateCore = function aggregateCore(aggregator) {
    var d = new _deferred.Deferred().fail(handleError);
    var seed;
    var step = aggregator.step;
    var finalize = aggregator.finalize;

    try {
      iter.reset();

      if ('seed' in aggregator) {
        seed = aggregator.seed;
      } else {
        seed = iter.next() ? iter.current() : NaN;
      }

      var accumulator = seed;

      while (iter.next()) {
        accumulator = step(accumulator, iter.current());
      }

      d.resolve(finalize ? finalize(accumulator) : accumulator);
    } catch (x) {
      d.reject(x);
    }

    return d.promise();
  };

  var aggregate = function aggregate(seed, step, finalize) {
    if (arguments.length < 2) {
      return aggregateCore({
        step: arguments[0]
      });
    }

    return aggregateCore({
      seed: seed,
      step: step,
      finalize: finalize
    });
  };

  var standardAggregate = function standardAggregate(name) {
    return aggregateCore(_utils.default.aggregators[name]);
  };

  var select = function select(getter) {
    if (!(0, _type.isFunction)(getter) && !Array.isArray(getter)) {
      getter = [].slice.call(arguments);
    }

    return chainQuery(new SelectIterator(iter, getter));
  };

  var selectProp = function selectProp(name) {
    return select((0, _data.compileGetter)(name));
  };

  function chainQuery(iter) {
    return arrayQueryImpl(iter, queryOptions);
  }

  return {
    toArray: function toArray() {
      return iter.toArray();
    },
    enumerate: function enumerate() {
      var d = new _deferred.Deferred().fail(handleError);

      try {
        d.resolve(iter.toArray());
      } catch (x) {
        d.reject(x);
      }

      return d.promise();
    },
    sortBy: function sortBy(getter, desc, compare) {
      return chainQuery(new SortIterator(iter, getter, desc, compare));
    },
    thenBy: function thenBy(getter, desc, compare) {
      if (iter instanceof SortIterator) {
        return chainQuery(iter.thenBy(getter, desc, compare));
      }

      throw _errors.errors.Error('E4004');
    },
    filter: function filter(criteria) {
      if (!Array.isArray(criteria)) {
        criteria = [].slice.call(arguments);
      }

      return chainQuery(new FilterIterator(iter, criteria));
    },
    slice: function slice(skip, take) {
      if (take === undefined) {
        take = Number.MAX_VALUE;
      }

      return chainQuery(new SliceIterator(iter, skip, take));
    },
    select: select,
    groupBy: function groupBy(getter) {
      return chainQuery(new GroupIterator(iter, getter));
    },
    aggregate: aggregate,
    count: function count() {
      if (iter.countable()) {
        var d = new _deferred.Deferred().fail(handleError);

        try {
          d.resolve(iter.count());
        } catch (x) {
          d.reject(x);
        }

        return d.promise();
      }

      return standardAggregate('count');
    },
    sum: function sum(getter) {
      if (getter) {
        return selectProp(getter).sum();
      }

      return standardAggregate('sum');
    },
    min: function min(getter) {
      if (getter) {
        return selectProp(getter).min();
      }

      return standardAggregate('min');
    },
    max: function max(getter) {
      if (getter) {
        return selectProp(getter).max();
      }

      return standardAggregate('max');
    },
    avg: function avg(getter) {
      if (getter) {
        return selectProp(getter).avg();
      }

      return standardAggregate('avg');
    }
  };
};

var _default = arrayQueryImpl;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.name = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _support = __webpack_require__(48);

var _devices = _interopRequireDefault(__webpack_require__(13));

var _class = _interopRequireDefault(__webpack_require__(15));

var _event_registrator = _interopRequireDefault(__webpack_require__(68));

var _index = __webpack_require__(8);

var _hold = _interopRequireDefault(__webpack_require__(98));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CONTEXTMENU_NAMESPACE = 'dxContexMenu';
var CONTEXTMENU_NAMESPACED_EVENT_NAME = (0, _index.addNamespace)('contextmenu', CONTEXTMENU_NAMESPACE);
var HOLD_NAMESPACED_EVENT_NAME = (0, _index.addNamespace)(_hold.default.name, CONTEXTMENU_NAMESPACE);
var CONTEXTMENU_EVENT_NAME = 'dxcontextmenu';

var ContextMenu = _class.default.inherit({
  setup: function setup(element) {
    var $element = (0, _renderer.default)(element);

    _events_engine.default.on($element, CONTEXTMENU_NAMESPACED_EVENT_NAME, this._contextMenuHandler.bind(this));

    if (_support.touch || _devices.default.isSimulator()) {
      _events_engine.default.on($element, HOLD_NAMESPACED_EVENT_NAME, this._holdHandler.bind(this));
    }
  },
  _holdHandler: function _holdHandler(e) {
    if ((0, _index.isMouseEvent)(e) && !_devices.default.isSimulator()) {
      return;
    }

    this._fireContextMenu(e);
  },
  _contextMenuHandler: function _contextMenuHandler(e) {
    this._fireContextMenu(e);
  },
  _fireContextMenu: function _fireContextMenu(e) {
    return (0, _index.fireEvent)({
      type: CONTEXTMENU_EVENT_NAME,
      originalEvent: e
    });
  },
  teardown: function teardown(element) {
    _events_engine.default.off(element, '.' + CONTEXTMENU_NAMESPACE);
  }
});
/**
  * @name UI Events.dxcontextmenu
  * @type eventType
  * @type_function_param1 event:event
  * @module events/contextmenu
*/


(0, _event_registrator.default)(CONTEXTMENU_EVENT_NAME, new ContextMenu());
var name = CONTEXTMENU_EVENT_NAME;
exports.name = name;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.odata = void 0;

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

var _config = _interopRequireDefault(__webpack_require__(29));

var _extend = __webpack_require__(0);

var _query_adapters = _interopRequireDefault(__webpack_require__(196));

var _utils = __webpack_require__(99);

var _errors = __webpack_require__(37);

var _utils2 = _interopRequireDefault(__webpack_require__(44));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_PROTOCOL_VERSION = 2;
var STRING_FUNCTIONS = ['contains', 'notcontains', 'startswith', 'endswith'];

var compileCriteria = function () {
  var protocolVersion;
  var forceLowerCase;
  var fieldTypes;

  var createBinaryOperationFormatter = function createBinaryOperationFormatter(op) {
    return function (prop, val) {
      return "".concat(prop, " ").concat(op, " ").concat(val);
    };
  };

  var createStringFuncFormatter = function createStringFuncFormatter(op, reverse) {
    return function (prop, val) {
      var bag = [op, '('];

      if (forceLowerCase) {
        prop = prop.indexOf('tolower(') === -1 ? "tolower(".concat(prop, ")") : prop;
        val = val.toLowerCase();
      }

      if (reverse) {
        bag.push(val, ',', prop);
      } else {
        bag.push(prop, ',', val);
      }

      bag.push(')');
      return bag.join('');
    };
  };

  var isStringFunction = function isStringFunction(name) {
    return STRING_FUNCTIONS.some(function (funcName) {
      return funcName === name;
    });
  };

  var formatters = {
    '=': createBinaryOperationFormatter('eq'),
    '<>': createBinaryOperationFormatter('ne'),
    '>': createBinaryOperationFormatter('gt'),
    '>=': createBinaryOperationFormatter('ge'),
    '<': createBinaryOperationFormatter('lt'),
    '<=': createBinaryOperationFormatter('le'),
    'startswith': createStringFuncFormatter('startswith'),
    'endswith': createStringFuncFormatter('endswith')
  };
  var formattersV2 = (0, _extend.extend)({}, formatters, {
    'contains': createStringFuncFormatter('substringof', true),
    'notcontains': createStringFuncFormatter('not substringof', true)
  });
  var formattersV4 = (0, _extend.extend)({}, formatters, {
    'contains': createStringFuncFormatter('contains'),
    'notcontains': createStringFuncFormatter('not contains')
  });

  var compileBinary = function compileBinary(criteria) {
    var _fieldTypes;

    criteria = _utils2.default.normalizeBinaryCriterion(criteria);
    var op = criteria[1];
    var fieldName = criteria[0];
    var fieldType = fieldTypes && fieldTypes[fieldName];

    if (fieldType && isStringFunction(op) && fieldType !== 'String') {
      throw new _errors.errors.Error('E4024', op, fieldName, fieldType);
    }

    var formatters = protocolVersion === 4 ? formattersV4 : formattersV2;
    var formatter = formatters[op.toLowerCase()];

    if (!formatter) {
      throw _errors.errors.Error('E4003', op);
    }

    var value = criteria[2];

    if ((_fieldTypes = fieldTypes) !== null && _fieldTypes !== void 0 && _fieldTypes[fieldName]) {
      value = (0, _utils.convertPrimitiveValue)(fieldTypes[fieldName], value);
    }

    return formatter((0, _utils.serializePropName)(fieldName), (0, _utils.serializeValue)(value, protocolVersion));
  };

  var compileUnary = function compileUnary(criteria) {
    var op = criteria[0];
    var crit = compileCore(criteria[1]);

    if (op === '!') {
      return "not (".concat(crit, ")");
    }

    throw _errors.errors.Error('E4003', op);
  };

  var compileGroup = function compileGroup(criteria) {
    var bag = [];
    var groupOperator;
    var nextGroupOperator;
    (0, _iterator.each)(criteria, function (index, criterion) {
      if (Array.isArray(criterion)) {
        if (bag.length > 1 && groupOperator !== nextGroupOperator) {
          throw new _errors.errors.Error('E4019');
        }

        bag.push("(".concat(compileCore(criterion), ")"));
        groupOperator = nextGroupOperator;
        nextGroupOperator = 'and';
      } else {
        nextGroupOperator = _utils2.default.isConjunctiveOperator(this) ? 'and' : 'or';
      }
    });
    return bag.join(" ".concat(groupOperator, " "));
  };

  var compileCore = function compileCore(criteria) {
    if (Array.isArray(criteria[0])) {
      return compileGroup(criteria);
    }

    if (_utils2.default.isUnaryOperation(criteria)) {
      return compileUnary(criteria);
    }

    return compileBinary(criteria);
  };

  return function (criteria, version, types, filterToLower) {
    fieldTypes = types;
    forceLowerCase = filterToLower !== null && filterToLower !== void 0 ? filterToLower : (0, _config.default)().oDataFilterToLower;
    protocolVersion = version;
    return compileCore(criteria);
  };
}();

var createODataQueryAdapter = function createODataQueryAdapter(queryOptions) {
  var _sorting = [];
  var _criteria = [];
  var _expand = queryOptions.expand;

  var _select;

  var _skip;

  var _take;

  var _countQuery;

  var _oDataVersion = queryOptions.version || DEFAULT_PROTOCOL_VERSION;

  var hasSlice = function hasSlice() {
    return _skip || _take !== undefined;
  };

  var hasFunction = function hasFunction(criterion) {
    for (var i = 0; i < criterion.length; i++) {
      if ((0, _type.isFunction)(criterion[i])) {
        return true;
      }

      if (Array.isArray(criterion[i]) && hasFunction(criterion[i])) {
        return true;
      }
    }

    return false;
  };

  var requestData = function requestData() {
    var result = {};

    if (!_countQuery) {
      if (_sorting.length) {
        result['$orderby'] = _sorting.join(',');
      }

      if (_skip) {
        result['$skip'] = _skip;
      }

      if (_take !== undefined) {
        result['$top'] = _take;
      }

      result['$select'] = (0, _utils.generateSelect)(_oDataVersion, _select) || undefined;
      result['$expand'] = (0, _utils.generateExpand)(_oDataVersion, _expand, _select) || undefined;
    }

    if (_criteria.length) {
      var criteria = _criteria.length < 2 ? _criteria[0] : _criteria;
      var fieldTypes = queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.fieldTypes;
      var filterToLower = queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.filterToLower;
      result['$filter'] = compileCriteria(criteria, _oDataVersion, fieldTypes, filterToLower);
    }

    if (_countQuery) {
      result['$top'] = 0;
    }

    if (queryOptions.requireTotalCount || _countQuery) {
      // todo: tests!!!
      if (_oDataVersion !== 4) {
        result['$inlinecount'] = 'allpages';
      } else {
        result['$count'] = 'true';
      }
    }

    return result;
  };

  var tryLiftSelect = function tryLiftSelect(tasks) {
    var selectIndex = -1;

    for (var i = 0; i < tasks.length; i++) {
      if (tasks[i].name === 'select') {
        selectIndex = i;
        break;
      }
    }

    if (selectIndex < 0 || !(0, _type.isFunction)(tasks[selectIndex].args[0])) return;
    var nextTask = tasks[1 + selectIndex];
    if (!nextTask || nextTask.name !== 'slice') return;
    tasks[1 + selectIndex] = tasks[selectIndex];
    tasks[selectIndex] = nextTask;
  };

  return {
    optimize: tryLiftSelect,
    exec: function exec(url) {
      return (0, _utils.sendRequest)(_oDataVersion, {
        url: url,
        params: (0, _extend.extend)(requestData(), queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.params)
      }, {
        beforeSend: queryOptions.beforeSend,
        jsonp: queryOptions.jsonp,
        withCredentials: queryOptions.withCredentials,
        countOnly: _countQuery,
        deserializeDates: queryOptions.deserializeDates,
        fieldTypes: queryOptions.fieldTypes,
        isPaged: isFinite(_take)
      });
    },
    multiSort: function multiSort(args) {
      var rules;

      if (hasSlice()) {
        return false;
      }

      for (var i = 0; i < args.length; i++) {
        var getter = args[i][0];
        var desc = !!args[i][1];
        var rule = void 0;

        if (typeof getter !== 'string') {
          return false;
        }

        rule = (0, _utils.serializePropName)(getter);

        if (desc) {
          rule += ' desc';
        }

        rules = rules || [];
        rules.push(rule);
      }

      _sorting = rules;
    },
    slice: function slice(skipCount, takeCount) {
      if (hasSlice()) {
        return false;
      }

      _skip = skipCount;
      _take = takeCount;
    },
    filter: function filter(criterion) {
      if (hasSlice()) {
        return false;
      }

      if (!Array.isArray(criterion)) {
        criterion = [].slice.call(arguments);
      }

      if (hasFunction(criterion)) {
        return false;
      }

      if (_criteria.length) {
        _criteria.push('and');
      }

      _criteria.push(criterion);
    },
    select: function select(expr) {
      if (_select || (0, _type.isFunction)(expr)) {
        return false;
      }

      if (!Array.isArray(expr)) {
        expr = [].slice.call(arguments);
      }

      _select = expr;
    },
    count: function count() {
      return _countQuery = true;
    }
  };
};

_query_adapters.default.odata = createODataQueryAdapter;
var odata = createODataQueryAdapter;
exports.odata = odata;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.version = void 0;
var version = '21.2.0';
exports.version = version;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getFormat = void 0;

var _number = _interopRequireDefault(__webpack_require__(46));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ARABIC_COMMA = "\u060C";
var FORMAT_SEPARATORS = ' .,:;/\\<>()-[]' + ARABIC_COMMA;
var AM_PM_PATTERN = '. m.';

var checkDigit = function checkDigit(char) {
  var code = char && _number.default.convertDigits(char, false).charCodeAt(0);

  var zeroCode = _number.default.convertDigits('0', false).charCodeAt(0);

  return zeroCode <= code && code < zeroCode + 10;
};

var checkPatternContinue = function checkPatternContinue(text, patterns, index, isDigit) {
  var char = text[index];
  var nextChar = text[index + 1];

  if (!isDigit) {
    if (char === '.' || char === ' ' && text.slice(index - 1, index + 3) === AM_PM_PATTERN) {
      return true;
    }

    if (char === '-' && !checkDigit(nextChar)) {
      return true;
    }
  }

  var isDigitChanged = isDigit && patterns.some(function (pattern) {
    return text[index] !== pattern[index];
  });
  return FORMAT_SEPARATORS.indexOf(char) < 0 && isDigit === checkDigit(char) && (!isDigit || isDigitChanged);
};

var getPatternStartIndex = function getPatternStartIndex(defaultPattern, index) {
  if (!checkDigit(defaultPattern[index])) {
    while (index > 0 && !checkDigit(defaultPattern[index - 1]) && (defaultPattern[index - 1] === '.' || FORMAT_SEPARATORS.indexOf(defaultPattern[index - 1]) < 0)) {
      index--;
    }
  }

  return index;
};

var getDifference = function getDifference(defaultPattern, patterns, processedIndexes, isDigit) {
  var i = 0;
  var result = [];

  var patternsFilter = function patternsFilter(pattern) {
    return defaultPattern[i] !== pattern[i] && (isDigit === undefined || checkDigit(defaultPattern[i]) === isDigit);
  };

  if (!Array.isArray(patterns)) {
    patterns = [patterns];
  }

  for (i = 0; i < defaultPattern.length; i++) {
    if (processedIndexes.indexOf(i) < 0 && patterns.filter(patternsFilter).length) {
      i = getPatternStartIndex(defaultPattern, i);

      do {
        isDigit = checkDigit(defaultPattern[i]);

        if (!result.length && !isDigit && checkDigit(patterns[0][i])) {
          break;
        }

        result.push(i);
        processedIndexes.unshift(i);
        i++;
      } while (defaultPattern[i] && checkPatternContinue(defaultPattern, patterns, i, isDigit));

      break;
    }
  }

  if (result.length === 1 && (defaultPattern[processedIndexes[0] - 1] === '0' || defaultPattern[processedIndexes[0] - 1] === '')) {
    processedIndexes.unshift(processedIndexes[0] - 1);
  }

  return result;
};

var replaceCharsCore = function replaceCharsCore(pattern, indexes, char, patternPositions) {
  var baseCharIndex = indexes[0];
  var patternIndex = baseCharIndex < patternPositions.length ? patternPositions[baseCharIndex] : baseCharIndex;
  indexes.forEach(function (_, index) {
    pattern = pattern.substr(0, patternIndex + index) + (char.length > 1 ? char[index] : char) + pattern.substr(patternIndex + index + 1);
  });

  if (indexes.length === 1) {
    pattern = pattern.replace('0' + char, char + char);
    pattern = pattern.replace('' + char, char + char);
  }

  return pattern;
};

var replaceChars = function replaceChars(pattern, indexes, char, patternPositions) {
  var i;
  var index;
  var patternIndex;

  if (!checkDigit(pattern[indexes[0]] || '0')) {
    var letterCount = Math.max(indexes.length <= 3 ? 3 : 4, char.length);

    while (indexes.length > letterCount) {
      index = indexes.pop();
      patternIndex = patternPositions[index];
      patternPositions[index] = -1;

      for (i = index + 1; i < patternPositions.length; i++) {
        patternPositions[i]--;
      }

      pattern = pattern.substr(0, patternIndex) + pattern.substr(patternIndex + 1);
    }

    index = indexes[indexes.length - 1] + 1, patternIndex = index < patternPositions.length ? patternPositions[index] : index;

    while (indexes.length < letterCount) {
      indexes.push(indexes[indexes.length - 1] + 1);

      for (i = index; i < patternPositions.length; i++) {
        patternPositions[i]++;
      }

      pattern = pattern.substr(0, patternIndex) + ' ' + pattern.substr(patternIndex);
    }
  }

  pattern = replaceCharsCore(pattern, indexes, char, patternPositions);
  return pattern;
};

var formatValue = function formatValue(value, formatter) {
  if (Array.isArray(value)) {
    return value.map(function (value) {
      return (formatter(value) || '').toString();
    });
  }

  return (formatter(value) || '').toString();
};

var ESCAPE_CHARS_REGEXP = /[a-zA-Z]/g;

var escapeChars = function escapeChars(pattern, defaultPattern, processedIndexes, patternPositions) {
  var escapeIndexes = defaultPattern.split('').map(function (char, index) {
    if (processedIndexes.indexOf(index) < 0 && (char.match(ESCAPE_CHARS_REGEXP) || char === '\'')) {
      return patternPositions[index];
    }

    return -1;
  });
  pattern = pattern.split('').map(function (char, index) {
    var result = char;
    var isCurrentCharEscaped = escapeIndexes.indexOf(index) >= 0;
    var isPrevCharEscaped = index > 0 && escapeIndexes.indexOf(index - 1) >= 0;
    var isNextCharEscaped = escapeIndexes.indexOf(index + 1) >= 0;

    if (isCurrentCharEscaped) {
      if (!isPrevCharEscaped) {
        result = '\'' + result;
      }

      if (!isNextCharEscaped) {
        result = result + '\'';
      }
    }

    return result;
  }).join('');
  return pattern;
};

var getFormat = function getFormat(formatter) {
  var processedIndexes = [];
  var defaultPattern = formatValue(new Date(2009, 8, 8, 6, 5, 4), formatter);
  var patternPositions = defaultPattern.split('').map(function (_, index) {
    return index;
  });
  var result = defaultPattern;
  var replacedPatterns = {};
  var datePatterns = [{
    date: new Date(2009, 8, 8, 6, 5, 4, 111),
    pattern: 'S'
  }, {
    date: new Date(2009, 8, 8, 6, 5, 2),
    pattern: 's'
  }, {
    date: new Date(2009, 8, 8, 6, 2, 4),
    pattern: 'm'
  }, {
    date: new Date(2009, 8, 8, 18, 5, 4),
    pattern: 'H',
    isDigit: true
  }, {
    date: new Date(2009, 8, 8, 2, 5, 4),
    pattern: 'h',
    isDigit: true
  }, {
    date: new Date(2009, 8, 8, 18, 5, 4),
    pattern: 'a',
    isDigit: false
  }, {
    date: new Date(2009, 8, 1, 6, 5, 4),
    pattern: 'd'
  }, {
    date: [new Date(2009, 8, 2, 6, 5, 4), new Date(2009, 8, 3, 6, 5, 4), new Date(2009, 8, 4, 6, 5, 4)],
    pattern: 'E'
  }, {
    date: new Date(2009, 9, 6, 6, 5, 4),
    pattern: 'M'
  }, {
    date: new Date(1998, 8, 8, 6, 5, 4),
    pattern: 'y'
  }];
  if (!result) return;
  datePatterns.forEach(function (test) {
    var diff = getDifference(defaultPattern, formatValue(test.date, formatter), processedIndexes, test.isDigit);
    var pattern = test.pattern === 'M' && !replacedPatterns['d'] ? 'L' : test.pattern;
    result = replaceChars(result, diff, pattern, patternPositions);
    replacedPatterns[pattern] = diff.length;
  });
  result = escapeChars(result, defaultPattern, processedIndexes, patternPositions);

  if (processedIndexes.length) {
    return result;
  }
};

exports.getFormat = getFormat;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.registerTemplateEngine = registerTemplateEngine;
exports.setTemplateEngine = setTemplateEngine;
exports.getCurrentTemplateEngine = getCurrentTemplateEngine;

var _type = __webpack_require__(1);

var _errors = _interopRequireDefault(__webpack_require__(24));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var templateEngines = {};
var currentTemplateEngine;

function registerTemplateEngine(name, templateEngine) {
  templateEngines[name] = templateEngine;
}

function setTemplateEngine(templateEngine) {
  if ((0, _type.isString)(templateEngine)) {
    currentTemplateEngine = templateEngines[templateEngine];

    if (!currentTemplateEngine) {
      throw _errors.default.Error('E0020', templateEngine);
    }
  } else {
    currentTemplateEngine = templateEngine;
  }
}

function getCurrentTemplateEngine() {
  return currentTemplateEngine;
}

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _devices = _interopRequireDefault(__webpack_require__(13));

var _style = __webpack_require__(92);

var _call_once = _interopRequireDefault(__webpack_require__(79));

var _dom = __webpack_require__(35);

var _ready_callbacks = _interopRequireDefault(__webpack_require__(51));

var _math = __webpack_require__(31);

var _common = __webpack_require__(4);

var _type = __webpack_require__(1);

var _index = __webpack_require__(8);

var _emitter = _interopRequireDefault(__webpack_require__(127));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ready = _ready_callbacks.default.add;
var abs = Math.abs;
var SLEEP = 0;
var INITED = 1;
var STARTED = 2;
var TOUCH_BOUNDARY = 10;
var IMMEDIATE_TOUCH_BOUNDARY = 0;
var IMMEDIATE_TIMEOUT = 180;

var supportPointerEvents = function supportPointerEvents() {
  return (0, _style.styleProp)('pointer-events');
};

var setGestureCover = (0, _call_once.default)(function () {
  var GESTURE_COVER_CLASS = 'dx-gesture-cover';
  var isDesktop = _devices.default.real().deviceType === 'desktop';

  if (!supportPointerEvents() || !isDesktop) {
    return _common.noop;
  }

  var $cover = (0, _renderer.default)('<div>').addClass(GESTURE_COVER_CLASS).css('pointerEvents', 'none');

  _events_engine.default.subscribeGlobal($cover, 'dxmousewheel', function (e) {
    e.preventDefault();
  });

  ready(function () {
    $cover.appendTo('body');
  });
  return function (toggle, cursor) {
    $cover.css('pointerEvents', toggle ? 'all' : 'none');
    toggle && $cover.css('cursor', cursor);
  };
});

var gestureCover = function gestureCover(toggle, cursor) {
  var gestureCoverStrategy = setGestureCover();
  gestureCoverStrategy(toggle, cursor);
};

var GestureEmitter = _emitter.default.inherit({
  gesture: true,
  configure: function configure(data) {
    this.getElement().css('msTouchAction', data.immediate ? 'pinch-zoom' : '');
    this.callBase(data);
  },
  allowInterruptionByMouseWheel: function allowInterruptionByMouseWheel() {
    return this._stage !== STARTED;
  },
  getDirection: function getDirection() {
    return this.direction;
  },
  _cancel: function _cancel() {
    this.callBase.apply(this, arguments);

    this._toggleGestureCover(false);

    this._stage = SLEEP;
  },
  start: function start(e) {
    if (e._needSkipEvent || (0, _index.needSkipEvent)(e)) {
      this._cancel(e);

      return;
    }

    this._startEvent = (0, _index.createEvent)(e);
    this._startEventData = (0, _index.eventData)(e);
    this._stage = INITED;

    this._init(e);

    this._setupImmediateTimer();
  },
  _setupImmediateTimer: function _setupImmediateTimer() {
    clearTimeout(this._immediateTimer);
    this._immediateAccepted = false;

    if (!this.immediate) {
      return;
    }

    this._immediateTimer = setTimeout(function () {
      this._immediateAccepted = true;
    }.bind(this), IMMEDIATE_TIMEOUT);
  },
  move: function move(e) {
    if (this._stage === INITED && this._directionConfirmed(e)) {
      this._stage = STARTED;

      this._resetActiveElement();

      this._toggleGestureCover(true);

      this._clearSelection(e);

      this._adjustStartEvent(e);

      this._start(this._startEvent);

      if (this._stage === SLEEP) {
        return;
      }

      this._requestAccept(e);

      this._move(e);

      this._forgetAccept();
    } else if (this._stage === STARTED) {
      this._clearSelection(e);

      this._move(e);
    }
  },
  _directionConfirmed: function _directionConfirmed(e) {
    var touchBoundary = this._getTouchBoundary(e);

    var delta = (0, _index.eventDelta)(this._startEventData, (0, _index.eventData)(e));
    var deltaX = abs(delta.x);
    var deltaY = abs(delta.y);

    var horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY);

    var verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);

    var direction = this.getDirection(e);
    var bothAccepted = direction === 'both' && (horizontalMove || verticalMove);
    var horizontalAccepted = direction === 'horizontal' && horizontalMove;
    var verticalAccepted = direction === 'vertical' && verticalMove;
    return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted;
  },
  _validateMove: function _validateMove(touchBoundary, mainAxis, crossAxis) {
    return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true);
  },
  _getTouchBoundary: function _getTouchBoundary(e) {
    return this.immediate || (0, _index.isDxMouseWheelEvent)(e) ? IMMEDIATE_TOUCH_BOUNDARY : TOUCH_BOUNDARY;
  },
  _adjustStartEvent: function _adjustStartEvent(e) {
    var touchBoundary = this._getTouchBoundary(e);

    var delta = (0, _index.eventDelta)(this._startEventData, (0, _index.eventData)(e));
    this._startEvent.pageX += (0, _math.sign)(delta.x) * touchBoundary;
    this._startEvent.pageY += (0, _math.sign)(delta.y) * touchBoundary;
  },
  _resetActiveElement: function _resetActiveElement() {
    if (_devices.default.real().platform === 'ios' && this.getElement().find(':focus').length) {
      (0, _dom.resetActiveElement)();
    }
  },
  _toggleGestureCover: function _toggleGestureCover(toggle) {
    this._toggleGestureCoverImpl(toggle);
  },
  _toggleGestureCoverImpl: function _toggleGestureCoverImpl(toggle) {
    var isStarted = this._stage === STARTED;

    if (isStarted) {
      gestureCover(toggle, this.getElement().css('cursor'));
    }
  },
  _clearSelection: function _clearSelection(e) {
    if ((0, _index.isDxMouseWheelEvent)(e) || (0, _index.isTouchEvent)(e)) {
      return;
    }

    (0, _dom.clearSelection)();
  },
  end: function end(e) {
    this._toggleGestureCover(false);

    if (this._stage === STARTED) {
      this._end(e);
    } else if (this._stage === INITED) {
      this._stop(e);
    }

    this._stage = SLEEP;
  },
  dispose: function dispose() {
    clearTimeout(this._immediateTimer);
    this.callBase.apply(this, arguments);

    this._toggleGestureCover(false);
  },
  _init: _common.noop,
  _start: _common.noop,
  _move: _common.noop,
  _stop: _common.noop,
  _end: _common.noop
});

GestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY;

GestureEmitter.touchBoundary = function (newBoundary) {
  if ((0, _type.isDefined)(newBoundary)) {
    TOUCH_BOUNDARY = newBoundary;
    return;
  }

  return TOUCH_BOUNDARY;
};

var _default = GestureEmitter;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _view_port = __webpack_require__(77);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SWATCH_CONTAINER_CLASS_PREFIX = 'dx-swatch-';

var getSwatchContainer = function getSwatchContainer(element) {
  var $element = (0, _renderer.default)(element);
  var swatchContainer = $element.closest("[class^=\"".concat(SWATCH_CONTAINER_CLASS_PREFIX, "\"], [class*=\" ").concat(SWATCH_CONTAINER_CLASS_PREFIX, "\"]"));
  var viewport = (0, _view_port.value)();
  if (!swatchContainer.length) return viewport;
  var swatchClassRegex = new RegExp("(\\s|^)(".concat(SWATCH_CONTAINER_CLASS_PREFIX, ".*?)(\\s|$)"));
  var swatchClass = swatchContainer[0].className.match(swatchClassRegex)[2];
  var viewportSwatchContainer = viewport.children('.' + swatchClass);

  if (!viewportSwatchContainer.length) {
    viewportSwatchContainer = (0, _renderer.default)('<div>').addClass(swatchClass).appendTo(viewport);
  }

  return viewportSwatchContainer;
};

var _default = {
  getSwatchContainer: getSwatchContainer
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _window = __webpack_require__(7);

var _position = __webpack_require__(26);

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _string = __webpack_require__(40);

var _component_registrator = _interopRequireDefault(__webpack_require__(9));

var _translator = __webpack_require__(34);

var _animator = _interopRequireDefault(__webpack_require__(285));

var _inflector = __webpack_require__(41);

var _extend = __webpack_require__(0);

var _dom_component = _interopRequireDefault(__webpack_require__(66));

var _element = __webpack_require__(22);

var _index = __webpack_require__(8);

var _pointer = _interopRequireDefault(__webpack_require__(25));

var _drag = __webpack_require__(78);

var _position2 = _interopRequireDefault(__webpack_require__(83));

var _type = __webpack_require__(1);

var _common = __webpack_require__(4);

var _view_port = __webpack_require__(77);

var _empty_template = __webpack_require__(93);

var _deferred = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var window = (0, _window.getWindow)();
var DRAGGABLE = 'dxDraggable';
var DRAGSTART_EVENT_NAME = (0, _index.addNamespace)(_drag.start, DRAGGABLE);
var DRAG_EVENT_NAME = (0, _index.addNamespace)(_drag.move, DRAGGABLE);
var DRAGEND_EVENT_NAME = (0, _index.addNamespace)(_drag.end, DRAGGABLE);
var DRAG_ENTER_EVENT_NAME = (0, _index.addNamespace)(_drag.enter, DRAGGABLE);
var DRAGEND_LEAVE_EVENT_NAME = (0, _index.addNamespace)(_drag.leave, DRAGGABLE);
var POINTERDOWN_EVENT_NAME = (0, _index.addNamespace)(_pointer.default.down, DRAGGABLE);
var CLONE_CLASS = 'clone';
var targetDraggable;
var sourceDraggable;
var ANONYMOUS_TEMPLATE_NAME = 'content';

var getMousePosition = function getMousePosition(event) {
  return {
    x: event.pageX - (0, _renderer.default)(window).scrollLeft(),
    y: event.pageY - (0, _renderer.default)(window).scrollTop()
  };
};

var GESTURE_COVER_CLASS = 'dx-gesture-cover';
var OVERLAY_WRAPPER_CLASS = 'dx-overlay-wrapper';
var OVERLAY_CONTENT_CLASS = 'dx-overlay-content';

var ScrollHelper = /*#__PURE__*/function () {
  function ScrollHelper(orientation, component) {
    this._preventScroll = true;
    this._component = component;

    if (orientation === 'vertical') {
      this._scrollValue = 'scrollTop';
      this._overFlowAttr = 'overflowY';
      this._sizeAttr = 'height';
      this._scrollSizeProp = 'scrollHeight';
      this._clientSizeProp = 'clientHeight';
      this._limitProps = {
        start: 'top',
        end: 'bottom'
      };
    } else {
      this._scrollValue = 'scrollLeft';
      this._overFlowAttr = 'overflowX';
      this._sizeAttr = 'width';
      this._scrollSizeProp = 'scrollWidth';
      this._clientSizeProp = 'clientWidth';
      this._limitProps = {
        start: 'left',
        end: 'right'
      };
    }
  }

  var _proto = ScrollHelper.prototype;

  _proto.updateScrollable = function updateScrollable(elements, mousePosition) {
    var _this = this;

    var needResetScrollable = !elements.some(function (element) {
      var $element = (0, _renderer.default)(element);
      var isTargetOverOverlayWrapper = $element.hasClass(OVERLAY_WRAPPER_CLASS);
      var isTargetOverOverlayContent = $element.hasClass(OVERLAY_CONTENT_CLASS);
      return isTargetOverOverlayWrapper || isTargetOverOverlayContent || _this._trySetScrollable(element, mousePosition);
    });

    if (needResetScrollable) {
      this._$scrollableAtPointer = null;
      this._scrollSpeed = 0;
    }
  };

  _proto.isScrolling = function isScrolling() {
    return !!this._scrollSpeed;
  };

  _proto.isScrollable = function isScrollable($element) {
    var that = this;
    return ($element.css(that._overFlowAttr) === 'auto' || $element.hasClass('dx-scrollable-container')) && $element.prop(that._scrollSizeProp) > $element[that._sizeAttr]();
  };

  _proto._trySetScrollable = function _trySetScrollable(element, mousePosition) {
    var that = this;
    var $element = (0, _renderer.default)(element);
    var distanceToBorders;

    var sensitivity = that._component.option('scrollSensitivity');

    var isScrollable = that.isScrollable($element);

    if (isScrollable) {
      distanceToBorders = that._calculateDistanceToBorders($element, mousePosition);

      if (sensitivity > distanceToBorders[that._limitProps.start]) {
        if (!that._preventScroll) {
          that._scrollSpeed = -that._calculateScrollSpeed(distanceToBorders[that._limitProps.start]);
          that._$scrollableAtPointer = $element;
        }
      } else if (sensitivity > distanceToBorders[that._limitProps.end]) {
        if (!that._preventScroll) {
          that._scrollSpeed = that._calculateScrollSpeed(distanceToBorders[that._limitProps.end]);
          that._$scrollableAtPointer = $element;
        }
      } else {
        isScrollable = false;
        that._preventScroll = false;
      }
    }

    return isScrollable;
  };

  _proto._calculateDistanceToBorders = function _calculateDistanceToBorders($area, mousePosition) {
    var area = $area.get(0);
    var areaBoundingRect;

    if (area) {
      areaBoundingRect = (0, _position.getBoundingRect)(area);
      return {
        left: mousePosition.x - areaBoundingRect.left,
        top: mousePosition.y - areaBoundingRect.top,
        right: areaBoundingRect.right - mousePosition.x,
        bottom: areaBoundingRect.bottom - mousePosition.y
      };
    } else {
      return {};
    }
  };

  _proto._calculateScrollSpeed = function _calculateScrollSpeed(distance) {
    var component = this._component;
    var sensitivity = component.option('scrollSensitivity');
    var maxSpeed = component.option('scrollSpeed');
    return Math.ceil(Math.pow((sensitivity - distance) / sensitivity, 2) * maxSpeed);
  };

  _proto.scrollByStep = function scrollByStep() {
    var that = this;

    if (that._$scrollableAtPointer && that._scrollSpeed) {
      if (that._$scrollableAtPointer.hasClass('dx-scrollable-container')) {
        var $scrollable = that._$scrollableAtPointer.closest('.dx-scrollable');

        var scrollableInstance = $scrollable.data('dxScrollable') || $scrollable.data('dxScrollView');

        if (scrollableInstance) {
          var nextScrollPosition = scrollableInstance.scrollOffset()[that._limitProps.start] + that._scrollSpeed;

          scrollableInstance.scrollTo(_defineProperty({}, that._limitProps.start, nextScrollPosition));
        }
      } else {
        var _nextScrollPosition = that._$scrollableAtPointer[that._scrollValue]() + that._scrollSpeed;

        that._$scrollableAtPointer[that._scrollValue](_nextScrollPosition);
      }

      var dragMoveArgs = that._component._dragMoveArgs;

      if (dragMoveArgs) {
        that._component._dragMoveHandler(dragMoveArgs);
      }
    }
  };

  _proto.reset = function reset() {
    this._$scrollableAtPointer = null;
    this._scrollSpeed = 0;
    this._preventScroll = true;
  };

  _proto.isOutsideScrollable = function isOutsideScrollable($scrollable, event) {
    if (!$scrollable) {
      return false;
    }

    var scrollableSize = (0, _position.getBoundingRect)($scrollable.get(0));
    var start = scrollableSize[this._limitProps.start];
    var size = scrollableSize[this._sizeAttr];
    var mousePosition = getMousePosition(event);
    var location = this._sizeAttr === 'width' ? mousePosition.x : mousePosition.y;
    return location < start || location > start + size;
  };

  return ScrollHelper;
}();

var ScrollAnimator = _animator.default.inherit({
  ctor: function ctor(strategy) {
    this.callBase();
    this._strategy = strategy;
  },
  _step: function _step() {
    var horizontalScrollHelper = this._strategy._horizontalScrollHelper;
    var verticalScrollHelper = this._strategy._verticalScrollHelper;
    horizontalScrollHelper && horizontalScrollHelper.scrollByStep();
    verticalScrollHelper && verticalScrollHelper.scrollByStep();
  }
});

var Draggable = _dom_component.default.inherit({
  reset: _common.noop,
  dragMove: _common.noop,
  dragEnter: _common.noop,
  dragLeave: _common.noop,
  dragEnd: function dragEnd(sourceEvent) {
    var sourceDraggable = this._getSourceDraggable();

    sourceDraggable._fireRemoveEvent(sourceEvent);

    return new _deferred.Deferred().resolve();
  },
  _fireRemoveEvent: _common.noop,
  _getDefaultOptions: function _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      onDragStart: null,
      onDragMove: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragLeave: null,

      /**
       * @name dxDraggableOptions.onDrop
       * @type function(e)
       * @extends Action
       * @type_function_param1 e:object
       * @type_function_param1_field4 event:event
       * @type_function_param1_field5 itemData:any
       * @type_function_param1_field6 itemElement:DxElement
       * @type_function_param1_field7 fromComponent:dxSortable|dxDraggable
       * @type_function_param1_field8 toComponent:dxSortable|dxDraggable
       * @type_function_param1_field9 fromData:any
       * @type_function_param1_field10 toData:any
       * @action
       * @hidden
       */
      onDrop: null,
      immediate: true,
      dragDirection: 'both',
      boundary: undefined,
      boundOffset: 0,
      allowMoveByClick: false,
      itemData: null,
      container: undefined,
      dragTemplate: undefined,

      /**
       * @name DraggableBaseOptions.contentTemplate
       * @type template|function
       * @type_function_return string|Element|jQuery
       * @hidden
       * @default "content"
       */
      contentTemplate: 'content',
      handle: '',

      /**
       * @name dxDraggableOptions.filter
       * @type string
       * @default ""
       * @hidden
       */
      filter: '',
      clone: false,
      autoScroll: true,
      scrollSpeed: 30,
      scrollSensitivity: 60,
      group: undefined,
      data: undefined
    });
  },
  _setOptionsByReference: function _setOptionsByReference() {
    this.callBase.apply(this, arguments);
    (0, _extend.extend)(this._optionsByReference, {
      component: true,
      group: true,
      itemData: true,
      data: true
    });
  },
  _init: function _init() {
    this.callBase();

    this._attachEventHandlers();

    this._scrollAnimator = new ScrollAnimator(this);
    this._horizontalScrollHelper = new ScrollHelper('horizontal', this);
    this._verticalScrollHelper = new ScrollHelper('vertical', this);
  },
  _normalizeCursorOffset: function _normalizeCursorOffset(offset) {
    if ((0, _type.isObject)(offset)) {
      offset = {
        h: offset.x,
        v: offset.y
      };
    }

    offset = (0, _common.splitPair)(offset).map(function (value) {
      return parseFloat(value);
    });
    return {
      left: offset[0],
      top: offset.length === 1 ? offset[0] : offset[1]
    };
  },
  _getNormalizedCursorOffset: function _getNormalizedCursorOffset(offset, options) {
    if ((0, _type.isFunction)(offset)) {
      offset = offset.call(this, options);
    }

    return this._normalizeCursorOffset(offset);
  },
  _calculateElementOffset: function _calculateElementOffset(options) {
    var elementOffset;
    var dragElementOffset;
    var event = options.event;
    var $element = (0, _renderer.default)(options.itemElement);
    var $dragElement = (0, _renderer.default)(options.dragElement);

    var isCloned = this._dragElementIsCloned();

    var cursorOffset = this.option('cursorOffset');
    var normalizedCursorOffset = {
      left: 0,
      top: 0
    };
    var currentLocate = this._initialLocate = (0, _translator.locate)($dragElement);

    if (isCloned || options.initialOffset || cursorOffset) {
      elementOffset = options.initialOffset || $element.offset();

      if (cursorOffset) {
        normalizedCursorOffset = this._getNormalizedCursorOffset(cursorOffset, options);

        if (isFinite(normalizedCursorOffset.left)) {
          elementOffset.left = event.pageX;
        }

        if (isFinite(normalizedCursorOffset.top)) {
          elementOffset.top = event.pageY;
        }
      }

      dragElementOffset = $dragElement.offset();
      elementOffset.top -= dragElementOffset.top + (normalizedCursorOffset.top || 0) - currentLocate.top;
      elementOffset.left -= dragElementOffset.left + (normalizedCursorOffset.left || 0) - currentLocate.left;
    }

    return elementOffset;
  },
  _initPosition: function _initPosition(options) {
    var $dragElement = (0, _renderer.default)(options.dragElement);

    var elementOffset = this._calculateElementOffset(options);

    if (elementOffset) {
      this._move(elementOffset, $dragElement);
    }

    this._startPosition = (0, _translator.locate)($dragElement);
  },
  _startAnimator: function _startAnimator() {
    if (!this._scrollAnimator.inProgress()) {
      this._scrollAnimator.start();
    }
  },
  _stopAnimator: function _stopAnimator() {
    this._scrollAnimator.stop();
  },
  _addWidgetPrefix: function _addWidgetPrefix(className) {
    var componentName = this.NAME;
    return (0, _inflector.dasherize)(componentName) + (className ? '-' + className : '');
  },
  _getItemsSelector: function _getItemsSelector() {
    return this.option('filter') || '';
  },
  _$content: function _$content() {
    var $element = this.$element();
    var $wrapper = $element.children('.dx-template-wrapper');
    return $wrapper.length ? $wrapper : $element;
  },
  _attachEventHandlers: function _attachEventHandlers() {
    var _this2 = this;

    if (this.option('disabled')) {
      return;
    }

    var $element = this._$content();

    var itemsSelector = this._getItemsSelector();

    var allowMoveByClick = this.option('allowMoveByClick');
    var data = {
      direction: this.option('dragDirection'),
      immediate: this.option('immediate'),
      checkDropTarget: function checkDropTarget($target, event) {
        var targetGroup = _this2.option('group');

        var sourceGroup = _this2._getSourceDraggable().option('group');

        var $scrollable = _this2._getScrollable($target);

        if (_this2._verticalScrollHelper.isOutsideScrollable($scrollable, event) || _this2._horizontalScrollHelper.isOutsideScrollable($scrollable, event)) {
          return false;
        }

        return sourceGroup && sourceGroup === targetGroup;
      }
    };

    if (allowMoveByClick) {
      $element = this._getArea();

      _events_engine.default.on($element, POINTERDOWN_EVENT_NAME, data, this._pointerDownHandler.bind(this));
    }

    if (itemsSelector[0] === '>') {
      itemsSelector = itemsSelector.slice(1);
    }

    _events_engine.default.on($element, DRAGSTART_EVENT_NAME, itemsSelector, data, this._dragStartHandler.bind(this));

    _events_engine.default.on($element, DRAG_EVENT_NAME, data, this._dragMoveHandler.bind(this));

    _events_engine.default.on($element, DRAGEND_EVENT_NAME, data, this._dragEndHandler.bind(this));

    _events_engine.default.on($element, DRAG_ENTER_EVENT_NAME, data, this._dragEnterHandler.bind(this));

    _events_engine.default.on($element, DRAGEND_LEAVE_EVENT_NAME, data, this._dragLeaveHandler.bind(this));
  },
  _dragElementIsCloned: function _dragElementIsCloned() {
    return this._$dragElement && this._$dragElement.hasClass(this._addWidgetPrefix(CLONE_CLASS));
  },
  _getDragTemplateArgs: function _getDragTemplateArgs($element, $container) {
    return {
      container: (0, _element.getPublicElement)($container),
      model: {
        itemData: this.option('itemData'),
        itemElement: (0, _element.getPublicElement)($element)
      }
    };
  },
  _createDragElement: function _createDragElement($element) {
    var result = $element;
    var clone = this.option('clone');

    var $container = this._getContainer();

    var template = this.option('dragTemplate');

    if (template) {
      template = this._getTemplate(template);
      result = (0, _renderer.default)('<div>').appendTo($container);
      template.render(this._getDragTemplateArgs($element, result));
    } else if (clone) {
      result = (0, _renderer.default)('<div>').appendTo($container);
      $element.clone().css({
        width: $element.css('width'),
        height: $element.css('height')
      }).appendTo(result);
    }

    return result.toggleClass(this._addWidgetPrefix(CLONE_CLASS), result.get(0) !== $element.get(0)).toggleClass('dx-rtl', this.option('rtlEnabled'));
  },
  _resetDragElement: function _resetDragElement() {
    if (this._dragElementIsCloned()) {
      this._$dragElement.remove();
    } else {
      this._toggleDraggingClass(false);
    }

    this._$dragElement = null;
  },
  _resetSourceElement: function _resetSourceElement() {
    this._toggleDragSourceClass(false);

    this._$sourceElement = null;
  },
  _detachEventHandlers: function _detachEventHandlers() {
    _events_engine.default.off(this._$content(), '.' + DRAGGABLE);

    _events_engine.default.off(this._getArea(), '.' + DRAGGABLE);
  },
  _move: function _move(position, $element) {
    (0, _translator.move)($element || this._$dragElement, position);
  },
  _getDraggableElement: function _getDraggableElement(e) {
    var $sourceElement = this._getSourceElement();

    if ($sourceElement) {
      return $sourceElement;
    }

    var allowMoveByClick = this.option('allowMoveByClick');

    if (allowMoveByClick) {
      return this.$element();
    }

    var $target = (0, _renderer.default)(e && e.target);

    var itemsSelector = this._getItemsSelector();

    if (itemsSelector[0] === '>') {
      var $items = this._$content().find(itemsSelector);

      if (!$items.is($target)) {
        $target = $target.closest($items);
      }
    }

    return $target;
  },
  _getSourceElement: function _getSourceElement() {
    var draggable = this._getSourceDraggable();

    return draggable._$sourceElement;
  },
  _pointerDownHandler: function _pointerDownHandler(e) {
    if ((0, _index.needSkipEvent)(e)) {
      return;
    }

    var position = {};
    var $element = this.$element();
    var dragDirection = this.option('dragDirection');

    if (dragDirection === 'horizontal' || dragDirection === 'both') {
      position.left = e.pageX - $element.offset().left + (0, _translator.locate)($element).left - $element.width() / 2;
    }

    if (dragDirection === 'vertical' || dragDirection === 'both') {
      position.top = e.pageY - $element.offset().top + (0, _translator.locate)($element).top - $element.height() / 2;
    }

    this._move(position, $element);

    this._getAction('onDragMove')(this._getEventArgs(e));
  },
  _isValidElement: function _isValidElement(event, $element) {
    var handle = this.option('handle');
    var $target = (0, _renderer.default)(event.originalEvent && event.originalEvent.target);

    if (handle && !$target.closest(handle).length) {
      return false;
    }

    if (!$element.length) {
      return false;
    }

    return !$element.is('.dx-state-disabled, .dx-state-disabled *');
  },
  _dragStartHandler: function _dragStartHandler(e) {
    var $element = this._getDraggableElement(e);

    if (this._$sourceElement) {
      return;
    }

    if (!this._isValidElement(e, $element)) {
      e.cancel = true;
      return;
    }

    var dragStartArgs = this._getDragStartArgs(e, $element);

    this._getAction('onDragStart')(dragStartArgs);

    if (dragStartArgs.cancel) {
      e.cancel = true;
      return;
    }

    this.option('itemData', dragStartArgs.itemData);

    this._setSourceDraggable();

    this._$sourceElement = $element;
    var initialOffset = $element.offset();

    var $dragElement = this._$dragElement = this._createDragElement($element);

    this._toggleDraggingClass(true);

    this._toggleDragSourceClass(true);

    this._setGestureCoverCursor($dragElement.children());

    var isFixedPosition = $dragElement.css('position') === 'fixed';

    this._initPosition((0, _extend.extend)({}, dragStartArgs, {
      dragElement: $dragElement.get(0),
      initialOffset: isFixedPosition && initialOffset
    }));

    var $area = this._getArea();

    var areaOffset = this._getAreaOffset($area);

    var boundOffset = this._getBoundOffset();

    var areaWidth = $area.outerWidth();
    var areaHeight = $area.outerHeight();
    var elementWidth = $dragElement.width();
    var elementHeight = $dragElement.height();
    var startOffset = {
      left: $dragElement.offset().left - areaOffset.left,
      top: $dragElement.offset().top - areaOffset.top
    };

    if ($area.length) {
      e.maxLeftOffset = startOffset.left - boundOffset.left;
      e.maxRightOffset = areaWidth - startOffset.left - elementWidth - boundOffset.right;
      e.maxTopOffset = startOffset.top - boundOffset.top;
      e.maxBottomOffset = areaHeight - startOffset.top - elementHeight - boundOffset.bottom;
    }

    if (this.option('autoScroll')) {
      this._startAnimator();
    }
  },
  _getAreaOffset: function _getAreaOffset($area) {
    var offset = $area && _position2.default.offset($area);

    return offset ? offset : {
      left: 0,
      top: 0
    };
  },
  _toggleDraggingClass: function _toggleDraggingClass(value) {
    this._$dragElement && this._$dragElement.toggleClass(this._addWidgetPrefix('dragging'), value);
  },
  _toggleDragSourceClass: function _toggleDragSourceClass(value, $element) {
    var $sourceElement = $element || this._$sourceElement;
    $sourceElement && $sourceElement.toggleClass(this._addWidgetPrefix('source'), value);
  },
  _setGestureCoverCursor: function _setGestureCoverCursor($element) {
    (0, _renderer.default)(".".concat(GESTURE_COVER_CLASS)).css('cursor', $element.css('cursor'));
  },
  _getBoundOffset: function _getBoundOffset() {
    var boundOffset = this.option('boundOffset');

    if ((0, _type.isFunction)(boundOffset)) {
      boundOffset = boundOffset.call(this);
    }

    return (0, _string.quadToObject)(boundOffset);
  },
  _getArea: function _getArea() {
    var area = this.option('boundary');

    if ((0, _type.isFunction)(area)) {
      area = area.call(this);
    }

    return (0, _renderer.default)(area);
  },
  _getContainer: function _getContainer() {
    var container = this.option('container');

    if (container === undefined) {
      container = (0, _view_port.value)();
    }

    return (0, _renderer.default)(container);
  },
  _dragMoveHandler: function _dragMoveHandler(e, scrollBy) {
    this._dragMoveArgs = e;

    if (!this._$dragElement) {
      e.cancel = true;
      return;
    }

    var offset = e.offset;
    var startPosition = this._startPosition;

    this._move({
      left: startPosition.left + offset.x,
      top: startPosition.top + offset.y
    });

    if (!scrollBy) {
      this._updateScrollable(e);
    }

    var eventArgs = this._getEventArgs(e);

    this._getAction('onDragMove')(eventArgs);

    if (eventArgs.cancel === true) {
      return;
    }

    var targetDraggable = this._getTargetDraggable();

    targetDraggable.dragMove(e, scrollBy);
  },
  _updateScrollable: function _updateScrollable(e) {
    var that = this;

    if (that.option('autoScroll')) {
      var mousePosition = getMousePosition(e);
      var allObjects = (0, _position.getElementsFromPoint)(mousePosition.x, mousePosition.y);

      that._verticalScrollHelper.updateScrollable(allObjects, mousePosition);

      that._horizontalScrollHelper.updateScrollable(allObjects, mousePosition);
    }
  },
  _getScrollable: function _getScrollable($element) {
    var _this3 = this;

    var $scrollable;
    $element.parents().toArray().some(function (parent) {
      var $parent = (0, _renderer.default)(parent);

      if (_this3._horizontalScrollHelper.isScrollable($parent) || _this3._verticalScrollHelper.isScrollable($parent)) {
        $scrollable = $parent;
        return true;
      }
    });
    return $scrollable;
  },
  _defaultActionArgs: function _defaultActionArgs() {
    var args = this.callBase.apply(this, arguments);
    var component = this.option('component');

    if (component) {
      args.component = component;
      args.element = component.element();
    }

    return args;
  },
  _getEventArgs: function _getEventArgs(e) {
    var sourceDraggable = this._getSourceDraggable();

    var targetDraggable = this._getTargetDraggable();

    return {
      event: e,
      itemData: sourceDraggable.option('itemData'),
      itemElement: (0, _element.getPublicElement)(sourceDraggable._$sourceElement),
      fromComponent: sourceDraggable.option('component') || sourceDraggable,
      toComponent: targetDraggable.option('component') || targetDraggable,
      fromData: sourceDraggable.option('data'),
      toData: targetDraggable.option('data')
    };
  },
  _getDragStartArgs: function _getDragStartArgs(e, $itemElement) {
    var args = this._getEventArgs(e);

    return {
      event: args.event,
      itemData: args.itemData,
      itemElement: $itemElement,
      fromData: args.fromData
    };
  },
  _revertItemToInitialPosition: function _revertItemToInitialPosition() {
    !this._dragElementIsCloned() && this._move(this._initialLocate, this._$sourceElement);
  },
  _dragEndHandler: function _dragEndHandler(e) {
    var _this4 = this;

    var d = new _deferred.Deferred();

    var dragEndEventArgs = this._getEventArgs(e);

    var dropEventArgs = this._getEventArgs(e);

    var targetDraggable = this._getTargetDraggable();

    var needRevertPosition = true;

    try {
      this._getAction('onDragEnd')(dragEndEventArgs);
    } finally {
      (0, _deferred.when)((0, _deferred.fromPromise)(dragEndEventArgs.cancel)).done(function (cancel) {
        if (!cancel) {
          if (targetDraggable !== _this4) {
            targetDraggable._getAction('onDrop')(dropEventArgs);
          }

          if (!dropEventArgs.cancel) {
            needRevertPosition = false;
            (0, _deferred.when)((0, _deferred.fromPromise)(targetDraggable.dragEnd(dragEndEventArgs))).always(d.resolve);
            return;
          }
        }

        d.resolve();
      }).fail(d.resolve);
      d.done(function () {
        if (needRevertPosition) {
          _this4._revertItemToInitialPosition();
        }

        _this4.reset();

        targetDraggable.reset();

        _this4._stopAnimator();

        _this4._horizontalScrollHelper.reset();

        _this4._verticalScrollHelper.reset();

        _this4._resetDragElement();

        _this4._resetSourceElement();

        _this4._resetTargetDraggable();

        _this4._resetSourceDraggable();
      });
    }
  },
  _isTargetOverAnotherDraggable: function _isTargetOverAnotherDraggable(e) {
    var _this5 = this;

    var sourceDraggable = this._getSourceDraggable();

    if (this === sourceDraggable) {
      return false;
    }

    var $dragElement = sourceDraggable._$dragElement;
    var $sourceDraggableElement = sourceDraggable.$element();
    var $targetDraggableElement = this.$element();
    var mousePosition = getMousePosition(e);
    var elements = (0, _position.getElementsFromPoint)(mousePosition.x, mousePosition.y);
    var firstWidgetElement = elements.filter(function (element) {
      var $element = (0, _renderer.default)(element);

      if ($element.hasClass(_this5._addWidgetPrefix())) {
        return !$element.closest($dragElement).length;
      }
    })[0];

    var $sourceElement = this._getSourceElement();

    var isTargetOverItself = firstWidgetElement === $sourceDraggableElement.get(0);
    var isTargetOverNestedDraggable = (0, _renderer.default)(firstWidgetElement).closest($sourceElement).length;
    return !firstWidgetElement || firstWidgetElement === $targetDraggableElement.get(0) && !isTargetOverItself && !isTargetOverNestedDraggable;
  },
  _dragEnterHandler: function _dragEnterHandler(e) {
    this._fireDragEnterEvent(e);

    if (this._isTargetOverAnotherDraggable(e)) {
      this._setTargetDraggable();
    }

    var sourceDraggable = this._getSourceDraggable();

    sourceDraggable.dragEnter(e);
  },
  _dragLeaveHandler: function _dragLeaveHandler(e) {
    this._fireDragLeaveEvent(e);

    this._resetTargetDraggable();

    if (this !== this._getSourceDraggable()) {
      this.reset();
    }

    var sourceDraggable = this._getSourceDraggable();

    sourceDraggable.dragLeave(e);
  },
  _getAction: function _getAction(name) {
    return this['_' + name + 'Action'] || this._createActionByOption(name);
  },
  _getAnonymousTemplateName: function _getAnonymousTemplateName() {
    return ANONYMOUS_TEMPLATE_NAME;
  },
  _initTemplates: function _initTemplates() {
    if (!this.option('contentTemplate')) return;

    this._templateManager.addDefaultTemplates({
      content: new _empty_template.EmptyTemplate()
    });

    this.callBase.apply(this, arguments);
  },
  _render: function _render() {
    this.callBase();
    this.$element().addClass(this._addWidgetPrefix());
    var transclude = this._templateManager.anonymousTemplateName === this.option('contentTemplate');

    var template = this._getTemplateByOption('contentTemplate');

    if (template) {
      (0, _renderer.default)(template.render({
        container: this.element(),
        transclude: transclude
      }));
    }
  },
  _optionChanged: function _optionChanged(args) {
    var name = args.name;

    switch (name) {
      case 'onDragStart':
      case 'onDragMove':
      case 'onDragEnd':
      case 'onDrop':
      case 'onDragEnter':
      case 'onDragLeave':
        this['_' + name + 'Action'] = this._createActionByOption(name);
        break;

      case 'dragTemplate':
      case 'contentTemplate':
      case 'container':
      case 'clone':
        break;

      case 'allowMoveByClick':
      case 'dragDirection':
      case 'disabled':
      case 'boundary':
      case 'filter':
      case 'immediate':
        this._resetDragElement();

        this._detachEventHandlers();

        this._attachEventHandlers();

        break;

      case 'autoScroll':
        this._verticalScrollHelper.reset();

        this._horizontalScrollHelper.reset();

        break;

      case 'scrollSensitivity':
      case 'scrollSpeed':
      case 'boundOffset':
      case 'handle':
      case 'group':
      case 'data':
      case 'itemData':
        break;

      default:
        this.callBase(args);
    }
  },
  _getTargetDraggable: function _getTargetDraggable() {
    return targetDraggable || this;
  },
  _getSourceDraggable: function _getSourceDraggable() {
    return sourceDraggable || this;
  },
  _setTargetDraggable: function _setTargetDraggable() {
    var currentGroup = this.option('group');

    var sourceDraggable = this._getSourceDraggable();

    if (currentGroup && currentGroup === sourceDraggable.option('group')) {
      targetDraggable = this;
    }
  },
  _setSourceDraggable: function _setSourceDraggable() {
    sourceDraggable = this;
  },
  _resetSourceDraggable: function _resetSourceDraggable() {
    sourceDraggable = null;
  },
  _resetTargetDraggable: function _resetTargetDraggable() {
    targetDraggable = null;
  },
  _dispose: function _dispose() {
    this.callBase();

    this._detachEventHandlers();

    this._resetDragElement();

    this._resetTargetDraggable();

    this._resetSourceDraggable();

    this._$sourceElement = null;

    this._stopAnimator();
  },
  _fireDragEnterEvent: function _fireDragEnterEvent(sourceEvent) {
    var args = this._getEventArgs(sourceEvent);

    this._getAction('onDragEnter')(args);
  },
  _fireDragLeaveEvent: function _fireDragLeaveEvent(sourceEvent) {
    var args = this._getEventArgs(sourceEvent);

    this._getAction('onDragLeave')(args);
  }
});

(0, _component_registrator.default)(DRAGGABLE, Draggable);
var _default = Draggable;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getFuncIri = getFuncIri;
exports.processHatchingAttrs = processHatchingAttrs;
exports.Renderer = Renderer;
exports.refreshPaths = exports.TextSvgElement = exports.RectSvgElement = exports.ArcSvgElement = exports.PathSvgElement = exports.SvgElement = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _window = __webpack_require__(7);

var _call_once = _interopRequireDefault(__webpack_require__(79));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _browser = _interopRequireDefault(__webpack_require__(32));

var _svg = __webpack_require__(213);

var _animation = __webpack_require__(1032);

var _utils = __webpack_require__(14);

var _type = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var window = (0, _window.getWindow)();
var max = Math.max,
    min = Math.min,
    floor = Math.floor,
    round = Math.round,
    sin = Math.sin,
    cos = Math.cos,
    abs = Math.abs,
    PI = Math.PI;
var PI_DIV_180 = PI / 180;
var SHARPING_CORRECTION = 0.5;
var ARC_COORD_PREC = 5;
var pxAddingExceptions = {
  'column-count': true,
  'fill-opacity': true,
  'flex-grow': true,
  'flex-shrink': true,
  'font-weight': true,
  'line-height': true,
  'opacity': true,
  'order': true,
  'orphans': true,
  'widows': true,
  'z-index': true,
  'zoom': true
};
var KEY_TEXT = 'text';
var KEY_STROKE = 'stroke';
var KEY_STROKE_WIDTH = 'stroke-width';
var KEY_STROKE_OPACITY = 'stroke-opacity';
var KEY_FONT_SIZE = 'font-size';
var KEY_FONT_STYLE = 'font-style';
var KEY_FONT_WEIGHT = 'font-weight';
var KEY_TEXT_DECORATION = 'text-decoration';
var KEY_TEXTS_ALIGNMENT = 'textsAlignment';
var NONE = 'none';
var DEFAULT_FONT_SIZE = 12;
var ELLIPSIS = '...';

var objectCreate = function () {
  if (!Object.create) {
    return function (proto) {
      var F = function F() {};

      F.prototype = proto;
      return new F();
    };
  } else {
    return function (proto) {
      return Object.create(proto);
    };
  }
}();

var DEFAULTS = {
  scaleX: 1,
  scaleY: 1,
  'pointer-events': null
};
var getBackup = (0, _call_once.default)(function () {
  var backupContainer = _dom_adapter.default.createElement('div');

  var backupCounter = 0;
  backupContainer.style.left = '-9999px';
  backupContainer.style.position = 'absolute';
  return {
    backupContainer: backupContainer,
    backupCounter: backupCounter
  };
});

function backupRoot(root) {
  if (getBackup().backupCounter === 0) {
    _dom_adapter.default.getBody().appendChild(getBackup().backupContainer);
  }

  ++getBackup().backupCounter;
  root.append({
    element: getBackup().backupContainer
  });
}

function restoreRoot(root, container) {
  root.append({
    element: container
  });
  --getBackup().backupCounter;

  if (getBackup().backupCounter === 0) {
    _dom_adapter.default.getBody().removeChild(getBackup().backupContainer);
  }
}

var getNextDefsSvgId = function () {
  var numDefsSvgElements = 1;
  return function () {
    return 'DevExpress_' + numDefsSvgElements++;
  };
}();

function isObjectArgument(value) {
  return value && typeof value !== 'string';
}

function createElement(tagName) {
  return _dom_adapter.default.createElementNS('http://www.w3.org/2000/svg', tagName);
}

function getFuncIri(id, pathModified) {
  return id !== null ? 'url(' + (pathModified ? window.location.href.split('#')[0] : '') + '#' + id + ')' : id;
}

function extend(target, source) {
  var key;

  for (key in source) {
    target[key] = source[key];
  }

  return target;
}

function roundValue(value, exp) {
  value = value.toString().split('e');
  value = round(+(value[0] + 'e' + (value[1] ? +value[1] + exp : exp)));
  value = value.toString().split('e');
  return +(value[0] + 'e' + (value[1] ? +value[1] - exp : -exp));
}

function getBoundingClientRect(element) {
  var box;

  try {
    box = element.getBoundingClientRect();
  } catch (e) {}

  return box || {
    left: 0,
    top: 0
  };
}

var preserveAspectRatioMap = {
  'full': NONE,
  'lefttop': 'xMinYMin',
  'leftcenter': 'xMinYMid',
  'leftbottom': 'xMinYMax',
  'centertop': 'xMidYMin',
  'center': 'xMidYMid',
  'centerbottom': 'xMidYMax',
  'righttop': 'xMaxYMin',
  'rightcenter': 'xMaxYMid',
  'rightbottom': 'xMaxYMax'
};

function processHatchingAttrs(element, attrs) {
  if (attrs.hatching && (0, _utils.normalizeEnum)(attrs.hatching.direction) !== 'none') {
    attrs = extend({}, attrs);
    attrs.fill = element._hatching = element.renderer.lockHatching(attrs.fill, attrs.hatching, element._hatching);
    delete attrs.hatching;
  } else if (element._hatching) {
    element.renderer.releaseHatching(element._hatching);
    element._hatching = null;
  }

  return attrs;
} //
// Build path segments
//


function normalizeArcParams(x, y, innerR, outerR, startAngle, endAngle) {
  var isCircle;
  var noArc = true;
  var angleDiff = roundValue(endAngle, 3) - roundValue(startAngle, 3);

  if (angleDiff) {
    if (abs(angleDiff) % 360 === 0) {
      startAngle = 0;
      endAngle = 360;
      isCircle = true;
      endAngle -= 0.01;
    }

    if (startAngle > 360) {
      startAngle = startAngle % 360;
    }

    if (endAngle > 360) {
      endAngle = endAngle % 360;
    }

    if (startAngle > endAngle) {
      startAngle -= 360;
    }

    noArc = false;
  }

  startAngle = startAngle * PI_DIV_180;
  endAngle = endAngle * PI_DIV_180;
  return [x, y, min(outerR, innerR), max(outerR, innerR), cos(startAngle), sin(startAngle), cos(endAngle), sin(endAngle), isCircle, floor(abs(endAngle - startAngle) / PI) % 2 ? '1' : '0', noArc];
}

var buildArcPath = function buildArcPath(x, y, innerR, outerR, startAngleCos, startAngleSin, endAngleCos, endAngleSin, isCircle, longFlag) {
  return ['M', (x + outerR * startAngleCos).toFixed(ARC_COORD_PREC), (y - outerR * startAngleSin).toFixed(ARC_COORD_PREC), 'A', outerR.toFixed(ARC_COORD_PREC), outerR.toFixed(ARC_COORD_PREC), 0, longFlag, 0, (x + outerR * endAngleCos).toFixed(ARC_COORD_PREC), (y - outerR * endAngleSin).toFixed(ARC_COORD_PREC), isCircle ? 'M' : 'L', (x + innerR * endAngleCos).toFixed(5), (y - innerR * endAngleSin).toFixed(ARC_COORD_PREC), 'A', innerR.toFixed(ARC_COORD_PREC), innerR.toFixed(ARC_COORD_PREC), 0, longFlag, 1, (x + innerR * startAngleCos).toFixed(ARC_COORD_PREC), (y - innerR * startAngleSin).toFixed(ARC_COORD_PREC), 'Z'].join(' ');
};

function buildPathSegments(points, type) {
  var list = [['M', 0, 0]];

  switch (type) {
    case 'line':
      list = buildLineSegments(points);
      break;

    case 'area':
      list = buildLineSegments(points, true);
      break;

    case 'bezier':
      list = buildCurveSegments(points);
      break;

    case 'bezierarea':
      list = buildCurveSegments(points, true);
      break;
  }

  return list;
}

function buildLineSegments(points, close) {
  return buildSegments(points, buildSimpleLineSegment, close);
}

function buildCurveSegments(points, close) {
  return buildSegments(points, buildSimpleCurveSegment, close);
}

function buildSegments(points, buildSimpleSegment, close) {
  var _points$;

  var i;
  var ii;
  var list = [];

  if ((_points$ = points[0]) !== null && _points$ !== void 0 && _points$.length) {
    for (i = 0, ii = points.length; i < ii; ++i) {
      buildSimpleSegment(points[i], close, list);
    }
  } else {
    buildSimpleSegment(points, close, list);
  }

  return list;
}

function buildSimpleLineSegment(points, close, list) {
  var i = 0;
  var k0 = list.length;
  var k = k0;
  var ii = (points || []).length;

  if (ii) {
    // backward compatibility
    if (points[0].x !== undefined) {
      for (; i < ii;) {
        list[k++] = ['L', points[i].x, points[i++].y];
      }
    } else {
      for (; i < ii;) {
        list[k++] = ['L', points[i++], points[i++]];
      }
    }

    list[k0][0] = 'M';
  } else {
    list[k] = ['M', 0, 0];
  }

  close && list.push(['Z']);
  return list;
}

function buildSimpleCurveSegment(points, close, list) {
  var i;
  var k = list.length;
  var ii = (points || []).length;

  if (ii) {
    // backward compatibility
    if (points[0].x !== undefined) {
      list[k++] = ['M', points[0].x, points[0].y];

      for (i = 1; i < ii;) {
        list[k++] = ['C', points[i].x, points[i++].y, points[i].x, points[i++].y, points[i].x, points[i++].y];
      }
    } else {
      list[k++] = ['M', points[0], points[1]];

      for (i = 2; i < ii;) {
        list[k++] = ['C', points[i++], points[i++], points[i++], points[i++], points[i++], points[i++]];
      }
    }
  } else {
    list[k] = ['M', 0, 0];
  }

  close && list.push(['Z']);
  return list;
}

function combinePathParam(segments) {
  var d = [];
  var k = 0;
  var i;
  var ii = segments.length;
  var segment;
  var j;
  var jj;

  for (i = 0; i < ii; ++i) {
    segment = segments[i];

    for (j = 0, jj = segment.length; j < jj; ++j) {
      d[k++] = segment[j];
    }
  }

  return d.join(' ');
}

function compensateSegments(oldSegments, newSegments, type) {
  var oldLength = oldSegments.length;
  var newLength = newSegments.length;
  var i;
  var originalNewSegments;
  var makeEqualSegments = type.indexOf('area') !== -1 ? makeEqualAreaSegments : makeEqualLineSegments;

  if (oldLength === 0) {
    for (i = 0; i < newLength; i++) {
      oldSegments.push(newSegments[i].slice(0));
    }
  } else if (oldLength < newLength) {
    makeEqualSegments(oldSegments, newSegments, type);
  } else if (oldLength > newLength) {
    originalNewSegments = newSegments.slice(0);
    makeEqualSegments(newSegments, oldSegments, type);
  }

  return originalNewSegments;
}

function prepareConstSegment(constSeg, type) {
  var x = constSeg[constSeg.length - 2];
  var y = constSeg[constSeg.length - 1];

  switch (type) {
    case 'line':
    case 'area':
      constSeg[0] = 'L';
      break;

    case 'bezier':
    case 'bezierarea':
      constSeg[0] = 'C';
      constSeg[1] = constSeg[3] = constSeg[5] = x;
      constSeg[2] = constSeg[4] = constSeg[6] = y;
      break;
  }
}

function makeEqualLineSegments(short, long, type) {
  var constSeg = short[short.length - 1].slice();
  var i = short.length;
  prepareConstSegment(constSeg, type);

  for (; i < long.length; i++) {
    short[i] = constSeg.slice(0);
  }
}

function makeEqualAreaSegments(short, long, type) {
  var i;
  var head;
  var shortLength = short.length;
  var longLength = long.length;
  var constsSeg1;
  var constsSeg2;

  if ((shortLength - 1) % 2 === 0 && (longLength - 1) % 2 === 0) {
    i = (shortLength - 1) / 2 - 1;
    head = short.slice(0, i + 1);
    constsSeg1 = head[head.length - 1].slice(0);
    constsSeg2 = short.slice(i + 1)[0].slice(0);
    prepareConstSegment(constsSeg1, type);
    prepareConstSegment(constsSeg2, type);

    for (var j = i; j < (longLength - 1) / 2 - 1; j++) {
      short.splice(j + 1, 0, constsSeg1);
      short.splice(j + 3, 0, constsSeg2);
    }
  }
}

function baseCss(that, styles) {
  var elemStyles = that._styles;
  var key;
  var value;
  styles = styles || {};

  for (key in styles) {
    value = styles[key];

    if ((0, _type.isDefined)(value)) {
      value += typeof value === 'number' && !pxAddingExceptions[key] ? 'px' : '';
      elemStyles[key] = value !== '' ? value : null;
    }
  } // NOTE: Seems that [].concat is not faster when there are only few entries in the `styles` (and in most cases there are few of them)


  for (key in elemStyles) {
    // The alternative is to *delete* entries in the previous cycle, but it is *delete*!
    value = elemStyles[key];

    if (value) {
      that.element.style[key] = value;
    } else if (value === null) {
      that.element.style[key] = '';
    }
  }

  return that;
}

function fixFuncIri(wrapper, attribute) {
  var element = wrapper.element;
  var id = wrapper.attr(attribute);

  if (id && id.indexOf('DevExpress') !== -1) {
    element.removeAttribute(attribute);
    element.setAttribute(attribute, getFuncIri(id, wrapper.renderer.pathModified));
  }
}

function baseAttr(that, attrs) {
  attrs = attrs || {};
  var settings = that._settings;
  var attributes = {};
  var key;
  var value;
  var elem = that.element;
  var renderer = that.renderer;
  var rtl = renderer.rtl;
  var hasTransformations;
  var recalculateDashStyle;
  var sw;
  var i;

  if (!isObjectArgument(attrs)) {
    if (attrs in settings) {
      return settings[attrs];
    }

    if (attrs in DEFAULTS) {
      return DEFAULTS[attrs];
    }

    return 0;
  }

  extend(attributes, attrs);

  for (key in attributes) {
    value = attributes[key];

    if (value === undefined) {
      continue;
    }

    settings[key] = value;

    if (key === 'align') {
      key = 'text-anchor';
      value = {
        left: rtl ? 'end' : 'start',
        center: 'middle',
        right: rtl ? 'start' : 'end'
      }[value] || null;
    } else if (key === 'dashStyle') {
      recalculateDashStyle = true;
      continue;
    } else if (key === KEY_STROKE_WIDTH) {
      recalculateDashStyle = true;
    } else if (value && (key === 'fill' || key === 'clip-path' || key === 'filter') && value.indexOf('DevExpress') === 0) {
      that._addFixIRICallback();

      value = getFuncIri(value, renderer.pathModified);
    } else if (/^(translate(X|Y)|rotate[XY]?|scale(X|Y)|sharp|sharpDirection)$/i.test(key)) {
      hasTransformations = true;
      continue;
    } else if (/^(x|y|d)$/i.test(key)) {
      // TODO test it
      hasTransformations = true;
    }

    if (value === null) {
      elem.removeAttribute(key);
    } else {
      elem.setAttribute(key, value);
    }
  }

  if (recalculateDashStyle && 'dashStyle' in settings) {
    value = settings.dashStyle;
    sw = ('_originalSW' in that ? that._originalSW : settings[KEY_STROKE_WIDTH]) || 1;
    key = 'stroke-dasharray';
    value = value === null ? '' : (0, _utils.normalizeEnum)(value);

    if (value === '' || value === 'solid' || value === NONE) {
      that.element.removeAttribute(key);
    } else {
      value = value.replace(/longdash/g, '8,3,').replace(/dash/g, '4,3,').replace(/dot/g, '1,3,').replace(/,$/, '').split(',');
      i = value.length;

      while (i--) {
        value[i] = parseInt(value[i]) * sw;
      }

      that.element.setAttribute(key, value.join(','));
    }
  }

  if (hasTransformations) {
    that._applyTransformation();
  }

  return that;
}

function pathAttr(attrs) {
  var that = this;
  var segments;

  if (isObjectArgument(attrs)) {
    attrs = extend({}, attrs);
    segments = attrs.segments;

    if ('points' in attrs) {
      segments = buildPathSegments(attrs.points, that.type);
      delete attrs.points;
    }

    if (segments) {
      attrs.d = combinePathParam(segments);
      that.segments = segments;
      delete attrs.segments;
    }
  }

  return baseAttr(that, attrs);
}

function arcAttr(attrs) {
  var settings = this._settings;
  var x;
  var y;
  var innerRadius;
  var outerRadius;
  var startAngle;
  var endAngle;

  if (isObjectArgument(attrs)) {
    attrs = extend({}, attrs);

    if ('x' in attrs || 'y' in attrs || 'innerRadius' in attrs || 'outerRadius' in attrs || 'startAngle' in attrs || 'endAngle' in attrs) {
      settings.x = x = 'x' in attrs ? attrs.x : settings.x;
      delete attrs.x;
      settings.y = y = 'y' in attrs ? attrs.y : settings.y;
      delete attrs.y;
      settings.innerRadius = innerRadius = 'innerRadius' in attrs ? attrs.innerRadius : settings.innerRadius;
      delete attrs.innerRadius;
      settings.outerRadius = outerRadius = 'outerRadius' in attrs ? attrs.outerRadius : settings.outerRadius;
      delete attrs.outerRadius;
      settings.startAngle = startAngle = 'startAngle' in attrs ? attrs.startAngle : settings.startAngle;
      delete attrs.startAngle;
      settings.endAngle = endAngle = 'endAngle' in attrs ? attrs.endAngle : settings.endAngle;
      delete attrs.endAngle;
      attrs.d = buildArcPath.apply(null, normalizeArcParams(x, y, innerRadius, outerRadius, startAngle, endAngle));
    }
  }

  return baseAttr(this, attrs);
}

function rectAttr(attrs) {
  var that = this;
  var x;
  var y;
  var width;
  var height;
  var sw;
  var maxSW;
  var newSW;

  if (isObjectArgument(attrs)) {
    attrs = extend({}, attrs);

    if (attrs.x !== undefined || attrs.y !== undefined || attrs.width !== undefined || attrs.height !== undefined || attrs[KEY_STROKE_WIDTH] !== undefined) {
      attrs.x !== undefined ? x = that._originalX = attrs.x : x = that._originalX || 0;
      attrs.y !== undefined ? y = that._originalY = attrs.y : y = that._originalY || 0;
      attrs.width !== undefined ? width = that._originalWidth = attrs.width : width = that._originalWidth || 0;
      attrs.height !== undefined ? height = that._originalHeight = attrs.height : height = that._originalHeight || 0;
      attrs[KEY_STROKE_WIDTH] !== undefined ? sw = that._originalSW = attrs[KEY_STROKE_WIDTH] : sw = that._originalSW;
      maxSW = ~~((width < height ? width : height) / 2);
      newSW = (sw || 0) < maxSW ? sw || 0 : maxSW;
      attrs.x = x + newSW / 2;
      attrs.y = y + newSW / 2;
      attrs.width = width - newSW;
      attrs.height = height - newSW;
      ((sw || 0) !== newSW || !(newSW === 0 && sw === undefined)) && (attrs[KEY_STROKE_WIDTH] = newSW);
    }

    if ('sharp' in attrs) {
      delete attrs.sharp;
    }
  }

  return baseAttr(that, attrs);
}

function textAttr(attrs) {
  var that = this;
  var isResetRequired;

  if (!isObjectArgument(attrs)) {
    return baseAttr(that, attrs);
  }

  attrs = extend({}, attrs);
  var settings = that._settings;
  var wasStroked = (0, _type.isDefined)(settings[KEY_STROKE]) && (0, _type.isDefined)(settings[KEY_STROKE_WIDTH]);

  if (attrs[KEY_TEXT] !== undefined) {
    settings[KEY_TEXT] = attrs[KEY_TEXT];
    delete attrs[KEY_TEXT];
    isResetRequired = true;
  }

  if (attrs[KEY_STROKE] !== undefined) {
    settings[KEY_STROKE] = attrs[KEY_STROKE];
    delete attrs[KEY_STROKE];
  }

  if (attrs[KEY_STROKE_WIDTH] !== undefined) {
    settings[KEY_STROKE_WIDTH] = attrs[KEY_STROKE_WIDTH];
    delete attrs[KEY_STROKE_WIDTH];
  }

  if (attrs[KEY_STROKE_OPACITY] !== undefined) {
    settings[KEY_STROKE_OPACITY] = attrs[KEY_STROKE_OPACITY];
    delete attrs[KEY_STROKE_OPACITY];
  }

  if (attrs[KEY_TEXTS_ALIGNMENT] !== undefined) {
    alignTextNodes(that, attrs[KEY_TEXTS_ALIGNMENT]);
    delete attrs[KEY_TEXTS_ALIGNMENT];
  }

  var isStroked = (0, _type.isDefined)(settings[KEY_STROKE]) && (0, _type.isDefined)(settings[KEY_STROKE_WIDTH]);
  baseAttr(that, attrs);
  isResetRequired = isResetRequired || isStroked !== wasStroked && settings[KEY_TEXT];

  if (isResetRequired) {
    createTextNodes(that, settings.text, isStroked);
    that._hasEllipsis = false;
  }

  if (isResetRequired || attrs['x'] !== undefined || attrs['y'] !== undefined) {
    locateTextNodes(that);
  }

  if (isStroked) {
    strokeTextNodes(that);
  }

  return that;
}

function textCss(styles) {
  styles = styles || {};
  baseCss(this, styles);

  if (KEY_FONT_SIZE in styles) {
    locateTextNodes(this);
  }

  return this;
}

function orderHtmlTree(list, line, node, parentStyle, parentClassName) {
  var style;
  var realStyle;
  var i;
  var ii;
  var nodes;

  if (node.wholeText !== undefined) {
    list.push({
      value: node.wholeText,
      style: parentStyle,
      className: parentClassName
      /* EXPERIMENTAL */
      ,
      line: line,
      height: parentStyle[KEY_FONT_SIZE] || 0
    });
  } else if (node.tagName === 'BR') {
    ++line;
  } else if (_dom_adapter.default.isElementNode(node)) {
    extend(style = {}, parentStyle);

    switch (node.tagName) {
      case 'B':
      case 'STRONG':
        style[KEY_FONT_WEIGHT] = 'bold';
        break;

      case 'I':
      case 'EM':
        style[KEY_FONT_STYLE] = 'italic';
        break;

      case 'U':
        style[KEY_TEXT_DECORATION] = 'underline';
        break;
    }

    realStyle = node.style;
    realStyle.color && (style.fill = realStyle.color);
    realStyle.fontSize && (style[KEY_FONT_SIZE] = realStyle.fontSize);
    realStyle.fontStyle && (style[KEY_FONT_STYLE] = realStyle.fontStyle);
    realStyle.fontWeight && (style[KEY_FONT_WEIGHT] = realStyle.fontWeight);
    realStyle.textDecoration && (style[KEY_TEXT_DECORATION] = realStyle.textDecoration);

    for (i = 0, nodes = node.childNodes, ii = nodes.length; i < ii; ++i) {
      line = orderHtmlTree(list, line, nodes[i], style, node.className || parentClassName);
    }
  }

  return line;
}

function adjustLineHeights(items) {
  var i;
  var ii;
  var currentItem = items[0];
  var item;

  for (i = 1, ii = items.length; i < ii; ++i) {
    item = items[i];

    if (item.line === currentItem.line) {
      // T177039
      currentItem.height = maxLengthFontSize(currentItem.height, item.height);
      currentItem.inherits = currentItem.inherits || parseFloat(item.height) === 0;
      item.height = NaN;
    } else {
      currentItem = item;
    }
  }
}

function removeExtraAttrs(html) {
  var findTagAttrs = /(?:(<[a-z0-9]+\s*))([\s\S]*?)(>|\/>)/gi;
  var findStyleAndClassAttrs = /(style|class)\s*=\s*(["'])(?:(?!\2).)*\2\s?/gi;
  return html.replace(findTagAttrs, function (allTagAttrs, p1, p2, p3) {
    p2 = (p2 && p2.match(findStyleAndClassAttrs) || []).map(function (str) {
      return str;
    }).join(' ');
    return p1 + p2 + p3;
  });
}

function parseHTML(text) {
  var items = [];

  var div = _dom_adapter.default.createElement('div');

  div.innerHTML = text.replace(/\r/g, '').replace(/\n/g, '<br/>');
  orderHtmlTree(items, 0, div, {}, '');
  adjustLineHeights(items);
  return items;
}

function parseMultiline(text) {
  var texts = text.replace(/\r/g, '').split(/\n/g);
  var i = 0;
  var items = [];

  for (; i < texts.length; i++) {
    items.push({
      value: texts[i].trim(),
      height: 0,
      line: i
    });
  }

  return items;
}

function createTspans(items, element, fieldName) {
  var i;
  var ii;
  var item;

  for (i = 0, ii = items.length; i < ii; ++i) {
    item = items[i];
    item[fieldName] = createElement('tspan');
    item[fieldName].appendChild(_dom_adapter.default.createTextNode(item.value));
    item.style && baseCss({
      element: item[fieldName],
      _styles: {}
    }, item.style);
    item.className && item[fieldName].setAttribute('class', item.className); // EXPERIMENTAL

    element.appendChild(item[fieldName]);
  }
}

function restoreText() {
  if (this._hasEllipsis) {
    this.attr({
      text: this._settings.text
    });
  }
}

function applyEllipsis(maxWidth) {
  var that = this;
  var lines;
  var hasEllipsis = false;
  var i;
  var ii;
  var lineParts;
  var j;
  var jj;
  var text;
  restoreText.call(that);
  var ellipsis = that.renderer.text(ELLIPSIS).attr(that._styles).append(that.renderer.root);
  var ellipsisWidth = ellipsis.getBBox().width;

  if (that._getElementBBox().width > maxWidth) {
    if (maxWidth - ellipsisWidth < 0) {
      maxWidth = 0;
    } else {
      maxWidth -= ellipsisWidth;
    }

    lines = prepareLines(that.element, that._texts, maxWidth);

    for (i = 0, ii = lines.length; i < ii; ++i) {
      lineParts = lines[i].parts;

      if (lines[i].commonLength === 1) {
        continue;
      }

      for (j = 0, jj = lineParts.length; j < jj; ++j) {
        text = lineParts[j];

        if ((0, _type.isDefined)(text.endIndex)) {
          setNewText(text, text.endIndex);
          hasEllipsis = true;
        } else if (text.startBox > maxWidth) {
          removeTextSpan(text);
        }
      }
    }
  }

  ellipsis.remove();
  that._hasEllipsis = hasEllipsis;
  return hasEllipsis;
}

function cloneAndRemoveAttrs(node) {
  var clone;

  if (node) {
    clone = node.cloneNode();
    clone.removeAttribute('y');
    clone.removeAttribute('x');
  }

  return clone || node;
}

function detachTitleElements(element) {
  var titleElements = _dom_adapter.default.querySelectorAll(element, 'title');

  for (var i = 0; i < titleElements.length; i++) {
    element.removeChild(titleElements[i]);
  }

  return titleElements;
}

function detachAndStoreTitleElements(element) {
  var titleElements = detachTitleElements(element);
  return function () {
    for (var i = 0; i < titleElements.length; i++) {
      element.appendChild(titleElements[i]);
    }
  };
}

function setMaxSize(maxWidth, maxHeight) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var that = this;
  var lines = [];
  var textChanged = false;
  var textIsEmpty = false;
  var ellipsisMaxWidth = maxWidth;
  restoreText.call(that);
  var restoreTitleElement = detachAndStoreTitleElements(this.element);
  var ellipsis = that.renderer.text(ELLIPSIS).attr(that._styles).append(that.renderer.root);
  var ellipsisWidth = ellipsis.getBBox().width;

  var _that$_getElementBBox = that._getElementBBox(),
      width = _that$_getElementBBox.width,
      height = _that$_getElementBBox.height;

  if ((width || height) && (width > maxWidth || maxHeight && height > maxHeight)) {
    if (maxWidth - ellipsisWidth < 0) {
      ellipsisMaxWidth = 0;
    } else {
      ellipsisMaxWidth -= ellipsisWidth;
    }

    lines = applyOverflowRules(that.element, that._texts, maxWidth, ellipsisMaxWidth, options);
    lines = setMaxHeight(lines, ellipsisMaxWidth, options, maxHeight, parseFloat(this._getLineHeight()));
    this._texts = lines.reduce(function (texts, line) {
      return texts.concat(line.parts);
    }, []).filter(function (t) {
      return t.value !== '';
    }).map(function (t) {
      t.stroke && t.tspan.parentNode.appendChild(t.stroke);
      return t;
    }).map(function (t) {
      t.tspan.parentNode.appendChild(t.tspan);
      return t;
    });
    !this._texts.length && (this._texts = null);
    textChanged = true;

    if (this._texts) {
      locateTextNodes(this);
    } else {
      this.element.textContent = '';
      textIsEmpty = true;
    }
  }

  ellipsis.remove();
  that._hasEllipsis = textChanged;
  restoreTitleElement();
  return {
    rowCount: lines.length,
    textChanged: textChanged,
    textIsEmpty: textIsEmpty
  };
}

function getIndexForEllipsis(text, maxWidth, startBox, endBox) {
  var k;
  var kk;

  if (startBox <= maxWidth && endBox > maxWidth) {
    for (k = 1, kk = text.value.length; k <= kk; ++k) {
      if (startBox + text.tspan.getSubStringLength(0, k) > maxWidth) {
        return k - 1;
      }
    }
  }
}

function getTextWidth(text) {
  return text.value.length ? text.tspan.getSubStringLength(0, text.value.length) : 0;
}

function prepareLines(element, texts, maxWidth) {
  var lines = [];
  var i;
  var ii;
  var text;
  var startBox;
  var endBox;

  if (texts) {
    for (i = 0, ii = texts.length; i < ii; ++i) {
      text = texts[i];

      if (!lines[text.line]) {
        text.startBox = startBox = 0;
        lines.push({
          commonLength: text.value.length,
          parts: [text]
        });
      } else {
        text.startBox = startBox;
        lines[text.line].parts.push(text);
        lines[text.line].commonLength += text.value.length;
      }

      endBox = startBox + text.tspan.getSubStringLength(0, text.value.length);
      text.endIndex = getIndexForEllipsis(text, maxWidth, startBox, endBox);
      startBox = endBox;
    }
  } else {
    text = {
      value: element.textContent,
      tspan: element
    };
    text.startBox = startBox = 0;
    endBox = startBox + getTextWidth(text);
    text.endIndex = getIndexForEllipsis(text, maxWidth, startBox, endBox);
    lines = [{
      commonLength: element.textContent.length,
      parts: [text]
    }];
  }

  return lines;
}

function getSpaceBreakIndex(text, maxWidth) {
  var initialIndices = text.startBox > 0 ? [0] : [];
  var spaceIndices = text.value.split('').reduce(function (indices, char, index) {
    if (char === ' ') {
      indices.push(index);
    }

    return indices;
  }, initialIndices);
  var spaceIndex = 0;

  while (spaceIndices[spaceIndex + 1] !== undefined && text.startBox + text.tspan.getSubStringLength(0, spaceIndices[spaceIndex + 1]) < maxWidth) {
    spaceIndex++;
  }

  return spaceIndices[spaceIndex];
}

function getWordBreakIndex(text, maxWidth) {
  for (var i = 0; i < text.value.length - 1; i++) {
    if (text.startBox + text.tspan.getSubStringLength(0, i + 1) > maxWidth) {
      return i;
    }
  }
}

function getEllipsisString(ellipsisMaxWidth, _ref) {
  var hideOverflowEllipsis = _ref.hideOverflowEllipsis;
  return hideOverflowEllipsis && ellipsisMaxWidth === 0 ? '' : ELLIPSIS;
}

function setEllipsis(text, ellipsisMaxWidth, options) {
  var ellipsis = getEllipsisString(ellipsisMaxWidth, options);

  if (text.value.length && text.tspan.parentNode) {
    for (var i = text.value.length - 1; i >= 1; i--) {
      if (text.startBox + text.tspan.getSubStringLength(0, i) < ellipsisMaxWidth) {
        setNewText(text, i, ellipsis);
        break;
      } else if (i === 1) {
        setNewText(text, 0, ellipsis);
      }
    }
  }
}

function wordWrap(text, maxWidth, ellipsisMaxWidth, options, lastStepBreakIndex) {
  var wholeText = text.value;
  var breakIndex;

  if (options.wordWrap !== 'none') {
    breakIndex = options.wordWrap === 'normal' ? getSpaceBreakIndex(text, maxWidth) : getWordBreakIndex(text, maxWidth);
  }

  var restLines = [];
  var restText;

  if (isFinite(breakIndex) && !(lastStepBreakIndex === 0 && breakIndex === 0)) {
    setNewText(text, breakIndex, '');
    var newTextOffset = wholeText[breakIndex] === ' ' ? 1 : 0;
    var restString = wholeText.slice(breakIndex + newTextOffset);

    if (restString.length) {
      var restTspan = cloneAndRemoveAttrs(text.tspan);
      restTspan.textContent = restString;
      text.tspan.parentNode.appendChild(restTspan);
      restText = extend(extend({}, text), {
        value: restString,
        startBox: 0,
        height: 0,
        tspan: restTspan,
        stroke: cloneAndRemoveAttrs(text.stroke),
        endBox: restTspan.getSubStringLength(0, restString.length)
      });
      restText.stroke && (restText.stroke.textContent = restString);

      if (restText.endBox > maxWidth) {
        restLines = wordWrap(restText, maxWidth, ellipsisMaxWidth, options, breakIndex);

        if (!restLines.length) {
          return [];
        }
      }
    }
  }

  if (text.value.length) {
    if (options.textOverflow === 'ellipsis' && text.tspan.getSubStringLength(0, text.value.length) > maxWidth) {
      setEllipsis(text, ellipsisMaxWidth, options);
    }

    if (options.textOverflow === 'hide' && text.tspan.getSubStringLength(0, text.value.length) > maxWidth) {
      return [];
    }
  } else {
    text.tspan.parentNode.removeChild(text.tspan);
  }

  var parts = [];

  if (restText) {
    parts.push(restText);
  }

  return [{
    commonLength: wholeText.length,
    parts: parts
  }].concat(restLines);
}

function calculateLineHeight(line, lineHeight) {
  return line.parts.reduce(function (height, text) {
    return max(height, getItemLineHeight(text, lineHeight));
  }, 0);
}

function setMaxHeight(lines, ellipsisMaxWidth, options, maxHeight, lineHeight) {
  var textOverflow = options.textOverflow;

  if (!isFinite(maxHeight) || Number(maxHeight) === 0 || textOverflow === 'none') {
    return lines;
  }

  var result = lines.reduce(function (_ref2, l, index, arr) {
    var _ref3 = _slicedToArray(_ref2, 2),
        lines = _ref3[0],
        commonHeight = _ref3[1];

    var height = calculateLineHeight(l, lineHeight);
    commonHeight += height;

    if (commonHeight < maxHeight) {
      lines.push(l);
    } else {
      l.parts.forEach(function (item) {
        removeTextSpan(item);
      });

      if (textOverflow === 'ellipsis') {
        var prevLine = arr[index - 1];

        if (prevLine) {
          var text = prevLine.parts[prevLine.parts.length - 1];

          if (!text.hasEllipsis) {
            if (ellipsisMaxWidth === 0 || text.endBox < ellipsisMaxWidth) {
              setNewText(text, text.value.length, getEllipsisString(ellipsisMaxWidth, options));
            } else {
              setEllipsis(text, ellipsisMaxWidth, options);
            }
          }
        }
      }
    }

    return [lines, commonHeight];
  }, [[], 0]);

  if (textOverflow === 'hide' && result[1] > maxHeight) {
    result[0].forEach(function (l) {
      l.parts.forEach(function (item) {
        removeTextSpan(item);
      });
    });
    return [];
  }

  return result[0];
}

function applyOverflowRules(element, texts, maxWidth, ellipsisMaxWidth, options) {
  if (!texts) {
    var textValue = element.textContent;
    var text = {
      value: textValue,
      height: 0,
      line: 0
    };
    element.textContent = '';
    createTspans([text], element, 'tspan');
    texts = [text];
  }

  return texts.reduce(function (_ref4, text) {
    var _ref5 = _slicedToArray(_ref4, 5),
        lines = _ref5[0],
        startBox = _ref5[1],
        endBox = _ref5[2],
        stop = _ref5[3],
        lineNumber = _ref5[4];

    var line = lines[lines.length - 1];

    if (stop) {
      return [lines, startBox, endBox, stop];
    }

    if (!line || text.line !== lineNumber) {
      text.startBox = startBox = 0;
      lines.push({
        commonLength: text.value.length,
        parts: [text]
      });
    } else {
      text.startBox = startBox;

      if (startBox > ellipsisMaxWidth && options.wordWrap === 'none' && options.textOverflow === 'ellipsis') {
        removeTextSpan(text);
        return [lines, startBox, endBox, stop, lineNumber];
      }

      line.parts.push(text);
      line.commonLength += text.value.length;
    }

    text.endBox = endBox = startBox + getTextWidth(text);
    startBox = endBox;

    if ((0, _type.isDefined)(maxWidth) && endBox > maxWidth) {
      var wordWrapLines = wordWrap(text, maxWidth, ellipsisMaxWidth, options);

      if (!wordWrapLines.length) {
        lines = [];
        stop = true;
      } else {
        lines = lines.concat(wordWrapLines.filter(function (l) {
          return l.parts.length > 0;
        }));
      }
    }

    return [lines, startBox, endBox, stop, text.line];
  }, [[], 0, 0, false, 0])[0];
}

function setNewText(text, index) {
  var insertString = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ELLIPSIS;
  var newText = text.value.substr(0, index) + insertString;
  text.value = text.tspan.textContent = newText;
  text.stroke && (text.stroke.textContent = newText);

  if (insertString === ELLIPSIS) {
    text.hasEllipsis = true;
  }
}

function removeTextSpan(text) {
  text.tspan.parentNode && text.tspan.parentNode.removeChild(text.tspan);
  text.stroke && text.stroke.parentNode && text.stroke.parentNode.removeChild(text.stroke);
}

function createTextNodes(wrapper, text, isStroked) {
  var items;
  var parsedHtml;
  wrapper._texts = null;
  wrapper.clear();
  if (text === null) return;
  text = '' + text;

  if (!wrapper.renderer.encodeHtml && (/<[a-z][\s\S]*>/i.test(text) || text.indexOf('&') !== -1)) {
    parsedHtml = removeExtraAttrs(text);
    items = parseHTML(parsedHtml);
  } else if (/\n/g.test(text)) {
    items = parseMultiline(text);
  } else if (isStroked) {
    items = [{
      value: text.trim(),
      height: 0
    }];
  }

  if (items) {
    if (items.length) {
      // T227388
      wrapper._texts = items;

      if (isStroked) {
        createTspans(items, wrapper.element, KEY_STROKE);
      }

      createTspans(items, wrapper.element, 'tspan');
    }
  } else {
    wrapper.element.appendChild(_dom_adapter.default.createTextNode(text));
  }
}

function setTextNodeAttribute(item, name, value) {
  item.tspan.setAttribute(name, value);
  item.stroke && item.stroke.setAttribute(name, value);
}

function getItemLineHeight(item, defaultValue) {
  return item.inherits ? maxLengthFontSize(item.height, defaultValue) : item.height || defaultValue;
}

function locateTextNodes(wrapper) {
  if (!wrapper._texts) return;
  var items = wrapper._texts;
  var x = wrapper._settings.x;

  var lineHeight = wrapper._getLineHeight();

  var i;
  var ii;
  var item = items[0];
  setTextNodeAttribute(item, 'x', x);
  setTextNodeAttribute(item, 'y', wrapper._settings.y);

  for (i = 1, ii = items.length; i < ii; ++i) {
    item = items[i];

    if (parseFloat(item.height) >= 0) {
      setTextNodeAttribute(item, 'x', x);
      var height = getItemLineHeight(item, lineHeight);
      setTextNodeAttribute(item, 'dy', height); // T177039
    }
  }
}

function alignTextNodes(wrapper, alignment) {
  if (!wrapper._texts || alignment === 'center') {
    return;
  }

  var items = wrapper._texts;
  var direction = alignment === 'left' ? -1 : 1;
  var maxTextWidth = Math.max.apply(Math, items.map(function (t) {
    return getTextWidth(t);
  }));

  for (var i = 0; i < items.length; i++) {
    var item = items[i];
    var textWidth = getTextWidth(item);

    if (maxTextWidth !== 0 && maxTextWidth !== textWidth) {
      setTextNodeAttribute(item, 'dx', direction * round((maxTextWidth - textWidth) / 2 * 10) / 10);
    }
  }
}

function maxLengthFontSize(fontSize1, fontSize2) {
  var parsedHeight1 = parseFloat(fontSize1);
  var parsedHeight2 = parseFloat(fontSize2);
  var height1 = parsedHeight1 || DEFAULT_FONT_SIZE;
  var height2 = parsedHeight2 || DEFAULT_FONT_SIZE;
  return height1 > height2 ? !isNaN(parsedHeight1) ? fontSize1 : height1 : !isNaN(parsedHeight2) ? fontSize2 : height2;
}

function strokeTextNodes(wrapper) {
  if (!wrapper._texts) return;
  var items = wrapper._texts;
  var stroke = wrapper._settings[KEY_STROKE];
  var strokeWidth = wrapper._settings[KEY_STROKE_WIDTH];
  var strokeOpacity = wrapper._settings[KEY_STROKE_OPACITY] || 1;
  var tspan;
  var i;
  var ii;

  for (i = 0, ii = items.length; i < ii; ++i) {
    tspan = items[i].stroke;
    tspan.setAttribute(KEY_STROKE, stroke);
    tspan.setAttribute(KEY_STROKE_WIDTH, strokeWidth);
    tspan.setAttribute(KEY_STROKE_OPACITY, strokeOpacity);
    tspan.setAttribute('stroke-linejoin', 'round');
  }
}

function baseAnimate(that, params, options, complete) {
  options = options || {};
  var key;
  var value;
  var renderer = that.renderer;
  var settings = that._settings;
  var animationParams = {};
  var defaults = {
    translateX: 0,
    translateY: 0,
    scaleX: 1,
    scaleY: 1,
    rotate: 0,
    rotateX: 0,
    rotateY: 0
  };

  if (complete) {
    options.complete = complete;
  }

  if (renderer.animationEnabled()) {
    for (key in params) {
      value = params[key];

      if (/^(translate(X|Y)|rotate[XY]?|scale(X|Y))$/i.test(key)) {
        animationParams.transform = animationParams.transform || {
          from: {},
          to: {}
        };
        animationParams.transform.from[key] = key in settings ? Number(settings[key].toFixed(3)) : defaults[key]; // T338486

        animationParams.transform.to[key] = value;
      } else if (key === 'arc' || key === 'segments') {
        animationParams[key] = value;
      } else {
        animationParams[key] = {
          from: key in settings ? settings[key] : parseFloat(that.element.getAttribute(key) || 0),
          to: value
        };
      }
    }

    renderer.animateElement(that, animationParams, extend(extend({}, renderer._animation), options));
  } else {
    options.step && options.step.call(that, 1, 1);
    options.complete && options.complete.call(that);
    that.attr(params);
  }

  return that;
}

function pathAnimate(params, options, complete) {
  var that = this;
  var curSegments = that.segments || [];
  var newSegments;
  var endSegments;

  if (that.renderer.animationEnabled() && 'points' in params) {
    newSegments = buildPathSegments(params.points, that.type);
    endSegments = compensateSegments(curSegments, newSegments, that.type);
    params.segments = {
      from: curSegments,
      to: newSegments,
      end: endSegments
    };
    delete params.points;
  }

  return baseAnimate(that, params, options, complete);
}

function arcAnimate(params, options, complete) {
  var that = this;
  var settings = that._settings;
  var arcParams = {
    from: {},
    to: {}
  };

  if (that.renderer.animationEnabled() && ('x' in params || 'y' in params || 'innerRadius' in params || 'outerRadius' in params || 'startAngle' in params || 'endAngle' in params)) {
    arcParams.from.x = settings.x || 0;
    arcParams.from.y = settings.y || 0;
    arcParams.from.innerRadius = settings.innerRadius || 0;
    arcParams.from.outerRadius = settings.outerRadius || 0;
    arcParams.from.startAngle = settings.startAngle || 0;
    arcParams.from.endAngle = settings.endAngle || 0;
    arcParams.to.x = 'x' in params ? params.x : settings.x;
    delete params.x;
    arcParams.to.y = 'y' in params ? params.y : settings.y;
    delete params.y;
    arcParams.to.innerRadius = 'innerRadius' in params ? params.innerRadius : settings.innerRadius;
    delete params.innerRadius;
    arcParams.to.outerRadius = 'outerRadius' in params ? params.outerRadius : settings.outerRadius;
    delete params.outerRadius;
    arcParams.to.startAngle = 'startAngle' in params ? params.startAngle : settings.startAngle;
    delete params.startAngle;
    arcParams.to.endAngle = 'endAngle' in params ? params.endAngle : settings.endAngle;
    delete params.endAngle;
    params.arc = arcParams;
  }

  return baseAnimate(that, params, options, complete);
}

function buildLink(target, parameters) {
  var obj = {
    is: false,
    name: parameters.name || parameters,
    after: parameters.after
  };

  if (target) {
    obj.to = target;
  } else {
    obj.virtual = true;
  }

  return obj;
} // SvgElement


var SvgElement = function SvgElement(renderer, tagName, type) {
  var that = this;
  that.renderer = renderer;
  that.element = createElement(tagName);
  that._settings = {};
  that._styles = {};

  if (tagName === 'path') {
    that.type = type || 'line';
  }
};

exports.SvgElement = SvgElement;

function removeFuncIriCallback(callback) {
  fixFuncIriCallbacks.remove(callback);
}

SvgElement.prototype = {
  constructor: SvgElement,
  _getJQElement: function _getJQElement() {
    return this._$element || (this._$element = (0, _renderer.default)(this.element));
  },
  _addFixIRICallback: function _addFixIRICallback() {
    var that = this;

    var fn = function fn() {
      fixFuncIri(that, 'fill');
      fixFuncIri(that, 'clip-path');
      fixFuncIri(that, 'filter');
    };

    that.element._fixFuncIri = fn;
    fn.renderer = that.renderer;
    fixFuncIriCallbacks.add(fn);

    that._addFixIRICallback = function () {};
  },
  _clearChildrenFuncIri: function _clearChildrenFuncIri() {
    var clearChildren = function clearChildren(element) {
      var i;

      for (i = 0; i < element.childNodes.length; i++) {
        removeFuncIriCallback(element.childNodes[i]._fixFuncIri);
        clearChildren(element.childNodes[i]);
      }
    };

    clearChildren(this.element);
  },
  dispose: function dispose() {
    removeFuncIriCallback(this.element._fixFuncIri);

    this._clearChildrenFuncIri();

    this._getJQElement().remove();

    return this;
  },
  append: function append(parent) {
    (parent || this.renderer.root).element.appendChild(this.element);
    return this;
  },
  remove: function remove() {
    var element = this.element;
    element.parentNode && element.parentNode.removeChild(element);
    return this;
  },
  // NOTE: Though it is not actually required I think it would be better to explicitly declare usage of link mechanism
  enableLinks: function enableLinks() {
    this._links = [];
    return this;
  },
  virtualLink: function virtualLink(parameters) {
    linkItem({
      _link: buildLink(null, parameters)
    }, this);
    return this;
  },
  linkAfter: function linkAfter(name) {
    this._linkAfter = name;
    return this;
  },
  linkOn: function linkOn(target, parameters) {
    this._link = buildLink(target, parameters);
    linkItem(this, target);
    return this;
  },
  linkOff: function linkOff() {
    unlinkItem(this);
    this._link = null;
    return this;
  },
  // It might be better to traverse list to start (not to end) as widget components more likely will be rendered in the same order as they were created
  linkAppend: function linkAppend() {
    var link = this._link;
    var items = link.to._links;
    var i;
    var next;

    for (i = link.i + 1; (next = items[i]) && !next._link.is; ++i) {
      ;
    }

    this._insert(link.to, next);

    link.is = true;
    return this;
  },
  // The method exists only for being overridden in vml
  _insert: function _insert(parent, next) {
    parent.element.insertBefore(this.element, next ? next.element : null);
  },
  linkRemove: function linkRemove() {
    this.remove();
    this._link.is = false;
    return this;
  },
  clear: function clear() {
    this._clearChildrenFuncIri(); // T711457


    this._getJQElement().empty();

    return this;
  },
  toBackground: function toBackground() {
    var elem = this.element;
    var parent = elem.parentNode;
    parent && parent.insertBefore(elem, parent.firstChild);
    return this;
  },
  toForeground: function toForeground() {
    var elem = this.element;
    var parent = elem.parentNode;
    parent && parent.appendChild(elem);
    return this;
  },
  attr: function attr(attrs) {
    return baseAttr(this, attrs);
  },
  smartAttr: function smartAttr(attrs) {
    return this.attr(processHatchingAttrs(this, attrs));
  },
  css: function css(styles) {
    return baseCss(this, styles);
  },
  animate: function animate(params, options, complete) {
    return baseAnimate(this, params, options, complete);
  },
  sharp: function sharp(pos, sharpDirection) {
    return this.attr({
      sharp: pos || true,
      sharpDirection: sharpDirection
    });
  },
  _applyTransformation: function _applyTransformation() {
    var tr = this._settings;
    var rotateX;
    var rotateY;
    var transformations = [];
    var sharpMode = tr.sharp;
    var trDirection = tr.sharpDirection || 1;
    var strokeOdd = tr[KEY_STROKE_WIDTH] % 2;
    var correctionX = strokeOdd && (sharpMode === 'h' || sharpMode === true) ? SHARPING_CORRECTION * trDirection : 0;
    var correctionY = strokeOdd && (sharpMode === 'v' || sharpMode === true) ? SHARPING_CORRECTION * trDirection : 0;
    transformations.push('translate(' + ((tr.translateX || 0) + correctionX) + ',' + ((tr.translateY || 0) + correctionY) + ')');

    if (tr.rotate) {
      if ('rotateX' in tr) {
        rotateX = tr.rotateX;
      } else {
        rotateX = tr.x;
      }

      if ('rotateY' in tr) {
        rotateY = tr.rotateY;
      } else {
        rotateY = tr.y;
      }

      transformations.push('rotate(' + tr.rotate + ',' + (rotateX || 0) + ',' + (rotateY || 0) + ')');
    }

    var scaleXDefined = (0, _type.isDefined)(tr.scaleX);
    var scaleYDefined = (0, _type.isDefined)(tr.scaleY);

    if (scaleXDefined || scaleYDefined) {
      transformations.push('scale(' + (scaleXDefined ? tr.scaleX : 1) + ',' + (scaleYDefined ? tr.scaleY : 1) + ')');
    }

    if (transformations.length) {
      this.element.setAttribute('transform', transformations.join(' '));
    }
  },
  move: function move(x, y, animate, animOptions) {
    var obj = {};
    (0, _type.isDefined)(x) && (obj.translateX = x);
    (0, _type.isDefined)(y) && (obj.translateY = y);

    if (!animate) {
      this.attr(obj);
    } else {
      this.animate(obj, animOptions);
    }

    return this;
  },
  rotate: function rotate(angle, x, y, animate, animOptions) {
    var obj = {
      rotate: angle || 0
    };
    (0, _type.isDefined)(x) && (obj.rotateX = x);
    (0, _type.isDefined)(y) && (obj.rotateY = y);

    if (!animate) {
      this.attr(obj);
    } else {
      this.animate(obj, animOptions);
    }

    return this;
  },
  _getElementBBox: function _getElementBBox() {
    var elem = this.element;
    var bBox;

    try {
      bBox = elem.getBBox && elem.getBBox();
    } catch (e) {}

    return bBox || {
      x: 0,
      y: 0,
      width: elem.offsetWidth || 0,
      height: elem.offsetHeight || 0
    };
  },
  // TODO do we need to round results and consider rotation coordinates?
  getBBox: function getBBox() {
    var transformation = this._settings;

    var bBox = this._getElementBBox();

    if (transformation.rotate) {
      bBox = (0, _utils.rotateBBox)(bBox, [('rotateX' in transformation ? transformation.rotateX : transformation.x) || 0, ('rotateY' in transformation ? transformation.rotateY : transformation.y) || 0], -transformation.rotate); // Angle is transformed from svg to right-handed cartesian space
    } else {
      bBox = (0, _utils.normalizeBBox)(bBox);
    }

    return bBox;
  },
  markup: function markup() {
    return (0, _svg.getSvgMarkup)(this.element);
  },
  getOffset: function getOffset() {
    return this._getJQElement().offset();
  },
  stopAnimation: function stopAnimation(disableComplete) {
    var animation = this.animation;
    animation && animation.stop(disableComplete);
    return this;
  },
  setTitle: function setTitle(text) {
    var titleElem = createElement('title');
    titleElem.textContent = text || '';
    this.element.appendChild(titleElem);
  },
  removeTitle: function removeTitle() {
    detachTitleElements(this.element);
  },
  data: function data(obj, val) {
    var elem = this.element;
    var key;

    if (val !== undefined) {
      elem[obj] = val;
    } else {
      for (key in obj) {
        elem[key] = obj[key];
      }
    }

    return this;
  },
  on: function on() {
    var args = [this._getJQElement()];
    args.push.apply(args, arguments);

    _events_engine.default.on.apply(_events_engine.default, args);

    return this;
  },
  off: function off() {
    var args = [this._getJQElement()];
    args.push.apply(args, arguments);

    _events_engine.default.off.apply(_events_engine.default, args);

    return this;
  },
  trigger: function trigger() {
    var args = [this._getJQElement()];
    args.push.apply(args, arguments);

    _events_engine.default.trigger.apply(_events_engine.default, args);

    return this;
  }
}; // SvgElement
// PathSvgElement

var PathSvgElement = function PathSvgElement(renderer, type) {
  SvgElement.call(this, renderer, 'path', type);
};

exports.PathSvgElement = PathSvgElement;
PathSvgElement.prototype = objectCreate(SvgElement.prototype);
extend(PathSvgElement.prototype, {
  constructor: PathSvgElement,
  attr: pathAttr,
  animate: pathAnimate
}); // PathSvgElement
// ArcSvgElement

var ArcSvgElement = function ArcSvgElement(renderer) {
  SvgElement.call(this, renderer, 'path', 'arc');
};

exports.ArcSvgElement = ArcSvgElement;
ArcSvgElement.prototype = objectCreate(SvgElement.prototype);
extend(ArcSvgElement.prototype, {
  constructor: ArcSvgElement,
  attr: arcAttr,
  animate: arcAnimate
}); // ArcSvgElement
// RectSvgElement

var RectSvgElement = function RectSvgElement(renderer) {
  SvgElement.call(this, renderer, 'rect');
};

exports.RectSvgElement = RectSvgElement;
RectSvgElement.prototype = objectCreate(SvgElement.prototype);
extend(RectSvgElement.prototype, {
  constructor: RectSvgElement,
  attr: rectAttr
}); // RectSvgElement
// TextSvgElement

var TextSvgElement = function TextSvgElement(renderer) {
  SvgElement.call(this, renderer, 'text');
  this.css({
    'white-space': 'pre'
  });
};

exports.TextSvgElement = TextSvgElement;
TextSvgElement.prototype = objectCreate(SvgElement.prototype);
extend(TextSvgElement.prototype, {
  constructor: TextSvgElement,
  attr: textAttr,
  css: textCss,
  applyEllipsis: applyEllipsis,
  setMaxSize: setMaxSize,
  restoreText: restoreText,
  _getLineHeight: function _getLineHeight() {
    return !isNaN(parseFloat(this._styles[KEY_FONT_SIZE])) ? this._styles[KEY_FONT_SIZE] : DEFAULT_FONT_SIZE;
  }
}); // TextSvgElement

function updateIndexes(items, k) {
  var i;
  var item;

  for (i = k; item = items[i]; ++i) {
    item._link.i = i;
  }
}

function linkItem(target, container) {
  var items = container._links;
  var key = target._link.after = target._link.after || container._linkAfter;
  var i;
  var item;

  if (key) {
    for (i = 0; (item = items[i]) && item._link.name !== key; ++i) {
      ;
    }

    if (item) {
      for (++i; (item = items[i]) && item._link.after === key; ++i) {
        ;
      }
    }
  } else {
    i = items.length;
  }

  items.splice(i, 0, target);
  updateIndexes(items, i);
}

function unlinkItem(target) {
  var i;
  var items = target._link.to._links;

  for (i = 0; items[i] !== target; ++i) {
    ;
  }

  items.splice(i, 1);
  updateIndexes(items, i);
}

function Renderer(options) {
  var that = this;
  that.root = that._createElement('svg', {
    xmlns: 'http://www.w3.org/2000/svg',
    version: '1.1',
    // Backward compatibility
    fill: NONE,
    stroke: NONE,
    'stroke-width': 0
  }).attr({
    'class': options.cssClass
  }).css({
    'line-height': 'normal',
    // T179515
    '-ms-user-select': NONE,
    '-moz-user-select': NONE,
    '-webkit-user-select': NONE,
    '-webkit-tap-highlight-color': 'rgba(0, 0, 0, 0)',
    display: 'block',
    overflow: 'hidden'
  });

  that._init();

  that.pathModified = !!options.pathModified;
  that._$container = (0, _renderer.default)(options.container);
  that.root.append({
    element: options.container
  });
  that.fixPlacement();
  that._locker = 0;
  that._backed = false;
}

Renderer.prototype = {
  constructor: Renderer,
  _init: function _init() {
    var that = this;
    that._defs = that._createElement('defs').append(that.root);
    that._animationController = new _animation.AnimationController(that.root.element);
    that._animation = {
      enabled: true,
      duration: 1000,
      easing: 'easeOutCubic'
    };
  },
  fixPlacement: function fixPlacement() {
    if (!_browser.default.mozilla && !_browser.default.msie) {
      return;
    }

    var box = getBoundingClientRect(this._$container.get(0));
    var dx = roundValue(box.left % 1, 2);
    var dy = roundValue(box.top % 1, 2);

    if (_browser.default.msie) {
      this.root.css({
        transform: 'translate(' + -dx + 'px,' + -dy + 'px)'
      });
    } else if (_browser.default.mozilla) {
      this.root.move(-dx, -dy);
    }
  },
  removePlacementFix: function removePlacementFix() {
    if (!_browser.default.mozilla && !_browser.default.msie) {
      return;
    }

    if (_browser.default.msie) {
      this.root.css({
        transform: ''
      });
    } else if (_browser.default.mozilla) {
      this.root.attr({
        transform: null
      });
    }
  },
  setOptions: function setOptions(options) {
    var that = this;
    that.rtl = !!options.rtl;
    that.encodeHtml = !!options.encodeHtml;
    that.updateAnimationOptions(options.animation || {});
    that.root.attr({
      direction: that.rtl ? 'rtl' : 'ltr'
    });
    return that;
  },
  _createElement: function _createElement(tagName, attr, type) {
    var elem = new SvgElement(this, tagName, type);
    attr && elem.attr(attr);
    return elem;
  },
  lock: function lock() {
    var that = this;

    if (that._locker === 0) {
      that._backed = !that._$container.is(':visible');

      if (that._backed) {
        backupRoot(that.root);
      }
    }

    ++that._locker;
    return that;
  },
  unlock: function unlock() {
    var that = this;
    --that._locker;

    if (that._locker === 0) {
      if (that._backed) {
        restoreRoot(that.root, that._$container[0]);
        that.fixPlacement();
      }

      that._backed = false;
    }

    return that;
  },
  resize: function resize(width, height) {
    if (width >= 0 && height >= 0) {
      this.root.attr({
        width: width,
        height: height
      });
    }

    return this;
  },
  dispose: function dispose() {
    var that = this;
    var key;
    that.root.dispose();

    that._defs.dispose();

    that._animationController.dispose();

    fixFuncIriCallbacks.removeByRenderer(that);

    for (key in that) {
      that[key] = null;
    }

    return that;
  },
  animationEnabled: function animationEnabled() {
    return !!this._animation.enabled;
  },
  updateAnimationOptions: function updateAnimationOptions(newOptions) {
    extend(this._animation, newOptions);
    return this;
  },
  stopAllAnimations: function stopAllAnimations(lock) {
    this._animationController[lock ? 'lock' : 'stop']();

    return this;
  },
  animateElement: function animateElement(element, params, options) {
    this._animationController.animateElement(element, params, options);

    return this;
  },
  svg: function svg() {
    this.removePlacementFix();
    var markup = this.root.markup();
    this.fixPlacement();
    return markup;
  },
  getRootOffset: function getRootOffset() {
    return this.root.getOffset();
  },
  onEndAnimation: function onEndAnimation(endAnimation) {
    this._animationController.onEndAnimation(endAnimation);
  },
  rect: function rect(x, y, width, height) {
    var elem = new RectSvgElement(this);
    return elem.attr({
      x: x || 0,
      y: y || 0,
      width: width || 0,
      height: height || 0
    });
  },
  simpleRect: function simpleRect() {
    return this._createElement('rect');
  },
  circle: function circle(x, y, r) {
    return this._createElement('circle', {
      cx: x || 0,
      cy: y || 0,
      r: r || 0
    });
  },
  g: function g() {
    return this._createElement('g');
  },
  image: function image(x, y, w, h, href, location) {
    var image = this._createElement('image', {
      x: x || 0,
      y: y || 0,
      width: w || 0,
      height: h || 0,
      preserveAspectRatio: preserveAspectRatioMap[(0, _utils.normalizeEnum)(location)] || NONE
    });

    image.element.setAttributeNS('http://www.w3.org/1999/xlink', 'href', href || '');
    return image;
  },
  // to combine different d attributes use helper methods
  path: function path(points, type) {
    var elem = new PathSvgElement(this, type);
    return elem.attr({
      points: points || []
    });
  },
  // TODO check B232257
  // TODO animate end angle special case
  arc: function arc(x, y, innerRadius, outerRadius, startAngle, endAngle) {
    var elem = new ArcSvgElement(this);
    return elem.attr({
      x: x || 0,
      y: y || 0,
      innerRadius: innerRadius || 0,
      outerRadius: outerRadius || 0,
      startAngle: startAngle || 0,
      endAngle: endAngle || 0
    });
  },
  text: function text(_text, x, y) {
    var elem = new TextSvgElement(this);
    return elem.attr({
      text: _text,
      x: x || 0,
      y: y || 0
    });
  },
  linearGradient: function linearGradient(stops) {
    var id = getNextDefsSvgId();
    var that = this;

    var gradient = that._createElement('linearGradient', {
      id: id
    }).append(that._defs);

    gradient.id = id;
    stops.forEach(function (stop) {
      that._createElement('stop', {
        offset: stop.offset,
        'stop-color': stop['stop-color']
      }).append(gradient);
    });
    return gradient;
  },
  // appended automatically
  pattern: function pattern(color, hatching, _id) {
    hatching = hatching || {};
    var that = this;
    var step = hatching.step || 6;
    var stepTo2 = step / 2;
    var stepBy15 = step * 1.5;

    var id = _id || getNextDefsSvgId();

    var d = (0, _utils.normalizeEnum)(hatching.direction) === 'right' ? 'M ' + stepTo2 + ' ' + -stepTo2 + ' L ' + -stepTo2 + ' ' + stepTo2 + ' M 0 ' + step + ' L ' + step + ' 0 M ' + stepBy15 + ' ' + stepTo2 + ' L ' + stepTo2 + ' ' + stepBy15 : 'M 0 0 L ' + step + ' ' + step + ' M ' + -stepTo2 + ' ' + stepTo2 + ' L ' + stepTo2 + ' ' + stepBy15 + ' M ' + stepTo2 + ' ' + -stepTo2 + ' L ' + stepBy15 + ' ' + stepTo2;

    var pattern = that._createElement('pattern', {
      id: id,
      width: step,
      height: step,
      patternUnits: 'userSpaceOnUse'
    }).append(that._defs);

    pattern.id = id;
    var rect = that.rect(0, 0, step, step).attr({
      fill: color,
      opacity: hatching.opacity
    }).append(pattern);
    var path = new PathSvgElement(this).attr({
      d: d,
      'stroke-width': hatching.width || 1,
      stroke: color
    }).append(pattern);
    return pattern;
  },
  _getPointsWithYOffset: function _getPointsWithYOffset(points, offset) {
    return points.map(function (point, index) {
      if (index % 2 !== 0) {
        return point + offset;
      }

      return point;
    });
  },
  // appended automatically
  clipShape: function clipShape(method, methodArgs) {
    var that = this;
    var id = getNextDefsSvgId();

    var clipPath = that._createElement('clipPath', {
      id: id
    }).append(that._defs);

    var shape = method.apply(that, methodArgs).append(clipPath);
    shape.id = id;

    shape.remove = function () {
      throw 'Not implemented';
    };

    shape.dispose = function () {
      clipPath.dispose();
      clipPath = null;
      return this;
    };

    return shape;
  },
  // appended automatically
  clipRect: function clipRect(x, y, width, height) {
    return this.clipShape(this.rect, arguments);
  },
  // appended automatically
  clipCircle: function clipCircle(x, y, radius) {
    return this.clipShape(this.circle, arguments);
  },
  // appended automatically
  shadowFilter: function shadowFilter(x, y, width, height, offsetX, offsetY, blur, color, opacity) {
    var that = this;
    var id = getNextDefsSvgId();

    var filter = that._createElement('filter', {
      id: id,
      x: x || 0,
      y: y || 0,
      width: width || 0,
      height: height || 0
    }).append(that._defs);

    var gaussianBlur = that._createElement('feGaussianBlur', {
      'in': 'SourceGraphic',
      'result': 'gaussianBlurResult',
      'stdDeviation': blur || 0
    }).append(filter);

    var offset = that._createElement('feOffset', {
      'in': 'gaussianBlurResult',
      'result': 'offsetResult',
      'dx': offsetX || 0,
      'dy': offsetY || 0
    }).append(filter);

    var flood = that._createElement('feFlood', {
      'result': 'floodResult',
      'flood-color': color || '',
      'flood-opacity': opacity
    }).append(filter);

    var composite = that._createElement('feComposite', {
      'in': 'floodResult',
      'in2': 'offsetResult',
      'operator': 'in',
      'result': 'compositeResult'
    }).append(filter);

    var finalComposite = that._createElement('feComposite', {
      'in': 'SourceGraphic',
      'in2': 'compositeResult',
      'operator': 'over'
    }).append(filter);

    filter.id = id;
    filter.gaussianBlur = gaussianBlur;
    filter.offset = offset;
    filter.flood = flood;
    filter.composite = composite;
    filter.finalComposite = finalComposite;

    filter.attr = function (attrs) {
      var that = this;
      var filterAttrs = {};
      var offsetAttrs = {};
      var floodAttrs = {};
      'x' in attrs && (filterAttrs.x = attrs.x);
      'y' in attrs && (filterAttrs.y = attrs.y);
      'width' in attrs && (filterAttrs.width = attrs.width);
      'height' in attrs && (filterAttrs.height = attrs.height);
      baseAttr(that, filterAttrs);
      'blur' in attrs && that.gaussianBlur.attr({
        'stdDeviation': attrs.blur
      });
      'offsetX' in attrs && (offsetAttrs.dx = attrs.offsetX);
      'offsetY' in attrs && (offsetAttrs.dy = attrs.offsetY);
      that.offset.attr(offsetAttrs);
      'color' in attrs && (floodAttrs['flood-color'] = attrs.color);
      'opacity' in attrs && (floodAttrs['flood-opacity'] = attrs.opacity);
      that.flood.attr(floodAttrs);
      return that;
    };

    return filter;
  },
  brightFilter: function brightFilter(type, slope) {
    var that = this;
    var id = getNextDefsSvgId();

    var filter = that._createElement('filter', {
      id: id
    }).append(that._defs);

    var componentTransferElement = that._createElement('feComponentTransfer').append(filter);

    var attrs = {
      type: type,
      slope: slope
    };
    filter.id = id;

    that._createElement('feFuncR', attrs).append(componentTransferElement);

    that._createElement('feFuncG', attrs).append(componentTransferElement);

    that._createElement('feFuncB', attrs).append(componentTransferElement);

    return filter;
  },
  getGrayScaleFilter: function getGrayScaleFilter() {
    if (this._grayScaleFilter) {
      return this._grayScaleFilter;
    }

    var that = this;
    var id = getNextDefsSvgId();

    var filter = that._createElement('filter', {
      id: id
    }).append(that._defs);

    that._createElement('feColorMatrix').attr({
      type: 'matrix',
      values: '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 0.6 0'
    }).append(filter);

    filter.id = id;
    that._grayScaleFilter = filter;
    return filter;
  },
  initHatching: function initHatching() {
    var storage = this._hatchingStorage = this._hatchingStorage || {
      byHash: {},
      baseId: getNextDefsSvgId()
    };
    var byHash = storage.byHash;
    var name;

    for (name in byHash) {
      byHash[name].pattern.dispose();
    }

    storage.byHash = {};
    storage.refToHash = {};
    storage.nextId = 0;
  },
  lockHatching: function lockHatching(color, hatching, ref) {
    var storage = this._hatchingStorage;
    var hash = getHatchingHash(color, hatching);
    var storageItem;
    var pattern;

    if (storage.refToHash[ref] !== hash) {
      if (ref) {
        this.releaseHatching(ref);
      }

      storageItem = storage.byHash[hash];

      if (!storageItem) {
        pattern = this.pattern(color, hatching, storage.baseId + '-hatching-' + storage.nextId++);
        storageItem = storage.byHash[hash] = {
          pattern: pattern,
          count: 0
        };
        storage.refToHash[pattern.id] = hash;
      }

      ++storageItem.count;
      ref = storageItem.pattern.id;
    }

    return ref;
  },
  releaseHatching: function releaseHatching(ref) {
    var storage = this._hatchingStorage;
    var hash = storage.refToHash[ref];
    var storageItem = storage.byHash[hash];

    if (storageItem && --storageItem.count === 0) {
      storageItem.pattern.dispose();
      delete storage.byHash[hash];
      delete storage.refToHash[ref];
    }
  }
};

function getHatchingHash(color, hatching) {
  return '@' + color + '::' + hatching.step + ':' + hatching.width + ':' + hatching.opacity + ':' + hatching.direction;
} // paths modifier


var fixFuncIriCallbacks = function () {
  var callbacks = [];
  return {
    add: function add(fn) {
      callbacks.push(fn);
    },
    remove: function remove(fn) {
      callbacks = callbacks.filter(function (el) {
        return el !== fn;
      });
    },
    removeByRenderer: function removeByRenderer(renderer) {
      callbacks = callbacks.filter(function (el) {
        return el.renderer !== renderer;
      });
    },
    fire: function fire() {
      callbacks.forEach(function (fn) {
        fn();
      });
    }
  };
}();

var refreshPaths = function refreshPaths() {
  fixFuncIriCallbacks.fire();
};

exports.refreshPaths = refreshPaths;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.expand = expand;
exports.changes = changes;
exports.replaceInherit = void 0;

var _extend2 = __webpack_require__(0);

var _window = __webpack_require__(7);

var _common = __webpack_require__(4);

var isServerSide = !(0, _window.hasWindow)();

function Flags() {
  this.reset();
}

Flags.prototype = {
  constructor: Flags,
  add: function add(codes) {
    var i;
    var ii = codes.length;
    var flags = this._flags;

    for (i = 0; i < ii; ++i) {
      flags[codes[i]] = 1;
    }
  },
  has: function has(code) {
    return this._flags[code] > 0;
  },
  count: function count() {
    return Object.keys(this._flags).length;
  },
  reset: function reset() {
    this._flags = {};
  }
};

function combineMaps(baseMap, thisMap) {
  return baseMap !== thisMap ? (0, _extend2.extend)({}, baseMap, thisMap) : (0, _extend2.extend)({}, baseMap);
}

function combineLists(baseList, thisList) {
  return baseList !== thisList ? baseList.concat(thisList) : baseList.slice();
}

function buildTotalChanges(proto) {
  proto._totalChangesOrder = proto._optionChangesOrder.concat(proto._layoutChangesOrder, proto._customChangesOrder);
}

function addChange(settings) {
  var proto = this.prototype;
  var code = settings.code;
  proto['_change_' + code] = settings.handler;

  if (settings.isThemeDependent) {
    proto._themeDependentChanges.push(code);
  }

  if (settings.option) {
    proto._optionChangesMap[settings.option] = code;
  }

  (settings.isOptionChange ? proto._optionChangesOrder : proto._customChangesOrder).push(code);
  buildTotalChanges(proto);
}

function createChainExecutor() {
  var executeChain = function executeChain() {
    var i;
    var ii = executeChain._chain.length;
    var result;

    for (i = 0; i < ii; ++i) {
      result = executeChain._chain[i].apply(this, arguments);
    }

    return result;
  };

  executeChain._chain = [];

  executeChain.add = function (item) {
    executeChain._chain.push(item);
  };

  executeChain.copy = function (executor) {
    executeChain._chain = executor._chain.slice();
  };

  return executeChain;
}

function expand(target, name, expander) {
  var current = target[name];

  if (!current) {
    current = expander;
  } else {
    if (!current.add) {
      current = createChainExecutor();
      current.add(target[name]);
      current.add(expander);
    } else {
      if (Object.prototype.hasOwnProperty.call(target, name) === false) {
        current = createChainExecutor();
        current.copy(target[name]);
      }

      current.add(expander);
    }
  }

  target[name] = current;
}

function addPlugin(plugin) {
  var proto = this.prototype;

  proto._plugins.push(plugin);

  plugin.fontFields && proto._fontFields.push.apply(proto._fontFields, plugin.fontFields);

  if (plugin.members) {
    (0, _extend2.extend)(this.prototype, plugin.members);
  }

  if (plugin.customize) {
    plugin.customize(this);
  }

  if (plugin.extenders) {
    Object.keys(plugin.extenders).forEach(function (key) {
      var func = plugin.extenders[key];
      expand(proto, key, func);
    }, this);
  }
}

var replaceInherit = isServerSide ? function (widget) {
  var _inherit = widget.inherit;

  widget.inherit = function () {
    var result = _inherit.apply(this, arguments);

    var proto = result.prototype;
    ['_plugins', '_eventsMap', '_initialChanges', '_themeDependentChanges', '_optionChangesMap', '_optionChangesOrder', '_layoutChangesOrder', '_customChangesOrder', '_totalChangesOrder'].forEach(function (key) {
      proto[key] = {};
    });
    result.addPlugin = _common.noop;
    return result;
  };

  widget.addChange = _common.noop;
  widget.addPlugin = _common.noop;
} : function (widget) {
  var _inherit = widget.inherit;

  widget.inherit = function () {
    var proto = this.prototype;
    var plugins = proto._plugins;
    var fontFields = proto._fontFields;
    var eventsMap = proto._eventsMap;
    var initialChanges = proto._initialChanges;
    var themeDependentChanges = proto._themeDependentChanges;
    var optionChangesMap = proto._optionChangesMap;
    var partialOptionChangesMap = proto._partialOptionChangesMap;
    var partialOptionChangesPath = proto._partialOptionChangesPath;
    var optionChangesOrder = proto._optionChangesOrder;
    var layoutChangesOrder = proto._layoutChangesOrder;
    var customChangesOrder = proto._customChangesOrder;

    var result = _inherit.apply(this, arguments);

    proto = result.prototype;
    proto._plugins = combineLists(plugins, proto._plugins);
    proto._fontFields = combineLists(fontFields, proto._fontFields);
    proto._eventsMap = combineMaps(eventsMap, proto._eventsMap);
    proto._initialChanges = combineLists(initialChanges, proto._initialChanges);
    proto._themeDependentChanges = combineLists(themeDependentChanges, proto._themeDependentChanges);
    proto._optionChangesMap = combineMaps(optionChangesMap, proto._optionChangesMap);
    proto._partialOptionChangesMap = combineMaps(partialOptionChangesMap, proto._partialOptionChangesMap);
    proto._partialOptionChangesPath = combineMaps(partialOptionChangesPath, proto._partialOptionChangesPath);
    proto._optionChangesOrder = combineLists(optionChangesOrder, proto._optionChangesOrder);
    proto._layoutChangesOrder = combineLists(layoutChangesOrder, proto._layoutChangesOrder);
    proto._customChangesOrder = combineLists(customChangesOrder, proto._customChangesOrder);
    buildTotalChanges(proto);
    result.addPlugin = addPlugin;
    return result;
  };

  widget.prototype._plugins = [];
  widget.prototype._fontFields = [];
  widget.addChange = addChange;
  widget.addPlugin = addPlugin;
};
exports.replaceInherit = replaceInherit;

function changes() {
  return new Flags();
}

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.polar = exports.chart = void 0;

var _extend2 = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var scatterSeries = _interopRequireWildcard(__webpack_require__(139));

var _area_series = __webpack_require__(209);

var _utils = __webpack_require__(14);

var _type = __webpack_require__(1);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var areaSeries = _area_series.chart.area;
var chartSeries = scatterSeries.chart;
var polarSeries = scatterSeries.polar;
var _extend = _extend2.extend;
var _each = _iterator.each;
var chart = {};
exports.chart = chart;
var polar = {};
exports.polar = polar;
var baseBarSeriesMethods = {
  _createLegendState: function _createLegendState(styleOptions, defaultColor) {
    return {
      fill: styleOptions.color || defaultColor,
      hatching: styleOptions.hatching
    };
  },
  _parsePointStyle: function _parsePointStyle(style, defaultColor, defaultBorderColor) {
    var color = style.color || defaultColor;

    var base = chartSeries._parsePointStyle.call(this, style, color, defaultBorderColor);

    base.fill = color;
    base.hatching = style.hatching;
    base.dashStyle = style.border && style.border.dashStyle || 'solid';
    delete base.r;
    return base;
  },
  _applyMarkerClipRect: function _applyMarkerClipRect(settings) {
    settings['clip-path'] = null;
  },
  _setGroupsSettings: function _setGroupsSettings(animationEnabled, firstDrawing) {
    var that = this;
    var settings = {};

    chartSeries._setGroupsSettings.apply(that, arguments);

    if (animationEnabled && firstDrawing) {
      settings = this._getAffineCoordOptions();
    } else if (!animationEnabled) {
      settings = {
        scaleX: 1,
        scaleY: 1,
        translateX: 0,
        translateY: 0
      };
    }

    that._markersGroup.attr(settings);
  },
  _drawPoint: function _drawPoint(options) {
    options.hasAnimation = options.hasAnimation && !options.firstDrawing;
    options.firstDrawing = false;

    chartSeries._drawPoint.call(this, options);
  },
  _getMainColor: function _getMainColor() {
    return this._options.mainSeriesColor;
  },
  _createPointStyles: function _createPointStyles(pointOptions) {
    var that = this;

    var mainColor = pointOptions.color || that._getMainColor();

    return {
      normal: that._parsePointStyle(pointOptions, mainColor, mainColor),
      hover: that._parsePointStyle(pointOptions.hoverStyle || {}, mainColor, mainColor),
      selection: that._parsePointStyle(pointOptions.selectionStyle || {}, mainColor, mainColor)
    };
  },
  _updatePointsVisibility: function _updatePointsVisibility() {
    var visibility = this._options.visible;
    (0, _iterator.each)(this._points, function (_, point) {
      point._options.visible = visibility;
    });
  },
  _getOptionsForPoint: function _getOptionsForPoint() {
    return this._options;
  },
  _animate: function _animate(firstDrawing) {
    var that = this;

    var complete = function complete() {
      that._animateComplete();
    };

    var animateFunc = function animateFunc(drawnPoints, complete) {
      var lastPointIndex = drawnPoints.length - 1;

      _each(drawnPoints || [], function (i, point) {
        point.animate(i === lastPointIndex ? complete : undefined, point.getMarkerCoords());
      });
    };

    that._animatePoints(firstDrawing, complete, animateFunc);
  },
  getValueRangeInitialValue: areaSeries.getValueRangeInitialValue,
  _patchMarginOptions: function _patchMarginOptions(options) {
    options.checkInterval = !this.useAggregation();
    return options;
  },
  _defaultAggregator: 'sum',
  _defineDrawingState: function _defineDrawingState() {},
  usePointsToDefineAutoHiding: function usePointsToDefineAutoHiding() {
    return false;
  }
};
chart.bar = _extend({}, chartSeries, baseBarSeriesMethods, {
  _getAffineCoordOptions: function _getAffineCoordOptions() {
    var rotated = this._options.rotated;
    var direction = rotated ? 'X' : 'Y';
    var settings = {
      scaleX: rotated ? 0.001 : 1,
      scaleY: rotated ? 1 : 0.001
    };
    settings['translate' + direction] = this.getValueAxis().getTranslator().translate('canvas_position_default');
    return settings;
  },
  _animatePoints: function _animatePoints(firstDrawing, complete, animateFunc) {
    var that = this;

    that._markersGroup.animate({
      scaleX: 1,
      scaleY: 1,
      translateY: 0,
      translateX: 0
    }, undefined, complete);

    if (!firstDrawing) {
      animateFunc(that._drawnPoints, complete);
    }
  },
  checkSeriesViewportCoord: function checkSeriesViewportCoord(axis, coord) {
    if (!chartSeries.checkSeriesViewportCoord.call(this)) {
      return false;
    }

    if (axis.isArgumentAxis) {
      return true;
    }

    var translator = axis.getTranslator();
    var range = this.getViewport();
    var min = translator.translate(range.categories ? range.categories[0] : range.min);
    var max = translator.translate(range.categories ? range.categories[range.categories.length - 1] : range.max);
    var rotated = this.getOptions().rotated;
    var inverted = axis.getOptions().inverted;
    return rotated && !inverted || !rotated && inverted ? coord >= min && coord <= max : coord >= max && coord <= min;
  },
  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {
    var oppositeCoord = null;
    var rotated = this._options.rotated;
    var isOpposite = !isArgument && !rotated || isArgument && rotated;
    var coordName = isOpposite ? 'vy' : 'vx';
    var oppositeCoordName = isOpposite ? 'vx' : 'vy';
    var points = this.getPoints();

    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      var tmpCoord = void 0;

      if (isArgument) {
        tmpCoord = p.getCenterCoord()[coordName[1]] === coord ? p[oppositeCoordName] : undefined;
      } else {
        tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : undefined;
      }

      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
        oppositeCoord = tmpCoord;
        break;
      }
    }

    return oppositeCoord;
  }
});
polar.bar = _extend({}, polarSeries, baseBarSeriesMethods, {
  _animatePoints: function _animatePoints(firstDrawing, complete, animateFunc) {
    animateFunc(this._drawnPoints, complete);
  },
  _setGroupsSettings: chartSeries._setGroupsSettings,
  _drawPoint: function _drawPoint(point, groups, animationEnabled) {
    chartSeries._drawPoint.call(this, point, groups, animationEnabled);
  },
  _parsePointStyle: function _parsePointStyle(style) {
    var base = baseBarSeriesMethods._parsePointStyle.apply(this, arguments);

    base.opacity = style.opacity;
    return base;
  },
  _createGroups: chartSeries._createGroups,
  _setMarkerGroupSettings: function _setMarkerGroupSettings() {
    var that = this;

    var markersSettings = that._createPointStyles(that._getMarkerGroupOptions()).normal;

    markersSettings['class'] = 'dxc-markers';

    that._applyMarkerClipRect(markersSettings);

    var groupSettings = _extend({}, markersSettings);

    delete groupSettings.opacity; // T110796

    that._markersGroup.attr(groupSettings);
  },
  getSeriesPairCoord: function getSeriesPairCoord(params, isArgument) {
    var coords = null;
    var paramName = isArgument ? 'argument' : 'radius';
    var points = this.getVisiblePoints();
    var argAxis = this.getArgumentAxis();
    var startAngle = argAxis.getAngles()[0];

    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      var tmpPoint = (0, _type.isDefined)(p[paramName]) && (0, _type.isDefined)(params[paramName]) && p[paramName].valueOf() === params[paramName].valueOf() ? (0, _utils.convertPolarToXY)(argAxis.getCenter(), startAngle, -argAxis.getTranslatedAngle(p.angle), p.radius) : undefined;

      if ((0, _type.isDefined)(tmpPoint)) {
        coords = tmpPoint;
        break;
      }
    }

    return coords;
  },
  _createLegendState: areaSeries._createLegendState
});

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.plugin = void 0;

var _common = __webpack_require__(4);

var _data_helper = _interopRequireDefault(__webpack_require__(97));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var postCtor = _data_helper.default.postCtor;
var name;
var members = {
  _dataSourceLoadErrorHandler: function _dataSourceLoadErrorHandler() {
    this._dataSourceChangedHandler();
  },
  _dataSourceOptions: function _dataSourceOptions() {
    return {
      paginate: false
    };
  },
  _updateDataSource: function _updateDataSource() {
    this._refreshDataSource();

    if (!this.option('dataSource')) {
      this._dataSourceChangedHandler();
    }
  },
  _dataIsLoaded: function _dataIsLoaded() {
    return !this._dataSource || this._dataSource.isLoaded();
  },
  _dataSourceItems: function _dataSourceItems() {
    return this._dataSource && this._dataSource.items();
  }
};

for (name in _data_helper.default) {
  if (name === 'postCtor') {
    continue;
  }

  members[name] = _data_helper.default[name];
}

var plugin = {
  name: 'data_source',
  init: function init() {
    postCtor.call(this);
  },
  dispose: _common.noop,
  members: members
};
exports.plugin = plugin;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getAlgorithm = getAlgorithm;
exports.addAlgorithm = addAlgorithm;
exports.setDefaultAlgorithm = setDefaultAlgorithm;
exports.buildSidesData = buildSidesData;
exports.calculateRectangles = calculateRectangles;
exports.getStaticSideIndex = void 0;

var _type = __webpack_require__(1);

var _utils = __webpack_require__(14);

var _round = Math.round;
var algorithms = {};
var defaultAlgorithm;

function getAlgorithm(value) {
  return algorithms[(0, _utils.normalizeEnum)(value)] || (0, _type.isFunction)(value) && value || defaultAlgorithm;
}

function addAlgorithm(name, callback) {
  algorithms[name] = callback;
}

function setDefaultAlgorithm(name) {
  defaultAlgorithm = algorithms[name];
}

var directionToIndexOffsets = {};
directionToIndexOffsets[-1] = [2, 0];
directionToIndexOffsets[+1] = [0, 2];

var getStaticSideIndex = function getStaticSideIndex(rect) {
  return rect[2] - rect[0] < rect[3] - rect[1] ? 0 : 1;
};

exports.getStaticSideIndex = getStaticSideIndex;

function buildSidesData(rect, directions, _staticSideIndex) {
  var staticSideIndex = _staticSideIndex !== undefined ? _staticSideIndex : getStaticSideIndex(rect);
  var variedSideIndex = 1 - staticSideIndex;
  var staticSideDirection = directions[staticSideIndex];
  var variedSideDirection = directions[variedSideIndex];
  var staticSideIndexOffsets = directionToIndexOffsets[staticSideDirection];
  var variedSideIndexOffsets = directionToIndexOffsets[variedSideDirection];
  return {
    staticSide: rect[2 + staticSideIndex] - rect[staticSideIndex],
    variedSide: rect[2 + variedSideIndex] - rect[variedSideIndex],
    static1: staticSideIndex + staticSideIndexOffsets[0],
    static2: staticSideIndex + staticSideIndexOffsets[1],
    varied1: variedSideIndex + variedSideIndexOffsets[0],
    varied2: variedSideIndex + variedSideIndexOffsets[1],
    staticDir: staticSideDirection,
    variedDir: variedSideDirection
  };
}

function calculateRectangles(nodes, head, totalRect, sidesData, rowData) {
  var i;
  var ii;
  var variedSidePart = [0, 0, 0, 0];
  var static1 = sidesData.static1;
  var static2 = sidesData.static2;
  var position = totalRect[static1];
  var dir = sidesData.staticDir;
  var side = sidesData.staticSide;
  var sum = rowData.sum;
  var rect;
  var delta;
  variedSidePart[sidesData.varied1] = totalRect[sidesData.varied1];
  variedSidePart[sidesData.varied2] = totalRect[sidesData.varied1] + sidesData.variedDir * rowData.side;

  for (i = head, ii = head + rowData.count; i < ii; ++i) {
    rect = variedSidePart.slice();
    rect[static1] = position;
    delta = _round(side * nodes[i].value / sum) || 0;
    sum -= nodes[i].value;
    side -= delta;
    position += dir * delta;
    rect[static2] = position;
    nodes[i].rect = rect;
  }

  totalRect[sidesData.varied1] = variedSidePart[sidesData.varied2];
}

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _tree_map = _interopRequireDefault(__webpack_require__(120));

var _node = _interopRequireDefault(__webpack_require__(211));

var _extend2 = __webpack_require__(0);

var _common = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var proto = _tree_map.default.prototype;
var nodeProto = _node.default.prototype;
proto._eventsMap.onNodesInitialized = {
  name: 'nodesInitialized'
};
proto._eventsMap.onNodesRendering = {
  name: 'nodesRendering'
};

proto._createProxyType = function () {
  var that = this;
  var nodes;
  Proxy.prototype = {
    constructor: Proxy,
    getParent: function getParent() {
      return nodes[this._id].parent.proxy || null;
    },
    getChild: function getChild(index) {
      var _nodes = nodes[this._id].nodes;
      return _nodes ? _nodes[index].proxy : null;
    },
    getChildrenCount: function getChildrenCount() {
      var _nodes = nodes[this._id].nodes;
      return _nodes ? _nodes.length : 0;
    },
    getAllChildren: function getAllChildren() {
      var _nodes = nodes[this._id].nodes;
      var i;
      var ii = _nodes && _nodes.length;
      var list = [];

      for (i = 0; i < ii; ++i) {
        list.push(_nodes[i].proxy);
      }

      return list;
    },
    getAllNodes: function getAllNodes() {
      var list = [];
      collectNodes(nodes[this._id], list);
      return list;
    },
    isLeaf: function isLeaf() {
      return !nodes[this._id].isNode();
    },
    isActive: function isActive() {
      return nodes[this._id].isActive();
    },
    value: function value(arg) {
      var node = nodes[this._id];
      var result;

      if (arg !== undefined) {
        updateValue(node, arg > 0 ? Number(arg) : 0);
        change(node, ['TILING']);
        result = this;
      } else {
        result = node.value;
      }

      return result;
    },
    label: function label(arg) {
      var node = nodes[this._id];
      var result;

      if (arg !== undefined) {
        node.customLabel = arg ? String(arg) : null;
        change(node, ['LABELS']);
        result = this;
      } else {
        result = node.customLabel || node.label;
      }

      return result;
    },
    customize: function customize(settings) {
      var node = nodes[this._id];

      if (settings) {
        node._custom = node._custom || {};
        (0, _extend2.extend)(true, node._custom, settings);
        node._partialState = node._partialLabelState = null;
      }

      change(node, ['TILES', 'LABELS']);
      return this;
    },
    resetCustomization: function resetCustomization() {
      var node = nodes[this._id];
      node._custom = node._partialState = node._partialLabelState = null;
      change(node, ['TILES', 'LABELS']);
      return this;
    }
  };

  that._extendProxyType(Proxy.prototype);

  function Proxy(node) {
    var that = this;
    node.proxy = that;
    that._id = node._id;
    that.level = node.level;
    that.index = node.index;
    that.data = node.data;
  } // TODO: Find a way to make the following methods exist one per module rather then one per instance


  that._handlers.beginBuildNodes = function () {
    nodes = that._nodes;
    new Proxy(that._root);
  };

  that._handlers.buildNode = function (node) {
    new Proxy(node);
  };

  that._handlers.endBuildNodes = function () {
    that._eventTrigger('nodesInitialized', {
      root: that._root.proxy
    });
  };
};

function change(node, codes) {
  var ctx = node.ctx;
  ctx.suspend();
  ctx.change(codes);
  ctx.resume();
}

function collectNodes(node, list) {
  var nodes = node.nodes;
  var i;
  var ii = nodes && nodes.length;

  for (i = 0; i < ii; ++i) {
    list.push(nodes[i].proxy);
    collectNodes(nodes[i], list);
  }
}

function updateValue(node, value) {
  var delta = value - node.value;

  while (node) {
    node.value += delta;
    node = node.parent;
  }
}

proto._extendProxyType = _common.noop;
var _resetNodes = proto._resetNodes;

proto._resetNodes = function () {
  _resetNodes.call(this);

  this._eventTrigger('nodesRendering', {
    node: this._topNode.proxy
  });
};

var _updateStyles = nodeProto.updateStyles;

nodeProto.updateStyles = function () {
  var that = this;

  _updateStyles.call(that);

  if (that._custom) {
    that._partialState = !that.ctx.forceReset && that._partialState || that.ctx.calculateState(that._custom);
    (0, _extend2.extend)(true, that.state, that._partialState);
  }
};

var _updateLabelStyle = nodeProto.updateLabelStyle;

nodeProto.updateLabelStyle = function () {
  var that = this;
  var custom = that._custom;

  _updateLabelStyle.call(that);

  if (custom && custom.label) {
    that._partialLabelState = !that.ctx.forceReset && that._partialLabelState || calculatePartialLabelState(that, custom.label);
    that.labelState = (0, _extend2.extend)(true, {}, that.labelState, that._partialLabelState);
  }
};

function calculatePartialLabelState(node, settings) {
  var state = node.ctx.calculateLabelState(settings);

  if ('visible' in settings) {
    state.visible = !!settings.visible;
  }

  return state;
}

proto.getRootNode = function () {
  return this._root.proxy;
};

proto.resetNodes = function () {
  var context = this._context;
  context.suspend();
  context.change(['NODES_CREATE']);
  context.resume();
  return this;
};

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.fileSaver = exports.MIME_TYPES = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _window = __webpack_require__(7);

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _ui = _interopRequireDefault(__webpack_require__(19));

var _type = __webpack_require__(1);

var _console = __webpack_require__(111);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* global Windows */
var window = (0, _window.getWindow)();
var navigator = (0, _window.getNavigator)();
var FILE_EXTESIONS = {
  EXCEL: 'xlsx',
  CSS: 'css',
  PNG: 'png',
  JPEG: 'jpeg',
  GIF: 'gif',
  SVG: 'svg',
  PDF: 'pdf'
};
var MIME_TYPES = {
  CSS: 'text/css',
  EXCEL: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  PNG: 'image/png',
  JPEG: 'image/jpeg',
  GIF: 'image/gif',
  SVG: 'image/svg+xml',
  PDF: 'application/pdf'
}; // Use github.com/eligrey/FileSaver.js library instead this method

exports.MIME_TYPES = MIME_TYPES;
var fileSaver = {
  _revokeObjectURLTimeout: 30000,
  _getDataUri: function _getDataUri(format, data) {
    var mimeType = this._getMimeType(format);

    return "data:".concat(mimeType, ";base64,").concat(data);
  },
  _getMimeType: function _getMimeType(format) {
    return MIME_TYPES[format] || 'application/octet-stream';
  },
  _linkDownloader: function _linkDownloader(fileName, href) {
    var exportLinkElement = _dom_adapter.default.createElement('a');

    exportLinkElement.download = fileName;
    exportLinkElement.href = href;
    exportLinkElement.target = '_blank'; // cors policy

    return exportLinkElement;
  },
  _formDownloader: function _formDownloader(proxyUrl, fileName, contentType, data) {
    var formAttributes = {
      method: 'post',
      action: proxyUrl,
      enctype: 'multipart/form-data'
    };
    var exportForm = (0, _renderer.default)('<form>').css({
      'display': 'none'
    }).attr(formAttributes);

    function setAttributes(element, attributes) {
      for (var key in attributes) {
        element.setAttribute(key, attributes[key]);
      }

      return element;
    }

    exportForm.append(setAttributes(_dom_adapter.default.createElement('input'), {
      type: 'hidden',
      name: 'fileName',
      value: fileName
    }));
    exportForm.append(setAttributes(_dom_adapter.default.createElement('input'), {
      type: 'hidden',
      name: 'contentType',
      value: contentType
    }));
    exportForm.append(setAttributes(_dom_adapter.default.createElement('input'), {
      type: 'hidden',
      name: 'data',
      value: data
    }));
    exportForm.appendTo('body');

    _events_engine.default.trigger(exportForm, 'submit');

    if (_events_engine.default.trigger(exportForm, 'submit')) exportForm.remove();
  },
  _saveByProxy: function _saveByProxy(proxyUrl, fileName, format, data) {
    var contentType = this._getMimeType(format);

    return this._formDownloader(proxyUrl, fileName, contentType, data);
  },
  _winJSBlobSave: function _winJSBlobSave(blob, fileName, format) {
    var savePicker = new Windows.Storage.Pickers.FileSavePicker();
    savePicker.suggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.documentsLibrary;
    var fileExtension = FILE_EXTESIONS[format];

    if (fileExtension) {
      var mimeType = this._getMimeType(format);

      savePicker.fileTypeChoices.insert(mimeType, ['.' + fileExtension]);
    }

    savePicker.suggestedFileName = fileName;
    savePicker.pickSaveFileAsync().then(function (file) {
      if (file) {
        file.openAsync(Windows.Storage.FileAccessMode.readWrite).then(function (outputStream) {
          var inputStream = blob.msDetachStream();
          Windows.Storage.Streams.RandomAccessStream.copyAsync(inputStream, outputStream).then(function () {
            outputStream.flushAsync().done(function () {
              inputStream.close();
              outputStream.close();
            });
          });
        });
      }
    });
  },
  _click: function _click(link) {
    try {
      // eslint-disable-next-line no-undef
      link.dispatchEvent(new MouseEvent('click', {
        cancelable: true
      }));
    } catch (e) {
      var event = _dom_adapter.default.getDocument().createEvent('MouseEvents');

      event.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
      link.dispatchEvent(event);
    }
  },
  _saveBlobAs: function _saveBlobAs(fileName, format, data) {
    var _this = this;

    this._blobSaved = false;

    if ((0, _type.isDefined)(navigator.msSaveOrOpenBlob)) {
      navigator.msSaveOrOpenBlob(data, fileName);
      this._blobSaved = true;
    } else if ((0, _type.isDefined)(window.WinJS)) {
      this._winJSBlobSave(data, fileName, format);

      this._blobSaved = true;
    } else {
      var URL = window.URL || window.webkitURL || window.mozURL || window.msURL || window.oURL;

      if ((0, _type.isDefined)(URL)) {
        var objectURL = URL.createObjectURL(data);

        var downloadLink = this._linkDownloader(fileName, objectURL);

        setTimeout(function () {
          URL.revokeObjectURL(objectURL);
          _this._objectUrlRevoked = true;
        }, this._revokeObjectURLTimeout);

        this._click(downloadLink);
      } else {
        _console.logger.warn('window.URL || window.webkitURL || window.mozURL || window.msURL || window.oURL is not defined');
      }
    }
  },
  saveAs: function saveAs(fileName, format, data, proxyURL, forceProxy) {
    var fileExtension = FILE_EXTESIONS[format];

    if (fileExtension) {
      fileName += '.' + fileExtension;
    }

    if ((0, _type.isDefined)(proxyURL)) {
      _ui.default.log('W0001', 'Export', 'proxyURL', '19.2', 'This option is no longer required');
    }

    if (forceProxy) {
      this._saveByProxy(proxyURL, fileName, format, data);
    } else if ((0, _type.isFunction)(window.Blob)) {
      this._saveBlobAs(fileName, format, data);
    } else {
      if ((0, _type.isDefined)(proxyURL) && !(0, _type.isDefined)(navigator.userAgent.match(/iPad/i))) {
        this._saveByProxy(proxyURL, fileName, format, data);
      } else {
        if (!(0, _type.isDefined)(navigator.userAgent.match(/iPad/i))) _ui.default.log('E1034');

        var downloadLink = this._linkDownloader(fileName, this._getDataUri(format, data));

        this._click(downloadLink);
      }
    }
  }
};
exports.fileSaver = fileSaver;

/***/ }),
/* 190 */,
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/// BUNDLER_PARTS

/* Core (dx.module-core.js) */

/* eslint-disable import/no-commonjs */
var DevExpress = __webpack_require__(146);
/* Integrations (dx.module-core.js) */


__webpack_require__(268);

__webpack_require__(407);

__webpack_require__(418);

__webpack_require__(130);

__webpack_require__(427);

__webpack_require__(200);

__webpack_require__(428);

__webpack_require__(429);
/* Events (dx.module-core.js) */


__webpack_require__(23);

__webpack_require__(167);

__webpack_require__(152);

__webpack_require__(78);

__webpack_require__(98);

__webpack_require__(145);

__webpack_require__(25);

__webpack_require__(201);

__webpack_require__(286); /// BUNDLER_PARTS_END


module.exports = DevExpress;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.export = _export;
Object.defineProperty(exports, "fileSaver", {
  enumerable: true,
  get: function get() {
    return _file_saver.fileSaver;
  }
});
exports.svg = exports.pdf = exports.image = exports.excel = void 0;

var _file_saver = __webpack_require__(189);

var _excel_creator = __webpack_require__(356);

var _image_creator = __webpack_require__(258);

var _svg_creator = __webpack_require__(368);

var _type = __webpack_require__(1);

var _deferred = __webpack_require__(6);

var _excel_format_converter = _interopRequireDefault(__webpack_require__(250));

var _pdf_creator = __webpack_require__(370);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _export(data, options, getData) {
  if (!data) {
    return new _deferred.Deferred().resolve();
  } // TODO: Can the following actions be not defined? (since they are provided by a widget not by a user)


  var exportingAction = options.exportingAction;
  var exportedAction = options.exportedAction;
  var fileSavingAction = options.fileSavingAction;
  var eventArgs = {
    fileName: options.fileName,
    format: options.format,
    cancel: false
  };
  (0, _type.isFunction)(exportingAction) && exportingAction(eventArgs);

  if (!eventArgs.cancel) {
    return getData(data, options).then(function (blob) {
      (0, _type.isFunction)(exportedAction) && exportedAction();

      if ((0, _type.isFunction)(fileSavingAction)) {
        eventArgs.data = blob;
        fileSavingAction(eventArgs);
      }

      if (!eventArgs.cancel) {
        _file_saver.fileSaver.saveAs(eventArgs.fileName, options.format, blob, options.proxyUrl, options.forceProxy);
      }
    });
  }

  return new _deferred.Deferred().resolve();
}

var excel = {
  creator: _excel_creator.ExcelCreator,
  getData: _excel_creator.getData,
  formatConverter: _excel_format_converter.default
};
exports.excel = excel;
var image = {
  creator: _image_creator.imageCreator,
  getData: _image_creator.getData,
  testFormats: _image_creator.testFormats
};
exports.image = image;
var pdf = {
  getData: _pdf_creator.getData
};
exports.pdf = pdf;
var svg = {
  creator: _svg_creator.svgCreator,
  getData: _svg_creator.getData
};
exports.svg = svg;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _array = __webpack_require__(12);

var _window = __webpack_require__(7);

var weakMap = (0, _window.hasWindow)() ? (0, _window.getWindow)().WeakMap : WeakMap;

if (!weakMap) {
  // NOTE: This is an incomplete WeakMap polyfill but it is enough for creation purposes
  weakMap = function weakMap() {
    var keys = [];
    var values = [];

    this.set = function (key, value) {
      var index = (0, _array.inArray)(key, keys);

      if (index === -1) {
        keys.push(key);
        values.push(value);
      } else {
        values[index] = value;
      }
    };

    this.get = function (key) {
      var index = (0, _array.inArray)(key, keys);

      if (index === -1) {
        return undefined;
      }

      return values[index];
    };

    this.has = function (key) {
      var index = (0, _array.inArray)(key, keys);

      if (index === -1) {
        return false;
      }

      return true;
    };

    this.delete = function (key) {
      var index = (0, _array.inArray)(key, keys);

      if (index === -1) {
        return;
      }

      keys.splice(index, 1);
      values.splice(index, 1);
    };
  };
}

var _default = weakMap;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _iterator = __webpack_require__(3);

var _callbacks = _interopRequireDefault(__webpack_require__(28));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MemorizedCallbacks = /*#__PURE__*/function () {
  function MemorizedCallbacks() {
    this.memory = [];
    this.callbacks = (0, _callbacks.default)();
  }

  var _proto = MemorizedCallbacks.prototype;

  _proto.add = function add(fn) {
    (0, _iterator.each)(this.memory, function (_, item) {
      return fn.apply(fn, item);
    });
    this.callbacks.add(fn);
  };

  _proto.remove = function remove(fn) {
    this.callbacks.remove(fn);
  };

  _proto.fire = function fire() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.memory.push(args);
    this.callbacks.fire.apply(this.callbacks, args);
  };

  return MemorizedCallbacks;
}();

exports.default = MemorizedCallbacks;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getOffset = exports.getWindowByElement = exports.elementSize = exports.setInnerHeight = exports.getInnerHeight = exports.setInnerWidth = exports.getInnerWidth = exports.setOuterHeight = exports.getOuterHeight = exports.setOuterWidth = exports.getOuterWidth = exports.setHeight = exports.getHeight = exports.setWidth = exports.getWidth = exports.getVisibleHeight = exports.getVerticalOffsets = exports.addOffsetToMinHeight = exports.addOffsetToMaxHeight = exports.parseHeight = exports.getSize = exports.getElementBoxParams = void 0;

var _window = __webpack_require__(7);

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _type = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var window = (0, _window.getWindow)();
var SPECIAL_HEIGHT_VALUES = ['auto', 'none', 'inherit', 'initial'];

var getSizeByStyles = function getSizeByStyles(elementStyles, styles) {
  var result = 0;
  styles.forEach(function (style) {
    result += parseFloat(elementStyles[style]) || 0;
  });
  return result;
};

var getElementBoxParams = function getElementBoxParams(name, elementStyles) {
  var beforeName = name === 'width' ? 'Left' : 'Top';
  var afterName = name === 'width' ? 'Right' : 'Bottom';
  return {
    padding: getSizeByStyles(elementStyles, ['padding' + beforeName, 'padding' + afterName]),
    border: getSizeByStyles(elementStyles, ['border' + beforeName + 'Width', 'border' + afterName + 'Width']),
    margin: getSizeByStyles(elementStyles, ['margin' + beforeName, 'margin' + afterName])
  };
};

exports.getElementBoxParams = getElementBoxParams;

var getBoxSizingOffset = function getBoxSizingOffset(name, elementStyles, boxParams) {
  var size = elementStyles[name];

  if (elementStyles.boxSizing === 'border-box' && size.length && size[size.length - 1] !== '%') {
    return boxParams.border + boxParams.padding;
  }

  return 0;
};

var getSize = function getSize(element, name, include) {
  var elementStyles = window.getComputedStyle(element);
  var boxParams = getElementBoxParams(name, elementStyles);
  var clientRect = element.getClientRects().length;
  var boundingClientRect = element.getBoundingClientRect()[name];
  var result = clientRect ? boundingClientRect : 0;

  if (result <= 0) {
    result = parseFloat(elementStyles[name] || element.style[name]) || 0;
    result -= getBoxSizingOffset(name, elementStyles, boxParams);
  } else {
    result -= boxParams.padding + boxParams.border;
  }

  if (include.paddings) {
    result += boxParams.padding;
  }

  if (include.borders) {
    result += boxParams.border;
  }

  if (include.margins) {
    result += boxParams.margin;
  }

  return result;
};

exports.getSize = getSize;

var getContainerHeight = function getContainerHeight(container) {
  return (0, _type.isWindow)(container) ? container.innerHeight : container.offsetHeight;
};

var parseHeight = function parseHeight(value, container) {
  if (value.indexOf('px') > 0) {
    value = parseInt(value.replace('px', ''));
  } else if (value.indexOf('%') > 0) {
    value = parseInt(value.replace('%', '')) * getContainerHeight(container) / 100;
  } else if (!isNaN(value)) {
    value = parseInt(value);
  }

  return value;
};

exports.parseHeight = parseHeight;

var getHeightWithOffset = function getHeightWithOffset(value, offset, container) {
  if (!value) {
    return null;
  }

  if (SPECIAL_HEIGHT_VALUES.indexOf(value) > -1) {
    return offset ? null : value;
  }

  if ((0, _type.isString)(value)) {
    value = parseHeight(value, container);
  }

  if ((0, _type.isNumeric)(value)) {
    return Math.max(0, value + offset);
  }

  var operationString = offset < 0 ? ' - ' : ' ';
  return 'calc(' + value + operationString + Math.abs(offset) + 'px)';
};

var addOffsetToMaxHeight = function addOffsetToMaxHeight(value, offset, container) {
  var maxHeight = getHeightWithOffset(value, offset, container);
  return maxHeight !== null ? maxHeight : 'none';
};

exports.addOffsetToMaxHeight = addOffsetToMaxHeight;

var addOffsetToMinHeight = function addOffsetToMinHeight(value, offset, container) {
  var minHeight = getHeightWithOffset(value, offset, container);
  return minHeight !== null ? minHeight : 0;
};

exports.addOffsetToMinHeight = addOffsetToMinHeight;

var getVerticalOffsets = function getVerticalOffsets(element, withMargins) {
  if (!element) {
    return 0;
  }

  var boxParams = getElementBoxParams('height', window.getComputedStyle(element));
  return boxParams.padding + boxParams.border + (withMargins ? boxParams.margin : 0);
};

exports.getVerticalOffsets = getVerticalOffsets;

var getVisibleHeight = function getVisibleHeight(element) {
  if (element) {
    var boundingClientRect = element.getBoundingClientRect();

    if (boundingClientRect.height) {
      return boundingClientRect.height;
    }
  }

  return 0;
};

exports.getVisibleHeight = getVisibleHeight;

var getWidth = function getWidth(el) {
  return elementSize(el, 'width');
};

exports.getWidth = getWidth;

var setWidth = function setWidth(el, value) {
  return elementSize(el, 'width', value);
};

exports.setWidth = setWidth;

var getHeight = function getHeight(el) {
  return elementSize(el, 'height');
};

exports.getHeight = getHeight;

var setHeight = function setHeight(el, value) {
  return elementSize(el, 'height', value);
};

exports.setHeight = setHeight;

var getOuterWidth = function getOuterWidth(el) {
  return elementSize(el, 'outerWidth');
};

exports.getOuterWidth = getOuterWidth;

var setOuterWidth = function setOuterWidth(el, value) {
  return elementSize(el, 'outerWidth', value);
};

exports.setOuterWidth = setOuterWidth;

var getOuterHeight = function getOuterHeight(el) {
  return elementSize(el, 'outerHeight');
};

exports.getOuterHeight = getOuterHeight;

var setOuterHeight = function setOuterHeight(el, value) {
  return elementSize(el, 'outerHeight', value);
};

exports.setOuterHeight = setOuterHeight;

var getInnerWidth = function getInnerWidth(el) {
  return elementSize(el, 'innerWidth');
};

exports.getInnerWidth = getInnerWidth;

var setInnerWidth = function setInnerWidth(el, value) {
  return elementSize(el, 'innerWidth', value);
};

exports.setInnerWidth = setInnerWidth;

var getInnerHeight = function getInnerHeight(el) {
  return elementSize(el, 'innerHeight');
};

exports.getInnerHeight = getInnerHeight;

var setInnerHeight = function setInnerHeight(el, value) {
  return elementSize(el, 'innerHeight', value);
};

exports.setInnerHeight = setInnerHeight;

var elementSize = function elementSize(el, sizeProperty, value) {
  var partialName = sizeProperty.toLowerCase().indexOf('width') >= 0 ? 'Width' : 'Height';
  var propName = partialName.toLowerCase();
  var isOuter = sizeProperty.indexOf('outer') === 0;
  var isInner = sizeProperty.indexOf('inner') === 0;

  if ((0, _type.isWindow)(el)) {
    return isOuter ? el['inner' + partialName] : _dom_adapter.default.getDocumentElement()['client' + partialName];
  }

  if (_dom_adapter.default.isDocument(el)) {
    var documentElement = _dom_adapter.default.getDocumentElement();

    var body = _dom_adapter.default.getBody();

    return Math.max(body['scroll' + partialName], body['offset' + partialName], documentElement['scroll' + partialName], documentElement['offset' + partialName], documentElement['client' + partialName]);
  }

  if (arguments.length === 2 || typeof value === 'boolean') {
    var include = {
      paddings: isInner || isOuter,
      borders: isOuter,
      margins: value
    };
    return getSize(el, propName, include);
  }

  if ((0, _type.isNumeric)(value)) {
    var elementStyles = window.getComputedStyle(el);
    var sizeAdjustment = getElementBoxParams(propName, elementStyles);
    var isBorderBox = elementStyles.boxSizing === 'border-box';
    value = Number(value);

    if (isOuter) {
      value -= isBorderBox ? 0 : sizeAdjustment.border + sizeAdjustment.padding;
    } else if (isInner) {
      value += isBorderBox ? sizeAdjustment.border : -sizeAdjustment.padding;
    } else if (isBorderBox) {
      value += sizeAdjustment.border + sizeAdjustment.padding;
    }
  }

  value += (0, _type.isNumeric)(value) ? 'px' : '';

  _dom_adapter.default.setStyle(el, propName, value);

  return null;
};

exports.elementSize = elementSize;

var getWindowByElement = function getWindowByElement(el) {
  return (0, _type.isWindow)(el) ? el : el.defaultView;
};

exports.getWindowByElement = getWindowByElement;

var getOffset = function getOffset(el) {
  if (!el.getClientRects().length) {
    return {
      top: 0,
      left: 0
    };
  }

  var rect = el.getBoundingClientRect();
  var win = getWindowByElement(el.ownerDocument);
  var docElem = el.ownerDocument.documentElement;
  return {
    top: rect.top + win.pageYOffset - docElem.clientTop,
    left: rect.left + win.pageXOffset - docElem.clientLeft
  };
};

exports.getOffset = getOffset;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;
var _default = {};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.PresetCollection = exports.presets = void 0;

var _component = __webpack_require__(125);

var _iterator = __webpack_require__(3);

var _extend = __webpack_require__(0);

var _devices = _interopRequireDefault(__webpack_require__(13));

var _fx = _interopRequireDefault(__webpack_require__(45));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var directionPostfixes = {
  forward: ' dx-forward',
  backward: ' dx-backward',
  none: ' dx-no-direction',
  undefined: ' dx-no-direction'
};
var optionPrefix = 'preset_';

var AnimationPresetCollection = _component.Component.inherit({
  ctor: function ctor() {
    this.callBase.apply(this, arguments);
    this._registeredPresets = [];
    this.resetToDefaults();
  },
  _getDefaultOptions: function _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      defaultAnimationDuration: 400,
      defaultAnimationDelay: 0,
      defaultStaggerAnimationDuration: 300,
      defaultStaggerAnimationDelay: 40,
      defaultStaggerAnimationStartDelay: 500 // hack for better animations on ipad mini

    });
  },
  _defaultOptionsRules: function _defaultOptionsRules() {
    return this.callBase().concat([{
      device: function device(_device) {
        return _device.phone;
      },
      options: {
        defaultStaggerAnimationDuration: 350,
        defaultStaggerAnimationDelay: 50,
        defaultStaggerAnimationStartDelay: 0
      }
    }, {
      // T254756
      device: function device() {
        return _devices.default.current().android || _devices.default.real.android;
      },
      options: {
        defaultAnimationDelay: 100
      }
    }]);
  },
  _getPresetOptionName: function _getPresetOptionName(animationName) {
    return optionPrefix + animationName;
  },
  // T257755
  _createAndroidSlideAnimationConfig: function _createAndroidSlideAnimationConfig(throughOpacity, widthMultiplier) {
    var that = this;

    var createBaseConfig = function createBaseConfig(configModifier) {
      return {
        type: 'slide',
        delay: configModifier.delay === undefined ? that.option('defaultAnimationDelay') : configModifier.delay,
        duration: configModifier.duration === undefined ? that.option('defaultAnimationDuration') : configModifier.duration
      };
    };

    return {
      enter: function enter($element, configModifier) {
        var width = $element.parent().width() * widthMultiplier;
        var direction = configModifier.direction;
        var config = createBaseConfig(configModifier);
        config.to = {
          left: 0,
          opacity: 1
        };

        if (direction === 'forward') {
          config.from = {
            left: width,
            opacity: throughOpacity
          };
        } else if (direction === 'backward') {
          config.from = {
            left: -width,
            opacity: throughOpacity
          };
        } else {
          config.from = {
            left: 0,
            opacity: 0
          };
        }

        return _fx.default.createAnimation($element, config);
      },
      leave: function leave($element, configModifier) {
        var width = $element.parent().width() * widthMultiplier;
        var direction = configModifier.direction;
        var config = createBaseConfig(configModifier);
        config.from = {
          left: 0,
          opacity: 1
        };

        if (direction === 'forward') {
          config.to = {
            left: -width,
            opacity: throughOpacity
          };
        } else if (direction === 'backward') {
          config.to = {
            left: width,
            opacity: throughOpacity
          };
        } else {
          config.to = {
            left: 0,
            opacity: 0
          };
        }

        return _fx.default.createAnimation($element, config);
      }
    };
  },
  _createOpenDoorConfig: function _createOpenDoorConfig() {
    var that = this;

    var createBaseConfig = function createBaseConfig(configModifier) {
      return {
        type: 'css',
        extraCssClasses: 'dx-opendoor-animation',
        delay: configModifier.delay === undefined ? that.option('defaultAnimationDelay') : configModifier.delay,
        duration: configModifier.duration === undefined ? that.option('defaultAnimationDuration') : configModifier.duration
      };
    };

    return {
      enter: function enter($element, configModifier) {
        var direction = configModifier.direction;
        var config = createBaseConfig(configModifier);
        config.delay = direction === 'none' ? config.delay : config.duration;
        config.from = 'dx-enter dx-opendoor-animation' + directionPostfixes[direction];
        config.to = 'dx-enter-active';
        return _fx.default.createAnimation($element, config);
      },
      leave: function leave($element, configModifier) {
        var direction = configModifier.direction;
        var config = createBaseConfig(configModifier);
        config.from = 'dx-leave dx-opendoor-animation' + directionPostfixes[direction];
        config.to = 'dx-leave-active';
        return _fx.default.createAnimation($element, config);
      }
    };
  },
  _createWinPopConfig: function _createWinPopConfig() {
    var that = this;
    var baseConfig = {
      type: 'css',
      extraCssClasses: 'dx-win-pop-animation',
      duration: that.option('defaultAnimationDuration')
    };
    return {
      enter: function enter($element, configModifier) {
        var config = baseConfig;
        var direction = configModifier.direction;
        config.delay = direction === 'none' ? that.option('defaultAnimationDelay') : that.option('defaultAnimationDuration') / 2;
        config.from = 'dx-enter dx-win-pop-animation' + directionPostfixes[direction];
        config.to = 'dx-enter-active';
        return _fx.default.createAnimation($element, config);
      },
      leave: function leave($element, configModifier) {
        var config = baseConfig;
        var direction = configModifier.direction;
        config.delay = that.option('defaultAnimationDelay');
        config.from = 'dx-leave dx-win-pop-animation' + directionPostfixes[direction];
        config.to = 'dx-leave-active';
        return _fx.default.createAnimation($element, config);
      }
    };
  },
  resetToDefaults: function resetToDefaults() {
    this.clear();
    this.registerDefaultPresets();
    this.applyChanges();
  },
  clear: function clear(name) {
    var that = this;
    var newRegisteredPresets = [];
    (0, _iterator.each)(this._registeredPresets, function (index, preset) {
      if (!name || name === preset.name) {
        that.option(that._getPresetOptionName(preset.name), undefined);
      } else {
        newRegisteredPresets.push(preset);
      }
    });
    this._registeredPresets = newRegisteredPresets;
    this.applyChanges();
  },
  registerPreset: function registerPreset(name, config) {
    this._registeredPresets.push({
      name: name,
      config: config
    });
  },
  applyChanges: function applyChanges() {
    var that = this;
    var customRules = [];
    (0, _iterator.each)(this._registeredPresets, function (index, preset) {
      var rule = {
        device: preset.config.device,
        options: {}
      };
      rule.options[that._getPresetOptionName(preset.name)] = preset.config.animation;
      customRules.push(rule);
    });

    this._setOptionsByDevice(customRules);
  },
  getPreset: function getPreset(name) {
    var result = name;

    while (typeof result === 'string') {
      result = this.option(this._getPresetOptionName(result));
    }

    return result;
  },
  registerDefaultPresets: function registerDefaultPresets() {
    this.registerPreset('pop', {
      animation: {
        extraCssClasses: 'dx-android-pop-animation',
        delay: this.option('defaultAnimationDelay'),
        duration: this.option('defaultAnimationDuration')
      }
    });
    this.registerPreset('openDoor', {
      animation: this._createOpenDoorConfig()
    });
    this.registerPreset('win-pop', {
      animation: this._createWinPopConfig()
    });
    this.registerPreset('fade', {
      animation: {
        extraCssClasses: 'dx-fade-animation',
        delay: this.option('defaultAnimationDelay'),
        duration: this.option('defaultAnimationDuration')
      }
    });
    this.registerPreset('slide', {
      device: function device() {
        return _devices.default.current().android || _devices.default.real.android;
      },
      animation: this._createAndroidSlideAnimationConfig(1, 1)
    });
    this.registerPreset('slide', {
      device: function device() {
        return !_devices.default.current().android && !_devices.default.real.android;
      },
      animation: {
        extraCssClasses: 'dx-slide-animation',
        delay: this.option('defaultAnimationDelay'),
        duration: this.option('defaultAnimationDuration')
      }
    });
    this.registerPreset('ios7-slide', {
      animation: {
        extraCssClasses: 'dx-ios7-slide-animation',
        delay: this.option('defaultAnimationDelay'),
        duration: this.option('defaultAnimationDuration')
      }
    });
    this.registerPreset('overflow', {
      animation: {
        extraCssClasses: 'dx-overflow-animation',
        delay: this.option('defaultAnimationDelay'),
        duration: this.option('defaultAnimationDuration')
      }
    });
    this.registerPreset('ios7-toolbar', {
      device: function device() {
        return !_devices.default.current().android && !_devices.default.real.android;
      },
      animation: {
        extraCssClasses: 'dx-ios7-toolbar-animation',
        delay: this.option('defaultAnimationDelay'),
        duration: this.option('defaultAnimationDuration')
      }
    });
    this.registerPreset('ios7-toolbar', {
      device: function device() {
        return _devices.default.current().android || _devices.default.real.android;
      },
      animation: this._createAndroidSlideAnimationConfig(0, 0.4)
    });
    this.registerPreset('stagger-fade', {
      animation: {
        extraCssClasses: 'dx-fade-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-slide', {
      animation: {
        extraCssClasses: 'dx-slide-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-fade-slide', {
      animation: {
        extraCssClasses: 'dx-fade-slide-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-drop', {
      animation: {
        extraCssClasses: 'dx-drop-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-fade-drop', {
      animation: {
        extraCssClasses: 'dx-fade-drop-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-fade-rise', {
      animation: {
        extraCssClasses: 'dx-fade-rise-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-3d-drop', {
      animation: {
        extraCssClasses: 'dx-3d-drop-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-fade-zoom', {
      animation: {
        extraCssClasses: 'dx-fade-zoom-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
  }
});

exports.PresetCollection = AnimationPresetCollection;
var animationPresets = new AnimationPresetCollection();
exports.presets = animationPresets;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _translator = __webpack_require__(34);

var _component_registrator = _interopRequireDefault(__webpack_require__(9));

var _dom_component = _interopRequireDefault(__webpack_require__(66));

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _array = __webpack_require__(12);

var _common = __webpack_require__(4);

var _extend = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _math = __webpack_require__(31);

var _type = __webpack_require__(1);

var _window = __webpack_require__(7);

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _drag = __webpack_require__(78);

var _position = __webpack_require__(26);

var _index = __webpack_require__(8);

var _visibility_change = __webpack_require__(59);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RESIZABLE = 'dxResizable';
var RESIZABLE_CLASS = 'dx-resizable';
var RESIZABLE_RESIZING_CLASS = 'dx-resizable-resizing';
var RESIZABLE_HANDLE_CLASS = 'dx-resizable-handle';
var RESIZABLE_HANDLE_TOP_CLASS = 'dx-resizable-handle-top';
var RESIZABLE_HANDLE_BOTTOM_CLASS = 'dx-resizable-handle-bottom';
var RESIZABLE_HANDLE_LEFT_CLASS = 'dx-resizable-handle-left';
var RESIZABLE_HANDLE_RIGHT_CLASS = 'dx-resizable-handle-right';
var RESIZABLE_HANDLE_CORNER_CLASS = 'dx-resizable-handle-corner';
var DRAGSTART_START_EVENT_NAME = (0, _index.addNamespace)(_drag.start, RESIZABLE);
var DRAGSTART_EVENT_NAME = (0, _index.addNamespace)(_drag.move, RESIZABLE);
var DRAGSTART_END_EVENT_NAME = (0, _index.addNamespace)(_drag.end, RESIZABLE);
var SIDE_BORDER_WIDTH_STYLES = {
  'left': 'borderLeftWidth',
  'top': 'borderTopWidth',
  'right': 'borderRightWidth',
  'bottom': 'borderBottomWidth'
};

var Resizable = _dom_component.default.inherit({
  _getDefaultOptions: function _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      handles: 'all',
      step: '1',

      /**
      * @name dxResizableOptions.stepPrecision
      * @type string
      * @default "simple"
      * @acceptValues 'simple'|'strict'
      * @hidden
      */
      stepPrecision: 'simple',
      area: undefined,
      minWidth: 30,
      maxWidth: Infinity,
      minHeight: 30,
      maxHeight: Infinity,
      onResizeStart: null,
      onResize: null,
      onResizeEnd: null,
      roundStepValue: true
    });
  },
  _init: function _init() {
    this.callBase();
    this.$element().addClass(RESIZABLE_CLASS);
  },
  _initMarkup: function _initMarkup() {
    this.callBase();

    this._renderHandles();
  },
  _render: function _render() {
    this.callBase();

    this._renderActions();
  },
  _renderActions: function _renderActions() {
    this._resizeStartAction = this._createActionByOption('onResizeStart');
    this._resizeEndAction = this._createActionByOption('onResizeEnd');
    this._resizeAction = this._createActionByOption('onResize');
  },
  _renderHandles: function _renderHandles() {
    var _this = this;

    this._handles = [];
    var handles = this.option('handles');

    if (handles === 'none') {
      return;
    }

    var directions = handles === 'all' ? ['top', 'bottom', 'left', 'right'] : handles.split(' ');
    (0, _iterator.each)(directions, function (index, handleName) {
      _this._renderHandle(handleName);
    });
    (0, _array.inArray)('bottom', directions) + 1 && (0, _array.inArray)('right', directions) + 1 && this._renderHandle('corner-bottom-right');
    (0, _array.inArray)('bottom', directions) + 1 && (0, _array.inArray)('left', directions) + 1 && this._renderHandle('corner-bottom-left');
    (0, _array.inArray)('top', directions) + 1 && (0, _array.inArray)('right', directions) + 1 && this._renderHandle('corner-top-right');
    (0, _array.inArray)('top', directions) + 1 && (0, _array.inArray)('left', directions) + 1 && this._renderHandle('corner-top-left');

    this._attachEventHandlers();
  },
  _renderHandle: function _renderHandle(handleName) {
    var $handle = (0, _renderer.default)('<div>').addClass(RESIZABLE_HANDLE_CLASS).addClass(RESIZABLE_HANDLE_CLASS + '-' + handleName).appendTo(this.$element());

    this._handles.push($handle);
  },
  _attachEventHandlers: function _attachEventHandlers() {
    if (this.option('disabled')) {
      return;
    }

    var handlers = {};
    handlers[DRAGSTART_START_EVENT_NAME] = this._dragStartHandler.bind(this);
    handlers[DRAGSTART_EVENT_NAME] = this._dragHandler.bind(this);
    handlers[DRAGSTART_END_EVENT_NAME] = this._dragEndHandler.bind(this);

    this._handles.forEach(function (handleElement) {
      _events_engine.default.on(handleElement, handlers, {
        direction: 'both',
        immediate: true
      });
    });
  },
  _detachEventHandlers: function _detachEventHandlers() {
    this._handles.forEach(function (handleElement) {
      _events_engine.default.off(handleElement);
    });
  },
  _toggleEventHandlers: function _toggleEventHandlers(shouldAttachEvents) {
    shouldAttachEvents ? this._attachEventHandlers() : this._detachEventHandlers();
  },
  _dragStartHandler: function _dragStartHandler(e) {
    var $element = this.$element();

    if ($element.is('.dx-state-disabled, .dx-state-disabled *')) {
      e.cancel = true;
      return;
    }

    this._toggleResizingClass(true);

    this._movingSides = this._getMovingSides(e);
    this._elementLocation = (0, _translator.locate)($element);
    var elementRect = (0, _position.getBoundingRect)($element.get(0));
    this._elementSize = {
      width: elementRect.width,
      height: elementRect.height
    };

    this._renderDragOffsets(e);

    this._resizeStartAction({
      event: e,
      width: this._elementSize.width,
      height: this._elementSize.height,
      handles: this._movingSides
    });

    e.targetElements = null;
  },
  _toggleResizingClass: function _toggleResizingClass(value) {
    this.$element().toggleClass(RESIZABLE_RESIZING_CLASS, value);
  },
  _renderDragOffsets: function _renderDragOffsets(e) {
    var area = this._getArea();

    if (!area) {
      return;
    }

    var $handle = (0, _renderer.default)(e.target).closest('.' + RESIZABLE_HANDLE_CLASS);
    var handleWidth = $handle.outerWidth();
    var handleHeight = $handle.outerHeight();
    var handleOffset = $handle.offset();
    var areaOffset = area.offset;

    var scrollOffset = this._getAreaScrollOffset();

    e.maxLeftOffset = handleOffset.left - areaOffset.left - scrollOffset.scrollX;
    e.maxRightOffset = areaOffset.left + area.width - handleOffset.left - handleWidth + scrollOffset.scrollX;
    e.maxTopOffset = handleOffset.top - areaOffset.top - scrollOffset.scrollY;
    e.maxBottomOffset = areaOffset.top + area.height - handleOffset.top - handleHeight + scrollOffset.scrollY;
  },
  _getBorderWidth: function _getBorderWidth($element, direction) {
    if ((0, _type.isWindow)($element.get(0))) return 0;
    var borderWidth = $element.css(SIDE_BORDER_WIDTH_STYLES[direction]);
    return parseInt(borderWidth) || 0;
  },
  _dragHandler: function _dragHandler(e) {
    var $element = this.$element();
    var sides = this._movingSides;
    var location = this._elementLocation;
    var size = this._elementSize;

    var offset = this._getOffset(e);

    var width = size.width + offset.x * (sides.left ? -1 : 1);
    var height = size.height + offset.y * (sides.top ? -1 : 1);
    if (offset.x || this.option('stepPrecision') === 'strict') this._renderWidth(width);
    if (offset.y || this.option('stepPrecision') === 'strict') this._renderHeight(height);
    var elementRect = (0, _position.getBoundingRect)($element.get(0));
    var offsetTop = offset.y - ((elementRect.height || height) - height);
    var offsetLeft = offset.x - ((elementRect.width || width) - width);
    (0, _translator.move)($element, {
      top: location.top + (sides.top ? offsetTop : 0),
      left: location.left + (sides.left ? offsetLeft : 0)
    });

    this._resizeAction({
      event: e,
      width: this.option('width') || width,
      height: this.option('height') || height,
      handles: this._movingSides
    });

    (0, _visibility_change.triggerResizeEvent)($element);
  },
  _getOffset: function _getOffset(e) {
    var offset = e.offset;
    var steps = (0, _common.pairToObject)(this.option('step'), !this.option('roundStepValue'));

    var sides = this._getMovingSides(e);

    var strictPrecision = this.option('stepPrecision') === 'strict';
    if (!sides.left && !sides.right) offset.x = 0;
    if (!sides.top && !sides.bottom) offset.y = 0;
    return strictPrecision ? this._getStrictOffset(offset, steps, sides) : this._getSimpleOffset(offset, steps);
  },
  _getSimpleOffset: function _getSimpleOffset(offset, steps) {
    return {
      x: offset.x - offset.x % steps.h,
      y: offset.y - offset.y % steps.v
    };
  },
  _getStrictOffset: function _getStrictOffset(offset, steps, sides) {
    var location = this._elementLocation;
    var size = this._elementSize;
    var xPos = sides.left ? location.left : location.left + size.width;
    var yPos = sides.top ? location.top : location.top + size.height;
    var newXShift = (xPos + offset.x) % steps.h;
    var newYShift = (yPos + offset.y) % steps.v;

    var sign = Math.sign || function (x) {
      x = +x;

      if (x === 0 || isNaN(x)) {
        return x;
      }

      return x > 0 ? 1 : -1;
    };

    var separatorOffset = function separatorOffset(steps, offset) {
      return (1 + sign(offset) * 0.2) % 1 * steps;
    };

    var isSmallOffset = function isSmallOffset(offset, steps) {
      return Math.abs(offset) < 0.2 * steps;
    };

    var newOffsetX = offset.x - newXShift;
    var newOffsetY = offset.y - newYShift;

    if (newXShift > separatorOffset(steps.h, offset.x)) {
      newOffsetX += steps.h;
    }

    if (newYShift > separatorOffset(steps.v, offset.y)) {
      newOffsetY += steps.v;
    }

    return {
      x: (sides.left || sides.right) && !isSmallOffset(offset.x, steps.h) ? newOffsetX : 0,
      y: (sides.top || sides.bottom) && !isSmallOffset(offset.y, steps.v) ? newOffsetY : 0
    };
  },
  _getMovingSides: function _getMovingSides(e) {
    var $target = (0, _renderer.default)(e.target);
    var hasCornerTopLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + '-top-left');
    var hasCornerTopRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + '-top-right');
    var hasCornerBottomLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + '-bottom-left');
    var hasCornerBottomRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + '-bottom-right');
    return {
      'top': $target.hasClass(RESIZABLE_HANDLE_TOP_CLASS) || hasCornerTopLeftClass || hasCornerTopRightClass,
      'left': $target.hasClass(RESIZABLE_HANDLE_LEFT_CLASS) || hasCornerTopLeftClass || hasCornerBottomLeftClass,
      'bottom': $target.hasClass(RESIZABLE_HANDLE_BOTTOM_CLASS) || hasCornerBottomLeftClass || hasCornerBottomRightClass,
      'right': $target.hasClass(RESIZABLE_HANDLE_RIGHT_CLASS) || hasCornerTopRightClass || hasCornerBottomRightClass
    };
  },
  _getArea: function _getArea() {
    var area = this.option('area');

    if ((0, _type.isFunction)(area)) {
      area = area.call(this);
    }

    if ((0, _type.isPlainObject)(area)) {
      return this._getAreaFromObject(area);
    }

    return this._getAreaFromElement(area);
  },
  _getAreaScrollOffset: function _getAreaScrollOffset() {
    var area = this.option('area');
    var isElement = !(0, _type.isFunction)(area) && !(0, _type.isPlainObject)(area);
    var scrollOffset = {
      scrollY: 0,
      scrollX: 0
    };

    if (isElement) {
      var areaElement = (0, _renderer.default)(area)[0];

      if ((0, _type.isWindow)(areaElement)) {
        scrollOffset.scrollX = areaElement.pageXOffset;
        scrollOffset.scrollY = areaElement.pageYOffset;
      }
    }

    return scrollOffset;
  },
  _getAreaFromObject: function _getAreaFromObject(area) {
    var result = {
      width: area.right - area.left,
      height: area.bottom - area.top,
      offset: {
        left: area.left,
        top: area.top
      }
    };

    this._correctAreaGeometry(result);

    return result;
  },
  _getAreaFromElement: function _getAreaFromElement(area) {
    var $area = (0, _renderer.default)(area);
    var result;

    if ($area.length) {
      result = {
        width: $area.innerWidth(),
        height: $area.innerHeight(),
        offset: (0, _extend.extend)({
          top: 0,
          left: 0
        }, (0, _type.isWindow)($area[0]) ? {} : $area.offset())
      };

      this._correctAreaGeometry(result, $area);
    }

    return result;
  },
  _correctAreaGeometry: function _correctAreaGeometry(result, $area) {
    var areaBorderLeft = $area ? this._getBorderWidth($area, 'left') : 0;
    var areaBorderTop = $area ? this._getBorderWidth($area, 'top') : 0;
    result.offset.left += areaBorderLeft + this._getBorderWidth(this.$element(), 'left');
    result.offset.top += areaBorderTop + this._getBorderWidth(this.$element(), 'top');
    result.width -= this.$element().outerWidth() - this.$element().innerWidth();
    result.height -= this.$element().outerHeight() - this.$element().innerHeight();
  },
  _dragEndHandler: function _dragEndHandler(e) {
    var $element = this.$element();

    this._resizeEndAction({
      event: e,
      width: $element.outerWidth(),
      height: $element.outerHeight(),
      handles: this._movingSides
    });

    this._toggleResizingClass(false);
  },
  _renderWidth: function _renderWidth(width) {
    this.option('width', (0, _math.fitIntoRange)(width, this.option('minWidth'), this.option('maxWidth')));
  },
  _renderHeight: function _renderHeight(height) {
    this.option('height', (0, _math.fitIntoRange)(height, this.option('minHeight'), this.option('maxHeight')));
  },
  _optionChanged: function _optionChanged(args) {
    switch (args.name) {
      case 'disabled':
        this._toggleEventHandlers(!args.value);

        this.callBase(args);
        break;

      case 'handles':
        this._invalidate();

        break;

      case 'minWidth':
      case 'maxWidth':
        (0, _window.hasWindow)() && this._renderWidth(this.$element().outerWidth());
        break;

      case 'minHeight':
      case 'maxHeight':
        (0, _window.hasWindow)() && this._renderHeight(this.$element().outerHeight());
        break;

      case 'onResize':
      case 'onResizeStart':
      case 'onResizeEnd':
        this._renderActions();

        break;

      case 'area':
      case 'stepPrecision':
      case 'step':
      case 'roundStepValue':
        break;

      default:
        this.callBase(args);
        break;
    }
  },
  _clean: function _clean() {
    this.$element().find('.' + RESIZABLE_HANDLE_CLASS).remove();
  },
  _useTemplates: function _useTemplates() {
    return false;
  }
});

(0, _component_registrator.default)(RESIZABLE, Resizable);
var _default = Resizable;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _angular = _interopRequireDefault(__webpack_require__(128));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
var ngModule = {};

if (_angular.default) {
  ngModule = _angular.default.module('dx', []);
}

var _default = ngModule;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(130);

var _globalize = _interopRequireDefault(__webpack_require__(74));

var _number = _interopRequireDefault(__webpack_require__(46));

var _errors = _interopRequireDefault(__webpack_require__(24));

__webpack_require__(74);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

if (_globalize.default && _globalize.default.formatNumber) {
  var enNumbers = {
    'main': {
      'en': {
        'identity': {
          'version': {
            '_cldrVersion': '28',
            '_number': '$Revision: 11972 $'
          },
          'language': 'en'
        },
        'numbers': {
          'defaultNumberingSystem': 'latn',
          'otherNumberingSystems': {
            'native': 'latn'
          },
          'minimumGroupingDigits': '1',
          'symbols-numberSystem-latn': {
            'decimal': '.',
            'group': ',',
            'list': ';',
            'percentSign': '%',
            'plusSign': '+',
            'minusSign': '-',
            'exponential': 'E',
            'superscriptingExponent': '',
            'perMille': '',
            'infinity': '',
            'nan': 'NaN',
            'timeSeparator': ':'
          },
          'decimalFormats-numberSystem-latn': {
            'standard': '#,##0.###',
            'long': {
              'decimalFormat': {
                '1000-count-one': '0 thousand',
                '1000-count-other': '0 thousand',
                '10000-count-one': '00 thousand',
                '10000-count-other': '00 thousand',
                '100000-count-one': '000 thousand',
                '100000-count-other': '000 thousand',
                '1000000-count-one': '0 million',
                '1000000-count-other': '0 million',
                '10000000-count-one': '00 million',
                '10000000-count-other': '00 million',
                '100000000-count-one': '000 million',
                '100000000-count-other': '000 million',
                '1000000000-count-one': '0 billion',
                '1000000000-count-other': '0 billion',
                '10000000000-count-one': '00 billion',
                '10000000000-count-other': '00 billion',
                '100000000000-count-one': '000 billion',
                '100000000000-count-other': '000 billion',
                '1000000000000-count-one': '0 trillion',
                '1000000000000-count-other': '0 trillion',
                '10000000000000-count-one': '00 trillion',
                '10000000000000-count-other': '00 trillion',
                '100000000000000-count-one': '000 trillion',
                '100000000000000-count-other': '000 trillion'
              }
            },
            'short': {
              'decimalFormat': {
                '1000-count-one': '0K',
                '1000-count-other': '0K',
                '10000-count-one': '00K',
                '10000-count-other': '00K',
                '100000-count-one': '000K',
                '100000-count-other': '000K',
                '1000000-count-one': '0M',
                '1000000-count-other': '0M',
                '10000000-count-one': '00M',
                '10000000-count-other': '00M',
                '100000000-count-one': '000M',
                '100000000-count-other': '000M',
                '1000000000-count-one': '0B',
                '1000000000-count-other': '0B',
                '10000000000-count-one': '00B',
                '10000000000-count-other': '00B',
                '100000000000-count-one': '000B',
                '100000000000-count-other': '000B',
                '1000000000000-count-one': '0T',
                '1000000000000-count-other': '0T',
                '10000000000000-count-one': '00T',
                '10000000000000-count-other': '00T',
                '100000000000000-count-one': '000T',
                '100000000000000-count-other': '000T'
              }
            }
          },
          'scientificFormats-numberSystem-latn': {
            'standard': '#E0'
          },
          'percentFormats-numberSystem-latn': {
            'standard': '#,##0%'
          },
          'currencyFormats-numberSystem-latn': {
            'currencySpacing': {
              'beforeCurrency': {
                'currencyMatch': '[:^S:]',
                'surroundingMatch': '[:digit:]',
                'insertBetween': ''
              },
              'afterCurrency': {
                'currencyMatch': '[:^S:]',
                'surroundingMatch': '[:digit:]',
                'insertBetween': ''
              }
            },
            'standard': '#,##0.00',
            'accounting': '#,##0.00;(#,##0.00)',
            'short': {
              'standard': {
                '1000-count-one': '0K',
                '1000-count-other': '0K',
                '10000-count-one': '00K',
                '10000-count-other': '00K',
                '100000-count-one': '000K',
                '100000-count-other': '000K',
                '1000000-count-one': '0M',
                '1000000-count-other': '0M',
                '10000000-count-one': '00M',
                '10000000-count-other': '00M',
                '100000000-count-one': '000M',
                '100000000-count-other': '000M',
                '1000000000-count-one': '0B',
                '1000000000-count-other': '0B',
                '10000000000-count-one': '00B',
                '10000000000-count-other': '00B',
                '100000000000-count-one': '000B',
                '100000000000-count-other': '000B',
                '1000000000000-count-one': '0T',
                '1000000000000-count-other': '0T',
                '10000000000000-count-one': '00T',
                '10000000000000-count-other': '00T',
                '100000000000000-count-one': '000T',
                '100000000000000-count-other': '000T'
              }
            },
            'unitPattern-count-one': '{0} {1}',
            'unitPattern-count-other': '{0} {1}'
          },
          'miscPatterns-numberSystem-latn': {
            'atLeast': '{0}+',
            'range': '{0}{1}'
          }
        }
      }
    }
  };

  if (_globalize.default.locale().locale === 'en') {
    _globalize.default.load(enNumbers);

    _globalize.default.locale('en');
  }

  var formattersCache = {};

  var getFormatter = function getFormatter(format) {
    var formatter;
    var formatCacheKey;

    if (_typeof(format) === 'object') {
      formatCacheKey = _globalize.default.locale().locale + ':' + JSON.stringify(format);
    } else {
      formatCacheKey = _globalize.default.locale().locale + ':' + format;
    }

    formatter = formattersCache[formatCacheKey];

    if (!formatter) {
      formatter = formattersCache[formatCacheKey] = _globalize.default.numberFormatter(format);
    }

    return formatter;
  };

  var globalizeNumberLocalization = {
    engine: function engine() {
      return 'globalize';
    },
    _formatNumberCore: function _formatNumberCore(value, format, formatConfig) {
      if (format === 'exponential') {
        return this.callBase.apply(this, arguments);
      }

      return getFormatter(this._normalizeFormatConfig(format, formatConfig, value))(value);
    },
    _normalizeFormatConfig: function _normalizeFormatConfig(format, formatConfig, value) {
      var config;

      if (format === 'decimal') {
        config = {
          minimumIntegerDigits: formatConfig.precision || 1,
          useGrouping: false,
          minimumFractionDigits: 0,
          maximumFractionDigits: 20,
          round: value < 0 ? 'ceil' : 'floor'
        };
      } else {
        config = this._getPrecisionConfig(formatConfig.precision);
      }

      if (format === 'percent') {
        config.style = 'percent';
      }

      return config;
    },
    _getPrecisionConfig: function _getPrecisionConfig(precision) {
      var config;

      if (precision === null) {
        config = {
          minimumFractionDigits: 0,
          maximumFractionDigits: 20
        };
      } else {
        config = {
          minimumFractionDigits: precision || 0,
          maximumFractionDigits: precision || 0
        };
      }

      return config;
    },
    format: function format(value, _format) {
      if (typeof value !== 'number') {
        return value;
      }

      _format = this._normalizeFormat(_format);

      if (!_format || typeof _format !== 'function' && !_format.type && !_format.formatter) {
        return getFormatter(_format)(value);
      }

      return this.callBase.apply(this, arguments);
    },
    parse: function parse(text, format) {
      if (!text) {
        return;
      }

      if (format && (format.parser || typeof format === 'string')) {
        return this.callBase.apply(this, arguments);
      }

      if (format) {
        // Current parser functionality provided as-is and is independent of the most of capabilities of formatter.
        _errors.default.log('W0011');
      }

      var result = _globalize.default.parseNumber(text);

      if (isNaN(result)) {
        result = this.callBase.apply(this, arguments);
      }

      return result;
    }
  };

  _number.default.resetInjection();

  _number.default.inject(globalizeNumberLocalization);
}

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.end = exports.start = exports.swipe = void 0;

var _index = __webpack_require__(8);

var _emitter = _interopRequireDefault(__webpack_require__(172));

var _emitter_registrator = _interopRequireDefault(__webpack_require__(104));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SWIPE_START_EVENT = 'dxswipestart';
exports.start = SWIPE_START_EVENT;
var SWIPE_EVENT = 'dxswipe';
exports.swipe = SWIPE_EVENT;
var SWIPE_END_EVENT = 'dxswipeend';
exports.end = SWIPE_END_EVENT;
var HorizontalStrategy = {
  defaultItemSizeFunc: function defaultItemSizeFunc() {
    return this.getElement().width();
  },
  getBounds: function getBounds() {
    return [this._maxLeftOffset, this._maxRightOffset];
  },
  calcOffsetRatio: function calcOffsetRatio(e) {
    var endEventData = (0, _index.eventData)(e);
    return (endEventData.x - (this._savedEventData && this._savedEventData.x || 0)) / this._itemSizeFunc().call(this, e);
  },
  isFastSwipe: function isFastSwipe(e) {
    var endEventData = (0, _index.eventData)(e);
    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.x - this._tickData.x) >= endEventData.time - this._tickData.time;
  }
};
var VerticalStrategy = {
  defaultItemSizeFunc: function defaultItemSizeFunc() {
    return this.getElement().height();
  },
  getBounds: function getBounds() {
    return [this._maxTopOffset, this._maxBottomOffset];
  },
  calcOffsetRatio: function calcOffsetRatio(e) {
    var endEventData = (0, _index.eventData)(e);
    return (endEventData.y - (this._savedEventData && this._savedEventData.y || 0)) / this._itemSizeFunc().call(this, e);
  },
  isFastSwipe: function isFastSwipe(e) {
    var endEventData = (0, _index.eventData)(e);
    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.y - this._tickData.y) >= endEventData.time - this._tickData.time;
  }
};
var STRATEGIES = {
  'horizontal': HorizontalStrategy,
  'vertical': VerticalStrategy
};

var SwipeEmitter = _emitter.default.inherit({
  TICK_INTERVAL: 300,
  FAST_SWIPE_SPEED_LIMIT: 10,
  ctor: function ctor(element) {
    this.callBase(element);
    this.direction = 'horizontal';
    this.elastic = true;
  },
  _getStrategy: function _getStrategy() {
    return STRATEGIES[this.direction];
  },
  _defaultItemSizeFunc: function _defaultItemSizeFunc() {
    return this._getStrategy().defaultItemSizeFunc.call(this);
  },
  _itemSizeFunc: function _itemSizeFunc() {
    return this.itemSizeFunc || this._defaultItemSizeFunc;
  },
  _init: function _init(e) {
    this._tickData = (0, _index.eventData)(e);
  },
  _start: function _start(e) {
    this._savedEventData = (0, _index.eventData)(e);
    e = this._fireEvent(SWIPE_START_EVENT, e);

    if (!e.cancel) {
      this._maxLeftOffset = e.maxLeftOffset;
      this._maxRightOffset = e.maxRightOffset;
      this._maxTopOffset = e.maxTopOffset;
      this._maxBottomOffset = e.maxBottomOffset;
    }
  },
  _move: function _move(e) {
    var strategy = this._getStrategy();

    var moveEventData = (0, _index.eventData)(e);
    var offset = strategy.calcOffsetRatio.call(this, e);
    offset = this._fitOffset(offset, this.elastic);

    if (moveEventData.time - this._tickData.time > this.TICK_INTERVAL) {
      this._tickData = moveEventData;
    }

    this._fireEvent(SWIPE_EVENT, e, {
      offset: offset
    });

    e.preventDefault();
  },
  _end: function _end(e) {
    var strategy = this._getStrategy();

    var offsetRatio = strategy.calcOffsetRatio.call(this, e);
    var isFast = strategy.isFastSwipe.call(this, e);
    var startOffset = offsetRatio;

    var targetOffset = this._calcTargetOffset(offsetRatio, isFast);

    startOffset = this._fitOffset(startOffset, this.elastic);
    targetOffset = this._fitOffset(targetOffset, false);

    this._fireEvent(SWIPE_END_EVENT, e, {
      offset: startOffset,
      targetOffset: targetOffset
    });
  },
  _fitOffset: function _fitOffset(offset, elastic) {
    var strategy = this._getStrategy();

    var bounds = strategy.getBounds.call(this);

    if (offset < -bounds[0]) {
      return elastic ? (-2 * bounds[0] + offset) / 3 : -bounds[0];
    }

    if (offset > bounds[1]) {
      return elastic ? (2 * bounds[1] + offset) / 3 : bounds[1];
    }

    return offset;
  },
  _calcTargetOffset: function _calcTargetOffset(offsetRatio, isFast) {
    var result;

    if (isFast) {
      result = Math.ceil(Math.abs(offsetRatio));

      if (offsetRatio < 0) {
        result = -result;
      }
    } else {
      result = Math.round(offsetRatio);
    }

    return result;
  }
});
/**
 * @name UI Events.dxswipestart
 * @type eventType
 * @type_function_param1 event:event
 * @type_function_param1_field1 cancel:boolean
 * @module events/swipe
*/

/**
  * @name UI Events.dxswipe
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 offset:number
  * @type_function_param1_field2 cancel:boolean
  * @module events/swipe
*/

/**
  * @name UI Events.dxswipeend
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 offset:number
  * @type_function_param1_field2 targetOffset:number
  * @module events/swipe
*/


(0, _emitter_registrator.default)({
  emitter: SwipeEmitter,
  events: [SWIPE_START_EVENT, SWIPE_EVENT, SWIPE_END_EVENT]
});

/***/ }),
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.currentPalette = currentPalette;
exports.generateColors = generateColors;
exports.getPalette = getPalette;
exports.registerPalette = registerPalette;
exports.getAccentColor = getAccentColor;
exports.createPalette = createPalette;
exports.getDiscretePalette = getDiscretePalette;
exports.getGradientPalette = getGradientPalette;

var _utils = __webpack_require__(14);

var _extend = __webpack_require__(0);

var _color = _interopRequireDefault(__webpack_require__(102));

var _type = __webpack_require__(1);

var _palettes;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _floor = Math.floor;
var _ceil = Math.ceil;
var _isArray = Array.isArray;
var HIGHLIGHTING_STEP = 50;
var DEFAULT_PALETTE = 'material';
var officePalette = {
  simpleSet: ['#5f8b95', '#ba4d51', '#af8a53', '#955f71', '#859666', '#7e688c'],
  indicatingSet: ['#a3b97c', '#e1b676', '#ec7f83'],
  gradientSet: ['#5f8b95', '#ba4d51'],
  accentColor: '#ba4d51'
};
var palettes = (_palettes = {}, _defineProperty(_palettes, DEFAULT_PALETTE, {
  simpleSet: ['#1db2f5', '#f5564a', '#97c95c', '#ffc720', '#eb3573', '#a63db8'],
  indicatingSet: ['#97c95c', '#ffc720', '#f5564a'],
  gradientSet: ['#1db2f5', '#97c95c'],
  accentColor: '#1db2f5'
}), _defineProperty(_palettes, 'office', officePalette), _defineProperty(_palettes, 'harmony light', {
  simpleSet: ['#fcb65e', '#679ec5', '#ad79ce', '#7abd5c', '#e18e92', '#b6d623', '#b7abea', '#85dbd5'],
  indicatingSet: ['#b6d623', '#fcb65e', '#e18e92'],
  gradientSet: ['#7abd5c', '#fcb65e'],
  accentColor: '#679ec5'
}), _defineProperty(_palettes, 'soft pastel', {
  simpleSet: ['#60a69f', '#78b6d9', '#6682bb', '#a37182', '#eeba69', '#90ba58', '#456c68', '#7565a4'],
  indicatingSet: ['#90ba58', '#eeba69', '#a37182'],
  gradientSet: ['#78b6d9', '#eeba69'],
  accentColor: '#60a69f'
}), _defineProperty(_palettes, 'pastel', {
  simpleSet: ['#bb7862', '#70b3a1', '#bb626a', '#057d85', '#ab394b', '#dac599', '#153459', '#b1d2c6'],
  indicatingSet: ['#70b3a1', '#dac599', '#bb626a'],
  gradientSet: ['#bb7862', '#70b3a1'],
  accentColor: '#bb7862'
}), _defineProperty(_palettes, 'bright', {
  simpleSet: ['#70c92f', '#f8ca00', '#bd1550', '#e97f02', '#9d419c', '#7e4452', '#9ab57e', '#36a3a6'],
  indicatingSet: ['#70c92f', '#f8ca00', '#bd1550'],
  gradientSet: ['#e97f02', '#f8ca00'],
  accentColor: '#e97f02'
}), _defineProperty(_palettes, 'soft', {
  simpleSet: ['#cbc87b', '#9ab57e', '#e55253', '#7e4452', '#e8c267', '#565077', '#6babac', '#ad6082'],
  indicatingSet: ['#9ab57e', '#e8c267', '#e55253'],
  gradientSet: ['#9ab57e', '#e8c267'],
  accentColor: '#565077'
}), _defineProperty(_palettes, 'ocean', {
  simpleSet: ['#75c099', '#acc371', '#378a8a', '#5fa26a', '#064970', '#38c5d2', '#00a7c6', '#6f84bb'],
  indicatingSet: ['#c8e394', '#7bc59d', '#397c8b'],
  gradientSet: ['#acc371', '#38c5d2'],
  accentColor: '#378a8a'
}), _defineProperty(_palettes, 'vintage', {
  simpleSet: ['#dea484', '#efc59c', '#cb715e', '#eb9692', '#a85c4c', '#f2c0b5', '#c96374', '#dd956c'],
  indicatingSet: ['#ffe5c6', '#f4bb9d', '#e57660'],
  gradientSet: ['#efc59c', '#cb715e'],
  accentColor: '#cb715e'
}), _defineProperty(_palettes, 'violet', {
  simpleSet: ['#d1a1d1', '#eeacc5', '#7b5685', '#7e7cad', '#a13d73', '#5b41ab', '#e287e2', '#689cc1'],
  indicatingSet: ['#d8e2f6', '#d0b2da', '#d56a8a'],
  gradientSet: ['#eeacc5', '#7b5685'],
  accentColor: '#7b5685'
}), _defineProperty(_palettes, 'carmine', {
  simpleSet: ['#fb7764', '#73d47f', '#fed85e', '#d47683', '#dde392', '#757ab2'],
  indicatingSet: ['#5cb85c', '#f0ad4e', '#d9534f'],
  gradientSet: ['#fb7764', '#73d47f'],
  accentColor: '#f05b41'
}), _defineProperty(_palettes, 'dark moon', {
  simpleSet: ['#4ddac1', '#f4c99a', '#80dd9b', '#f998b3', '#4aaaa0', '#a5aef1'],
  indicatingSet: ['#59d8a4', '#f0ad4e', '#f9517e'],
  gradientSet: ['#4ddac1', '#f4c99a'],
  accentColor: '#3debd3'
}), _defineProperty(_palettes, 'soft blue', {
  simpleSet: ['#7ab8eb', '#97da97', '#facb86', '#e78683', '#839bda', '#4db7be'],
  indicatingSet: ['#5cb85c', '#f0ad4e', '#d9534f'],
  gradientSet: ['#7ab8eb', '#97da97'],
  accentColor: '#7ab8eb'
}), _defineProperty(_palettes, 'dark violet', {
  simpleSet: ['#9c63ff', '#64c064', '#eead51', '#d2504b', '#4b6bbf', '#2da7b0'],
  indicatingSet: ['#5cb85c', '#f0ad4e', '#d9534f'],
  gradientSet: ['#9c63ff', '#64c064'],
  accentColor: '#9c63ff'
}), _defineProperty(_palettes, 'green mist', {
  simpleSet: ['#3cbab2', '#8ed962', '#5b9d95', '#efcc7c', '#f1929f', '#4d8dab'],
  indicatingSet: ['#72d63c', '#ffc852', '#f74a5e'],
  gradientSet: ['#3cbab2', '#8ed962'],
  accentColor: '#3cbab2'
}), _palettes);
var currentPaletteName;

function currentPalette(name) {
  if (name === undefined) {
    return currentPaletteName || DEFAULT_PALETTE;
  } else {
    name = (0, _utils.normalizeEnum)(name);
    currentPaletteName = name in palettes ? name : undefined;
  }
}

function generateColors(palette, count) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    keepLastColorInEnd: false
  };
  options.type = options.baseColorSet;
  options.extensionMode = options.paletteExtensionMode;
  return createPalette(palette, options).generateColors(count);
}

function getPalette(palette, parameters) {
  parameters = parameters || {};
  palette = palette || (currentPaletteName === undefined ? parameters.themeDefault : currentPalette());
  var result;
  var type = parameters.type;

  if (_isArray(palette)) {
    return palette.slice(0);
  } else {
    if ((0, _type.isString)(palette)) {
      result = palettes[(0, _utils.normalizeEnum)(palette)];
    }

    if (!result) {
      result = palettes[currentPalette()];
    }
  }

  return type ? result[type].slice(0) : result;
}

function registerPalette(name, palette) {
  var item = {};
  var paletteName;

  if (_isArray(palette)) {
    item.simpleSet = palette.slice(0);
  } else if (palette) {
    item.simpleSet = _isArray(palette.simpleSet) ? palette.simpleSet.slice(0) : undefined;
    item.indicatingSet = _isArray(palette.indicatingSet) ? palette.indicatingSet.slice(0) : undefined;
    item.gradientSet = _isArray(palette.gradientSet) ? palette.gradientSet.slice(0) : undefined;
    item.accentColor = palette.accentColor;
  }

  if (!item.accentColor) {
    item.accentColor = item.simpleSet && item.simpleSet[0];
  }

  if (item.simpleSet || item.indicatingSet || item.gradientSet) {
    paletteName = (0, _utils.normalizeEnum)(name);
    (0, _extend.extend)(palettes[paletteName] = palettes[paletteName] || {}, item);
  }
}

function getAccentColor(palette, themeDefault) {
  palette = getPalette(palette, {
    themeDefault: themeDefault
  });
  return palette.accentColor || palette[0];
}

function RingBuf(buf) {
  var ind = 0;

  this.next = function () {
    var res = buf[ind++];

    if (ind === buf.length) {
      this.reset();
    }

    return res;
  };

  this.reset = function () {
    ind = 0;
  };
}

function getAlternateColorsStrategy(palette, parameters) {
  var stepHighlight = parameters.useHighlight ? HIGHLIGHTING_STEP : 0;
  var paletteSteps = new RingBuf([0, stepHighlight, -stepHighlight]);
  var currentPalette = [];

  function _reset() {
    var step = paletteSteps.next();
    currentPalette = step ? getAlteredPalette(palette, step) : palette.slice(0);
  }

  return {
    getColor: function getColor(index) {
      var color = currentPalette[index % palette.length];

      if (index % palette.length === palette.length - 1) {
        _reset();
      }

      return color;
    },
    generateColors: function generateColors(count) {
      var colors = [];
      count = count || parameters.count;

      for (var i = 0; i < count; i++) {
        colors.push(this.getColor(i));
      }

      return colors;
    },
    reset: function reset() {
      paletteSteps.reset();

      _reset();
    }
  };
}

function getExtrapolateColorsStrategy(palette, parameters) {
  function convertColor(color, cycleIndex, cycleCount) {
    var hsl = new _color.default(color).hsl;
    var l = hsl.l / 100;
    var diapason = cycleCount - 1 / cycleCount;
    var minL = l - diapason * 0.5;
    var maxL = l + diapason * 0.5;
    var cycleMiddle = (cycleCount - 1) / 2;
    var cycleDiff = cycleIndex - cycleMiddle;

    if (minL < Math.min(0.5, l * 0.9)) {
      minL = Math.min(0.5, l * 0.9);
    }

    if (maxL > Math.max(0.8, l + (1 - l) * 0.15)) {
      maxL = Math.max(0.8, l + (1 - l) * 0.15);
    }

    if (cycleDiff < 0) {
      l = l - (minL - l) * cycleDiff / cycleMiddle;
    } else {
      l = l + (maxL - l) * (cycleDiff / cycleMiddle);
    }

    hsl.l = l * 100;
    return _color.default.prototype.fromHSL(hsl).toHex();
  }

  return {
    getColor: function getColor(index, count) {
      var paletteCount = palette.length;

      var cycles = _floor((count - 1) / paletteCount + 1);

      var color = palette[index % paletteCount];

      if (cycles > 1) {
        return convertColor(color, _floor(index / paletteCount), cycles);
      }

      return color;
    },
    generateColors: function generateColors(count) {
      var colors = [];
      count = count || parameters.count;

      for (var i = 0; i < count; i++) {
        colors.push(this.getColor(i, count));
      }

      return colors;
    },
    reset: function reset() {}
  };
}

function getColorMixer(palette, parameters) {
  var paletteCount = palette.length;
  var extendedPalette = [];

  function distributeColors(count, colorsCount, startIndex, distribution) {
    var groupSize = Math.floor(count / colorsCount);
    var extraItems = count - colorsCount * groupSize;
    var i = startIndex;
    var middleIndex;
    var size;

    while (i < startIndex + count) {
      size = groupSize;

      if (extraItems > 0) {
        size += 1;
        extraItems--;
      }

      middleIndex = size > 2 ? Math.floor(size / 2) : 0;
      distribution.push(i + middleIndex);
      i += size;
    }

    return distribution.sort(function (a, b) {
      return a - b;
    });
  }

  function getColorAndDistance(arr, startIndex, count) {
    startIndex = (count + startIndex) % count;
    var distance = 0;

    for (var i = startIndex; i < count * 2; i += 1) {
      var index = (count + i) % count;

      if (arr[index]) {
        return [arr[index], distance];
      }

      distance++;
    }
  }

  function blendColors(paletteWithEmptyColors, paletteLength) {
    for (var i = 0; i < paletteLength; i++) {
      var color = paletteWithEmptyColors[i];

      if (!color) {
        var color1 = paletteWithEmptyColors[i - 1];

        if (!color1) {
          continue;
        } else {
          var c2 = getColorAndDistance(paletteWithEmptyColors, i, paletteLength);
          var color2 = new _color.default(c2[0]);
          color1 = new _color.default(color1);

          for (var j = 0; j < c2[1]; j++, i++) {
            paletteWithEmptyColors[i] = color1.blend(color2, (j + 1) / (c2[1] + 1)).toHex();
          }
        }
      }
    }

    return paletteWithEmptyColors;
  }

  function extendPalette(count) {
    if (count <= paletteCount) {
      return palette;
    }

    var result = [];
    var colorInGroups = paletteCount - 2;
    var currentColorIndex = 0;
    var cleanColorIndices = [];

    if (parameters.keepLastColorInEnd) {
      cleanColorIndices = distributeColors(count - 2, colorInGroups, 1, [0, count - 1]);
    } else {
      cleanColorIndices = distributeColors(count - 1, paletteCount - 1, 1, [0]);
    }

    for (var i = 0; i < count; i++) {
      if (cleanColorIndices.indexOf(i) > -1) {
        result[i] = palette[currentColorIndex++];
      }
    }

    result = blendColors(result, count);
    return result;
  }

  return {
    getColor: function getColor(index, count) {
      count = count || parameters.count || paletteCount;

      if (extendedPalette.length !== count) {
        extendedPalette = extendPalette(count);
      }

      return extendedPalette[index % count];
    },
    generateColors: function generateColors(count, repeat) {
      count = count || parameters.count || paletteCount;

      if (repeat && count > paletteCount) {
        var colors = extendPalette(paletteCount);

        for (var i = 0; i < count - paletteCount; i++) {
          colors.push(colors[i]);
        }

        return colors;
      } else {
        return paletteCount > 0 ? extendPalette(count).slice(0, count) : [];
      }
    },
    reset: function reset() {}
  };
}

function createPalette(palette, parameters, themeDefaultPalette) {
  var paletteObj = {
    dispose: function dispose() {
      this._extensionStrategy = null;
    },
    getNextColor: function getNextColor(count) {
      return this._extensionStrategy.getColor(this._currentColor++, count);
    },
    generateColors: function generateColors(count, parameters) {
      return this._extensionStrategy.generateColors(count, (parameters || {}).repeat);
    },
    reset: function reset() {
      this._currentColor = 0;

      this._extensionStrategy.reset();

      return this;
    }
  };
  parameters = parameters || {};
  var extensionMode = (parameters.extensionMode || '').toLowerCase();
  var colors = getPalette(palette, {
    type: parameters.type || 'simpleSet',
    themeDefault: themeDefaultPalette
  });

  if (extensionMode === 'alternate') {
    paletteObj._extensionStrategy = getAlternateColorsStrategy(colors, parameters);
  } else if (extensionMode === 'extrapolate') {
    paletteObj._extensionStrategy = getExtrapolateColorsStrategy(colors, parameters);
  } else {
    paletteObj._extensionStrategy = getColorMixer(colors, parameters);
  }

  paletteObj.reset();
  return paletteObj;
}

function getAlteredPalette(originalPalette, step) {
  var palette = [];
  var i;
  var ii = originalPalette.length;

  for (i = 0; i < ii; ++i) {
    palette.push(getNewColor(originalPalette[i], step));
  }

  return palette;
}

function getNewColor(currentColor, step) {
  var newColor = new _color.default(currentColor).alter(step);
  var lightness = getLightness(newColor);

  if (lightness > 200 || lightness < 55) {
    newColor = new _color.default(currentColor).alter(-step / 2);
  }

  return newColor.toHex();
}

function getLightness(color) {
  return color.r * 0.3 + color.g * 0.59 + color.b * 0.11;
}

function getDiscretePalette(source, size, themeDefaultPalette) {
  var palette = size > 0 ? createDiscreteColors(getPalette(source, {
    type: 'gradientSet',
    themeDefault: themeDefaultPalette
  }), size) : [];
  return {
    getColor: function getColor(index) {
      return palette[index] || null;
    }
  };
}

function createDiscreteColors(source, count) {
  var colorCount = count - 1;
  var sourceCount = source.length - 1;
  var colors = [];
  var gradient = [];
  var i;

  function addColor(pos) {
    var k = sourceCount * pos;

    var kl = _floor(k);

    var kr = _ceil(k);

    gradient.push(colors[kl].blend(colors[kr], k - kl).toHex());
  }

  for (i = 0; i <= sourceCount; ++i) {
    colors.push(new _color.default(source[i]));
  }

  if (colorCount > 0) {
    for (i = 0; i <= colorCount; ++i) {
      addColor(i / colorCount);
    }
  } else {
    addColor(0.5);
  }

  return gradient;
}

function getGradientPalette(source, themeDefaultPalette) {
  // TODO: Looks like some new set is going to be added
  var palette = getPalette(source, {
    type: 'gradientSet',
    themeDefault: themeDefaultPalette
  });
  var color1 = new _color.default(palette[0]);
  var color2 = new _color.default(palette[1]);
  return {
    getColor: function getColor(ratio) {
      return 0 <= ratio && ratio <= 1 ? color1.blend(color2, ratio).toHex() : null;
    }
  };
}

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.polar = exports.chart = void 0;

var _object = __webpack_require__(52);

var _extend2 = __webpack_require__(0);

var _scatter_series = __webpack_require__(139);

var _line_series = __webpack_require__(242);

var _utils = __webpack_require__(14);

// there are area, steparea, stackedarea, fullstackedarea, splinearea
var chartLineSeries = _line_series.chart.line;
var polarLineSeries = _line_series.polar.line;
var _extend = _extend2.extend;
var calculateBezierPoints = _line_series.chart['spline']._calculateBezierPoints;
var chart = {};
exports.chart = chart;
var polar = {};
exports.polar = polar;
var baseAreaMethods = {
  _createBorderElement: chartLineSeries._createMainElement,
  _createLegendState: function _createLegendState(styleOptions, defaultColor) {
    return {
      fill: styleOptions.color || defaultColor,
      opacity: styleOptions.opacity,
      hatching: styleOptions.hatching
    };
  },
  getValueRangeInitialValue: function getValueRangeInitialValue() {
    if (this.valueAxisType !== 'logarithmic' && this.valueType !== 'datetime' && this.showZero !== false) {
      return 0;
    } else {
      return _scatter_series.chart.getValueRangeInitialValue.call(this);
    }
  },
  _getDefaultSegment: function _getDefaultSegment(segment) {
    var defaultSegment = chartLineSeries._getDefaultSegment(segment);

    defaultSegment.area = defaultSegment.line.concat(defaultSegment.line.slice().reverse());
    return defaultSegment;
  },
  _updateElement: function _updateElement(element, segment, animate, complete) {
    var lineParams = {
      points: segment.line
    };
    var areaParams = {
      points: segment.area
    };
    var borderElement = element.line;

    if (animate) {
      borderElement && borderElement.animate(lineParams);
      element.area.animate(areaParams, {}, complete);
    } else {
      borderElement && borderElement.attr(lineParams);
      element.area.attr(areaParams);
    }
  },
  _removeElement: function _removeElement(element) {
    element.line && element.line.remove();
    element.area.remove();
  },
  _drawElement: function _drawElement(segment) {
    return {
      line: this._bordersGroup && this._createBorderElement(segment.line, {
        'stroke-width': this._styles.normal.border['stroke-width']
      }).append(this._bordersGroup),
      area: this._createMainElement(segment.area).append(this._elementsGroup)
    };
  },
  _applyStyle: function _applyStyle(style) {
    var that = this;
    that._elementsGroup && that._elementsGroup.smartAttr(style.elements);
    that._bordersGroup && that._bordersGroup.attr(style.border);
    (that._graphics || []).forEach(function (graphic) {
      graphic.line && graphic.line.attr({
        'stroke-width': style.border['stroke-width']
      }).sharp();
    });
  },
  _parseStyle: function _parseStyle(options, defaultColor, defaultBorderColor) {
    var borderOptions = options.border || {};

    var borderStyle = chartLineSeries._parseLineOptions(borderOptions, defaultBorderColor);

    borderStyle.stroke = borderOptions.visible && borderStyle['stroke-width'] ? borderStyle.stroke : 'none';
    borderStyle['stroke-width'] = borderStyle['stroke-width'] || 1;
    return {
      border: borderStyle,
      elements: {
        stroke: 'none',
        fill: options.color || defaultColor,
        hatching: options.hatching,
        opacity: options.opacity
      }
    };
  },
  _areBordersVisible: function _areBordersVisible() {
    var options = this._options;
    return options.border.visible || options.hoverStyle.border.visible || options.selectionStyle.border.visible;
  },
  _createMainElement: function _createMainElement(points, settings) {
    return this._renderer.path(points, 'area').attr(settings);
  },
  _getTrackerSettings: function _getTrackerSettings(segment) {
    return {
      'stroke-width': segment.singlePointSegment ? this._defaultTrackerWidth : 0
    };
  },
  _getMainPointsFromSegment: function _getMainPointsFromSegment(segment) {
    return segment.area;
  }
};

function createAreaPoints(points) {
  return (0, _utils.map)(points, function (pt) {
    return pt.getCoords();
  }).concat((0, _utils.map)(points.slice().reverse(), function (pt) {
    return pt.getCoords(true);
  }));
}

var areaSeries = chart['area'] = _extend({}, chartLineSeries, baseAreaMethods, {
  _prepareSegment: function _prepareSegment(points, rotated) {
    var that = this;

    var processedPoints = that._processSinglePointsAreaSegment(points, rotated);

    var areaPoints = createAreaPoints(processedPoints);
    var argAxis = that.getArgumentAxis();

    if (argAxis.getAxisPosition) {
      var argAxisPosition = argAxis.getAxisPosition();
      var axisOptions = argAxis.getOptions();
      var edgeOffset = (!rotated ? -1 : 1) * Math.round(axisOptions.width / 2);

      if (axisOptions.visible) {
        areaPoints.forEach(function (p, i) {
          if (p) {
            var index = points.length === 1 ? 0 : i < points.length ? i : areaPoints.length - 1 - i;
            rotated && p.x === points[index].defaultX && p.x === argAxisPosition - argAxis.getAxisShift() && (p.x += edgeOffset);
            !rotated && p.y === points[index].defaultY && p.y === argAxisPosition - argAxis.getAxisShift() && (p.y += edgeOffset);
          }
        });
      }
    }

    return {
      line: processedPoints,
      area: areaPoints,
      singlePointSegment: processedPoints !== points
    };
  },
  _processSinglePointsAreaSegment: function _processSinglePointsAreaSegment(points, rotated) {
    if (points && points.length === 1) {
      var p = points[0];
      var p1 = (0, _object.clone)(p);
      p1[rotated ? 'y' : 'x'] += 1;
      p1.argument = null;
      return [p, p1];
    }

    return points;
  }
});

polar['area'] = _extend({}, polarLineSeries, baseAreaMethods, {
  _prepareSegment: function _prepareSegment(points, rotated, lastSegment) {
    lastSegment && polarLineSeries._closeSegment.call(this, points);
    return areaSeries._prepareSegment.call(this, points);
  },
  _processSinglePointsAreaSegment: function _processSinglePointsAreaSegment(points) {
    return _line_series.polar.line._prepareSegment.call(this, points).line;
  }
});
chart['steparea'] = _extend({}, areaSeries, {
  _prepareSegment: function _prepareSegment(points, rotated) {
    var stepLineSeries = _line_series.chart['stepline'];
    points = areaSeries._processSinglePointsAreaSegment(points, rotated);
    return areaSeries._prepareSegment.call(this, stepLineSeries._calculateStepLinePoints.call(this, points), rotated);
  },
  getSeriesPairCoord: _line_series.chart['stepline'].getSeriesPairCoord
});
chart['splinearea'] = _extend({}, areaSeries, {
  _areaPointsToSplineAreaPoints: function _areaPointsToSplineAreaPoints(areaPoints) {
    var previousMiddlePoint = areaPoints[areaPoints.length / 2 - 1];
    var middlePoint = areaPoints[areaPoints.length / 2];
    areaPoints.splice(areaPoints.length / 2, 0, {
      x: previousMiddlePoint.x,
      y: previousMiddlePoint.y
    }, {
      x: middlePoint.x,
      y: middlePoint.y
    });
  },
  _prepareSegment: function _prepareSegment(points, rotated) {
    var processedPoints = areaSeries._processSinglePointsAreaSegment(points, rotated);

    var areaSegment = areaSeries._prepareSegment.call(this, calculateBezierPoints(processedPoints, rotated));

    this._areaPointsToSplineAreaPoints(areaSegment.area);

    areaSegment.singlePointSegment = processedPoints !== points;
    return areaSegment;
  },
  _getDefaultSegment: function _getDefaultSegment(segment) {
    var areaDefaultSegment = areaSeries._getDefaultSegment(segment);

    this._areaPointsToSplineAreaPoints(areaDefaultSegment.area);

    return areaDefaultSegment;
  },
  _createMainElement: function _createMainElement(points, settings) {
    return this._renderer.path(points, 'bezierarea').attr(settings);
  },
  _createBorderElement: _line_series.chart['spline']._createMainElement,
  getSeriesPairCoord: _line_series.chart['spline'].getSeriesPairCoord,
  _getNearestPoints: _line_series.chart['spline']._getNearestPoints,
  _getBezierPoints: _line_series.chart['spline']._getBezierPoints,
  obtainCubicBezierTCoef: _line_series.chart['spline'].obtainCubicBezierTCoef
});

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.compareArrays = compareArrays;
exports.getSampleText = exports.formatValue = exports.BaseGauge = void 0;

var _utils = __webpack_require__(14);

var _extend2 = __webpack_require__(0);

var _translator1d = __webpack_require__(601);

var _base_widget = _interopRequireDefault(__webpack_require__(119));

var _theme_manager = _interopRequireDefault(__webpack_require__(1071));

var _tracker = _interopRequireDefault(__webpack_require__(1072));

var _format_helper = _interopRequireDefault(__webpack_require__(82));

var _export = __webpack_require__(118);

var _title = __webpack_require__(138);

var _tooltip = __webpack_require__(140);

var _loading_indicator = __webpack_require__(163);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _Number = Number;
var _extend = _extend2.extend;
var _format = _format_helper.default.format;

var BaseGauge = _base_widget.default.inherit({
  _rootClassPrefix: 'dxg',
  _themeSection: 'gauge',
  _createThemeManager: function _createThemeManager() {
    return new _theme_manager.default.ThemeManager(this._getThemeManagerOptions());
  },
  _initCore: function _initCore() {
    var that = this;
    var root = that._renderer.root;
    that._valueChangingLocker = 0;
    that._translator = that._factory.createTranslator();
    that._tracker = that._factory.createTracker({
      renderer: that._renderer,
      container: root
    });

    that._setTrackerCallbacks();
  },
  _beginValueChanging: function _beginValueChanging() {
    this._resetIsReady();

    this._onBeginUpdate();

    ++this._valueChangingLocker;
  },
  _endValueChanging: function _endValueChanging() {
    if (--this._valueChangingLocker === 0) {
      this._drawn();
    }
  },
  _setTrackerCallbacks: function _setTrackerCallbacks() {
    var that = this;
    var renderer = that._renderer;
    var tooltip = that._tooltip;

    that._tracker.setCallbacks({
      'tooltip-show': function tooltipShow(target, info, callback) {
        var tooltipParameters = target.getTooltipParameters();
        var offset = renderer.getRootOffset();

        var formatObject = _extend({
          value: tooltipParameters.value,
          valueText: tooltip.formatValue(tooltipParameters.value),
          color: tooltipParameters.color
        }, info);

        return tooltip.show(formatObject, {
          x: tooltipParameters.x + offset.left,
          y: tooltipParameters.y + offset.top,
          offset: tooltipParameters.offset
        }, {
          target: info
        }, undefined, callback);
      },
      'tooltip-hide': function tooltipHide() {
        return tooltip.hide();
      }
    });
  },
  _dispose: function _dispose() {
    this._cleanCore();

    this.callBase.apply(this, arguments);
  },
  _disposeCore: function _disposeCore() {
    var that = this;

    that._themeManager.dispose();

    that._tracker.dispose();

    that._translator = that._tracker = null;
  },
  _cleanCore: function _cleanCore() {
    var that = this;

    that._tracker.deactivate();

    that._cleanContent();
  },
  _renderCore: function _renderCore() {
    var that = this;
    if (!that._isValidDomain) return;

    that._renderContent();

    that._tracker.setTooltipState(that._tooltip.isEnabled());

    that._tracker.activate();

    that._noAnimation = false;
  },
  _applyChanges: function _applyChanges() {
    this.callBase.apply(this, arguments);
    this._resizing = this._noAnimation = false;
  },
  _setContentSize: function _setContentSize() {
    var that = this;
    that._resizing = that._noAnimation = that._changes.count() === 2;
    that.callBase.apply(that, arguments);
  },
  _applySize: function _applySize(rect) {
    var that = this;
    that._innerRect = {
      left: rect[0],
      top: rect[1],
      right: rect[2],
      bottom: rect[3]
    }; // If loading indicator is shown it is got hidden at the end of "_renderCore" - during "_drawn". Then "loadingIndicator" option is changed.
    // It causes another "_setContentSize" execution (inside of the first one). Layout backwards during inner "_setContentSize" and clears its cache and
    // then backwards again during outer "_setContentSize" when "_cache" is null - so it fails.
    // The following code dirtily preserves layout cache for the outer backward.
    // The appropriate solution is to remove heavy rendering from "_applySize" - it should be done later during some other change processing.
    // It would be even better to somehow defer any inside option changes - so they all are applied after all changes are processed.

    var layoutCache = that._layout._cache;

    that._cleanCore();

    that._renderCore();

    that._layout._cache = that._layout._cache || layoutCache;
    return [rect[0], that._innerRect.top, rect[2], that._innerRect.bottom];
  },
  _initialChanges: ['DOMAIN'],
  _themeDependentChanges: ['DOMAIN'],
  _optionChangesMap: {
    subtitle: 'MOSTLY_TOTAL',
    indicator: 'MOSTLY_TOTAL',
    geometry: 'MOSTLY_TOTAL',
    animation: 'MOSTLY_TOTAL',
    startValue: 'DOMAIN',
    endValue: 'DOMAIN'
  },
  _optionChangesOrder: ['DOMAIN', 'MOSTLY_TOTAL'],
  _change_DOMAIN: function _change_DOMAIN() {
    this._setupDomain();
  },
  _change_MOSTLY_TOTAL: function _change_MOSTLY_TOTAL() {
    this._applyMostlyTotalChange();
  },
  _setupDomain: function _setupDomain() {
    var that = this;

    that._setupDomainCore(); // T130599


    that._isValidDomain = isFinite(1 / (that._translator.getDomain()[1] - that._translator.getDomain()[0]));

    if (!that._isValidDomain) {
      that._incidentOccurred('W2301');
    }

    that._change(['MOSTLY_TOTAL']);
  },
  _applyMostlyTotalChange: function _applyMostlyTotalChange() {
    var that = this;

    that._setupCodomain();

    that._setupAnimationSettings();

    that._setupDefaultFormat();

    that._change(['LAYOUT']);
  },
  _setupAnimationSettings: function _setupAnimationSettings() {
    var that = this;
    var option = that.option('animation');
    that._animationSettings = null;

    if (option === undefined || option) {
      option = _extend({
        enabled: true,
        duration: 1000,
        easing: 'easeOutCubic'
      }, option);

      if (option.enabled && option.duration > 0) {
        that._animationSettings = {
          duration: _Number(option.duration),
          easing: option.easing
        };
      }
    } //  It is better to place it here than to create separate function for one line of code


    that._containerBackgroundColor = that.option('containerBackgroundColor') || that._themeManager.theme().containerBackgroundColor;
  },
  _setupDefaultFormat: function _setupDefaultFormat() {
    var domain = this._translator.getDomain();

    this._defaultFormatOptions = (0, _utils.getAppropriateFormat)(domain[0], domain[1], this._getApproximateScreenRange());
  },
  _setupDomainCore: null,
  _calculateSize: null,
  _cleanContent: null,
  _renderContent: null,
  _setupCodomain: null,
  _getApproximateScreenRange: null,
  _factory: {
    createTranslator: function createTranslator() {
      return new _translator1d.Translator1D();
    },
    createTracker: function createTracker(parameters) {
      return new _tracker.default(parameters);
    }
  }
}); //  TODO: find a better place for it


exports.BaseGauge = BaseGauge;

var formatValue = function formatValue(value, options, extra) {
  options = options || {};

  var text = _format(value, options.format);

  var formatObject;

  if (typeof options.customizeText === 'function') {
    formatObject = _extend({
      value: value,
      valueText: text
    }, extra);
    return String(options.customizeText.call(formatObject, formatObject));
  }

  return text;
}; //  TODO: find a better place for it


exports.formatValue = formatValue;

var getSampleText = function getSampleText(translator, options) {
  var text1 = formatValue(translator.getDomainStart(), options);
  var text2 = formatValue(translator.getDomainEnd(), options);
  return text1.length >= text2.length ? text1 : text2;
};

exports.getSampleText = getSampleText;

function compareArrays(array1, array2) {
  return array1 && array2 && array1.length === array2.length && compareArraysElements(array1, array2);
}

function compareArraysElements(array1, array2) {
  var i;
  var ii = array1.length;
  var array1ValueIsNaN;
  var array2ValueIsNaN;

  for (i = 0; i < ii; ++i) {
    array1ValueIsNaN = array1[i] !== array1[i];
    array2ValueIsNaN = array2[i] !== array2[i];

    if (array1ValueIsNaN && array2ValueIsNaN) {
      continue;
    }

    if (array1[i] !== array2[i]) return false;
  }

  return true;
} // PLUGINS_SECTION


BaseGauge.addPlugin(_export.plugin);
BaseGauge.addPlugin(_title.plugin);
BaseGauge.addPlugin(_tooltip.plugin);
BaseGauge.addPlugin(_loading_indicator.plugin); // These are gauges specifics on using tooltip - they require refactoring.

var _setTooltipOptions = BaseGauge.prototype._setTooltipOptions;

BaseGauge.prototype._setTooltipOptions = function () {
  _setTooltipOptions.apply(this, arguments);

  this._tracker && this._tracker.setTooltipState(this._tooltip.isEnabled());
};

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _extend2 = __webpack_require__(0);

function Node() {}

var updateTile = [updateLeaf, updateGroup];
(0, _extend2.extend)(Node.prototype, {
  value: 0,
  isNode: function isNode() {
    return !!(this.nodes && this.level < this.ctx.maxLevel);
  },
  isActive: function isActive() {
    var ctx = this.ctx;
    return this.level >= ctx.minLevel && this.level <= ctx.maxLevel;
  },
  updateStyles: function updateStyles() {
    var that = this;
    var isNode = Number(that.isNode());
    that.state = that._buildState(that.ctx.settings[isNode].state, !isNode && that.color && {
      fill: that.color
    });
  },
  _buildState: function _buildState(state, extra) {
    var base = (0, _extend2.extend)({}, state);
    return extra ? (0, _extend2.extend)(base, extra) : base;
  },
  updateLabelStyle: function updateLabelStyle() {
    var settings = this.ctx.settings[Number(this.isNode())];
    this.labelState = settings.labelState;
    this.labelParams = settings.labelParams;
  },
  _getState: function _getState() {
    return this.state;
  },
  applyState: function applyState() {
    updateTile[Number(this.isNode())](this.tile, this._getState());
  }
});

function updateLeaf(content, attrs) {
  content.smartAttr(attrs);
}

function updateGroup(content, attrs) {
  content.outer.attr({
    stroke: attrs.stroke,
    'stroke-width': attrs['stroke-width'],
    'stroke-opacity': attrs['stroke-opacity']
  });
  content.inner.smartAttr({
    fill: attrs.fill,
    opacity: attrs.opacity,
    hatching: attrs.hatching
  });
}

var _default = Node;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getLanguageId = getLanguageId;

var _core = _interopRequireDefault(__webpack_require__(85));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LANGUAGE_CODES = {
  'ar': 1,
  'bg': 2,
  'ca': 3,
  'zh-Hans': 4,
  'cs': 5,
  'da': 6,
  'de': 7,
  'el': 8,
  'en': 9,
  'es': 10,
  'fi': 11,
  'fr': 12,
  'he': 13,
  'hu': 14,
  'is': 15,
  'it': 16,
  'ja': 17,
  'ko': 18,
  'nl': 19,
  'no': 20,
  'pl': 21,
  'pt': 22,
  'rm': 23,
  'ro': 24,
  'ru': 25,
  'hr': 26,
  'sk': 27,
  'sq': 28,
  'sv': 29,
  'th': 30,
  'tr': 31,
  'ur': 32,
  'id': 33,
  'uk': 34,
  'be': 35,
  'sl': 36,
  'et': 37,
  'lv': 38,
  'lt': 39,
  'tg': 40,
  'fa': 41,
  'vi': 42,
  'hy': 43,
  'az': 44,
  'eu': 45,
  'hsb': 46,
  'mk': 47,
  'tn': 50,
  'xh': 52,
  'zu': 53,
  'af': 54,
  'ka': 55,
  'fo': 56,
  'hi': 57,
  'mt': 58,
  'se': 59,
  'ga': 60,
  'ms': 62,
  'kk': 63,
  'ky': 64,
  'sw': 65,
  'tk': 66,
  'uz': 67,
  'tt': 68,
  'bn': 69,
  'pa': 70,
  'gu': 71,
  'or': 72,
  'ta': 73,
  'te': 74,
  'kn': 75,
  'ml': 76,
  'as': 77,
  'mr': 78,
  'sa': 79,
  'mn': 80,
  'bo': 81,
  'cy': 82,
  'km': 83,
  'lo': 84,
  'gl': 86,
  'kok': 87,
  'syr': 90,
  'si': 91,
  'iu': 93,
  'am': 94,
  'tzm': 95,
  'ne': 97,
  'fy': 98,
  'ps': 99,
  'fil': 100,
  'dv': 101,
  'ha': 104,
  'yo': 106,
  'quz': 107,
  'nso': 108,
  'ba': 109,
  'lb': 110,
  'kl': 111,
  'ig': 112,
  'ii': 120,
  'arn': 122,
  'moh': 124,
  'br': 126,
  'ug': 128,
  'mi': 129,
  'oc': 130,
  'co': 131,
  'gsw': 132,
  'sah': 133,
  'qut': 134,
  'rw': 135,
  'wo': 136,
  'prs': 140,
  'gd': 145,
  'ar-SA': 1025,
  'bg-BG': 1026,
  'ca-ES': 1027,
  'zh-TW': 1028,
  'cs-CZ': 1029,
  'da-DK': 1030,
  'de-DE': 1031,
  'el-GR': 1032,
  'en-US': 1033,
  'fi-FI': 1035,
  'fr-FR': 1036,
  'he-IL': 1037,
  'hu-HU': 1038,
  'is-IS': 1039,
  'it-IT': 1040,
  'ja-JP': 1041,
  'ko-KR': 1042,
  'nl-NL': 1043,
  'nb-NO': 1044,
  'pl-PL': 1045,
  'pt-BR': 1046,
  'rm-CH': 1047,
  'ro-RO': 1048,
  'ru-RU': 1049,
  'hr-HR': 1050,
  'sk-SK': 1051,
  'sq-AL': 1052,
  'sv-SE': 1053,
  'th-TH': 1054,
  'tr-TR': 1055,
  'ur-PK': 1056,
  'id-ID': 1057,
  'uk-UA': 1058,
  'be-BY': 1059,
  'sl-SI': 1060,
  'et-EE': 1061,
  'lv-LV': 1062,
  'lt-LT': 1063,
  'tg-Cyrl-TJ': 1064,
  'fa-IR': 1065,
  'vi-VN': 1066,
  'hy-AM': 1067,
  'az-Latn-AZ': 1068,
  'eu-ES': 1069,
  'hsb-DE': 1070,
  'mk-MK': 1071,
  'tn-ZA': 1074,
  'xh-ZA': 1076,
  'zu-ZA': 1077,
  'af-ZA': 1078,
  'ka-GE': 1079,
  'fo-FO': 1080,
  'hi-IN': 1081,
  'mt-MT': 1082,
  'se-NO': 1083,
  'ms-MY': 1086,
  'kk-KZ': 1087,
  'ky-KG': 1088,
  'sw-KE': 1089,
  'tk-TM': 1090,
  'uz-Latn-UZ': 1091,
  'tt-RU': 1092,
  'bn-IN': 1093,
  'pa-IN': 1094,
  'gu-IN': 1095,
  'or-IN': 1096,
  'ta-IN': 1097,
  'te-IN': 1098,
  'kn-IN': 1099,
  'ml-IN': 1100,
  'as-IN': 1101,
  'mr-IN': 1102,
  'sa-IN': 1103,
  'mn-MN': 1104,
  'bo-CN': 1105,
  'cy-GB': 1106,
  'km-KH': 1107,
  'lo-LA': 1108,
  'gl-ES': 1110,
  'kok-IN': 1111,
  'syr-SY': 1114,
  'si-LK': 1115,
  'iu-Cans-CA': 1117,
  'am-ET': 1118,
  'ne-NP': 1121,
  'fy-NL': 1122,
  'ps-AF': 1123,
  'fil-PH': 1124,
  'dv-MV': 1125,
  'ha-Latn-NG': 1128,
  'yo-NG': 1130,
  'quz-BO': 1131,
  'nso-ZA': 1132,
  'ba-RU': 1133,
  'lb-LU': 1134,
  'kl-GL': 1135,
  'ig-NG': 1136,
  'ii-CN': 1144,
  'arn-CL': 1146,
  'moh-CA': 1148,
  'br-FR': 1150,
  'ug-CN': 1152,
  'mi-NZ': 1153,
  'oc-FR': 1154,
  'co-FR': 1155,
  'gsw-FR': 1156,
  'sah-RU': 1157,
  'qut-GT': 1158,
  'rw-RW': 1159,
  'wo-SN': 1160,
  'prs-AF': 1164,
  'gd-GB': 1169,
  'ar-IQ': 2049,
  'zh-CN': 2052,
  'de-CH': 2055,
  'en-GB': 2057,
  'es-MX': 2058,
  'fr-BE': 2060,
  'it-CH': 2064,
  'nl-BE': 2067,
  'nn-NO': 2068,
  'pt-PT': 2070,
  'sr-Latn-CS': 2074,
  'sv-FI': 2077,
  'az-Cyrl-AZ': 2092,
  'dsb-DE': 2094,
  'se-SE': 2107,
  'ga-IE': 2108,
  'ms-BN': 2110,
  'uz-Cyrl-UZ': 2115,
  'bn-BD': 2117,
  'mn-Mong-CN': 2128,
  'iu-Latn-CA': 2141,
  'tzm-Latn-DZ': 2143,
  'quz-EC': 2155,
  'ar-EG': 3073,
  'zh-HK': 3076,
  'de-AT': 3079,
  'en-AU': 3081,
  'es-ES': 3082,
  'fr-CA': 3084,
  'sr-Cyrl-CS': 3098,
  'se-FI': 3131,
  'quz-PE': 3179,
  'ar-LY': 4097,
  'zh-SG': 4100,
  'de-LU': 4103,
  'en-CA': 4105,
  'es-GT': 4106,
  'fr-CH': 4108,
  'hr-BA': 4122,
  'smj-NO': 4155,
  'ar-DZ': 5121,
  'zh-MO': 5124,
  'de-LI': 5127,
  'en-NZ': 5129,
  'es-CR': 5130,
  'fr-LU': 5132,
  'bs-Latn-BA': 5146,
  'smj-SE': 5179,
  'ar-MA': 6145,
  'en-IE': 6153,
  'es-PA': 6154,
  'fr-MC': 6156,
  'sr-Latn-BA': 6170,
  'sma-NO': 6203,
  'ar-TN': 7169,
  'en-ZA': 7177,
  'es-DO': 7178,
  'sr-Cyrl-BA': 7194,
  'sma-SE': 7227,
  'ar-OM': 8193,
  'en-JM': 8201,
  'es-VE': 8202,
  'bs-Cyrl-BA': 8218,
  'sms-FI': 8251,
  'ar-YE': 9217,
  'en-029': 9225,
  'es-CO': 9226,
  'sr-Latn-RS': 9242,
  'smn-FI': 9275,
  'ar-SY': 10241,
  'en-BZ': 10249,
  'es-PE': 10250,
  'sr-Cyrl-RS': 10266,
  'ar-JO': 11265,
  'en-TT': 11273,
  'es-AR': 11274,
  'sr-Latn-ME': 11290,
  'ar-LB': 12289,
  'en-ZW': 12297,
  'es-EC': 12298,
  'sr-Cyrl-ME': 12314,
  'ar-KW': 13313,
  'en-PH': 13321,
  'es-CL': 13322,
  'ar-AE': 14337,
  'es-UY': 14346,
  'ar-BH': 15361,
  'es-PY': 15370,
  'ar-QA': 16385,
  'en-IN': 16393,
  'es-BO': 16394,
  'en-MY': 17417,
  'es-SV': 17418,
  'en-SG': 18441,
  'es-HN': 18442,
  'es-NI': 19466,
  'es-PR': 20490,
  'es-US': 21514,
  'bs-Cyrl': 25626,
  'bs-Latn': 26650,
  'sr-Cyrl': 27674,
  'sr-Latn': 28698,
  'smn': 28731,
  'az-Cyrl': 29740,
  'sms': 29755,
  'zh': 30724,
  'nn': 30740,
  'bs': 30746,
  'az-Latn': 30764,
  'sma': 30779,
  'uz-Cyrl': 30787,
  'mn-Cyrl': 30800,
  'iu-Cans': 30813,
  'zh-Hant': 31748,
  'nb': 31764,
  'sr': 31770,
  'tg-Cyrl': 31784,
  'dsb': 31790,
  'smj': 31803,
  'uz-Latn': 31811,
  'mn-Mong': 31824,
  'iu-Latn': 31837,
  'tzm-Latn': 31839,
  'ha-Latn': 31848
};

function getLanguageId() {
  return LANGUAGE_CODES[_core.default.locale()];
}

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getSvgMarkup = getSvgMarkup;
exports.getSvgElement = getSvgElement;

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _window = __webpack_require__(7);

var _renderer = _interopRequireDefault(__webpack_require__(2));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var window = (0, _window.getWindow)();

function getMarkup(element, backgroundColor) {
  var temp = _dom_adapter.default.createElement('div');

  var clone = element.cloneNode(true);

  if (backgroundColor) {
    (0, _renderer.default)(clone).css('backgroundColor', backgroundColor);
  }

  temp.appendChild(clone);
  return temp.innerHTML;
}

function fixNamespaces(markup) {
  var first = true;

  if (markup.indexOf('xmlns:xlink') === -1) {
    markup = markup.replace('<svg', '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
  }

  markup = markup.replace(/xmlns="[\s\S]*?"/gi, function (match) {
    if (!first) return '';
    first = false;
    return match;
  });
  return markup.replace(/xmlns:NS1="[\s\S]*?"/gi, '').replace(/NS1:xmlns:xlink="([\s\S]*?)"/gi, 'xmlns:xlink="$1"');
} // T428345 we decode only restricted HTML entities, looks like other entities do not cause problems
// as they presented as symbols itself, not named entities


function decodeHtmlEntities(markup) {
  return markup.replace(/&quot;/gi, '&#34;').replace(/&amp;/gi, '&#38;').replace(/&apos;/gi, '&#39;').replace(/&lt;/gi, '&#60;').replace(/&gt;/gi, '&#62;').replace(/&nbsp;/gi, '&#160;').replace(/&shy;/gi, '&#173;');
}

function getSvgMarkup(element, backgroundColor) {
  return fixNamespaces(decodeHtmlEntities(getMarkup(element, backgroundColor)));
}

function getSvgElement(markup) {
  return _dom_adapter.default.isNode(markup) ? markup : new window.DOMParser().parseFromString(markup, 'image/svg+xml').childNodes[0];
}

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.themeReadyCallback = void 0;

var _callbacks = _interopRequireDefault(__webpack_require__(28));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var themeReadyCallback = new _callbacks.default();
exports.themeReadyCallback = themeReadyCallback;

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _array = __webpack_require__(12);

var _uiCollection_widgetEdit = _interopRequireDefault(__webpack_require__(412));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var PlainEditStrategy = _uiCollection_widgetEdit.default.inherit({
  _getPlainItems: function _getPlainItems() {
    return this._collectionWidget.option('items') || [];
  },
  getIndexByItemData: function getIndexByItemData(itemData) {
    var keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);

    if (keyOf) {
      return this.getIndexByKey(keyOf(itemData));
    } else {
      return (0, _array.inArray)(itemData, this._getPlainItems());
    }
  },
  getItemDataByIndex: function getItemDataByIndex(index) {
    return this._getPlainItems()[index];
  },
  deleteItemAtIndex: function deleteItemAtIndex(index) {
    this._getPlainItems().splice(index, 1);
  },
  itemsGetter: function itemsGetter() {
    return this._getPlainItems();
  },
  getKeysByItems: function getKeysByItems(items) {
    var keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);

    var result = items;

    if (keyOf) {
      result = [];

      for (var i = 0; i < items.length; i++) {
        result.push(keyOf(items[i]));
      }
    }

    return result;
  },
  getIndexByKey: function getIndexByKey(key) {
    var cache = this._cache;
    var keys = cache && cache.keys || this.getKeysByItems(this._getPlainItems());

    if (cache && !cache.keys) {
      cache.keys = keys;
    }

    if (_typeof(key) === 'object') {
      for (var i = 0, length = keys.length; i < length; i++) {
        if (this._equalKeys(key, keys[i])) return i;
      }
    } else {
      return keys.indexOf(key);
    }

    return -1;
  },
  getItemsByKeys: function getItemsByKeys(keys, items) {
    return (items || keys).slice();
  },
  moveItemAtIndexToIndex: function moveItemAtIndexToIndex(movingIndex, destinationIndex) {
    var items = this._getPlainItems();

    var movedItemData = items[movingIndex];
    items.splice(movingIndex, 1);
    items.splice(destinationIndex, 0, movedItemData);
  },
  _isItemIndex: function _isItemIndex(index) {
    return typeof index === 'number' && Math.round(index) === index;
  },
  _getNormalizedItemIndex: function _getNormalizedItemIndex(itemElement) {
    return this._collectionWidget._itemElements().index(itemElement);
  },
  _normalizeItemIndex: function _normalizeItemIndex(index) {
    return index;
  },
  _denormalizeItemIndex: function _denormalizeItemIndex(index) {
    return index;
  },
  _getItemByNormalizedIndex: function _getItemByNormalizedIndex(index) {
    return index > -1 ? this._collectionWidget._itemElements().eq(index) : null;
  },
  _itemsFromSameParent: function _itemsFromSameParent() {
    return true;
  }
});

var _default = PlainEditStrategy;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getParser = exports.getPatternSetters = exports.getRegExpInfo = void 0;

var _common = __webpack_require__(4);

var FORMAT_TYPES = {
  '3': 'abbreviated',
  '4': 'wide',
  '5': 'narrow'
};

var monthRegExpGenerator = function monthRegExpGenerator(count, dateParts) {
  if (count > 2) {
    return Object.keys(FORMAT_TYPES).map(function (count) {
      return ['format', 'standalone'].map(function (type) {
        return dateParts.getMonthNames(FORMAT_TYPES[count], type).join('|');
      }).join('|');
    }).join('|');
  }

  return '0?[1-9]|1[012]';
};

var PATTERN_REGEXPS = {
  ':': function _(count, dateParts) {
    var countSuffix = count > 1 ? "{".concat(count, "}") : '';
    return "\\".concat(dateParts.getTimeSeparator()).concat(countSuffix);
  },
  y: function y(count) {
    return '[0-9]+';
  },
  M: monthRegExpGenerator,
  L: monthRegExpGenerator,
  Q: function Q(count, dateParts) {
    if (count > 2) {
      return dateParts.getQuarterNames(FORMAT_TYPES[count], 'format').join('|');
    }

    return '0?[1-4]';
  },
  E: function E(count, dateParts) {
    return '\\D*';
  },
  a: function a(count, dateParts) {
    return dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], 'format').join('|');
  },
  d: function d(count) {
    return '0?[1-9]|[12][0-9]|3[01]';
  },
  H: function H(count) {
    return '0?[0-9]|1[0-9]|2[0-3]';
  },
  h: function h(count) {
    return '0?[1-9]|1[012]';
  },
  m: function m(count) {
    return '0?[0-9]|[1-5][0-9]';
  },
  s: function s(count) {
    return '0?[0-9]|[1-5][0-9]';
  },
  S: function S(count) {
    return '[0-9]{1,' + count + '}';
  },
  w: function w(count) {
    return '0?[0-9]|[1-5][0-9]';
  }
};
var parseNumber = Number;

var caseInsensitiveIndexOf = function caseInsensitiveIndexOf(array, value) {
  return array.map(function (item) {
    return item.toLowerCase();
  }).indexOf(value.toLowerCase());
};

var monthPatternParser = function monthPatternParser(text, count, dateParts) {
  if (count > 2) {
    return ['format', 'standalone'].map(function (type) {
      return Object.keys(FORMAT_TYPES).map(function (count) {
        var monthNames = dateParts.getMonthNames(FORMAT_TYPES[count], type);
        return caseInsensitiveIndexOf(monthNames, text);
      });
    }).reduce(function (a, b) {
      return a.concat(b);
    }).filter(function (index) {
      return index >= 0;
    })[0];
  }

  return parseNumber(text) - 1;
};

var PATTERN_PARSERS = {
  y: function y(text, count) {
    var year = parseNumber(text);

    if (count === 2) {
      return year < 30 ? 2000 + year : 1900 + year;
    }

    return year;
  },
  M: monthPatternParser,
  L: monthPatternParser,
  Q: function Q(text, count, dateParts) {
    if (count > 2) {
      return dateParts.getQuarterNames(FORMAT_TYPES[count], 'format').indexOf(text);
    }

    return parseNumber(text) - 1;
  },
  E: function E(text, count, dateParts) {
    var dayNames = dateParts.getDayNames(FORMAT_TYPES[count < 3 ? 3 : count], 'format');
    return caseInsensitiveIndexOf(dayNames, text);
  },
  a: function a(text, count, dateParts) {
    var periodNames = dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], 'format');
    return caseInsensitiveIndexOf(periodNames, text);
  },
  d: parseNumber,
  H: parseNumber,
  h: parseNumber,
  m: parseNumber,
  s: parseNumber,
  S: function S(text, count) {
    count = Math.max(count, 3);
    text = text.slice(0, 3);

    while (count < 3) {
      text = text + '0';
      count++;
    }

    return parseNumber(text);
  }
};
var ORDERED_PATTERNS = ['y', 'M', 'd', 'h', 'm', 's', 'S'];
var PATTERN_SETTERS = {
  y: 'setFullYear',
  M: 'setMonth',
  L: 'setMonth',
  a: function a(date, value, datePartValues) {
    var hours = date.getHours();
    var hourPartValue = datePartValues['h'];

    if (hourPartValue !== undefined && hourPartValue !== hours) {
      hours--;
    }

    if (!value && hours === 12) {
      hours = 0;
    } else if (value && hours !== 12) {
      hours += 12;
    }

    date.setHours(hours);
  },
  d: 'setDate',
  H: 'setHours',
  h: 'setHours',
  m: 'setMinutes',
  s: 'setSeconds',
  S: 'setMilliseconds'
};

var getSameCharCount = function getSameCharCount(text, index) {
  var char = text[index];
  var count = 0;

  do {
    index++;
    count++;
  } while (text[index] === char);

  return count;
};

var createPattern = function createPattern(char, count) {
  var result = '';

  for (var i = 0; i < count; i++) {
    result += char;
  }

  return result;
};

var getRegExpInfo = function getRegExpInfo(format, dateParts) {
  var regexpText = '';
  var stubText = '';
  var isEscaping;
  var patterns = [];

  var addPreviousStub = function addPreviousStub() {
    if (stubText) {
      patterns.push('\'' + stubText + '\'');
      regexpText += (0, _common.escapeRegExp)(stubText) + ')';
      stubText = '';
    }
  };

  for (var i = 0; i < format.length; i++) {
    var char = format[i];
    var isEscapeChar = char === '\'';
    var regexpPart = PATTERN_REGEXPS[char];

    if (isEscapeChar) {
      isEscaping = !isEscaping;

      if (format[i - 1] !== '\'') {
        continue;
      }
    }

    if (regexpPart && !isEscaping) {
      var count = getSameCharCount(format, i);
      var pattern = createPattern(char, count);
      addPreviousStub();
      patterns.push(pattern);
      regexpText += '(' + regexpPart(count, dateParts) + ')';
      i += count - 1;
    } else {
      if (!stubText) {
        regexpText += '(';
      }

      stubText += char;
    }
  }

  addPreviousStub();
  return {
    patterns: patterns,
    regexp: new RegExp('^' + regexpText + '$', 'i')
  };
};

exports.getRegExpInfo = getRegExpInfo;

var getPatternSetters = function getPatternSetters() {
  return PATTERN_SETTERS;
};

exports.getPatternSetters = getPatternSetters;

var setPatternPart = function setPatternPart(date, pattern, text, dateParts, datePartValues) {
  var patternChar = pattern[0];
  var partSetter = PATTERN_SETTERS[patternChar];
  var partParser = PATTERN_PARSERS[patternChar];

  if (partSetter && partParser) {
    var value = partParser(text, pattern.length, dateParts);
    datePartValues[pattern] = value;

    if (date[partSetter]) {
      date[partSetter](value);
    } else {
      partSetter(date, value, datePartValues);
    }
  }
};

var setPatternPartFromNow = function setPatternPartFromNow(date, pattern, now) {
  var setterName = PATTERN_SETTERS[pattern];
  var getterName = 'g' + setterName.substr(1);
  var value = now[getterName]();
  date[setterName](value);
};

var getShortPatterns = function getShortPatterns(fullPatterns) {
  return fullPatterns.map(function (pattern) {
    if (pattern[0] === '\'') {
      return '';
    } else {
      return pattern[0] === 'H' ? 'h' : pattern[0];
    }
  });
};

var getMaxOrderedPatternIndex = function getMaxOrderedPatternIndex(patterns) {
  var indexes = patterns.map(function (pattern) {
    return ORDERED_PATTERNS.indexOf(pattern);
  });
  return Math.max.apply(Math, indexes);
};

var getOrderedFormatPatterns = function getOrderedFormatPatterns(formatPatterns) {
  var otherPatterns = formatPatterns.filter(function (pattern) {
    return ORDERED_PATTERNS.indexOf(pattern) < 0;
  });
  return ORDERED_PATTERNS.concat(otherPatterns);
};

var getParser = function getParser(format, dateParts) {
  var regExpInfo = getRegExpInfo(format, dateParts);
  return function (text) {
    var regExpResult = regExpInfo.regexp.exec(text);

    if (regExpResult) {
      var now = new Date();
      var date = new Date(now.getFullYear(), 0, 1);
      var formatPatterns = getShortPatterns(regExpInfo.patterns);
      var maxPatternIndex = getMaxOrderedPatternIndex(formatPatterns);
      var orderedFormatPatterns = getOrderedFormatPatterns(formatPatterns);
      var datePartValues = {};
      orderedFormatPatterns.forEach(function (pattern, index) {
        if (!pattern || index < ORDERED_PATTERNS.length && index > maxPatternIndex) {
          return;
        }

        var patternIndex = formatPatterns.indexOf(pattern);

        if (patternIndex >= 0) {
          var regExpPattern = regExpInfo.patterns[patternIndex];
          var regExpText = regExpResult[patternIndex + 1];
          setPatternPart(date, regExpPattern, regExpText, dateParts, datePartValues);
        } else {
          setPatternPartFromNow(date, pattern, now);
        }
      });
      return date;
    }

    return null;
  };
};

exports.getParser = getParser;

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.hideCallback = void 0;

var _array = __webpack_require__(12);

var hideCallback = function () {
  var callbacks = [];
  return {
    add: function add(callback) {
      var indexOfCallback = (0, _array.inArray)(callback, callbacks);

      if (indexOfCallback === -1) {
        callbacks.push(callback);
      }
    },
    remove: function remove(callback) {
      var indexOfCallback = (0, _array.inArray)(callback, callbacks);

      if (indexOfCallback !== -1) {
        callbacks.splice(indexOfCallback, 1);
      }
    },
    fire: function fire() {
      var callback = callbacks.pop();
      var result = !!callback;

      if (result) {
        callback();
      }

      return result;
    },
    hasCallback: function hasCallback() {
      return callbacks.length > 0;
    }
  };
}();

exports.hideCallback = hideCallback;

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _class = _interopRequireDefault(__webpack_require__(15));

var _selectionStrategy = _interopRequireDefault(__webpack_require__(413));

var _selectionStrategy2 = _interopRequireDefault(__webpack_require__(414));

var _extend = __webpack_require__(0);

var _common = __webpack_require__(4);

var _type = __webpack_require__(1);

var _deferred = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = _class.default.inherit({
  ctor: function ctor(options) {
    this.options = (0, _extend.extend)(this._getDefaultOptions(), options, {
      selectedItemKeys: options.selectedKeys || []
    });
    this._selectionStrategy = this.options.deferred ? new _selectionStrategy.default(this.options) : new _selectionStrategy2.default(this.options);
    this._focusedItemIndex = -1;

    if (!this.options.equalByReference) {
      this._selectionStrategy.updateSelectedItemKeyHash(this.options.selectedItemKeys);
    }
  },
  _getDefaultOptions: function _getDefaultOptions() {
    return {
      allowNullValue: false,
      deferred: false,
      equalByReference: false,
      mode: 'multiple',
      selectedItems: [],
      selectionFilter: [],
      maxFilterLengthInRequest: 0,
      onSelectionChanged: _common.noop,
      key: _common.noop,
      keyOf: function keyOf(item) {
        return item;
      },
      load: function load() {
        return new _deferred.Deferred().resolve([]);
      },
      totalCount: function totalCount() {
        return -1;
      },
      isSelectableItem: function isSelectableItem() {
        return true;
      },
      isItemSelected: function isItemSelected() {
        return false;
      },
      getItemData: function getItemData(item) {
        return item;
      },
      dataFields: _common.noop,
      filter: _common.noop
    };
  },
  validate: function validate() {
    this._selectionStrategy.validate();
  },
  getSelectedItemKeys: function getSelectedItemKeys() {
    return this._selectionStrategy.getSelectedItemKeys();
  },
  getSelectedItems: function getSelectedItems() {
    return this._selectionStrategy.getSelectedItems();
  },
  selectionFilter: function selectionFilter(value) {
    if (value === undefined) {
      return this.options.selectionFilter;
    }

    var filterIsChanged = this.options.selectionFilter !== value && JSON.stringify(this.options.selectionFilter) !== JSON.stringify(value);
    this.options.selectionFilter = value;
    filterIsChanged && this.onSelectionChanged();
  },
  setSelection: function setSelection(keys) {
    return this.selectedItemKeys(keys);
  },
  select: function select(keys) {
    return this.selectedItemKeys(keys, true);
  },
  deselect: function deselect(keys) {
    return this.selectedItemKeys(keys, true, true);
  },
  selectedItemKeys: function selectedItemKeys(keys, preserve, isDeselect, isSelectAll) {
    var _keys;

    var that = this;
    keys = (_keys = keys) !== null && _keys !== void 0 ? _keys : [];
    keys = Array.isArray(keys) ? keys : [keys];
    that.validate();
    return this._selectionStrategy.selectedItemKeys(keys, preserve, isDeselect, isSelectAll);
  },
  clearSelection: function clearSelection() {
    return this.selectedItemKeys([]);
  },
  _addSelectedItem: function _addSelectedItem(itemData, key) {
    this._selectionStrategy.addSelectedItem(key, itemData);
  },
  _removeSelectedItem: function _removeSelectedItem(key) {
    this._selectionStrategy.removeSelectedItem(key);
  },
  _setSelectedItems: function _setSelectedItems(keys, items) {
    this._selectionStrategy.setSelectedItems(keys, items);
  },
  onSelectionChanged: function onSelectionChanged() {
    this._selectionStrategy.onSelectionChanged();
  },
  changeItemSelection: function changeItemSelection(itemIndex, keys) {
    var isSelectedItemsChanged;
    var items = this.options.plainItems();
    var item = items[itemIndex];

    if (!this.isSelectable() || !this.isDataItem(item)) {
      return false;
    }

    var itemData = this.options.getItemData(item);
    var itemKey = this.options.keyOf(itemData);
    keys = keys || {};

    if (keys.shift && this.options.mode === 'multiple' && this._focusedItemIndex >= 0) {
      isSelectedItemsChanged = this.changeItemSelectionWhenShiftKeyPressed(itemIndex, items);
    } else if (keys.control) {
      this._resetItemSelectionWhenShiftKeyPressed();

      var isSelected = this._selectionStrategy.isItemDataSelected(itemData);

      if (this.options.mode === 'single') {
        this.clearSelectedItems();
      }

      if (isSelected) {
        this._removeSelectedItem(itemKey);
      } else {
        this._addSelectedItem(itemData, itemKey);
      }

      isSelectedItemsChanged = true;
    } else {
      this._resetItemSelectionWhenShiftKeyPressed();

      var isKeysEqual = this._selectionStrategy.equalKeys(this.options.selectedItemKeys[0], itemKey);

      if (this.options.selectedItemKeys.length !== 1 || !isKeysEqual) {
        this._setSelectedItems([itemKey], [itemData]);

        isSelectedItemsChanged = true;
      }
    }

    if (isSelectedItemsChanged) {
      this._focusedItemIndex = itemIndex;
      this.onSelectionChanged();
      return true;
    }
  },
  isDataItem: function isDataItem(item) {
    return this.options.isSelectableItem(item);
  },
  isSelectable: function isSelectable() {
    return this.options.mode === 'single' || this.options.mode === 'multiple';
  },
  isItemDataSelected: function isItemDataSelected(data) {
    return this._selectionStrategy.isItemDataSelected(data, {
      checkPending: true
    });
  },
  isItemSelected: function isItemSelected(arg, options) {
    return this._selectionStrategy.isItemKeySelected(arg, options);
  },
  _resetItemSelectionWhenShiftKeyPressed: function _resetItemSelectionWhenShiftKeyPressed() {
    delete this._shiftFocusedItemIndex;
  },
  _resetFocusedItemIndex: function _resetFocusedItemIndex() {
    this._focusedItemIndex = -1;
  },
  changeItemSelectionWhenShiftKeyPressed: function changeItemSelectionWhenShiftKeyPressed(itemIndex, items) {
    var isSelectedItemsChanged = false;
    var itemIndexStep;
    var index;
    var keyOf = this.options.keyOf;
    var focusedItem = items[this._focusedItemIndex];
    var focusedData = this.options.getItemData(focusedItem);
    var focusedKey = keyOf(focusedData);
    var isFocusedItemSelected = focusedItem && this.isItemDataSelected(focusedData);

    if (!(0, _type.isDefined)(this._shiftFocusedItemIndex)) {
      this._shiftFocusedItemIndex = this._focusedItemIndex;
    }

    var data;
    var itemKey;

    if (this._shiftFocusedItemIndex !== this._focusedItemIndex) {
      itemIndexStep = this._focusedItemIndex < this._shiftFocusedItemIndex ? 1 : -1;

      for (index = this._focusedItemIndex; index !== this._shiftFocusedItemIndex; index += itemIndexStep) {
        if (this.isDataItem(items[index])) {
          itemKey = keyOf(this.options.getItemData(items[index]));

          this._removeSelectedItem(itemKey);

          isSelectedItemsChanged = true;
        }
      }
    }

    if (itemIndex !== this._shiftFocusedItemIndex) {
      itemIndexStep = itemIndex < this._shiftFocusedItemIndex ? 1 : -1;

      for (index = itemIndex; index !== this._shiftFocusedItemIndex; index += itemIndexStep) {
        if (this.isDataItem(items[index])) {
          data = this.options.getItemData(items[index]);
          itemKey = keyOf(data);

          this._addSelectedItem(data, itemKey);

          isSelectedItemsChanged = true;
        }
      }
    }

    if (this.isDataItem(focusedItem) && !isFocusedItemSelected) {
      this._addSelectedItem(focusedData, focusedKey);

      isSelectedItemsChanged = true;
    }

    return isSelectedItemsChanged;
  },
  clearSelectedItems: function clearSelectedItems() {
    this._setSelectedItems([], []);
  },
  selectAll: function selectAll(isOnePage) {
    this._resetFocusedItemIndex();

    if (isOnePage) {
      return this._onePageSelectAll(false);
    } else {
      return this.selectedItemKeys([], true, false, true);
    }
  },
  deselectAll: function deselectAll(isOnePage) {
    this._resetFocusedItemIndex();

    if (isOnePage) {
      return this._onePageSelectAll(true);
    } else {
      return this.selectedItemKeys([], true, true, true);
    }
  },
  _onePageSelectAll: function _onePageSelectAll(isDeselect) {
    var items = this._selectionStrategy.getSelectableItems(this.options.plainItems());

    for (var i = 0; i < items.length; i++) {
      var item = items[i];

      if (this.isDataItem(item)) {
        var itemData = this.options.getItemData(item);
        var itemKey = this.options.keyOf(itemData);
        var isSelected = this.isItemSelected(itemKey);

        if (!isSelected && !isDeselect) {
          this._addSelectedItem(itemData, itemKey);
        }

        if (isSelected && isDeselect) {
          this._removeSelectedItem(itemKey);
        }
      }
    }

    this.onSelectionChanged();
    return new _deferred.Deferred().resolve();
  },
  getSelectAllState: function getSelectAllState(visibleOnly) {
    return this._selectionStrategy.getSelectAllState(visibleOnly);
  }
});

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.findChanges = exports.isKeysEqual = void 0;

var _type = __webpack_require__(1);

var getKeyWrapper = function getKeyWrapper(item, getKey) {
  var key = getKey(item);

  if ((0, _type.isObject)(key)) {
    try {
      return JSON.stringify(key);
    } catch (e) {
      return key;
    }
  }

  return key;
};

var getSameNewByOld = function getSameNewByOld(oldItem, newItems, newIndexByKey, getKey) {
  var key = getKeyWrapper(oldItem, getKey);
  return newItems[newIndexByKey[key]];
};

var isKeysEqual = function isKeysEqual(oldKeys, newKeys) {
  if (oldKeys.length !== newKeys.length) {
    return false;
  }

  for (var i = 0; i < newKeys.length; i++) {
    if (oldKeys[i] !== newKeys[i]) {
      return false;
    }
  }

  return true;
};

exports.isKeysEqual = isKeysEqual;

var findChanges = function findChanges(oldItems, newItems, getKey, isItemEquals) {
  var oldIndexByKey = {};
  var newIndexByKey = {};
  var addedCount = 0;
  var removeCount = 0;
  var result = [];
  oldItems.forEach(function (item, index) {
    var key = getKeyWrapper(item, getKey);
    oldIndexByKey[key] = index;
  });
  newItems.forEach(function (item, index) {
    var key = getKeyWrapper(item, getKey);
    newIndexByKey[key] = index;
  });
  var itemCount = Math.max(oldItems.length, newItems.length);

  for (var index = 0; index < itemCount + addedCount; index++) {
    var newItem = newItems[index];
    var oldNextIndex = index - addedCount + removeCount;
    var nextOldItem = oldItems[oldNextIndex];
    var isRemoved = !newItem || nextOldItem && !getSameNewByOld(nextOldItem, newItems, newIndexByKey, getKey);

    if (isRemoved) {
      if (nextOldItem) {
        result.push({
          type: 'remove',
          key: getKey(nextOldItem),
          index: index,
          oldItem: nextOldItem
        });
        removeCount++;
        index--;
      }
    } else {
      var key = getKeyWrapper(newItem, getKey);
      var oldIndex = oldIndexByKey[key];
      var oldItem = oldItems[oldIndex];

      if (!oldItem) {
        addedCount++;
        result.push({
          type: 'insert',
          data: newItem,
          index: index
        });
      } else if (oldIndex === oldNextIndex) {
        if (!isItemEquals(oldItem, newItem)) {
          result.push({
            type: 'update',
            data: newItem,
            key: getKey(newItem),
            index: index,
            oldItem: oldItem
          });
        }
      } else {
        return;
      }
    }
  }

  return result;
};

exports.findChanges = findChanges;

/***/ }),
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.plugin = exports.Legend = void 0;

var _utils = __webpack_require__(14);

var _extend2 = __webpack_require__(0);

var _layout_element = __webpack_require__(344);

var _type = __webpack_require__(1);

var _title = __webpack_require__(138);

var _object = __webpack_require__(52);

var _common = __webpack_require__(4);

var _renderer = __webpack_require__(183);

var _deferred = __webpack_require__(6);

var _Number = Number;
var _math = Math;
var _round = _math.round;
var _max = _math.max;
var _min = _math.min;
var _ceil = _math.ceil;
var _isDefined = _type.isDefined;
var _isFunction = _type.isFunction;
var _enumParser = _utils.enumParser;
var _normalizeEnum = _utils.normalizeEnum;
var _extend = _extend2.extend;
var DEFAULT_MARGIN = 10;
var DEFAULT_MARKER_HATCHING_WIDTH = 2;
var DEFAULT_MARKER_HATCHING_STEP = 5;
var CENTER = 'center';
var RIGHT = 'right';
var LEFT = 'left';
var TOP = 'top';
var BOTTOM = 'bottom';
var HORIZONTAL = 'horizontal';
var VERTICAL = 'vertical';
var INSIDE = 'inside';
var OUTSIDE = 'outside';
var NONE = 'none';
var HEIGHT = 'height';
var WIDTH = 'width';

var parseHorizontalAlignment = _enumParser([LEFT, CENTER, RIGHT]);

var parseVerticalAlignment = _enumParser([TOP, BOTTOM]);

var parseOrientation = _enumParser([VERTICAL, HORIZONTAL]);

var parseItemTextPosition = _enumParser([LEFT, RIGHT, TOP, BOTTOM]);

var parsePosition = _enumParser([OUTSIDE, INSIDE]);

var parseItemsAlignment = _enumParser([LEFT, CENTER, RIGHT]);

function getState(state, color, stateName) {
  if (!state) {
    return;
  }

  var colorFromAction = state.fill;
  return (0, _extend2.extend)({}, {
    state: stateName,
    fill: colorFromAction === NONE ? color : colorFromAction,
    opacity: state.opacity,
    hatching: _extend({}, state.hatching, {
      step: DEFAULT_MARKER_HATCHING_STEP,
      width: DEFAULT_MARKER_HATCHING_WIDTH
    })
  });
}

function getAttributes(item, state, size) {
  var attrs = (0, _renderer.processHatchingAttrs)(item, state);

  if (attrs.fill && attrs.fill.indexOf('DevExpress') === 0) {
    attrs.fill = (0, _renderer.getFuncIri)(attrs.fill);
  }

  attrs.opacity = attrs.opacity >= 0 ? attrs.opacity : 1;
  return (0, _extend2.extend)({}, attrs, {
    size: size
  });
}

function parseMargins(options) {
  var margin = options.margin;

  if (margin >= 0) {
    margin = _Number(options.margin);
    margin = {
      top: margin,
      bottom: margin,
      left: margin,
      right: margin
    };
  } else {
    margin = {
      top: margin.top >= 0 ? _Number(margin.top) : DEFAULT_MARGIN,
      bottom: margin.bottom >= 0 ? _Number(margin.bottom) : DEFAULT_MARGIN,
      left: margin.left >= 0 ? _Number(margin.left) : DEFAULT_MARGIN,
      right: margin.right >= 0 ? _Number(margin.right) : DEFAULT_MARGIN
    };
  }

  options.margin = margin;
}

function getSizeItem(options, markerBBox, labelBBox) {
  var defaultXMargin = 7;
  var defaultTopMargin = 4;
  var width;
  var height;

  switch (options.itemTextPosition) {
    case LEFT:
    case RIGHT:
      width = markerBBox.width + defaultXMargin + labelBBox.width;
      height = _max(markerBBox.height, labelBBox.height);
      break;

    case TOP:
    case BOTTOM:
      width = _max(markerBBox.width, labelBBox.width);
      height = markerBBox.height + defaultTopMargin + labelBBox.height;
      break;
  }

  return {
    width: width,
    height: height
  };
}

function calculateBBoxLabelAndMarker(markerBBox, labelBBox) {
  var bBox = {};
  bBox.left = _min(markerBBox.x, labelBBox.x);
  bBox.top = _min(markerBBox.y, labelBBox.y);
  bBox.right = _max(markerBBox.x + markerBBox.width, labelBBox.x + labelBBox.width);
  bBox.bottom = _max(markerBBox.y + markerBBox.height, labelBBox.y + labelBBox.height);
  return bBox;
}

function applyMarkerState(id, idToIndexMap, items, stateName) {
  var item = idToIndexMap && items[idToIndexMap[id]];

  if (item) {
    item.renderMarker(item.states[stateName]);
  }
}

function parseOptions(options, textField, allowInsidePosition) {
  if (!options) return null;
  parseMargins(options);
  options.horizontalAlignment = parseHorizontalAlignment(options.horizontalAlignment, RIGHT);
  options.verticalAlignment = parseVerticalAlignment(options.verticalAlignment, options.horizontalAlignment === CENTER ? BOTTOM : TOP);
  options.orientation = parseOrientation(options.orientation, options.horizontalAlignment === CENTER ? HORIZONTAL : VERTICAL);
  options.itemTextPosition = parseItemTextPosition(options.itemTextPosition, options.orientation === HORIZONTAL ? BOTTOM : RIGHT);
  options.position = allowInsidePosition ? parsePosition(options.position, OUTSIDE) : OUTSIDE;
  options.itemsAlignment = parseItemsAlignment(options.itemsAlignment, null);
  options.hoverMode = _normalizeEnum(options.hoverMode);
  options.customizeText = _isFunction(options.customizeText) ? options.customizeText : function () {
    return this[textField];
  };
  options.customizeHint = _isFunction(options.customizeHint) ? options.customizeHint : _common.noop;
  options._incidentOccurred = options._incidentOccurred || _common.noop;
  return options;
}

function createSquareMarker(renderer, size) {
  return renderer.rect(0, 0, size, size);
}

function createCircleMarker(renderer, size) {
  return renderer.circle(size / 2, size / 2, size / 2);
}

function isCircle(type) {
  return _normalizeEnum(type) === 'circle';
}

function inRect(rect, x, y) {
  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
}

function checkLinesSize(lines, layoutOptions, countItems, margins) {
  var position = {
    x: 0,
    y: 0
  };
  var maxMeasureLength = 0;
  var maxAltMeasureLength = 0;
  var margin = 0;

  if (layoutOptions.direction === 'y') {
    margin = margins.top + margins.bottom;
  } else {
    margin = margins.left + margins.right;
  }

  lines.forEach(function (line, i) {
    var firstItem = line[0];
    var lineLength = line.length;
    line.forEach(function (item, index) {
      var offset = item.offset || layoutOptions.spacing;
      position[layoutOptions.direction] += item[layoutOptions.measure] + (index !== lineLength - 1 ? offset : 0);
      maxMeasureLength = _max(maxMeasureLength, position[layoutOptions.direction]);
    });
    position[layoutOptions.direction] = 0;
    position[layoutOptions.altDirection] += firstItem[layoutOptions.altMeasure] + firstItem.altOffset || layoutOptions.altSpacing;
    maxAltMeasureLength = _max(maxAltMeasureLength, position[layoutOptions.altDirection]);
  });

  if (maxMeasureLength + margin > layoutOptions.length) {
    layoutOptions.countItem = decreaseItemCount(layoutOptions, countItems);
    return true;
  }
}

function decreaseItemCount(layoutOptions, countItems) {
  layoutOptions.altCountItem++;
  return _ceil(countItems / layoutOptions.altCountItem);
}

function getLineLength(line, layoutOptions) {
  return line.reduce(function (lineLength, item) {
    var offset = item.offset || layoutOptions.spacing;
    return lineLength + item[layoutOptions.measure] + offset;
  }, 0);
}

function getMaxLineLength(lines, layoutOptions) {
  return lines.reduce(function (maxLineLength, line) {
    return _max(maxLineLength, getLineLength(line, layoutOptions));
  }, 0);
}

function getInitPositionForDirection(line, layoutOptions, maxLineLength) {
  var lineLength = getLineLength(line, layoutOptions);
  var initPosition;

  switch (layoutOptions.itemsAlignment) {
    case RIGHT:
      initPosition = maxLineLength - lineLength;
      break;

    case CENTER:
      initPosition = (maxLineLength - lineLength) / 2;
      break;

    default:
      initPosition = 0;
  }

  return initPosition;
}

function getPos(layoutOptions) {
  switch (layoutOptions.itemTextPosition) {
    case BOTTOM:
      return {
        horizontal: CENTER,
        vertical: TOP
      };

    case TOP:
      return {
        horizontal: CENTER,
        vertical: BOTTOM
      };

    case LEFT:
      return {
        horizontal: RIGHT,
        vertical: CENTER
      };

    case RIGHT:
      return {
        horizontal: LEFT,
        vertical: CENTER
      };
  }
}

function getLines(lines, layoutOptions, itemIndex) {
  var tableLine = {};

  if (itemIndex % layoutOptions.countItem === 0) {
    if (layoutOptions.markerOffset) {
      lines.push([], []);
    } else {
      lines.push([]);
    }
  }

  if (layoutOptions.markerOffset) {
    tableLine.firstLine = lines[lines.length - 1];
    tableLine.secondLine = lines[lines.length - 2];
  } else {
    tableLine.firstLine = tableLine.secondLine = lines[lines.length - 1];
  }

  return tableLine;
}

function setMaxInLine(line, measure) {
  var maxLineSize = line.reduce(function (maxLineSize, item) {
    var itemMeasure = item ? item[measure] : maxLineSize;
    return _max(maxLineSize, itemMeasure);
  }, 0);
  line.forEach(function (item) {
    if (item) {
      item[measure] = maxLineSize;
    }
  });
}

function transpose(array) {
  var width = array.length;
  var height = array[0].length;
  var i;
  var j;
  var transposeArray = [];

  for (i = 0; i < height; i++) {
    transposeArray[i] = [];

    for (j = 0; j < width; j++) {
      transposeArray[i][j] = array[j][i];
    }
  }

  return transposeArray;
}

function getAlign(position) {
  switch (position) {
    case TOP:
    case BOTTOM:
      return CENTER;

    case LEFT:
      return RIGHT;

    case RIGHT:
      return LEFT;
  }
}

var getMarkerCreator = function getMarkerCreator(type) {
  return isCircle(type) ? createCircleMarker : createSquareMarker;
};

function getTitleHorizontalAlignment(options) {
  if (options.horizontalAlignment === CENTER) {
    return CENTER;
  } else {
    if (options.itemTextPosition === RIGHT) {
      return LEFT;
    } else if (options.itemTextPosition === LEFT) {
      return RIGHT;
    } else {
      return CENTER;
    }
  }
}

var Legend = function Legend(settings) {
  var that = this;
  that._renderer = settings.renderer;
  that._legendGroup = settings.group;
  that._backgroundClass = settings.backgroundClass;
  that._itemGroupClass = settings.itemGroupClass;
  that._textField = settings.textField;
  that._getCustomizeObject = settings.getFormatObject;
  that._titleGroupClass = settings.titleGroupClass;
  that._allowInsidePosition = settings.allowInsidePosition;
  that._widget = settings.widget;
  that._updated = false;
};

exports.Legend = Legend;
var _Legend = Legend;
var legendPrototype = _Legend.prototype = (0, _object.clone)(_layout_element.LayoutElement.prototype);
(0, _extend2.extend)(legendPrototype, {
  constructor: _Legend,
  getOptions: function getOptions() {
    return this._options;
  },
  update: function update() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var options = arguments.length > 1 ? arguments[1] : undefined;
    var themeManagerTitleOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var that = this;
    options = that._options = parseOptions(options, that._textField, that._allowInsidePosition) || {};
    var initMarkerSize = options.markerSize;
    this._updated = true;
    this._data = data.map(function (dataItem) {
      dataItem.size = _Number(dataItem.size > 0 ? dataItem.size : initMarkerSize);
      dataItem.marker = getAttributes(dataItem, dataItem.states.normal);
      Object.defineProperty(dataItem.marker, 'size', {
        get: function get() {
          return dataItem.size;
        },
        set: function set(value) {
          dataItem.size = value;
        }
      });
      Object.defineProperty(dataItem.marker, 'opacity', {
        get: function get() {
          return dataItem.states.normal.opacity;
        },
        set: function set(value) {
          dataItem.states.normal.opacity = dataItem.states.hover.opacity = dataItem.states.selection.opacity = value;
        }
      });
      return dataItem;
    });

    if (options.customizeItems) {
      that._data = options.customizeItems(data.slice()) || data;
    }

    that._boundingRect = {
      width: 0,
      height: 0,
      x: 0,
      y: 0
    };

    if (that.isVisible() && !that._title) {
      that._title = new _title.Title({
        renderer: that._renderer,
        cssClass: that._titleGroupClass,
        root: that._legendGroup
      });
    }

    if (that._title) {
      var titleOptions = options.title;
      themeManagerTitleOptions.horizontalAlignment = getTitleHorizontalAlignment(options);

      that._title.update(themeManagerTitleOptions, titleOptions);
    }

    this.erase();
    return that;
  },
  isVisible: function isVisible() {
    return this._options && this._options.visible;
  },
  draw: function draw(width, height) {
    // TODO check multiple groups creation
    var that = this;

    var items = that._getItemData();

    that.erase();

    if (!(that.isVisible() && items && items.length)) {
      return that;
    }

    that._insideLegendGroup = that._renderer.g().enableLinks().append(that._legendGroup);

    that._title.changeLink(that._insideLegendGroup);

    that._createBackground();

    if (that._title.hasText()) {
      var horizontalPadding = that._background ? 2 * that._options.paddingLeftRight : 0;

      that._title.draw(width - horizontalPadding, height);
    } // TODO review pass or process states in legend


    that._markersGroup = that._renderer.g().attr({
      class: that._itemGroupClass
    }).append(that._insideLegendGroup);

    that._createItems(items);

    that._updateElementsPosition(width, height);

    return that;
  },
  _measureElements: function _measureElements() {
    var options = this._options;
    var maxBBoxHeight = 0;

    this._items.forEach(function (item) {
      var labelBBox = item.label.getBBox();
      var markerBBox = item.marker.getBBox();
      item.markerBBox = markerBBox;
      item.markerSize = Math.max(markerBBox.width, markerBBox.height);
      var bBox = getSizeItem(options, markerBBox, labelBBox);
      item.labelBBox = labelBBox;
      item.bBox = bBox;
      maxBBoxHeight = _max(maxBBoxHeight, bBox.height);
    });

    if (options.equalRowHeight) {
      this._items.forEach(function (item) {
        return item.bBox.height = maxBBoxHeight;
      });
    }
  },
  _updateElementsPosition: function _updateElementsPosition(width, height) {
    var that = this;
    var options = that._options;
    this._size = {
      width: width,
      height: height
    };

    that._measureElements();

    that._locateElements(options);

    that._finalUpdate(options);

    var size = that.getLayoutOptions();

    if (size.width > width || size.height > height) {
      that.freeSpace();
    }
  },
  _createItems: function _createItems(items) {
    var that = this;
    var options = that._options;
    var renderer = that._renderer;
    var createMarker = getMarkerCreator(options.markerShape);
    that._markersId = {};
    var templateFunction = !options.markerTemplate ? function (dataItem, group) {
      var attrs = dataItem.marker;
      createMarker(renderer, attrs.size).attr({
        fill: attrs.fill,
        opacity: attrs.opacity
      }).append({
        element: group
      });
    } : options.markerTemplate;

    var template = that._widget._getTemplate(templateFunction);

    var markersGroup = that._markersGroup;
    markersGroup.css((0, _utils.patchFontOptions)(options.font));
    that._deferredItems = [];
    that._templatesGroups = [];
    that._items = (items || []).map(function (dataItem, i) {
      var stateOfDataItem = dataItem.states;
      var normalState = stateOfDataItem.normal;
      var normalStateFill = normalState.fill;
      dataItem.size = dataItem.marker.size;
      var states = {
        normal: (0, _extend2.extend)(normalState, {
          fill: normalStateFill || options.markerColor || options.defaultColor,
          state: 'normal'
        }),
        hover: getState(stateOfDataItem.hover, normalStateFill, 'hovered'),
        selection: getState(stateOfDataItem.selection, normalStateFill, 'selected')
      };
      dataItem.states = states;
      var itemGroup = renderer.g().append(markersGroup);
      var markerGroup = renderer.g().attr({
        class: 'dxl-marker'
      }).append(itemGroup);
      that._deferredItems[i] = new _deferred.Deferred();

      that._templatesGroups.push(markerGroup);

      var item = {
        label: that._createLabel(dataItem, itemGroup),
        marker: markerGroup,
        renderer: renderer,
        group: itemGroup,
        tracker: {
          id: dataItem.id,
          argument: dataItem.argument,
          argumentIndex: dataItem.argumentIndex
        },
        states: states,
        itemTextPosition: options.itemTextPosition,
        markerOffset: 0,
        bBoxes: [],
        renderMarker: function renderMarker(state) {
          dataItem.marker = getAttributes(item, state, dataItem.size);
          markerGroup.clear();
          template.render({
            model: dataItem,
            container: markerGroup.element,
            onRendered: that._deferredItems[i].resolve
          });
        }
      };
      item.renderMarker(states.normal);

      that._createHint(dataItem, itemGroup);

      if (dataItem.id !== undefined) {
        that._markersId[dataItem.id] = i;
      }

      return item;
    });
  },
  getTemplatesGroups: function getTemplatesGroups() {
    return this._templatesGroups || [];
  },
  getTemplatesDef: function getTemplatesDef() {
    return this._deferredItems || [];
  },
  _getItemData: function _getItemData() {
    var items = this._data || [];
    var options = this._options || {}; // For maps in dashboards

    if (options.inverted) {
      items = items.slice().reverse();
    }

    return items.filter(function (i) {
      return i.visible;
    });
  },
  _finalUpdate: function _finalUpdate(options) {
    this._adjustBackgroundSettings(options);

    this._setBoundingRect(options.margin);
  },
  // The name is chosen to be opposite for `draw`
  erase: function erase() {
    var that = this;
    var insideLegendGroup = that._insideLegendGroup;
    insideLegendGroup && insideLegendGroup.dispose();
    that._insideLegendGroup = that._markersGroup = that._x1 = that._x2 = that._y2 = that._y2 = null;
    return that;
  },
  _locateElements: function _locateElements(locationOptions) {
    this._moveInInitialValues();

    this._locateRowsColumns(locationOptions);
  },
  _moveInInitialValues: function _moveInInitialValues() {
    var that = this;
    that._title.hasText() && that._title.move([0, 0]);
    that._legendGroup && that._legendGroup.move(0, 0);
    that._background && that._background.attr({
      x: 0,
      y: 0,
      width: 0,
      height: 0
    });
  },
  applySelected: function applySelected(id) {
    applyMarkerState(id, this._markersId, this._items, 'selection');
    return this;
  },
  applyHover: function applyHover(id) {
    applyMarkerState(id, this._markersId, this._items, 'hover');
    return this;
  },
  resetItem: function resetItem(id) {
    applyMarkerState(id, this._markersId, this._items, 'normal');
    return this;
  },
  _createLabel: function _createLabel(data, group) {
    var labelFormatObject = this._getCustomizeObject(data);

    var options = this._options;
    var align = getAlign(options.itemTextPosition);
    var text = options.customizeText.call(labelFormatObject, labelFormatObject);
    var fontStyle = _isDefined(data.textOpacity) ? {
      color: options.font.color,
      opacity: data.textOpacity
    } : {};
    return this._renderer.text(text, 0, 0).css((0, _utils.patchFontOptions)(fontStyle)).attr({
      align: align,
      class: options.cssClass
    }).append(group);
  },
  _createHint: function _createHint(data, group) {
    var labelFormatObject = this._getCustomizeObject(data);

    var text = this._options.customizeHint.call(labelFormatObject, labelFormatObject);

    if (_isDefined(text) && text !== '') {
      group.setTitle(text);
    }
  },
  _createBackground: function _createBackground() {
    var that = this;
    var isInside = that._options.position === INSIDE;
    var color = that._options.backgroundColor;
    var fill = color || (isInside ? that._options.containerBackgroundColor : NONE);

    if (that._options.border.visible || (isInside || color) && color !== NONE) {
      that._background = that._renderer.rect(0, 0, 0, 0).attr({
        fill: fill,
        class: that._backgroundClass
      }).append(that._insideLegendGroup);
    }
  },
  _locateRowsColumns: function _locateRowsColumns(options) {
    var that = this;
    var iteration = 0;

    var layoutOptions = that._getItemsLayoutOptions();

    var countItems = that._items.length;
    var lines;

    do {
      lines = [];

      that._createLines(lines, layoutOptions);

      that._alignLines(lines, layoutOptions);

      iteration++;
    } while (checkLinesSize(lines, layoutOptions, countItems, options.margin) && iteration < countItems);

    that._applyItemPosition(lines, layoutOptions);
  },
  _createLines: function _createLines(lines, layoutOptions) {
    this._items.forEach(function (item, i) {
      var tableLine = getLines(lines, layoutOptions, i);
      var labelBox = {
        width: item.labelBBox.width,
        height: item.labelBBox.height,
        element: item.label,
        bBox: item.labelBBox,
        pos: getPos(layoutOptions),
        itemIndex: i
      };
      var markerBox = {
        width: item.markerBBox.width,
        height: item.markerBBox.height,
        element: item.marker,
        pos: {
          horizontal: CENTER,
          vertical: CENTER
        },
        bBox: {
          width: item.markerBBox.width,
          height: item.markerBBox.height,
          x: item.markerBBox.x,
          y: item.markerBBox.y
        },
        itemIndex: i
      };
      var firstItem;
      var secondItem;
      var offsetDirection = layoutOptions.markerOffset ? 'altOffset' : 'offset';

      if (layoutOptions.inverseLabelPosition) {
        firstItem = labelBox;
        secondItem = markerBox;
      } else {
        firstItem = markerBox;
        secondItem = labelBox;
      }

      firstItem[offsetDirection] = layoutOptions.labelOffset;
      tableLine.secondLine.push(firstItem);
      tableLine.firstLine.push(secondItem);
    });
  },
  _alignLines: function _alignLines(lines, layoutOptions) {
    var i;
    var measure = layoutOptions.altMeasure;
    lines.forEach(function (line) {
      return setMaxInLine(line, measure);
    });
    measure = layoutOptions.measure;

    if (layoutOptions.itemsAlignment) {
      if (layoutOptions.markerOffset) {
        for (i = 0; i < lines.length;) {
          transpose([lines[i++], lines[i++]]).forEach(processLine);
        }
      }
    } else {
      transpose(lines).forEach(processLine);
    }

    function processLine(line) {
      setMaxInLine(line, measure);
    }
  },
  _applyItemPosition: function _applyItemPosition(lines, layoutOptions) {
    var that = this;
    var position = {
      x: 0,
      y: 0
    };
    var maxLineLength = getMaxLineLength(lines, layoutOptions);
    lines.forEach(function (line) {
      var firstItem = line[0];
      var altOffset = firstItem.altOffset || layoutOptions.altSpacing;
      position[layoutOptions.direction] = getInitPositionForDirection(line, layoutOptions, maxLineLength);
      line.forEach(function (item) {
        var offset = item.offset || layoutOptions.spacing;
        var wrap = new _layout_element.WrapperLayoutElement(item.element, item.bBox);
        var itemBBoxOptions = {
          x: position.x,
          y: position.y,
          width: item.width,
          height: item.height
        };
        var itemBBox = new _layout_element.WrapperLayoutElement(null, itemBBoxOptions);
        var itemLegend = that._items[item.itemIndex];
        wrap.position({
          of: itemBBox,
          my: item.pos,
          at: item.pos
        });
        itemLegend.bBoxes.push(itemBBox);
        position[layoutOptions.direction] += item[layoutOptions.measure] + offset;
      });
      position[layoutOptions.altDirection] += firstItem[layoutOptions.altMeasure] + altOffset;
    });

    this._items.forEach(function (item) {
      var itemBBox = calculateBBoxLabelAndMarker(item.bBoxes[0].getLayoutOptions(), item.bBoxes[1].getLayoutOptions());
      var horizontal = that._options.columnItemSpacing / 2;
      var vertical = that._options.rowItemSpacing / 2;
      item.tracker.left = itemBBox.left - horizontal;
      item.tracker.right = itemBBox.right + horizontal;
      item.tracker.top = itemBBox.top - vertical;
      item.tracker.bottom = itemBBox.bottom + vertical;
    });
  },
  _getItemsLayoutOptions: function _getItemsLayoutOptions() {
    var that = this;
    var options = that._options;
    var orientation = options.orientation;
    var layoutOptions = {
      itemsAlignment: options.itemsAlignment,
      orientation: options.orientation
    };
    var width = that._size.width - (that._background ? 2 * options.paddingLeftRight : 0);
    var height = that._size.height - (that._background ? 2 * options.paddingTopBottom : 0);

    if (orientation === HORIZONTAL) {
      layoutOptions.length = width;
      layoutOptions.spacing = options.columnItemSpacing;
      layoutOptions.direction = 'x';
      layoutOptions.measure = WIDTH;
      layoutOptions.altMeasure = HEIGHT;
      layoutOptions.altDirection = 'y';
      layoutOptions.altSpacing = options.rowItemSpacing;
      layoutOptions.countItem = options.columnCount;
      layoutOptions.altCountItem = options.rowCount;
      layoutOptions.marginTextLabel = 4;
      layoutOptions.labelOffset = 7;

      if (options.itemTextPosition === BOTTOM || options.itemTextPosition === TOP) {
        layoutOptions.labelOffset = 4;
        layoutOptions.markerOffset = true;
      }
    } else {
      layoutOptions.length = height;
      layoutOptions.spacing = options.rowItemSpacing;
      layoutOptions.direction = 'y';
      layoutOptions.measure = HEIGHT;
      layoutOptions.altMeasure = WIDTH;
      layoutOptions.altDirection = 'x';
      layoutOptions.altSpacing = options.columnItemSpacing;
      layoutOptions.countItem = options.rowCount;
      layoutOptions.altCountItem = options.columnCount;
      layoutOptions.marginTextLabel = 7;
      layoutOptions.labelOffset = 4;

      if (options.itemTextPosition === RIGHT || options.itemTextPosition === LEFT) {
        layoutOptions.labelOffset = 7;
        layoutOptions.markerOffset = true;
      }
    }

    if (!layoutOptions.countItem) {
      if (layoutOptions.altCountItem) {
        layoutOptions.countItem = _ceil(that._items.length / layoutOptions.altCountItem);
      } else {
        layoutOptions.countItem = that._items.length;
      }
    }

    if (options.itemTextPosition === TOP || options.itemTextPosition === LEFT) {
      layoutOptions.inverseLabelPosition = true;
    }

    layoutOptions.itemTextPosition = options.itemTextPosition;
    layoutOptions.altCountItem = layoutOptions.altCountItem || _ceil(that._items.length / layoutOptions.countItem);
    return layoutOptions;
  },
  _adjustBackgroundSettings: function _adjustBackgroundSettings(locationOptions) {
    if (!this._background) return;
    var border = locationOptions.border;

    var legendBox = this._calculateTotalBox();

    var backgroundSettings = {
      x: _round(legendBox.x - locationOptions.paddingLeftRight),
      y: _round(legendBox.y - locationOptions.paddingTopBottom),
      width: _round(legendBox.width) + 2 * locationOptions.paddingLeftRight,
      height: _round(legendBox.height),
      opacity: locationOptions.backgroundOpacity
    };

    if (border.visible && border.width && border.color && border.color !== NONE) {
      backgroundSettings['stroke-width'] = border.width;
      backgroundSettings.stroke = border.color;
      backgroundSettings['stroke-opacity'] = border.opacity;
      backgroundSettings.dashStyle = border.dashStyle;
      backgroundSettings.rx = border.cornerRadius || 0;
      backgroundSettings.ry = border.cornerRadius || 0;
    }

    this._background.attr(backgroundSettings);
  },
  _setBoundingRect: function _setBoundingRect(margin) {
    if (!this._insideLegendGroup) {
      return;
    }

    var box = this._calculateTotalBox();

    box.height += margin.top + margin.bottom;
    box.widthWithoutMargins = box.width;
    box.width += margin.left + margin.right;
    box.x -= margin.left;
    box.y -= margin.top;
    this._boundingRect = box;
  },
  _calculateTotalBox: function _calculateTotalBox() {
    var markerBox = this._markersGroup.getBBox();

    var titleBox = this._title.getCorrectedLayoutOptions();

    var box = this._insideLegendGroup.getBBox();

    var verticalPadding = this._background ? 2 * this._options.paddingTopBottom : 0;
    box.height = markerBox.height + titleBox.height + verticalPadding;
    titleBox.width > box.width && (box.width = titleBox.width);
    return box;
  },
  getActionCallback: function getActionCallback(point) {
    var that = this;

    if (that._options.visible) {
      return function (act) {
        that[act](point.index);
      };
    } else {
      return _common.noop;
    }
  },
  getLayoutOptions: function getLayoutOptions() {
    var options = this._options;
    var boundingRect = this._insideLegendGroup ? this._boundingRect : {
      width: 0,
      height: 0,
      x: 0,
      y: 0
    };

    if (options) {
      boundingRect.verticalAlignment = options.verticalAlignment;
      boundingRect.horizontalAlignment = options.horizontalAlignment;

      if (options.orientation === HORIZONTAL) {
        boundingRect.cutLayoutSide = options.verticalAlignment;
        boundingRect.cutSide = 'vertical';
      } else {
        if (options.horizontalAlignment === CENTER) {
          boundingRect.cutLayoutSide = options.verticalAlignment;
          boundingRect.cutSide = 'vertical';
        } else {
          boundingRect.cutLayoutSide = options.horizontalAlignment;
          boundingRect.cutSide = 'horizontal';
        }
      }

      boundingRect.position = {
        horizontal: options.horizontalAlignment,
        vertical: options.verticalAlignment
      };
      return boundingRect;
    }

    return null;
  },
  shift: function shift(x, y) {
    var that = this;
    var box = {};

    if (that._insideLegendGroup) {
      that._insideLegendGroup.attr({
        translateX: x - that._boundingRect.x,
        translateY: y - that._boundingRect.y
      });
    }

    that._title && that._shiftTitle(that._boundingRect.widthWithoutMargins);
    that._markersGroup && that._shiftMarkers();
    if (that._insideLegendGroup) box = that._legendGroup.getBBox();
    that._x1 = box.x;
    that._y1 = box.y;
    that._x2 = box.x + box.width;
    that._y2 = box.y + box.height;
    return that;
  },
  _shiftTitle: function _shiftTitle(boxWidth) {
    var that = this;
    var title = that._title;
    var titleBox = title.getCorrectedLayoutOptions();

    if (!titleBox || !title.hasText()) {
      return;
    }

    var width = boxWidth - (that._background ? 2 * that._options.paddingLeftRight : 0);
    var titleOptions = title.getOptions();
    var titleY = titleBox.y + titleOptions.margin.top;
    var titleX = 0;

    if (titleOptions.verticalAlignment === BOTTOM && that._markersGroup) {
      titleY += that._markersGroup.getBBox().height;
    }

    if (titleOptions.horizontalAlignment === RIGHT) {
      titleX = width - titleBox.width;
    } else if (titleOptions.horizontalAlignment === CENTER) {
      titleX = (width - titleBox.width) / 2;
    }

    title.shift(titleX, titleY);
  },
  _shiftMarkers: function _shiftMarkers() {
    var titleBox = this._title.getLayoutOptions();

    var markerBox = this._markersGroup.getBBox();

    var titleOptions = this._title.getOptions() || {};
    var center = 0;
    var y = 0;

    if (titleBox.width > markerBox.width && this._options.horizontalAlignment === CENTER) {
      center = titleBox.width / 2 - markerBox.width / 2;
    }

    if (titleOptions.verticalAlignment === TOP) {
      y = titleBox.height;
    }

    if (center !== 0 || y !== 0) {
      this._markersGroup.attr({
        translateX: center,
        translateY: y
      });

      this._items.forEach(function (item) {
        item.tracker.left += center;
        item.tracker.right += center;
        item.tracker.top += y;
        item.tracker.bottom += y;
      });
    }
  },
  getPosition: function getPosition() {
    return this._options.position;
  },
  coordsIn: function coordsIn(x, y) {
    return x >= this._x1 && x <= this._x2 && y >= this._y1 && y <= this._y2;
  },
  getItemByCoord: function getItemByCoord(x, y) {
    var items = this._items;
    var legendGroup = this._insideLegendGroup;
    x = x - legendGroup.attr('translateX');
    y = y - legendGroup.attr('translateY');

    for (var i = 0; i < items.length; i++) {
      if (inRect(items[i].tracker, x, y)) {
        return items[i].tracker;
      }
    }

    return null;
  },
  dispose: function dispose() {
    var that = this;
    that._title && that._title.dispose();
    that._legendGroup = that._insideLegendGroup = that._title = that._renderer = that._options = that._data = that._items = null;
    return that;
  },
  // BaseWidget_layout_implementation
  layoutOptions: function layoutOptions() {
    if (!this.isVisible()) {
      return null;
    }

    var pos = this.getLayoutOptions();
    return {
      horizontalAlignment: this._options.horizontalAlignment,
      verticalAlignment: this._options.verticalAlignment,
      side: pos.cutSide,
      priority: 1,
      position: this.getPosition()
    };
  },
  measure: function measure(size) {
    if (this._updated || !this._insideLegendGroup) {
      this.draw(size[0], size[1]);
      this._updated = false;
    } else {
      this._items.forEach(function (item) {
        item.bBoxes = [];
      });

      this._updateElementsPosition(size[0], size[1]);
    }

    var rect = this.getLayoutOptions();
    return [rect.width, rect.height];
  },
  move: function move(rect) {
    this.shift(rect[0], rect[1]);
  },
  freeSpace: function freeSpace() {
    this._options._incidentOccurred('W2104');

    this.erase();
  } // BaseWidget_layout_implementation

});
var plugin = {
  name: 'legend',
  init: function init() {
    var that = this;

    var group = this._renderer.g().attr({
      class: this._rootClassPrefix + '-legend'
    }).enableLinks().append(that._renderer.root);

    that._legend = new Legend({
      renderer: that._renderer,
      group: group,
      widget: this,
      itemGroupClass: this._rootClassPrefix + '-item',
      titleGroupClass: this._rootClassPrefix + '-title',
      textField: 'text',
      getFormatObject: function getFormatObject(data) {
        return {
          item: data.item,
          text: data.text
        };
      }
    });

    that._layout.add(that._legend);
  },
  extenders: {
    _applyTilesAppearance: function _applyTilesAppearance() {
      var that = this;

      this._items.forEach(function (item) {
        that._applyLegendItemStyle(item.id, item.getState());
      });
    },
    _buildNodes: function _buildNodes() {
      this._createLegendItems();
    }
  },
  members: {
    _applyLegendItemStyle: function _applyLegendItemStyle(id, state) {
      var legend = this._legend;

      switch (state) {
        case 'hover':
          legend.applyHover(id);
          break;

        case 'selection':
          legend.applySelected(id);
          break;

        default:
          legend.resetItem(id);
          break;
      }
    },
    _createLegendItems: function _createLegendItems() {
      if (this._legend.update(this._getLegendData(), this._getOption('legend'), this._themeManager.theme('legend').title)) {
        this._requestChange(['LAYOUT']);
      }
    }
  },
  dispose: function dispose() {
    this._legend.dispose();
  },
  customize: function customize(constructor) {
    constructor.prototype._proxyData.push(function (x, y) {
      if (this._legend.coordsIn(x, y)) {
        var item = this._legend.getItemByCoord(x, y);

        if (item) {
          return {
            id: item.id,
            type: 'legend'
          };
        }
      }
    });

    constructor.addChange({
      code: 'LEGEND',
      handler: function handler() {
        this._createLegendItems();
      },
      isThemeDependent: true,
      option: 'legend',
      isOptionChange: true
    });
  }
};
exports.plugin = plugin;

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _extend2 = __webpack_require__(0);

var _symbol_point = _interopRequireDefault(__webpack_require__(162));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extend = _extend2.extend;
var _math = Math;
var _floor = _math.floor;
var _abs = _math.abs;
var CANVAS_POSITION_DEFAULT = 'canvas_position_default';
var DEFAULT_BAR_TRACKER_SIZE = 9;
var CORRECTING_BAR_TRACKER_VALUE = 4;
var RIGHT = 'right';
var LEFT = 'left';
var TOP = 'top';
var BOTTOM = 'bottom';

function getLabelOrientation(point) {
  var initialValue = point.initialValue;

  var invert = point._getValTranslator().getBusinessRange().invert;

  var isDiscreteValue = point.series.valueAxisType === 'discrete';
  var isFullStacked = point.series.isFullStackedSeries();
  var notAxisInverted = !isDiscreteValue && (initialValue >= 0 && !invert || initialValue < 0 && invert) || isDiscreteValue && !invert || isFullStacked;
  return notAxisInverted ? TOP : BOTTOM;
}

var _default = _extend({}, _symbol_point.default, {
  correctCoordinates: function correctCoordinates(correctOptions) {
    var that = this;

    var correction = _floor(correctOptions.offset - correctOptions.width / 2);

    if (that._options.rotated) {
      that.height = correctOptions.width;
      that.yCorrection = correction;
      that.xCorrection = null;
    } else {
      that.width = correctOptions.width;
      that.xCorrection = correction;
      that.yCorrection = null;
    }
  },
  _getGraphicBBox: function _getGraphicBBox(location) {
    var bBox = {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };

    if (location) {
      var isTop = location === 'top';

      if (!this._options.rotated) {
        bBox.y = isTop ? bBox.y : bBox.y + bBox.height;
        bBox.height = 0;
      } else {
        bBox.x = isTop ? bBox.x + bBox.width : bBox.x;
        bBox.width = 0;
      }
    }

    return bBox;
  },
  _getLabelConnector: function _getLabelConnector(location) {
    return this._getGraphicBBox(location);
  },
  _getLabelPosition: function _getLabelPosition() {
    var position = getLabelOrientation(this);

    if (this._options.rotated) {
      position = position === TOP ? RIGHT : LEFT;
    }

    return position;
  },
  _getLabelCoords: function _getLabelCoords(label) {
    var that = this;
    var coords;

    if (that.initialValue === 0 && that.series.isFullStackedSeries()) {
      if (!this._options.rotated) {
        coords = that._getLabelCoordOfPosition(label, TOP);
      } else {
        coords = that._getLabelCoordOfPosition(label, RIGHT);
      }
    } else if (label.getLayoutOptions().position === 'inside') {
      coords = that._getLabelCoordOfPosition(label, 'inside');
    } else {
      coords = _symbol_point.default._getLabelCoords.call(this, label);
    }

    return coords;
  },
  _drawLabel: function _drawLabel() {
    this._label.pointPosition = this._label.getLayoutOptions().position !== 'inside' && getLabelOrientation(this);

    _symbol_point.default._drawLabel.call(this);
  },
  hideInsideLabel: function hideInsideLabel(label, coord) {
    var graphicBBox = this._getGraphicBBox();

    var labelBBox = label.getBoundingRect();

    if (this._options.resolveLabelsOverlapping) {
      if ((coord.y <= graphicBBox.y && coord.y + labelBBox.height >= graphicBBox.y + graphicBBox.height || coord.x <= graphicBBox.x && coord.x + labelBBox.width >= graphicBBox.x + graphicBBox.width) && !(coord.y > graphicBBox.y + graphicBBox.height || coord.y + labelBBox.height < graphicBBox.y || coord.x > graphicBBox.x + graphicBBox.width || coord.x + labelBBox.width < graphicBBox.x)) {
        label.draw(false);
        return true;
      }
    }

    return false;
  },
  _showForZeroValues: function _showForZeroValues() {
    return this._options.label.showForZeroValues || this.initialValue;
  },
  _drawMarker: function _drawMarker(renderer, group, animationEnabled) {
    var that = this;

    var style = that._getStyle();

    var r = that._options.cornerRadius;
    var rotated = that._options.rotated;

    var _that$getMarkerCoords = that.getMarkerCoords(),
        x = _that$getMarkerCoords.x,
        y = _that$getMarkerCoords.y,
        width = _that$getMarkerCoords.width,
        height = _that$getMarkerCoords.height;

    if (animationEnabled) {
      if (rotated) {
        width = 0;
        x = that.defaultX;
      } else {
        height = 0;
        y = that.defaultY;
      }
    }

    that.graphic = renderer.rect(x, y, width, height).attr({
      rx: r,
      ry: r
    }).smartAttr(style).data({
      'chart-data-point': that
    }).append(group);
  },
  _getSettingsForTracker: function _getSettingsForTracker() {
    var that = this;
    var y = that.y;
    var height = that.height;
    var x = that.x;
    var width = that.width;

    if (that._options.rotated) {
      if (width === 1) {
        width = DEFAULT_BAR_TRACKER_SIZE;
        x -= CORRECTING_BAR_TRACKER_VALUE;
      }
    } else {
      if (height === 1) {
        height = DEFAULT_BAR_TRACKER_SIZE;
        y -= CORRECTING_BAR_TRACKER_VALUE;
      }
    }

    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  },
  getGraphicSettings: function getGraphicSettings() {
    var graphic = this.graphic;
    return {
      x: graphic.attr('x'),
      y: graphic.attr('y'),
      height: graphic.attr('height'),
      width: graphic.attr('width')
    };
  },
  _getEdgeTooltipParams: function _getEdgeTooltipParams() {
    var isPositive = this.value >= 0;
    var xCoord;
    var yCoord;

    var invertedBusinessRange = this._getValTranslator().getBusinessRange().invert;

    var x = this.x,
        y = this.y,
        width = this.width,
        height = this.height;

    if (this._options.rotated) {
      yCoord = y + height / 2;

      if (invertedBusinessRange) {
        xCoord = isPositive ? x : x + width;
      } else {
        xCoord = isPositive ? x + width : x;
      }
    } else {
      xCoord = x + width / 2;

      if (invertedBusinessRange) {
        yCoord = isPositive ? y + height : y;
      } else {
        yCoord = isPositive ? y : y + height;
      }
    }

    return {
      x: xCoord,
      y: yCoord,
      offset: 0
    };
  },
  getTooltipParams: function getTooltipParams(location) {
    if (location === 'edge') {
      return this._getEdgeTooltipParams();
    }

    var center = this.getCenterCoord();
    center.offset = 0;
    return center;
  },
  getCenterCoord: function getCenterCoord() {
    var width = this.width,
        height = this.height,
        x = this.x,
        y = this.y;
    return {
      x: x + width / 2,
      y: y + height / 2
    };
  },
  _truncateCoord: function _truncateCoord(coord, bounds) {
    if (coord === null) {
      return coord;
    }

    if (coord < bounds[0]) {
      return bounds[0];
    }

    if (coord > bounds[1]) {
      return bounds[1];
    }

    return coord;
  },
  _getErrorBarBaseEdgeLength: function _getErrorBarBaseEdgeLength() {
    return this._options.rotated ? this.height : this.width;
  },
  _translateErrorBars: function _translateErrorBars(argVisibleArea) {
    _symbol_point.default._translateErrorBars.call(this);

    if (this._errorBarPos < argVisibleArea[0] || this._errorBarPos > argVisibleArea[1]) {
      this._errorBarPos = undefined;
    }
  },
  // TODO check & rework
  _translate: function _translate() {
    var that = this;
    var rotated = that._options.rotated;
    var valAxis = rotated ? 'x' : 'y';
    var argAxis = rotated ? 'y' : 'x';
    var valIntervalName = rotated ? 'width' : 'height';
    var argIntervalName = rotated ? 'height' : 'width';

    var argTranslator = that._getArgTranslator();

    var valTranslator = that._getValTranslator();

    var argVisibleArea = that.series.getArgumentAxis().getVisibleArea();
    var valVisibleArea = that.series.getValueAxis().getVisibleArea();
    var arg = argTranslator.translate(that.argument);
    var val = valTranslator.translate(that.value, 1);
    var minVal = valTranslator.translate(that.minValue);
    that[argAxis] = arg = arg === null ? arg : arg + (that[argAxis + 'Correction'] || 0);
    that['v' + valAxis] = val;
    that['v' + argAxis] = arg + that[argIntervalName] / 2;
    val = that._truncateCoord(val, valVisibleArea);
    minVal = that._truncateCoord(minVal, valVisibleArea);
    that[valIntervalName] = _abs(val - minVal);
    val = val < minVal ? val : minVal;

    that._calculateVisibility(rotated ? val : arg, rotated ? arg : val, that.width, that.height);

    that[valAxis] = val === null ? val : val + (that[valAxis + 'Correction'] || 0);
    that['min' + valAxis.toUpperCase()] = minVal === null ? minVal : minVal + (that[valAxis + 'Correction'] || 0);
    that['default' + valAxis.toUpperCase()] = valTranslator.translate(CANVAS_POSITION_DEFAULT);

    that._translateErrorBars(argVisibleArea);

    if (that.inVisibleArea && that[argAxis] !== null) {
      if (that[argAxis] < argVisibleArea[0]) {
        that[argIntervalName] = that[argIntervalName] - (argVisibleArea[0] - that[argAxis]);
        that[argAxis] = argVisibleArea[0];
      }

      if (that[argAxis] + that[argIntervalName] > argVisibleArea[1]) {
        that[argIntervalName] = argVisibleArea[1] - that[argAxis];
      }
    }
  },
  _updateMarker: function _updateMarker(animationEnabled, style) {
    this.graphic.smartAttr(_extend({}, style, !animationEnabled ? this.getMarkerCoords() : {}));
  },
  getMarkerCoords: function getMarkerCoords() {
    var that = this;
    var x = that.x;
    var y = that.y;
    var width = that.width;
    var height = that.height;
    var argAxis = that.series.getArgumentAxis();
    var rotated = that._options.rotated;

    if (argAxis.getAxisPosition) {
      var axisOptions = argAxis.getOptions();
      var edgeOffset = Math.round(axisOptions.width / 2);
      var argAxisPosition = argAxis.getAxisPosition();

      if (axisOptions.visible) {
        if (!rotated) {
          height -= that.minY === that.defaultY && that.minY === argAxisPosition - argAxis.getAxisShift() ? edgeOffset : 0;
          height < 0 && (height = 0);
        } else {
          var isStartFromAxis = that.minX === that.defaultX && that.minX === argAxisPosition - argAxis.getAxisShift();
          x += isStartFromAxis ? edgeOffset : 0;
          width -= isStartFromAxis ? edgeOffset : 0;
          width < 0 && (width = 0);
        }
      }
    }

    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  },
  coordsIn: function coordsIn(x, y) {
    var that = this;
    return x >= that.x && x <= that.x + that.width && y >= that.y && y <= that.y + that.height;
  }
});

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _utils = __webpack_require__(14);

var _type = __webpack_require__(1);

var _common = __webpack_require__(4);

var DISCRETE = 'discrete';
var abs = Math.abs,
    floor = Math.floor,
    ceil = Math.ceil,
    min = Math.min;

function continuousRangeCalculator(range, minValue, maxValue) {
  range.min = range.min < minValue ? range.min : minValue;
  range.max = range.max > maxValue ? range.max : maxValue;
}

function createGetLogFunction(axisType, axis) {
  if (axisType !== 'logarithmic') {
    return null;
  }

  var base = axis.getOptions().logarithmBase;
  return function (value) {
    var log = (0, _utils.getLog)(abs(value), base);
    var round = log < 0 ? floor : ceil;
    return round(log);
  };
}

function getRangeCalculator(axisType, axis, getLog) {
  var rangeCalculator = continuousRangeCalculator;

  if (axisType === DISCRETE) {
    rangeCalculator = function rangeCalculator(range, minValue, maxValue) {
      if (minValue !== maxValue) {
        range.categories.push(maxValue);
      }

      range.categories.push(minValue);
    };
  } else if (axis) {
    rangeCalculator = function rangeCalculator(range, value) {
      var interval = axis.calculateInterval(value, range.prevValue);
      var minInterval = range.interval;
      range.interval = (minInterval < interval ? minInterval : interval) || minInterval;
      range.prevValue = value;
      continuousRangeCalculator(range, value, value);
    };
  }

  if (getLog) {
    return function (range, minValue, maxValue) {
      var minArgs = [];
      rangeCalculator(range, minValue, maxValue);
      minValue !== 0 && minArgs.push(getLog(minValue));
      maxValue !== 0 && minArgs.push(getLog(maxValue));
      var linearThreshold = min.apply(null, minArgs);
      range.linearThreshold = range.linearThreshold < linearThreshold ? range.linearThreshold : linearThreshold;
    };
  }

  return rangeCalculator;
}

function getInitialRange(axisType, dataType, firstValue) {
  var range = {
    axisType: axisType,
    dataType: dataType
  };

  if (axisType === DISCRETE) {
    range.categories = [];
  } else {
    range.min = (0, _type.isObject)(firstValue) ? firstValue.min : firstValue;
    range.max = (0, _type.isObject)(firstValue) ? firstValue.max : firstValue;
  }

  return range;
}

function processCategories(range) {
  if (range.categories) {
    range.categories = (0, _utils.unique)(range.categories);
  }

  return range;
}

function getValueForArgument(point, extraPoint, x, range) {
  if (extraPoint && (0, _type.isDefined)(extraPoint.value)) {
    var y1 = point.value;
    var y2 = extraPoint.value;
    var x1 = point.argument;
    var x2 = extraPoint.argument;
    var r = (x - x1) * (y2 - y1) / (x2 - x1) + y1.valueOf();
    return range.dataType === 'datetime' ? new Date(r) : r;
  } else {
    return point.value;
  }
}

function calculateRangeBetweenPoints(rangeCalculator, range, point, prevPoint, bound) {
  var value = getValueForArgument(point, prevPoint, bound, range);
  rangeCalculator(range, value, value);
}

function isLineSeries(series) {
  return series.type.toLowerCase().indexOf('line') >= 0 || series.type.toLowerCase().indexOf('area') >= 0;
}

function getViewportReducer(series) {
  var rangeCalculator = getRangeCalculator(series.valueAxisType);
  var argumentAxis = series.getArgumentAxis();
  var viewport = argumentAxis && series.getArgumentAxis().visualRange() || {};
  var calculatePointBetweenPoints = isLineSeries(series) ? calculateRangeBetweenPoints : _common.noop;

  if (argumentAxis && argumentAxis.getMarginOptions().checkInterval) {
    var range = series.getArgumentAxis().getTranslator().getBusinessRange();
    var add = (0, _utils.getAddFunction)(range, false);
    var interval = range.interval;

    if (isFinite(interval) && (0, _type.isDefined)(viewport.startValue) && (0, _type.isDefined)(viewport.endValue)) {
      viewport.startValue = add(viewport.startValue, interval, -1);
      viewport.endValue = add(viewport.endValue, interval);
    }
  }

  var viewportFilter = getViewPortFilter(viewport);
  return function (range, point, index, points) {
    var argument = point.argument;

    if (!point.hasValue()) {
      return range;
    }

    if (viewportFilter(argument)) {
      if (!range.startCalc) {
        range.startCalc = true;
        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue);
      }

      rangeCalculator(range, point.getMinValue(), point.getMaxValue());
    } else if (!viewport.categories && (0, _type.isDefined)(viewport.startValue) && argument > viewport.startValue) {
      if (!range.startCalc) {
        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue);
      }

      range.endCalc = true;
      calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.endValue);
    }

    return range;
  };
}

function getViewPortFilter(viewport) {
  if (viewport.categories) {
    var dictionary = viewport.categories.reduce(function (result, category) {
      result[category.valueOf()] = true;
      return result;
    }, {});
    return function (argument) {
      return (0, _type.isDefined)(argument) && dictionary[argument.valueOf()];
    };
  }

  if (!(0, _type.isDefined)(viewport.startValue) && !(0, _type.isDefined)(viewport.endValue)) {
    return function () {
      return true;
    };
  }

  if (!(0, _type.isDefined)(viewport.endValue)) {
    return function (argument) {
      return argument >= viewport.startValue;
    };
  }

  if (!(0, _type.isDefined)(viewport.startValue)) {
    return function (argument) {
      return argument <= viewport.endValue;
    };
  }

  return function (argument) {
    return argument >= viewport.startValue && argument <= viewport.endValue;
  };
}

var _default = {
  getViewPortFilter: getViewPortFilter,
  getArgumentRange: function getArgumentRange(series) {
    var data = series._data || [];
    var range = {};

    if (data.length) {
      if (series.argumentAxisType === DISCRETE) {
        range = {
          categories: data.map(function (item) {
            return item.argument;
          })
        };
      } else {
        var interval;

        if (data.length > 1) {
          var i1 = series.getArgumentAxis().calculateInterval(data[0].argument, data[1].argument);
          var i2 = series.getArgumentAxis().calculateInterval(data[data.length - 1].argument, data[data.length - 2].argument);
          interval = min(i1, i2);
        }

        range = {
          min: data[0].argument,
          max: data[data.length - 1].argument,
          interval: interval
        };
      }
    }

    return processCategories(range);
  },
  getRangeData: function getRangeData(series) {
    var points = series.getPoints();
    var useAggregation = series.useAggregation();
    var argumentCalculator = getRangeCalculator(series.argumentAxisType, points.length > 1 && series.getArgumentAxis(), createGetLogFunction(series.argumentAxisType, series.getArgumentAxis()));
    var valueRangeCalculator = getRangeCalculator(series.valueAxisType, null, createGetLogFunction(series.valueAxisType, series.getValueAxis()));
    var viewportReducer = getViewportReducer(series);
    var range = points.reduce(function (range, point, index, points) {
      var argument = point.argument;

      if (!point.isArgumentCorrect()) {
        return range;
      }

      argumentCalculator(range.arg, argument, argument);

      if (point.hasValue()) {
        valueRangeCalculator(range.val, point.getMinValue(), point.getMaxValue());
        viewportReducer(range.viewport, point, index, points);
      }

      return range;
    }, {
      arg: getInitialRange(series.argumentAxisType, series.argumentType, series.getArgumentRangeInitialValue()),
      val: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : undefined),
      viewport: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : undefined)
    });

    if (useAggregation) {
      var argumentRange = this.getArgumentRange(series);

      if (series.argumentAxisType === DISCRETE) {
        range.arg = argumentRange;
      } else {
        var viewport = series.getArgumentAxis().getViewport();

        if ((0, _type.isDefined)(viewport.startValue) || (0, _type.isDefined)(viewport.length)) {
          argumentCalculator(range.arg, argumentRange.min, argumentRange.min);
        }

        if ((0, _type.isDefined)(viewport.endValue) || (0, _type.isDefined)(viewport.length) && (0, _type.isDefined)(viewport.startValue)) {
          argumentCalculator(range.arg, argumentRange.max, argumentRange.max);
        }
      }
    }

    processCategories(range.arg);
    processCategories(range.val);
    return range;
  },
  getViewport: function getViewport(series) {
    var points = series.getPoints();
    var range = {};
    var reducer = getViewportReducer(series);
    range = getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : undefined);
    points.some(function (point, index) {
      reducer(range, point, index, points);
      return range.endCalc;
    });
    return range;
  },
  getPointsInViewPort: function getPointsInViewPort(series) {
    var argumentViewPortFilter = getViewPortFilter(series.getArgumentAxis().visualRange() || {});
    var valueViewPort = series.getValueAxis().visualRange() || {};
    var valueViewPortFilter = getViewPortFilter(valueViewPort);
    var points = series.getPoints();

    var addValue = function addValue(values, point, isEdge) {
      var minValue = point.getMinValue();
      var maxValue = point.getMaxValue();
      var isMinValueInViewPort = valueViewPortFilter(minValue);
      var isMaxValueInViewPort = valueViewPortFilter(maxValue);

      if (isMinValueInViewPort) {
        values.push(minValue);
      }

      if (maxValue !== minValue && isMaxValueInViewPort) {
        values.push(maxValue);
      }

      if (isEdge && !isMinValueInViewPort && !isMaxValueInViewPort) {
        if (!values.length) {
          values.push(valueViewPort.startValue);
        } else {
          values.push(valueViewPort.endValue);
        }
      }
    };

    var addEdgePoints = isLineSeries(series) ? function (result, points, index) {
      var point = points[index];
      var prevPoint = points[index - 1];
      var nextPoint = points[index + 1];

      if (nextPoint && argumentViewPortFilter(nextPoint.argument)) {
        addValue(result[1], point, true);
      }

      if (prevPoint && argumentViewPortFilter(prevPoint.argument)) {
        addValue(result[1], point, true);
      }
    } : _common.noop;

    var checkPointInViewport = function checkPointInViewport(result, point, index) {
      if (argumentViewPortFilter(point.argument)) {
        addValue(result[0], point);
      } else {
        addEdgePoints(result, points, index);
      }

      return result;
    };

    return points.reduce(checkPointInViewport, [[], []]);
  }
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.polar = exports.chart = void 0;

var _scatter_series = __webpack_require__(139);

var _object = __webpack_require__(52);

var _extend = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _utils = __webpack_require__(14);

var _math = __webpack_require__(31);

// there are line, stepline, stackedline, fullstackedline, spline
var DISCRETE = 'discrete';
var round = Math.round,
    sqrt = Math.sqrt,
    pow = Math.pow,
    min = Math.min,
    max = Math.max,
    abs = Math.abs;
var chart = {};
exports.chart = chart;
var polar = {};
exports.polar = polar;

function clonePoint(point, newX, newY, newAngle) {
  var p = (0, _object.clone)(point);
  p.x = newX;
  p.y = newY;
  p.angle = newAngle;
  return p;
}

function getTangentPoint(point, prevPoint, centerPoint, tan, nextStepAngle) {
  var correctAngle = point.angle + nextStepAngle;
  var cosSin = (0, _utils.getCosAndSin)(correctAngle);
  var x = centerPoint.x + (point.radius + tan * nextStepAngle) * cosSin.cos;
  var y = centerPoint.y - (point.radius + tan * nextStepAngle) * cosSin.sin;
  return clonePoint(prevPoint, x, y, correctAngle);
}

function obtainCubicBezierTCoef(p, p0, p1, p2, p3) {
  var d = p0 - p;
  var c = 3 * p1 - 3 * p0;
  var b = 3 * p2 - 6 * p1 + 3 * p0;
  var a = p3 - 3 * p2 + 3 * p1 - p0;
  return (0, _math.solveCubicEquation)(a, b, c, d);
}

var lineMethods = {
  autoHidePointMarkersEnabled: function autoHidePointMarkersEnabled() {
    return true;
  },
  _applyGroupSettings: function _applyGroupSettings(style, settings, group) {
    var that = this;
    settings = (0, _extend.extend)(settings, style);

    that._applyElementsClipRect(settings);

    group.attr(settings);
  },
  _setGroupsSettings: function _setGroupsSettings(animationEnabled) {
    var that = this;
    var style = that._styles.normal;

    that._applyGroupSettings(style.elements, {
      'class': 'dxc-elements'
    }, that._elementsGroup);

    that._bordersGroup && that._applyGroupSettings(style.border, {
      'class': 'dxc-borders'
    }, that._bordersGroup);

    _scatter_series.chart._setGroupsSettings.call(that, animationEnabled);

    animationEnabled && that._markersGroup && that._markersGroup.attr({
      opacity: 0.001
    });
  },
  _createGroups: function _createGroups() {
    var that = this;

    that._createGroup('_elementsGroup', that, that._group);

    that._areBordersVisible() && that._createGroup('_bordersGroup', that, that._group);

    _scatter_series.chart._createGroups.call(that);
  },
  _areBordersVisible: function _areBordersVisible() {
    return false;
  },
  _getDefaultSegment: function _getDefaultSegment(segment) {
    return {
      line: (0, _utils.map)(segment.line || [], function (pt) {
        return pt.getDefaultCoords();
      })
    };
  },
  _prepareSegment: function _prepareSegment(points) {
    return {
      line: points
    };
  },
  _parseLineOptions: function _parseLineOptions(options, defaultColor) {
    return {
      stroke: options.color || defaultColor,
      'stroke-width': options.width,
      dashStyle: options.dashStyle || 'solid'
    };
  },
  _parseStyle: function _parseStyle(options, defaultColor) {
    return {
      elements: this._parseLineOptions(options, defaultColor)
    };
  },
  _applyStyle: function _applyStyle(style) {
    var that = this;
    that._elementsGroup && that._elementsGroup.attr(style.elements);
    (0, _iterator.each)(that._graphics || [], function (_, graphic) {
      graphic.line && graphic.line.attr({
        'stroke-width': style.elements['stroke-width']
      }).sharp();
    });
  },
  _drawElement: function _drawElement(segment, group) {
    return {
      line: this._createMainElement(segment.line, {
        'stroke-width': this._styles.normal.elements['stroke-width']
      }).append(group)
    };
  },
  _removeElement: function _removeElement(element) {
    element.line.remove();
  },
  _updateElement: function _updateElement(element, segment, animate, animationComplete) {
    var params = {
      points: segment.line
    };
    var lineElement = element.line;
    animate ? lineElement.animate(params, {}, animationComplete) : lineElement.attr(params);
  },
  _animateComplete: function _animateComplete() {
    var that = this;

    _scatter_series.chart._animateComplete.call(that);

    that._markersGroup && that._markersGroup.animate({
      opacity: 1
    }, {
      duration: that._defaultDuration
    });
  },
  _animate: function _animate() {
    var that = this;
    var lastIndex = that._graphics.length - 1;
    (0, _iterator.each)(that._graphics || [], function (i, elem) {
      var complete;

      if (i === lastIndex) {
        complete = function complete() {
          that._animateComplete();
        };
      }

      that._updateElement(elem, that._segments[i], true, complete);
    });
  },
  _drawPoint: function _drawPoint(options) {
    _scatter_series.chart._drawPoint.call(this, {
      point: options.point,
      groups: options.groups
    });
  },
  _createMainElement: function _createMainElement(points, settings) {
    return this._renderer.path(points, 'line').attr(settings);
  },
  _sortPoints: function _sortPoints(points, rotated) {
    return rotated ? points.sort(function (p1, p2) {
      return p2.y - p1.y;
    }) : points.sort(function (p1, p2) {
      return p1.x - p2.x;
    });
  },
  _drawSegment: function _drawSegment(points, animationEnabled, segmentCount, lastSegment) {
    var that = this;
    var rotated = that._options.rotated;

    var segment = that._prepareSegment(points, rotated, lastSegment);

    that._segments.push(segment);

    if (!that._graphics[segmentCount]) {
      that._graphics[segmentCount] = that._drawElement(animationEnabled ? that._getDefaultSegment(segment) : segment, that._elementsGroup);
    } else if (!animationEnabled) {
      that._updateElement(that._graphics[segmentCount], segment);
    }
  },
  _getTrackerSettings: function _getTrackerSettings() {
    var that = this;
    var defaultTrackerWidth = that._defaultTrackerWidth;
    var strokeWidthFromElements = that._styles.normal.elements['stroke-width'];
    return {
      'stroke-width': strokeWidthFromElements > defaultTrackerWidth ? strokeWidthFromElements : defaultTrackerWidth,
      fill: 'none'
    };
  },
  _getMainPointsFromSegment: function _getMainPointsFromSegment(segment) {
    return segment.line;
  },
  _drawTrackerElement: function _drawTrackerElement(segment) {
    return this._createMainElement(this._getMainPointsFromSegment(segment), this._getTrackerSettings(segment));
  },
  _updateTrackerElement: function _updateTrackerElement(segment, element) {
    var settings = this._getTrackerSettings(segment);

    settings.points = this._getMainPointsFromSegment(segment);
    element.attr(settings);
  },
  checkSeriesViewportCoord: function checkSeriesViewportCoord(axis, coord) {
    if (!_scatter_series.chart.checkSeriesViewportCoord.call(this)) {
      return false;
    }

    var range = axis.isArgumentAxis ? this.getArgumentRange() : this.getViewport();
    var min = axis.getTranslator().translate(range.categories ? range.categories[0] : range.min);
    var max = axis.getTranslator().translate(range.categories ? range.categories[range.categories.length - 1] : range.max);
    var rotated = this.getOptions().rotated;
    var inverted = axis.getOptions().inverted;
    return axis.isArgumentAxis && (!rotated && !inverted || rotated && inverted) || !axis.isArgumentAxis && (rotated && !inverted || !rotated && inverted) ? coord >= min && coord <= max : coord >= max && coord <= min;
  }
};
var lineSeries = chart['line'] = (0, _extend.extend)({}, _scatter_series.chart, lineMethods, {
  getPointCenterByArg: function getPointCenterByArg(arg) {
    var value = this.getArgumentAxis().getTranslator().translate(arg);
    return {
      x: value,
      y: value
    };
  },
  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {
    var that = this;
    var oppositeCoord = null;

    var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);

    var needValueCoord = isArgument && !that._options.rotated || !isArgument && that._options.rotated;

    for (var i = 0; i < nearestPoints.length; i++) {
      var p = nearestPoints[i];
      var k = (p[1].vy - p[0].vy) / (p[1].vx - p[0].vx);
      var b = p[0].vy - p[0].vx * k;
      var tmpCoord = void 0;

      if (p[1].vx - p[0].vx === 0) {
        tmpCoord = needValueCoord ? p[0].vy : p[0].vx;
      } else {
        tmpCoord = needValueCoord ? k * coord + b : (coord - b) / k;
      }

      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
        oppositeCoord = tmpCoord;
        break;
      }
    }

    return oppositeCoord;
  }
});
chart['stepline'] = (0, _extend.extend)({}, lineSeries, {
  _calculateStepLinePoints: function _calculateStepLinePoints(points) {
    var segment = [];
    var coordName = this._options.rotated ? 'x' : 'y';
    (0, _iterator.each)(points, function (i, pt) {
      var point;

      if (!i) {
        segment.push(pt);
        return;
      }

      var step = segment[segment.length - 1][coordName];

      if (step !== pt[coordName]) {
        point = (0, _object.clone)(pt);
        point[coordName] = step;
        segment.push(point);
      }

      segment.push(pt);
    });
    return segment;
  },
  _prepareSegment: function _prepareSegment(points) {
    return lineSeries._prepareSegment(this._calculateStepLinePoints(points));
  },
  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {
    var oppositeCoord;
    var rotated = this._options.rotated;
    var isOpposite = !isArgument && !rotated || isArgument && rotated;
    var coordName = !isOpposite ? 'vx' : 'vy';
    var oppositeCoordName = !isOpposite ? 'vy' : 'vx';

    var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);

    for (var i = 0; i < nearestPoints.length; i++) {
      var p = nearestPoints[i];
      var tmpCoord = void 0;

      if (isArgument) {
        tmpCoord = coord !== p[1][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];
      } else {
        tmpCoord = coord === p[0][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];
      }

      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
        oppositeCoord = tmpCoord;
        break;
      }
    }

    return oppositeCoord;
  }
});
chart['spline'] = (0, _extend.extend)({}, lineSeries, {
  _calculateBezierPoints: function _calculateBezierPoints(src, rotated) {
    var bezierPoints = [];
    var pointsCopy = src;

    var checkExtremum = function checkExtremum(otherPointCoord, pointCoord, controlCoord) {
      return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord;
    };

    if (pointsCopy.length !== 1) {
      pointsCopy.forEach(function (curPoint, i) {
        var leftControlX;
        var leftControlY;
        var rightControlX;
        var rightControlY;
        var prevPoint = pointsCopy[i - 1];
        var nextPoint = pointsCopy[i + 1];
        var x1;
        var x2;
        var y1;
        var y2;
        var lambda = 0.5;
        var a;
        var b;
        var c;
        var xc;
        var yc;
        var shift;

        if (!i || i === pointsCopy.length - 1) {
          bezierPoints.push(curPoint, curPoint);
          return;
        }

        var xCur = curPoint.x;
        var yCur = curPoint.y;
        x1 = prevPoint.x;
        x2 = nextPoint.x;
        y1 = prevPoint.y;
        y2 = nextPoint.y; // check for extremum

        var curIsExtremum = !!(!rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));

        if (curIsExtremum) {
          if (!rotated) {
            rightControlY = leftControlY = yCur;
            rightControlX = (xCur + nextPoint.x) / 2;
            leftControlX = (xCur + prevPoint.x) / 2;
          } else {
            rightControlX = leftControlX = xCur;
            rightControlY = (yCur + nextPoint.y) / 2;
            leftControlY = (yCur + prevPoint.y) / 2;
          }
        } else {
          a = y2 - y1;
          b = x1 - x2;
          c = y1 * x2 - x1 * y2;

          if (!rotated) {
            if (!b) {
              bezierPoints.push(curPoint, curPoint, curPoint);
              return;
            }

            xc = xCur;
            yc = -1 * (a * xc + c) / b;
            shift = yc - yCur;
            y1 -= shift;
            y2 -= shift;
          } else {
            if (!a) {
              bezierPoints.push(curPoint, curPoint, curPoint);
              return;
            }

            yc = yCur;
            xc = -1 * (b * yc + c) / a;
            shift = xc - xCur;
            x1 -= shift;
            x2 -= shift;
          }

          rightControlX = (xCur + lambda * x2) / (1 + lambda);
          rightControlY = (yCur + lambda * y2) / (1 + lambda);
          leftControlX = (xCur + lambda * x1) / (1 + lambda);
          leftControlY = (yCur + lambda * y1) / (1 + lambda);
        } // check control points for extremum


        if (!rotated) {
          leftControlY = checkExtremum(prevPoint.y, yCur, leftControlY);
          rightControlY = checkExtremum(nextPoint.y, yCur, rightControlY);
        } else {
          leftControlX = checkExtremum(prevPoint.x, xCur, leftControlX);
          rightControlX = checkExtremum(nextPoint.x, xCur, rightControlX);
        }

        var leftPoint = clonePoint(curPoint, leftControlX, leftControlY);
        var rightPoint = clonePoint(curPoint, rightControlX, rightControlY);
        bezierPoints.push(leftPoint, curPoint, rightPoint);
      });
    } else {
      bezierPoints.push(pointsCopy[0]);
    }

    return bezierPoints;
  },
  _prepareSegment: function _prepareSegment(points, rotated) {
    return lineSeries._prepareSegment(this._calculateBezierPoints(points, rotated));
  },
  _createMainElement: function _createMainElement(points, settings) {
    return this._renderer.path(points, 'bezier').attr(settings);
  },
  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {
    var that = this;
    var oppositeCoord = null;
    var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;
    var coordName = !isOpposite ? 'vx' : 'vy';
    var bezierCoordName = !isOpposite ? 'x' : 'y';
    var oppositeCoordName = !isOpposite ? 'vy' : 'vx';
    var bezierOppositeCoordName = !isOpposite ? 'y' : 'x';
    var axis = !isArgument ? that.getArgumentAxis() : that.getValueAxis();
    var visibleArea = axis.getVisibleArea();

    var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);

    var _loop = function _loop(i) {
      var p = nearestPoints[i];

      if (p.length === 1) {
        visibleArea[0] <= p[0][oppositeCoordName] && visibleArea[1] >= p[0][oppositeCoordName] && (oppositeCoord = p[0][oppositeCoordName]);
      } else {
        var ts = obtainCubicBezierTCoef(coord, p[0][coordName], p[1][bezierCoordName], p[2][bezierCoordName], p[3][coordName]);
        ts.forEach(function (t) {
          if (t >= 0 && t <= 1) {
            var tmpCoord = Math.pow(1 - t, 3) * p[0][oppositeCoordName] + 3 * Math.pow(1 - t, 2) * t * p[1][bezierOppositeCoordName] + 3 * (1 - t) * t * t * p[2][bezierOppositeCoordName] + t * t * t * p[3][oppositeCoordName];

            if (visibleArea[0] <= tmpCoord && visibleArea[1] >= tmpCoord) {
              oppositeCoord = tmpCoord;
            }
          }
        });
      }

      if (oppositeCoord !== null) {
        return "break";
      }
    };

    for (var i = 0; i < nearestPoints.length; i++) {
      var _ret = _loop(i);

      if (_ret === "break") break;
    }

    return oppositeCoord;
  },
  _getNearestPoints: function _getNearestPoints(point, nextPoint, bezierPoints) {
    var index = bezierPoints.indexOf(point);
    return [point, bezierPoints[index + 1], bezierPoints[index + 2], nextPoint];
  },
  _getBezierPoints: function _getBezierPoints() {
    return this._segments.length > 0 ? this._segments.reduce(function (a, seg) {
      return a.concat(seg.line);
    }, []) : [];
  }
});
polar.line = (0, _extend.extend)({}, _scatter_series.polar, lineMethods, {
  _sortPoints: function _sortPoints(points) {
    return points;
  },
  _prepareSegment: function _prepareSegment(points, rotated, lastSegment) {
    var preparedPoints = [];
    var centerPoint = this.getValueAxis().getCenter();
    var i;
    lastSegment && this._closeSegment(points);

    if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {
      for (i = 1; i < points.length; i++) {
        preparedPoints = preparedPoints.concat(this._getTangentPoints(points[i], points[i - 1], centerPoint));
      }

      if (!preparedPoints.length) {
        // T174220
        preparedPoints = points;
      }
    } else {
      return lineSeries._prepareSegment.call(this, points);
    }

    return {
      line: preparedPoints
    };
  },
  _getRemainingAngle: function _getRemainingAngle(angle) {
    var normAngle = (0, _utils.normalizeAngle)(angle);
    return angle >= 0 ? 360 - normAngle : -normAngle;
  },
  _closeSegment: function _closeSegment(points) {
    var point;

    if (this._segments.length) {
      point = this._segments[0].line[0];
    } else {
      point = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);
    }

    point = this._modifyReflectedPoint(point, points[points.length - 1]);

    if (point) {
      points.push(point);
    }
  },
  _modifyReflectedPoint: function _modifyReflectedPoint(point, lastPoint) {
    if (lastPoint.angle === point.angle) {
      return undefined;
    }

    if ((0, _utils.normalizeAngle)(round(lastPoint.angle)) === (0, _utils.normalizeAngle)(round(point.angle))) {
      point.angle = lastPoint.angle;
    } else {
      var differenceAngle = lastPoint.angle - point.angle;
      point.angle = lastPoint.angle + this._getRemainingAngle(differenceAngle);
    }

    return point;
  },
  _getTangentPoints: function _getTangentPoints(point, prevPoint, centerPoint) {
    var tangentPoints = [];
    var betweenAngle = Math.round(prevPoint.angle - point.angle);
    var tan = (prevPoint.radius - point.radius) / betweenAngle;
    var i;

    if (betweenAngle === 0) {
      tangentPoints = [prevPoint, point];
    } else if (betweenAngle > 0) {
      for (i = betweenAngle; i >= 0; i--) {
        tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, i));
      }
    } else {
      for (i = 0; i >= betweenAngle; i--) {
        tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, betweenAngle - i));
      }
    }

    return tangentPoints;
  },
  getSeriesPairCoord: function getSeriesPairCoord(params, isArgument) {
    var that = this;
    var argAxis = that.getArgumentAxis();
    var paramName = isArgument ? 'angle' : 'radius';
    var coordParam = params[paramName];
    var centerPoint = argAxis.getCenter();

    var getLengthByCoords = function getLengthByCoords(p1, p2) {
      return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
    };

    var isInsideInterval = function isInsideInterval(prevPoint, point, _ref) {
      var x = _ref.x,
          y = _ref.y;
      return getLengthByCoords({
        x: x,
        y: y
      }, centerPoint) <= argAxis.getRadius() && min(prevPoint.x, point.x) <= x && max(prevPoint.x, point.x) >= x && min(prevPoint.y, point.y) <= y && max(prevPoint.y, point.y) >= y;
    };

    var coords;
    var neighborPoints = that.getNeighborPoints(coordParam, paramName);

    if (neighborPoints.length === 1) {
      coords = neighborPoints[0];
    } else if (neighborPoints.length > 1) {
      var prevPoint = neighborPoints[0];
      var point = neighborPoints[1];

      if (that.argumentAxisType !== DISCRETE && that.valueAxisType !== DISCRETE) {
        var tan;
        var stepAngle;

        if (isArgument) {
          tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);
          stepAngle = coordParam - point.angle;
        } else {
          tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);
          stepAngle = (coordParam - point.radius) / tan;
        }

        coords = getTangentPoint(point, prevPoint, centerPoint, tan, stepAngle);
      } else {
        if (isArgument) {
          var cosSin = (0, _utils.getCosAndSin)(-coordParam);
          var k1 = (point.y - prevPoint.y) / (point.x - prevPoint.x);
          var b1 = prevPoint.y - prevPoint.x * k1;
          var k2 = cosSin.sin / cosSin.cos;
          var b2 = centerPoint.y - k2 * centerPoint.x;
          var x = (b2 - b1) / (k1 - k2);
          var y = k1 * x + b1;

          if (isInsideInterval(prevPoint, point, {
            x: x,
            y: y
          })) {
            var quarter = abs((0, _math.trunc)((360 + coordParam) / 90) % 4);

            if (quarter === 0 && x >= centerPoint.x && y <= centerPoint.y || quarter === 1 && x <= centerPoint.x && y <= centerPoint.y || quarter === 2 && x <= centerPoint.x && y >= centerPoint.y || quarter === 3 && x >= centerPoint.x && y >= centerPoint.y) {
              coords = {
                x: x,
                y: y
              };
            }
          }
        } else {
          var k = (point.y - prevPoint.y) / (point.x - prevPoint.x);
          var y0 = prevPoint.y - prevPoint.x * k;
          var a = 1 + k * k;
          var b = -2 * centerPoint.x + 2 * k * y0 - 2 * k * centerPoint.y;
          var c = -pow(coordParam, 2) + pow(y0 - centerPoint.y, 2) + pow(centerPoint.x, 2);
          var d = b * b - 4 * a * c;

          if (d >= 0) {
            var x1 = (-b - sqrt(d)) / (2 * a);
            var x2 = (-b + sqrt(d)) / (2 * a);
            var y1 = k * x1 + y0;
            var y2 = k * x2 + y0;
            coords = isInsideInterval(prevPoint, point, {
              x: x1,
              y: y1
            }) ? {
              x: x1,
              y: y1
            } : isInsideInterval(prevPoint, point, {
              x: x2,
              y: y2
            }) ? {
              x: x2,
              y: y2
            } : undefined;
          }
        }
      }
    }

    return coords;
  },
  getNeighborPoints: function getNeighborPoints(param, paramName) {
    var points = this.getPoints();
    var neighborPoints = [];

    if (this.getOptions().closed) {
      points = (0, _extend.extend)(true, [], points);
      var lastPoint = points[points.length - 1];
      var firstPointCopy = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);
      var lastPointCopy = clonePoint(lastPoint, lastPoint.x, lastPoint.y, lastPoint.angle);

      var rearwardRefPoint = this._modifyReflectedPoint(firstPointCopy, lastPoint);

      var forwardRefPoint = this._modifyReflectedPoint(lastPointCopy, points[0]);

      if (forwardRefPoint) {
        points.unshift(forwardRefPoint);
      }

      if (rearwardRefPoint) {
        points.push(rearwardRefPoint);
      }
    }

    for (var i = 1; i < points.length; i++) {
      if (points[i - 1][paramName] === param) {
        neighborPoints.push(points[i - 1]);
      } else if (points[i][paramName] === param) {
        neighborPoints.push(points[i]);
      } else if (points[i][paramName] > param && points[i - 1][paramName] < param || points[i - 1][paramName] > param && points[i][paramName] < param) {
        neighborPoints.push(points[i - 1]);
        neighborPoints.push(points[i]);
      }

      if (neighborPoints.length > 0) {
        break;
      }
    }

    return neighborPoints;
  }
});

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _utils = __webpack_require__(14);

var _default = {
  logarithmic: 'logarithmic',
  discrete: 'discrete',
  numeric: 'numeric',
  left: 'left',
  right: 'right',
  top: 'top',
  bottom: 'bottom',
  center: 'center',
  horizontal: 'horizontal',
  vertical: 'vertical',
  convertTicksToValues: function convertTicksToValues(ticks) {
    return (0, _utils.map)(ticks || [], function (item) {
      return item.value;
    });
  },
  validateOverlappingMode: function validateOverlappingMode(mode) {
    return mode === 'ignore' || mode === 'none' ? mode : 'hide';
  },
  getTicksCountInRange: function getTicksCountInRange(ticks, valueKey, range) {
    var i = 1;

    if (ticks.length > 1) {
      for (; i < ticks.length; i++) {
        if (Math.abs(ticks[i].coords[valueKey] - ticks[0].coords[valueKey]) >= range) {
          break;
        }
      }
    }

    return i;
  },
  areLabelsOverlap: function areLabelsOverlap(bBox1, bBox2, spacing, alignment) {
    var horizontalInverted = bBox1.x > bBox2.x;
    var verticalInverted = bBox1.y > bBox2.y;
    var x1 = bBox1.x;
    var x2 = bBox2.x;
    var width1 = bBox1.width;
    var width2 = bBox2.width;

    if (alignment === 'left') {
      x1 += width1 / 2;
      x2 += width2 / 2;
    } else if (alignment === 'right') {
      x1 -= width1 / 2;
      x2 -= width2 / 2;
    }

    var hasHorizontalOverlapping = horizontalInverted ? x2 + width2 + spacing > x1 : x1 + width1 + spacing > x2;
    var hasVerticalOverlapping = verticalInverted ? bBox2.y + bBox2.height > bBox1.y : bBox1.y + bBox1.height > bBox2.y;
    return hasHorizontalOverlapping && hasVerticalOverlapping;
  }
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.plugins = exports.createAnnotations = void 0;

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _type = __webpack_require__(1);

var _tooltip = __webpack_require__(140);

var _extend = __webpack_require__(0);

var _utils = __webpack_require__(14);

var _plaque = __webpack_require__(592);

var _pointer = _interopRequireDefault(__webpack_require__(25));

var _drag = __webpack_require__(78);

var _index = __webpack_require__(8);

var _events_engine = _interopRequireDefault(__webpack_require__(5));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getDocument = _dom_adapter.default.getDocument;
var EVENT_NS = 'annotations';
var DOT_EVENT_NS = '.' + EVENT_NS;
var POINTER_ACTION = (0, _index.addNamespace)([_pointer.default.down, _pointer.default.move], EVENT_NS);
var POINTER_UP_EVENT_NAME = (0, _index.addNamespace)(_pointer.default.up, EVENT_NS);
var DRAG_START_EVENT_NAME = _drag.start + DOT_EVENT_NS;
var DRAG_EVENT_NAME = _drag.move + DOT_EVENT_NS;
var DRAG_END_EVENT_NAME = _drag.end + DOT_EVENT_NS;

function coreAnnotation(options, contentTemplate) {
  return {
    draw: function draw(widget, group) {
      var _this = this;

      var annotationGroup = widget._renderer.g().append(group).css((0, _utils.patchFontOptions)(options.font));

      if (this.plaque) {
        this.plaque.clear();
      }

      this.plaque = new _plaque.Plaque((0, _extend.extend)(true, {}, options, {
        cornerRadius: (options.border || {}).cornerRadius
      }), widget, annotationGroup, contentTemplate, widget._isAnnotationBounded(options));
      this.plaque.draw(widget._getAnnotationCoords(this));

      if (options.allowDragging) {
        annotationGroup.on(DRAG_START_EVENT_NAME, {
          immediate: true
        }, function (e) {
          _this._dragOffsetX = _this.plaque.x - e.pageX;
          _this._dragOffsetY = _this.plaque.y - e.pageY;
        }).on(DRAG_EVENT_NAME, function (e) {
          _this.plaque.move(e.pageX + _this._dragOffsetX, e.pageY + _this._dragOffsetY);
        }).on(DRAG_END_EVENT_NAME, function (e) {
          _this.offsetX = (_this.offsetX || 0) + e.offset.x;
          _this.offsetY = (_this.offsetY || 0) + e.offset.y;
        });
      }
    },
    hitTest: function hitTest(x, y) {
      return this.plaque.hitTest(x, y);
    },
    showTooltip: function showTooltip(tooltip, _ref) {
      var x = _ref.x,
          y = _ref.y;
      var that = this;
      var options = that.options;

      if (tooltip.annotation !== that) {
        tooltip.setTemplate(options.tooltipTemplate);

        var callback = function callback(result) {
          result && (tooltip.annotation = that);
        };

        callback(tooltip.show(options, {
          x: x,
          y: y
        }, {
          target: options
        }, options.customizeTooltip, callback));
      } else {
        tooltip.move(x, y);
      }
    }
  };
}

function getTemplateFunction(options, widget) {
  var template;

  if (options.type === 'text') {
    template = function template(item, groupElement) {
      var text = widget._renderer.text(item.text).attr({
        'class': item.cssClass
      }).append({
        element: groupElement
      });

      if (item.width > 0 || item.height > 0) {
        text.setMaxSize(item.width, item.height, {
          wordWrap: item.wordWrap,
          textOverflow: item.textOverflow
        });
      }
    };
  } else if (options.type === 'image') {
    template = function template(item, groupElement) {
      var _ref2 = item.image || {},
          width = _ref2.width,
          height = _ref2.height,
          url = _ref2.url,
          location = _ref2.location;

      var outerWidth = item.width,
          outerHeight = item.height;
      var imageWidth = outerWidth > 0 ? Math.min(width, outerWidth) : width;
      var imageHeight = outerHeight > 0 ? Math.min(height, outerHeight) : height;

      widget._renderer.image(0, 0, imageWidth, imageHeight, url, location || 'center').append({
        element: groupElement
      });
    };
  } else if (options.type === 'custom') {
    template = options.template;
  }

  return template;
}

function getImageObject(image) {
  return typeof image === 'string' ? {
    url: image
  } : image;
}

var createAnnotations = function createAnnotations(widget, items) {
  var commonAnnotationSettings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var customizeAnnotation = arguments.length > 3 ? arguments[3] : undefined;
  var pullOptions = arguments.length > 4 ? arguments[4] : undefined;
  var commonImageOptions = getImageObject(commonAnnotationSettings.image);
  return items.reduce(function (arr, item) {
    var currentImageOptions = getImageObject(item.image);
    var customizedItem = (0, _type.isFunction)(customizeAnnotation) ? customizeAnnotation(item) : {};

    if (customizedItem) {
      customizedItem.image = getImageObject(customizedItem.image); // T881143
    }

    var options = (0, _extend.extend)(true, {}, commonAnnotationSettings, item, {
      image: commonImageOptions
    }, {
      image: currentImageOptions
    }, customizedItem);
    var templateFunction = getTemplateFunction(options, widget);
    var annotation = templateFunction && (0, _extend.extend)(true, pullOptions(options), coreAnnotation(options, widget._getTemplate(templateFunction)));
    annotation && arr.push(annotation);
    return arr;
  }, []);
};

exports.createAnnotations = createAnnotations;
var chartPlugin = {
  name: 'annotations_chart',
  init: function init() {},
  dispose: function dispose() {},
  members: {
    _getAnnotationCoords: function _getAnnotationCoords(annotation) {
      var _axis, _axis2;

      var coords = {
        offsetX: annotation.offsetX,
        offsetY: annotation.offsetY
      };
      var argCoordName = this._options.silent('rotated') ? 'y' : 'x';
      var valCoordName = this._options.silent('rotated') ? 'x' : 'y';
      var argAxis = this.getArgumentAxis();
      var argument = argAxis.validateUnit(annotation.argument);
      var axis = this.getValueAxis(annotation.axis);
      var series;
      var pane = (_axis = axis) === null || _axis === void 0 ? void 0 : _axis.pane;

      if (annotation.series) {
        var _series;

        series = this.series.filter(function (s) {
          return s.name === annotation.series;
        })[0];
        axis = (_series = series) === null || _series === void 0 ? void 0 : _series.getValueAxis();
        (0, _type.isDefined)(axis) && (pane = axis.pane);
      }

      if ((0, _type.isDefined)(argument)) {
        if (series) {
          var center = series.getPointCenterByArg(argument);
          center && (coords[argCoordName] = center[argCoordName]);
        } else {
          coords[argCoordName] = argAxis.getTranslator().translate(argument);
        }

        !(0, _type.isDefined)(pane) && (pane = argAxis.pane);
      }

      var value = (_axis2 = axis) === null || _axis2 === void 0 ? void 0 : _axis2.validateUnit(annotation.value);

      if ((0, _type.isDefined)(value)) {
        var _axis3;

        coords[valCoordName] = (_axis3 = axis) === null || _axis3 === void 0 ? void 0 : _axis3.getTranslator().translate(value);
        !(0, _type.isDefined)(pane) && (0, _type.isDefined)(axis) && (pane = axis.pane);
      }

      coords.canvas = this._getCanvasForPane(pane);

      if ((0, _type.isDefined)(coords[argCoordName]) && !(0, _type.isDefined)(value)) {
        var _series2;

        if (!(0, _type.isDefined)(axis) && !(0, _type.isDefined)(series)) {
          coords[valCoordName] = argAxis.getAxisPosition();
        } else if ((0, _type.isDefined)(axis) && !(0, _type.isDefined)(series)) {
          coords[valCoordName] = this._argumentAxes.filter(function (a) {
            return a.pane === axis.pane;
          })[0].getAxisPosition();
        } else if ((_series2 = series) !== null && _series2 !== void 0 && _series2.checkSeriesViewportCoord(argAxis, coords[argCoordName])) {
          coords[valCoordName] = series.getSeriesPairCoord(coords[argCoordName], true);
        }
      }

      if (!(0, _type.isDefined)(argument) && (0, _type.isDefined)(coords[valCoordName])) {
        if ((0, _type.isDefined)(axis) && !(0, _type.isDefined)(series)) {
          coords[argCoordName] = axis.getAxisPosition();
        } else if ((0, _type.isDefined)(series)) {
          if (series.checkSeriesViewportCoord(axis, coords[valCoordName])) {
            coords[argCoordName] = series.getSeriesPairCoord(coords[valCoordName], false);
          }
        }
      }

      return coords;
    },
    _annotationsPointerEventHandler: function _annotationsPointerEventHandler(event) {
      if (this._disposed) {
        return;
      }

      var originalEvent = event.originalEvent || {};
      var touch = originalEvent.touches && originalEvent.touches[0] || {};

      var rootOffset = this._renderer.getRootOffset();

      var coords = {
        x: touch.pageX || originalEvent.pageX || event.pageX,
        y: touch.pageY || originalEvent.pageY || event.pageY
      };

      var annotation = this._annotations.items.filter(function (a) {
        return a.hitTest(coords.x - rootOffset.left, coords.y - rootOffset.top);
      })[0];

      if (!annotation || !annotation.options.tooltipEnabled) {
        this._annotations.hideTooltip();

        return;
      }

      this._clear();

      if (annotation.options.allowDragging && event.type === _pointer.default.down) {
        this._annotations._hideToolTipForDrag = true;
      }

      if (!this._annotations._hideToolTipForDrag) {
        annotation.showTooltip(this._annotations.tooltip, coords);
        event.stopPropagation();
      }
    },
    _isAnnotationBounded: function _isAnnotationBounded(options) {
      return (0, _type.isDefined)(options.value) || (0, _type.isDefined)(options.argument);
    },
    _pullOptions: function _pullOptions(options) {
      return {
        type: options.type,
        name: options.name,
        x: options.x,
        y: options.y,
        value: options.value,
        argument: options.argument,
        axis: options.axis,
        series: options.series,
        options: options,
        offsetX: options.offsetX,
        offsetY: options.offsetY
      };
    },
    _forceAnnotationRender: function _forceAnnotationRender() {
      this._change(['FORCE_RENDER']);
    },
    _clear: function _clear() {
      this.hideTooltip();
      this.clearHover();
    }
  }
};
var polarChartPlugin = {
  name: 'annotations_polar_chart',
  init: function init() {},
  dispose: function dispose() {},
  members: {
    _getAnnotationCoords: function _getAnnotationCoords(annotation) {
      var coords = {
        offsetX: annotation.offsetX,
        offsetY: annotation.offsetY,
        canvas: this._calcCanvas()
      };
      var argAxis = this.getArgumentAxis();
      var argument = argAxis.validateUnit(annotation.argument);
      var value = this.getValueAxis().validateUnit(annotation.value);
      var radius = annotation.radius;
      var angle = annotation.angle;
      var pointCoords;
      var series;

      if (annotation.series) {
        series = this.series.filter(function (s) {
          return s.name === annotation.series;
        })[0];
      }

      (0, _extend.extend)(true, coords, this.getXYFromPolar(angle, radius, argument, value));

      if ((0, _type.isDefined)(series)) {
        if ((0, _type.isDefined)(coords.angle) && !(0, _type.isDefined)(value) && !(0, _type.isDefined)(radius)) {
          if (!(0, _type.isDefined)(argument)) {
            argument = argAxis.getTranslator().from(isFinite(angle) ? this.getActualAngle(angle) : coords.angle);
          }

          pointCoords = series.getSeriesPairCoord({
            argument: argument,
            angle: -coords.angle
          }, true);
        } else if ((0, _type.isDefined)(coords.radius) && !(0, _type.isDefined)(argument) && !(0, _type.isDefined)(angle)) {
          pointCoords = series.getSeriesPairCoord({
            radius: coords.radius
          }, false);
        }

        if ((0, _type.isDefined)(pointCoords)) {
          coords.x = pointCoords.x;
          coords.y = pointCoords.y;
        }
      }

      if (annotation.series && !(0, _type.isDefined)(pointCoords)) {
        coords.x = coords.y = undefined;
      }

      return coords;
    },
    _annotationsPointerEventHandler: chartPlugin.members._annotationsPointerEventHandler,
    _isAnnotationBounded: chartPlugin.members._isAnnotationBounded,
    _pullOptions: function _pullOptions(options) {
      var polarOptions = (0, _extend.extend)({}, {
        radius: options.radius,
        angle: options.angle
      }, chartPlugin.members._pullOptions(options));
      delete polarOptions.axis;
      return polarOptions;
    },
    _forceAnnotationRender: chartPlugin.members._forceAnnotationRender,
    _clear: chartPlugin.members._clear
  }
};
var vectorMapPlugin = {
  name: 'annotations_vector_map',
  init: function init() {},
  dispose: function dispose() {
    this._annotations._offTracker();

    this._annotations._offTracker = null;
  },
  members: {
    _getAnnotationCoords: function _getAnnotationCoords(annotation) {
      var coords = {
        offsetX: annotation.offsetX,
        offsetY: annotation.offsetY
      };
      coords.canvas = this._projection.getCanvas();

      if (annotation.coordinates) {
        var data = this._projection.toScreenPoint(annotation.coordinates);

        coords.x = data[0];
        coords.y = data[1];
      }

      return coords;
    },
    _annotationsPointerEventHandler: chartPlugin.members._annotationsPointerEventHandler,
    _isAnnotationBounded: function _isAnnotationBounded(options) {
      return (0, _type.isDefined)(options.coordinates);
    },
    _pullOptions: function _pullOptions(options) {
      var vectorMapOptions = (0, _extend.extend)({}, {
        coordinates: options.coordinates
      }, chartPlugin.members._pullOptions(options));
      delete vectorMapOptions.axis;
      delete vectorMapOptions.series;
      delete vectorMapOptions.argument;
      delete vectorMapOptions.value;
      return vectorMapOptions;
    },
    _forceAnnotationRender: function _forceAnnotationRender() {
      this._change(['EXTRA_ELEMENTS']);
    },
    _getAnnotationStyles: function _getAnnotationStyles() {
      return {
        'text-anchor': 'start'
      };
    },
    _clear: function _clear() {}
  },
  extenders: {
    _prepareExtraElements: function _prepareExtraElements() {
      var that = this;

      var renderElements = function renderElements() {
        that._renderExtraElements();
      };

      that._annotations._offTracker = that._tracker.on({
        'move': renderElements,
        'zoom': renderElements,
        'end': renderElements
      });
    }
  }
};
var pieChartPlugin = {
  name: 'annotations_pie_chart',
  init: function init() {},
  dispose: function dispose() {},
  members: {
    _getAnnotationCoords: function _getAnnotationCoords(annotation) {
      var series;
      var coords = {
        offsetX: annotation.offsetX,
        offsetY: annotation.offsetY,
        canvas: this._canvas
      };

      if (annotation.argument) {
        if (annotation.series) {
          series = this.getSeriesByName(annotation.series);
        } else {
          series = this.series[0];
        }

        var argument = series.getPointsByArg(annotation.argument)[0];

        var _argument$getAnnotati = argument.getAnnotationCoords(annotation.location),
            x = _argument$getAnnotati.x,
            y = _argument$getAnnotati.y;

        coords.x = x;
        coords.y = y;
      }

      return coords;
    },
    _isAnnotationBounded: function _isAnnotationBounded(options) {
      return options.argument;
    },
    _annotationsPointerEventHandler: chartPlugin.members._annotationsPointerEventHandler,
    _pullOptions: function _pullOptions(options) {
      var pieChartOptions = (0, _extend.extend)({}, {
        location: options.location
      }, chartPlugin.members._pullOptions(options));
      delete pieChartOptions.axis;
      return pieChartOptions;
    },
    _clear: chartPlugin.members._clear,
    _forceAnnotationRender: chartPlugin.members._forceAnnotationRender
  }
};
var corePlugin = {
  name: 'annotations_core',
  init: function init() {
    this._annotations = {
      items: [],
      _hideToolTipForDrag: false,
      tooltip: new _tooltip.Tooltip({
        cssClass: "".concat(this._rootClassPrefix, "-annotation-tooltip"),
        eventTrigger: this._eventTrigger,
        widgetRoot: this.element(),
        widget: this
      }),
      hideTooltip: function hideTooltip() {
        this.tooltip.annotation = null;
        this.tooltip.hide();
      },
      clearItems: function clearItems() {
        this.items.forEach(function (i) {
          return i.plaque.clear();
        });
        this.items = [];
      }
    };

    this._annotations.tooltip.setRendererOptions(this._getRendererOptions());
  },
  dispose: function dispose() {
    this._annotationsGroup.linkRemove().linkOff();

    _events_engine.default.off(getDocument(), DOT_EVENT_NS);

    this._annotationsGroup.off(DOT_EVENT_NS);

    this._annotations.tooltip && this._annotations.tooltip.dispose();
  },
  extenders: {
    _createHtmlStructure: function _createHtmlStructure() {
      var _this2 = this;

      this._annotationsGroup = this._renderer.g().attr({
        'class': "".concat(this._rootClassPrefix, "-annotations")
      }).css(this._getAnnotationStyles()).linkOn(this._renderer.root, 'annotations').linkAppend();

      _events_engine.default.on(getDocument(), POINTER_ACTION, function () {
        return _this2._annotations.hideTooltip();
      });

      _events_engine.default.on(getDocument(), POINTER_UP_EVENT_NAME, function (event) {
        _this2._annotations._hideToolTipForDrag = false;

        _this2._annotationsPointerEventHandler(event);
      });

      this._annotationsGroup.on(POINTER_ACTION, this._annotationsPointerEventHandler.bind(this));
    },
    _renderExtraElements: function _renderExtraElements() {
      var _this3 = this;

      this._annotationsGroup.clear();

      this._annotations.items.forEach(function (item) {
        return item.draw(_this3, _this3._annotationsGroup);
      });
    },
    _stopCurrentHandling: function _stopCurrentHandling() {
      this._annotations.hideTooltip();
    }
  },
  members: {
    _buildAnnotations: function _buildAnnotations() {
      this._annotations.clearItems();

      var items = this._getOption('annotations', true);

      if (!(items !== null && items !== void 0 && items.length)) {
        return;
      }

      this._annotations.items = createAnnotations(this, items, this._getOption('commonAnnotationSettings'), this._getOption('customizeAnnotation', true), this._pullOptions);
    },
    _setAnnotationTooltipOptions: function _setAnnotationTooltipOptions() {
      var tooltipOptions = (0, _extend.extend)({}, this._getOption('tooltip'));
      tooltipOptions.contentTemplate = tooltipOptions.customizeTooltip = undefined;

      this._annotations.tooltip.update(tooltipOptions);
    },
    _getAnnotationCoords: function _getAnnotationCoords() {
      return {};
    },
    _pullOptions: function _pullOptions() {
      return {};
    },
    _getAnnotationStyles: function _getAnnotationStyles() {
      return {};
    }
  },
  customize: function customize(constructor) {
    constructor.addChange({
      code: 'ANNOTATIONITEMS',
      handler: function handler() {
        this._requestChange(['ANNOTATIONS']);
      },
      isOptionChange: true,
      option: 'annotations'
    });
    constructor.addChange({
      code: 'ANNOTATIONSSETTINGS',
      handler: function handler() {
        this._requestChange(['ANNOTATIONS']);
      },
      isOptionChange: true,
      option: 'commonAnnotationSettings'
    });
    constructor.addChange({
      code: 'ANNOTATIONS',
      handler: function handler() {
        this._buildAnnotations();

        this._setAnnotationTooltipOptions();

        this._forceAnnotationRender();
      },
      isThemeDependent: true,
      isOptionChange: true
    });
  },
  fontFields: ['commonAnnotationSettings.font']
};
var plugins = {
  core: corePlugin,
  chart: chartPlugin,
  polarChart: polarChartPlugin,
  vectorMap: vectorMapPlugin,
  pieChart: pieChartPlugin
};
exports.plugins = plugins;

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.formatValue = exports.consts = exports.utils = exports.HEIGHT_COMPACT_MODE = void 0;

var _smart_formatter = __webpack_require__(594);

var _type = __webpack_require__(1);

var HEIGHT_COMPACT_MODE = 24;
exports.HEIGHT_COMPACT_MODE = HEIGHT_COMPACT_MODE;
var POINTER_SIZE = 4;
var EMPTY_SLIDER_MARKER_TEXT = '. . .';
var utils = {
  trackerSettings: {
    fill: 'grey',
    stroke: 'grey',
    opacity: 0.0001
  },
  animationSettings: {
    duration: 250
  }
};
exports.utils = utils;
var consts = {
  emptySliderMarkerText: EMPTY_SLIDER_MARKER_TEXT,
  pointerSize: POINTER_SIZE
};
exports.consts = consts;

var formatValue = function formatValue(value, formatOptions, tickIntervalsInfo, valueType, type, logarithmBase) {
  var formatObject = {
    value: value,
    valueText: (0, _smart_formatter.smartFormatter)(value, {
      labelOptions: formatOptions,
      ticks: tickIntervalsInfo ? tickIntervalsInfo.ticks : [],
      tickInterval: tickIntervalsInfo ? tickIntervalsInfo.tickInterval : undefined,
      dataType: valueType,
      type: type,
      logarithmBase: logarithmBase
    })
  };
  return String((0, _type.isFunction)(formatOptions.customizeText) ? formatOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText);
};

exports.formatValue = formatValue;

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getColorizer = getColorizer;
exports.addColorizer = addColorizer;
exports.setDefaultColorizer = setDefaultColorizer;
exports.createColorCodeGetter = createColorCodeGetter;

var _utils = __webpack_require__(14);

var _common = __webpack_require__(4);

var colorizers = {};
var defaultColorizerName;

function wrapLeafColorGetter(getter) {
  return function (node) {
    return !node.isNode() ? getter(node) : undefined;
  };
}

function wrapGroupColorGetter(getter) {
  return function (node) {
    var parent = !node.isNode() && node.parent;
    return parent ? parent._groupColor = parent._groupColor || getter(parent) : undefined;
  };
}

function getColorizer(options, themeManager, root) {
  var type = (0, _utils.normalizeEnum)(options.type || defaultColorizerName);
  var colorizer = colorizers[type] && colorizers[type](options, themeManager, root);
  return colorizer ? (options.colorizeGroups ? wrapGroupColorGetter : wrapLeafColorGetter)(colorizer) : _common.noop;
}

function addColorizer(name, colorizer) {
  colorizers[name] = colorizer;
}

function setDefaultColorizer(name) {
  defaultColorizerName = name;
}

function getValueAsColorCode(node) {
  return node.value;
}

function createColorCode(colorCodeField) {
  return function (node) {
    return Number(node.data[colorCodeField]);
  };
}

function createColorCodeGetter(options) {
  return options.colorCodeField ? createColorCode(options.colorCodeField) : getValueAsColorCode;
}

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _element_data = __webpack_require__(43);

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _window = __webpack_require__(7);

var _type = __webpack_require__(1);

var _style = __webpack_require__(92);

var _size = __webpack_require__(195);

var _html_parser = __webpack_require__(249);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var window = (0, _window.getWindow)();
var renderer;

var initRender = function initRender(selector, context) {
  if (!selector) {
    this.length = 0;
    return this;
  }

  if (typeof selector === 'string') {
    if (selector === 'body') {
      this[0] = context ? context.body : _dom_adapter.default.getBody();
      this.length = 1;
      return this;
    }

    context = context || _dom_adapter.default.getDocument();

    if (selector[0] === '<') {
      this[0] = _dom_adapter.default.createElement(selector.slice(1, -1), context);
      this.length = 1;
      return this;
    }

    [].push.apply(this, _dom_adapter.default.querySelectorAll(context, selector));
    return this;
  } else if (_dom_adapter.default.isNode(selector) || (0, _type.isWindow)(selector)) {
    this[0] = selector;
    this.length = 1;
    return this;
  } else if (Array.isArray(selector)) {
    [].push.apply(this, selector);
    return this;
  }

  return renderer(selector.toArray ? selector.toArray() : [selector]);
};

renderer = function renderer(selector, context) {
  return new initRender(selector, context);
};

renderer.fn = {
  dxRenderer: true
};
initRender.prototype = renderer.fn;

var repeatMethod = function repeatMethod(methodName, args) {
  for (var i = 0; i < this.length; i++) {
    var item = renderer(this[i]);
    item[methodName].apply(item, args);
  }

  return this;
};

var setAttributeValue = function setAttributeValue(element, attrName, value) {
  if (value !== undefined && value !== null) {
    _dom_adapter.default.setAttribute(element, attrName, value);
  } else {
    _dom_adapter.default.removeAttribute(element, attrName);
  }
};

initRender.prototype.show = function () {
  return this.toggle(true);
};

initRender.prototype.hide = function () {
  return this.toggle(false);
};

initRender.prototype.toggle = function (value) {
  if (this[0]) {
    this.toggleClass('dx-state-invisible', !value);
  }

  return this;
};

initRender.prototype.attr = function (attrName, value) {
  if (this.length > 1 && arguments.length > 1) return repeatMethod.call(this, 'attr', arguments);

  if (!this[0]) {
    if ((0, _type.isObject)(attrName) || value !== undefined) {
      return this;
    } else {
      return undefined;
    }
  }

  if (!this[0].getAttribute) {
    return this.prop(attrName, value);
  }

  if (typeof attrName === 'string' && arguments.length === 1) {
    var result = this[0].getAttribute(attrName);
    return result == null ? undefined : result;
  } else if ((0, _type.isPlainObject)(attrName)) {
    for (var key in attrName) {
      this.attr(key, attrName[key]);
    }
  } else {
    setAttributeValue(this[0], attrName, value);
  }

  return this;
};

initRender.prototype.removeAttr = function (attrName) {
  this[0] && _dom_adapter.default.removeAttribute(this[0], attrName);
  return this;
};

initRender.prototype.prop = function (propName, value) {
  if (!this[0]) return this;

  if (typeof propName === 'string' && arguments.length === 1) {
    return this[0][propName];
  } else if ((0, _type.isPlainObject)(propName)) {
    for (var key in propName) {
      this.prop(key, propName[key]);
    }
  } else {
    _dom_adapter.default.setProperty(this[0], propName, value);
  }

  return this;
};

initRender.prototype.addClass = function (className) {
  return this.toggleClass(className, true);
};

initRender.prototype.removeClass = function (className) {
  return this.toggleClass(className, false);
};

initRender.prototype.hasClass = function (className) {
  if (!this[0] || this[0].className === undefined) return false;
  var classNames = className.split(' ');

  for (var i = 0; i < classNames.length; i++) {
    if (this[0].classList) {
      if (this[0].classList.contains(classNames[i])) return true;
    } else {
      // IE9
      var _className = (0, _type.isString)(this[0].className) ? this[0].className : _dom_adapter.default.getAttribute(this[0], 'class');

      if ((_className || '').split(' ').indexOf(classNames[i]) >= 0) return true;
    }
  }

  return false;
};

initRender.prototype.toggleClass = function (className, value) {
  if (this.length > 1) {
    return repeatMethod.call(this, 'toggleClass', arguments);
  }

  if (!this[0] || !className) return this;
  value = value === undefined ? !this.hasClass(className) : value;
  var classNames = className.split(' ');

  for (var i = 0; i < classNames.length; i++) {
    _dom_adapter.default.setClass(this[0], classNames[i], value);
  }

  return this;
};

['width', 'height', 'outerWidth', 'outerHeight', 'innerWidth', 'innerHeight'].forEach(function (methodName) {
  initRender.prototype[methodName] = function (value) {
    var hasValueArg = arguments.length > 0;
    var isValueBool = typeof value === 'boolean';
    var element = this[0];

    if (hasValueArg && this.length > 1) {
      return repeatMethod.call(this, methodName, arguments);
    }

    if (element) {
      if (!hasValueArg) {
        return (0, _size.elementSize)(element, methodName);
      }

      if (isValueBool) {
        return (0, _size.elementSize)(element, methodName, value);
      }

      if ((0, _type.isDefined)(value)) {
        (0, _size.elementSize)(element, methodName, value);
      }

      return this;
    }

    return null;
  };
});

initRender.prototype.html = function (value) {
  if (!arguments.length) {
    return this[0].innerHTML;
  }

  this.empty();

  if (typeof value === 'string' && !(0, _html_parser.isTablePart)(value) || typeof value === 'number') {
    this[0].innerHTML = value;
    return this;
  }

  return this.append((0, _html_parser.parseHTML)(value));
};

var appendElements = function appendElements(element, nextSibling) {
  if (!this[0] || !element) return;

  if (typeof element === 'string') {
    element = (0, _html_parser.parseHTML)(element);
  } else if (element.nodeType) {
    element = [element];
  } else if ((0, _type.isNumeric)(element)) {
    element = [_dom_adapter.default.createTextNode(element)];
  }

  for (var i = 0; i < element.length; i++) {
    var item = element[i];
    var container = this[0];
    var wrapTR = container.tagName === 'TABLE' && item.tagName === 'TR';

    if (wrapTR && container.tBodies && container.tBodies.length) {
      container = container.tBodies[0];
    }

    _dom_adapter.default.insertElement(container, item.nodeType ? item : item[0], nextSibling);
  }
};

var setCss = function setCss(name, value) {
  if (!this[0] || !this[0].style) return;

  if (value === null || typeof value === 'number' && isNaN(value)) {
    return;
  }

  name = (0, _style.styleProp)(name);

  for (var i = 0; i < this.length; i++) {
    this[i].style[name] = (0, _style.normalizeStyleProp)(name, value);
  }
};

initRender.prototype.css = function (name, value) {
  if ((0, _type.isString)(name)) {
    if (arguments.length === 2) {
      setCss.call(this, name, value);
    } else {
      if (!this[0]) return;
      name = (0, _style.styleProp)(name);
      var result = window.getComputedStyle(this[0])[name] || this[0].style[name];
      return (0, _type.isNumeric)(result) ? result.toString() : result;
    }
  } else if ((0, _type.isPlainObject)(name)) {
    for (var key in name) {
      setCss.call(this, key, name[key]);
    }
  }

  return this;
};

initRender.prototype.prepend = function (element) {
  if (arguments.length > 1) {
    for (var i = 0; i < arguments.length; i++) {
      this.prepend(arguments[i]);
    }

    return this;
  }

  appendElements.apply(this, [element, this[0].firstChild]);
  return this;
};

initRender.prototype.append = function (element) {
  if (arguments.length > 1) {
    for (var i = 0; i < arguments.length; i++) {
      this.append(arguments[i]);
    }

    return this;
  }

  appendElements.apply(this, [element]);
  return this;
};

initRender.prototype.prependTo = function (element) {
  if (this.length > 1) {
    for (var i = this.length - 1; i >= 0; i--) {
      renderer(this[i]).prependTo(element);
    }

    return this;
  }

  element = renderer(element);

  if (element[0]) {
    _dom_adapter.default.insertElement(element[0], this[0], element[0].firstChild);
  }

  return this;
};

initRender.prototype.appendTo = function (element) {
  if (this.length > 1) {
    return repeatMethod.call(this, 'appendTo', arguments);
  }

  _dom_adapter.default.insertElement(renderer(element)[0], this[0]);

  return this;
};

initRender.prototype.insertBefore = function (element) {
  if (element && element[0]) {
    _dom_adapter.default.insertElement(element[0].parentNode, this[0], element[0]);
  }

  return this;
};

initRender.prototype.insertAfter = function (element) {
  if (element && element[0]) {
    _dom_adapter.default.insertElement(element[0].parentNode, this[0], element[0].nextSibling);
  }

  return this;
};

initRender.prototype.before = function (element) {
  if (this[0]) {
    _dom_adapter.default.insertElement(this[0].parentNode, element[0], this[0]);
  }

  return this;
};

initRender.prototype.after = function (element) {
  if (this[0]) {
    _dom_adapter.default.insertElement(this[0].parentNode, element[0], this[0].nextSibling);
  }

  return this;
};

initRender.prototype.wrap = function (wrapper) {
  if (this[0]) {
    var wrap = renderer(wrapper);
    wrap.insertBefore(this);
    wrap.append(this);
  }

  return this;
};

initRender.prototype.wrapInner = function (wrapper) {
  var contents = this.contents();

  if (contents.length) {
    contents.wrap(wrapper);
  } else {
    this.append(wrapper);
  }

  return this;
};

initRender.prototype.replaceWith = function (element) {
  if (!(element && element[0])) return;
  if (element.is(this)) return this;
  element.insertBefore(this);
  this.remove();
  return element;
};

initRender.prototype.remove = function () {
  if (this.length > 1) {
    return repeatMethod.call(this, 'remove', arguments);
  }

  (0, _element_data.cleanDataRecursive)(this[0], true);

  _dom_adapter.default.removeElement(this[0]);

  return this;
};

initRender.prototype.detach = function () {
  if (this.length > 1) {
    return repeatMethod.call(this, 'detach', arguments);
  }

  _dom_adapter.default.removeElement(this[0]);

  return this;
};

initRender.prototype.empty = function () {
  if (this.length > 1) {
    return repeatMethod.call(this, 'empty', arguments);
  }

  (0, _element_data.cleanDataRecursive)(this[0]);

  _dom_adapter.default.setText(this[0], '');

  return this;
};

initRender.prototype.clone = function () {
  var result = [];

  for (var i = 0; i < this.length; i++) {
    result.push(this[i].cloneNode(true));
  }

  return renderer(result);
};

initRender.prototype.text = function (value) {
  if (!arguments.length) {
    var result = '';

    for (var i = 0; i < this.length; i++) {
      result += this[i] && this[i].textContent || '';
    }

    return result;
  }

  var text = (0, _type.isFunction)(value) ? value() : value;
  (0, _element_data.cleanDataRecursive)(this[0], false);

  _dom_adapter.default.setText(this[0], (0, _type.isDefined)(text) ? text : '');

  return this;
};

initRender.prototype.val = function (value) {
  if (arguments.length === 1) {
    return this.prop('value', (0, _type.isDefined)(value) ? value : '');
  }

  return this.prop('value');
};

initRender.prototype.contents = function () {
  if (!this[0]) return renderer();
  var result = [];
  result.push.apply(result, this[0].childNodes);
  return renderer(result);
};

initRender.prototype.find = function (selector) {
  var result = renderer();

  if (!selector) {
    return result;
  }

  var nodes = [];
  var i;

  if (typeof selector === 'string') {
    selector = selector.trim();

    for (i = 0; i < this.length; i++) {
      var element = this[i];

      if (_dom_adapter.default.isElementNode(element)) {
        var elementId = element.getAttribute('id');
        var queryId = elementId || 'dx-query-children';

        if (!elementId) {
          setAttributeValue(element, 'id', queryId);
        }

        queryId = '[id=\'' + queryId + '\'] ';
        var querySelector = queryId + selector.replace(/([^\\])(,)/g, '$1, ' + queryId);
        nodes.push.apply(nodes, _dom_adapter.default.querySelectorAll(element, querySelector));
        setAttributeValue(element, 'id', elementId);
      } else if (_dom_adapter.default.isDocument(element)) {
        nodes.push.apply(nodes, _dom_adapter.default.querySelectorAll(element, selector));
      }
    }
  } else {
    for (i = 0; i < this.length; i++) {
      selector = _dom_adapter.default.isNode(selector) ? selector : selector[0];

      if (this[i] !== selector && this[i].contains(selector)) {
        nodes.push(selector);
      }
    }
  }

  return result.add(nodes);
};

var isVisible = function isVisible(_, element) {
  if (!element.nodeType) return true;
  return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
};

initRender.prototype.filter = function (selector) {
  if (!selector) return renderer();

  if (selector === ':visible') {
    return this.filter(isVisible);
  } else if (selector === ':hidden') {
    return this.filter(function (_, element) {
      return !isVisible(_, element);
    });
  }

  var result = [];

  for (var i = 0; i < this.length; i++) {
    var item = this[i];

    if (_dom_adapter.default.isElementNode(item) && (0, _type.type)(selector) === 'string') {
      _dom_adapter.default.elementMatches(item, selector) && result.push(item);
    } else if (_dom_adapter.default.isNode(selector) || (0, _type.isWindow)(selector)) {
      selector === item && result.push(item);
    } else if ((0, _type.isFunction)(selector)) {
      selector.call(item, i, item) && result.push(item);
    } else {
      for (var j = 0; j < selector.length; j++) {
        selector[j] === item && result.push(item);
      }
    }
  }

  return renderer(result);
};

initRender.prototype.not = function (selector) {
  var result = [];
  var nodes = this.filter(selector).toArray();

  for (var i = 0; i < this.length; i++) {
    if (nodes.indexOf(this[i]) === -1) {
      result.push(this[i]);
    }
  }

  return renderer(result);
};

initRender.prototype.is = function (selector) {
  return !!this.filter(selector).length;
};

initRender.prototype.children = function (selector) {
  var result = [];

  for (var i = 0; i < this.length; i++) {
    var nodes = this[i] ? this[i].childNodes : [];

    for (var j = 0; j < nodes.length; j++) {
      if (_dom_adapter.default.isElementNode(nodes[j])) {
        result.push(nodes[j]);
      }
    }
  }

  result = renderer(result);
  return selector ? result.filter(selector) : result;
};

initRender.prototype.siblings = function () {
  var element = this[0];

  if (!element || !element.parentNode) {
    return renderer();
  }

  var result = [];
  var parentChildNodes = element.parentNode.childNodes || [];

  for (var i = 0; i < parentChildNodes.length; i++) {
    var node = parentChildNodes[i];

    if (_dom_adapter.default.isElementNode(node) && node !== element) {
      result.push(node);
    }
  }

  return renderer(result);
};

initRender.prototype.each = function (callback) {
  for (var i = 0; i < this.length; i++) {
    if (callback.call(this[i], i, this[i]) === false) {
      break;
    }
  }
};

initRender.prototype.index = function (element) {
  if (!element) {
    return this.parent().children().index(this);
  }

  element = renderer(element);
  return this.toArray().indexOf(element[0]);
};

initRender.prototype.get = function (index) {
  return this[index < 0 ? this.length + index : index];
};

initRender.prototype.eq = function (index) {
  index = index < 0 ? this.length + index : index;
  return renderer(this[index]);
};

initRender.prototype.first = function () {
  return this.eq(0);
};

initRender.prototype.last = function () {
  return this.eq(-1);
};

initRender.prototype.parent = function (selector) {
  if (!this[0]) return renderer();
  var result = renderer(this[0].parentNode);
  return !selector || result.is(selector) ? result : renderer();
};

initRender.prototype.parents = function (selector) {
  var result = [];
  var parent = this.parent();

  while (parent && parent[0] && !_dom_adapter.default.isDocument(parent[0])) {
    if (_dom_adapter.default.isElementNode(parent[0])) {
      if (!selector || parent.is(selector)) {
        result.push(parent.get(0));
      }
    }

    parent = parent.parent();
  }

  return renderer(result);
};

initRender.prototype.closest = function (selector) {
  if (this.is(selector)) {
    return this;
  }

  var parent = this.parent();

  while (parent && parent.length) {
    if (parent.is(selector)) {
      return parent;
    }

    parent = parent.parent();
  }

  return renderer();
};

initRender.prototype.next = function (selector) {
  if (!this[0]) return renderer();
  var next = renderer(this[0].nextSibling);

  if (!arguments.length) {
    return next;
  }

  while (next && next.length) {
    if (next.is(selector)) return next;
    next = next.next();
  }

  return renderer();
};

initRender.prototype.prev = function () {
  if (!this[0]) return renderer();
  return renderer(this[0].previousSibling);
};

initRender.prototype.add = function (selector) {
  var targets = renderer(selector);
  var result = this.toArray();

  for (var i = 0; i < targets.length; i++) {
    var target = targets[i];

    if (result.indexOf(target) === -1) {
      result.push(target);
    }
  }

  return renderer(result);
};

var emptyArray = [];

initRender.prototype.splice = function () {
  return renderer(emptyArray.splice.apply(this, arguments));
};

initRender.prototype.slice = function () {
  return renderer(emptyArray.slice.apply(this, arguments));
};

initRender.prototype.toArray = function () {
  return emptyArray.slice.call(this);
};

initRender.prototype.offset = function () {
  if (!this[0]) return;
  return (0, _size.getOffset)(this[0]);
};

initRender.prototype.offsetParent = function () {
  if (!this[0]) return renderer();
  var offsetParent = renderer(this[0].offsetParent);

  while (offsetParent[0] && offsetParent.css('position') === 'static') {
    offsetParent = renderer(offsetParent[0].offsetParent);
  }

  offsetParent = offsetParent[0] ? offsetParent : renderer(_dom_adapter.default.getDocumentElement());
  return offsetParent;
};

initRender.prototype.position = function () {
  if (!this[0]) return;
  var offset;
  var marginTop = parseFloat(this.css('marginTop'));
  var marginLeft = parseFloat(this.css('marginLeft'));

  if (this.css('position') === 'fixed') {
    offset = this[0].getBoundingClientRect();
    return {
      top: offset.top - marginTop,
      left: offset.left - marginLeft
    };
  }

  offset = this.offset();
  var offsetParent = this.offsetParent();
  var parentOffset = {
    top: 0,
    left: 0
  };

  if (offsetParent[0].nodeName !== 'HTML') {
    parentOffset = offsetParent.offset();
  }

  parentOffset = {
    top: parentOffset.top + parseFloat(offsetParent.css('borderTopWidth')),
    left: parentOffset.left + parseFloat(offsetParent.css('borderLeftWidth'))
  };
  return {
    top: offset.top - parentOffset.top - marginTop,
    left: offset.left - parentOffset.left - marginLeft
  };
};

[{
  name: 'scrollLeft',
  offsetProp: 'pageXOffset',
  scrollWindow: function scrollWindow(win, value) {
    win.scrollTo(value, win.pageYOffset);
  }
}, {
  name: 'scrollTop',
  offsetProp: 'pageYOffset',
  scrollWindow: function scrollWindow(win, value) {
    win.scrollTo(win.pageXOffset, value);
  }
}].forEach(function (directionStrategy) {
  var propName = directionStrategy.name;

  initRender.prototype[propName] = function (value) {
    if (!this[0]) {
      return;
    }

    var window = (0, _size.getWindowByElement)(this[0]);

    if (value === undefined) {
      return window ? window[directionStrategy.offsetProp] : this[0][propName];
    }

    if (window) {
      directionStrategy.scrollWindow(window, value);
    } else {
      this[0][propName] = value;
    }

    return this;
  };
});

initRender.prototype.data = function (key, value) {
  if (!this[0]) return;

  if (arguments.length < 2) {
    return _element_data.data.call(renderer, this[0], key);
  }

  _element_data.data.call(renderer, this[0], key, value);

  return this;
};

initRender.prototype.removeData = function (key) {
  this[0] && (0, _element_data.removeData)(this[0], key);
  return this;
};

var rendererWrapper = function rendererWrapper() {
  return renderer.apply(this, arguments);
};

Object.defineProperty(rendererWrapper, 'fn', {
  enumerable: true,
  configurable: true,
  get: function get() {
    return renderer.fn;
  },
  set: function set(value) {
    renderer.fn = value;
  }
});
var _default = {
  set: function set(strategy) {
    renderer = strategy;
  },
  get: function get() {
    return rendererWrapper;
  }
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = _default;
var touchPropsToHook = ['pageX', 'pageY', 'screenX', 'screenY', 'clientX', 'clientY'];

var touchPropHook = function touchPropHook(name, event) {
  if (event[name] && !event.touches || !event.touches) {
    return event[name];
  }

  var touches = event.touches.length ? event.touches : event.changedTouches;

  if (!touches.length) {
    return;
  }

  return touches[0][name];
};

function _default(callback) {
  touchPropsToHook.forEach(function (name) {
    callback(name, function (event) {
      return touchPropHook(name, event);
    });
  }, this);
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.isTablePart = exports.parseHTML = void 0;

var _array = __webpack_require__(12);

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isTagName = /<([a-z][^/\0>\x20\t\r\n\f]+)/i;
var tagWrappers = {
  default: {
    tagsCount: 0,
    startTags: '',
    endTags: ''
  },
  thead: {
    tagsCount: 1,
    startTags: '<table>',
    endTags: '</table>'
  },
  td: {
    tagsCount: 3,
    startTags: '<table><tbody><tr>',
    endTags: '</tr></tbody></table>'
  },
  col: {
    tagsCount: 2,
    startTags: '<table><colgroup>',
    endTags: '</colgroup></table>'
  },
  tr: {
    tagsCount: 2,
    startTags: '<table><tbody>',
    endTags: '</tbody></table>'
  }
};
tagWrappers.tbody = tagWrappers.colgroup = tagWrappers.caption = tagWrappers.tfoot = tagWrappers.thead;
tagWrappers.th = tagWrappers.td;

var parseHTML = function parseHTML(html) {
  if (typeof html !== 'string') {
    return null;
  }

  var fragment = _dom_adapter.default.createDocumentFragment();

  var container = fragment.appendChild(_dom_adapter.default.createElement('div'));
  var tags = isTagName.exec(html);
  var firstRootTag = tags && tags[1].toLowerCase();
  var tagWrapper = tagWrappers[firstRootTag] || tagWrappers.default;
  container.innerHTML = tagWrapper.startTags + html + tagWrapper.endTags;

  for (var i = 0; i < tagWrapper.tagsCount; i++) {
    container = container.lastChild;
  }

  return (0, _array.merge)([], container.childNodes);
};

exports.parseHTML = parseHTML;

var isTablePart = function isTablePart(html) {
  var tags = isTagName.exec(html);
  return tags && tags[1] in tagWrappers;
};

exports.isTablePart = isTablePart;

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _string = __webpack_require__(40);

var _number = _interopRequireDefault(__webpack_require__(46));

var _date = _interopRequireDefault(__webpack_require__(33));

var _type = __webpack_require__(1);

var _date2 = __webpack_require__(170);

var _language_codes = __webpack_require__(212);

__webpack_require__(112);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ARABIC_ZERO_CODE = 1632;
var DEFINED_NUMBER_FORMTATS = {
  thousands: '#,##0{0},&quot;K&quot;',
  millions: '#,##0{0},,&quot;M&quot;',
  billions: '#,##0{0},,,&quot;B&quot;',
  trillions: '#,##0{0},,,,&quot;T&quot;',
  percent: '0{0}%',
  decimal: '#{0}',
  'fixedpoint': '#,##0{0}',
  exponential: '0{0}E+00',
  currency: ' '
};
var PERIOD_REGEXP = /a+/g;
var DAY_REGEXP = /E/g;
var DO_REGEXP = /dE+/g;
var STANDALONE_MONTH_REGEXP = /L/g;
var HOUR_REGEXP = /h/g;
var ANY_REGEXP = /./g;
var excelFormatConverter = {
  _applyPrecision: function _applyPrecision(format, precision) {
    var result;
    var i;

    if (precision > 0) {
      result = format !== 'decimal' ? '.' : '';

      for (i = 0; i < precision; i++) {
        result = result + '0';
      }

      return result;
    }

    return '';
  },
  _hasArabicDigits: function _hasArabicDigits(text) {
    var code;

    for (var i = 0; i < text.length; i++) {
      code = text.charCodeAt(i);

      if (code >= ARABIC_ZERO_CODE && code < ARABIC_ZERO_CODE + 10) {
        return true;
      }
    }

    return false;
  },
  _convertDateFormatToOpenXml: function _convertDateFormatToOpenXml(format) {
    return format.split('/').join('\\/').split('\'').map(function (datePart, index) {
      if (index % 2 === 0) {
        return datePart.replace(PERIOD_REGEXP, 'AM/PM').replace(DO_REGEXP, 'd').replace(DAY_REGEXP, 'd').replace(STANDALONE_MONTH_REGEXP, 'M').replace(HOUR_REGEXP, 'H').split('[').join('\\[').split(']').join('\\]');
      }

      if (datePart) {
        return datePart.replace(ANY_REGEXP, '\\$&');
      }

      return '\'';
    }).join('');
  },
  _convertDateFormat: function _convertDateFormat(format) {
    var formattedValue = (_date.default.format(new Date(2009, 8, 8, 6, 5, 4), format) || '').toString();
    var result = (0, _date2.getFormat)(function (value) {
      return _date.default.format(value, format);
    });

    if (result) {
      result = this._convertDateFormatToOpenXml(result);
      result = this._getLanguageInfo(formattedValue) + result;
    }

    return result;
  },
  _getLanguageInfo: function _getLanguageInfo(defaultPattern) {
    var languageID = (0, _language_codes.getLanguageId)();
    var languageIDStr = languageID ? languageID.toString(16) : '';
    var languageInfo = '';

    if (this._hasArabicDigits(defaultPattern)) {
      while (languageIDStr.length < 3) {
        languageIDStr = '0' + languageIDStr;
      }

      languageInfo = '[$-2010' + languageIDStr + ']';
    } else if (languageIDStr) {
      languageInfo = '[$-' + languageIDStr + ']';
    }

    return languageInfo;
  },
  _convertNumberFormat: function _convertNumberFormat(format, precision, currency) {
    var result;
    var excelFormat;

    if (format === 'currency') {
      excelFormat = _number.default.getOpenXmlCurrencyFormat(currency);
    } else {
      excelFormat = DEFINED_NUMBER_FORMTATS[format.toLowerCase()];
    }

    if (excelFormat) {
      result = (0, _string.format)(excelFormat, this._applyPrecision(format, precision));
    }

    return result;
  },
  convertFormat: function convertFormat(format, precision, type, currency) {
    if ((0, _type.isDefined)(format)) {
      if (type === 'date') {
        return excelFormatConverter._convertDateFormat(format);
      } else {
        if ((0, _type.isString)(format) && DEFINED_NUMBER_FORMTATS[format.toLowerCase()]) {
          return excelFormatConverter._convertNumberFormat(format, precision, currency);
        }
      }
    }
  }
};
var _default = excelFormatConverter;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.toFixed = toFixed;

var _math = __webpack_require__(31);

var DECIMAL_BASE = 10;

function roundByAbs(value) {
  var valueSign = (0, _math.sign)(value);
  return valueSign * Math.round(Math.abs(value));
}

function adjustValue(value, precision) {
  var precisionMultiplier = Math.pow(DECIMAL_BASE, precision);
  var roundMultiplier = precisionMultiplier * DECIMAL_BASE;
  var intermediateValue = value * roundMultiplier / DECIMAL_BASE;
  return roundByAbs(intermediateValue) / precisionMultiplier;
}

function toFixed(value, precision) {
  var valuePrecision = precision || 0;
  var adjustedValue = valuePrecision > 0 ? adjustValue.apply(void 0, arguments) : value;
  return adjustedValue.toFixed(valuePrecision);
}

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _default = function _default(currencySymbol, accountingFormat) {
  if (!accountingFormat) {
    return;
  }

  var encodedCurrencySymbol = currencySymbol;

  if (typeof currencySymbol === 'string') {
    encodedCurrencySymbol = '';

    for (var i = 0; i < currencySymbol.length; i++) {
      if (currencySymbol[i] !== '$') {
        encodedCurrencySymbol += '\\';
      }

      encodedCurrencySymbol += currencySymbol[i];
    }
  }

  var encodeSymbols = {
    '.00': '{0}',
    '\'': '\\\'',
    '\\(': '\\(',
    '\\)': '\\)',
    ' ': '\\ ',
    '"': '&quot;',
    '\\': encodedCurrencySymbol
  };
  var result = accountingFormat.split(';');

  for (var _i = 0; _i < result.length; _i++) {
    for (var symbol in encodeSymbols) {
      if (Object.prototype.hasOwnProperty.call(encodeSymbols, symbol)) {
        result[_i] = result[_i].replace(new RegExp(symbol, 'g'), encodeSymbols[symbol]);
      }
    }
  }

  return result.length === 2 ? result[0] + '_);' + result[1] : result[0];
};

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getFormatter = void 0;

function leftPad(text, length) {
  while (text.length < length) {
    text = '0' + text;
  }

  return text;
}

var FORMAT_TYPES = {
  '3': 'abbreviated',
  '4': 'wide',
  '5': 'narrow'
};
var LDML_FORMATTERS = {
  y: function y(date, count, useUtc) {
    var year = date[useUtc ? 'getUTCFullYear' : 'getFullYear']();

    if (count === 2) {
      year = year % 100;
    }

    return leftPad(year.toString(), count);
  },
  M: function M(date, count, useUtc, dateParts) {
    var month = date[useUtc ? 'getUTCMonth' : 'getMonth']();
    var formatType = FORMAT_TYPES[count];

    if (formatType) {
      return dateParts.getMonthNames(formatType, 'format')[month];
    }

    return leftPad((month + 1).toString(), Math.min(count, 2));
  },
  L: function L(date, count, useUtc, dateParts) {
    var month = date[useUtc ? 'getUTCMonth' : 'getMonth']();
    var formatType = FORMAT_TYPES[count];

    if (formatType) {
      return dateParts.getMonthNames(formatType, 'standalone')[month];
    }

    return leftPad((month + 1).toString(), Math.min(count, 2));
  },
  Q: function Q(date, count, useUtc, dateParts) {
    var month = date[useUtc ? 'getUTCMonth' : 'getMonth']();
    var quarter = Math.floor(month / 3);
    var formatType = FORMAT_TYPES[count];

    if (formatType) {
      return dateParts.getQuarterNames(formatType)[quarter];
    }

    return leftPad((quarter + 1).toString(), Math.min(count, 2));
  },
  E: function E(date, count, useUtc, dateParts) {
    var day = date[useUtc ? 'getUTCDay' : 'getDay']();
    var formatType = FORMAT_TYPES[count < 3 ? 3 : count];
    return dateParts.getDayNames(formatType)[day];
  },
  a: function a(date, count, useUtc, dateParts) {
    var hours = date[useUtc ? 'getUTCHours' : 'getHours']();
    var period = hours < 12 ? 0 : 1;
    var formatType = FORMAT_TYPES[count];
    return dateParts.getPeriodNames(formatType)[period];
  },
  d: function d(date, count, useUtc) {
    return leftPad(date[useUtc ? 'getUTCDate' : 'getDate']().toString(), Math.min(count, 2));
  },
  H: function H(date, count, useUtc) {
    return leftPad(date[useUtc ? 'getUTCHours' : 'getHours']().toString(), Math.min(count, 2));
  },
  h: function h(date, count, useUtc) {
    var hours = date[useUtc ? 'getUTCHours' : 'getHours']();
    return leftPad((hours % 12 || 12).toString(), Math.min(count, 2));
  },
  m: function m(date, count, useUtc) {
    return leftPad(date[useUtc ? 'getUTCMinutes' : 'getMinutes']().toString(), Math.min(count, 2));
  },
  s: function s(date, count, useUtc) {
    return leftPad(date[useUtc ? 'getUTCSeconds' : 'getSeconds']().toString(), Math.min(count, 2));
  },
  S: function S(date, count, useUtc) {
    return leftPad(date[useUtc ? 'getUTCMilliseconds' : 'getMilliseconds']().toString(), 3).substr(0, count);
  },
  x: function x(date, count, useUtc) {
    var timezoneOffset = useUtc ? 0 : date.getTimezoneOffset();
    var signPart = timezoneOffset > 0 ? '-' : '+';
    var timezoneOffsetAbs = Math.abs(timezoneOffset);
    var hours = Math.floor(timezoneOffsetAbs / 60);
    var minutes = timezoneOffsetAbs % 60;
    var hoursPart = leftPad(hours.toString(), 2);
    var minutesPart = leftPad(minutes.toString(), 2);
    return signPart + hoursPart + (count >= 3 ? ':' : '') + (count > 1 || minutes ? minutesPart : '');
  },
  X: function X(date, count, useUtc) {
    if (useUtc || !date.getTimezoneOffset()) {
      return 'Z';
    }

    return LDML_FORMATTERS.x(date, count, useUtc);
  },
  Z: function Z(date, count, useUtc) {
    return LDML_FORMATTERS.X(date, count >= 5 ? 3 : 2, useUtc);
  }
};

var getFormatter = function getFormatter(format, dateParts) {
  return function (date) {
    var charIndex;
    var formatter;
    var char;
    var charCount = 0;
    var separator = '\'';
    var isEscaping = false;
    var isCurrentCharEqualsNext;
    var result = '';
    if (!date) return null;
    if (!format) return date;
    var useUtc = format[format.length - 1] === 'Z' || format.slice(-3) === '\'Z\'';

    for (charIndex = 0; charIndex < format.length; charIndex++) {
      char = format[charIndex];
      formatter = LDML_FORMATTERS[char];
      isCurrentCharEqualsNext = char === format[charIndex + 1];
      charCount++;

      if (!isCurrentCharEqualsNext) {
        if (formatter && !isEscaping) {
          result += formatter(date, charCount, useUtc, dateParts);
        }

        charCount = 0;
      }

      if (char === separator && !isCurrentCharEqualsNext) {
        isEscaping = !isEscaping;
      } else if (isEscaping || !formatter) {
        result += char;
      }

      if (char === separator && isCurrentCharEqualsNext) {
        charIndex++;
      }
    }

    return result;
  };
};

exports.getFormatter = getFormatter;

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _iterator = __webpack_require__(3);

var MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
var DAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
var PERIODS = ['AM', 'PM'];
var QUARTERS = ['Q1', 'Q2', 'Q3', 'Q4']; // TODO: optimize

var cutCaptions = function cutCaptions(captions, format) {
  var lengthByFormat = {
    abbreviated: 3,
    short: 2,
    narrow: 1
  };
  return (0, _iterator.map)(captions, function (caption) {
    return caption.substr(0, lengthByFormat[format]);
  });
};

var _default = {
  getMonthNames: function getMonthNames(format) {
    return cutCaptions(MONTHS, format);
  },
  getDayNames: function getDayNames(format) {
    return cutCaptions(DAYS, format);
  },
  getQuarterNames: function getQuarterNames(format) {
    return QUARTERS;
  },
  getPeriodNames: function getPeriodNames(format) {
    return PERIODS;
  }
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _type = __webpack_require__(1);

var _excel = _interopRequireDefault(__webpack_require__(86));

var _excel2 = _interopRequireDefault(__webpack_require__(366));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fillHelper = {
  tryCreateTag: function tryCreateTag(sourceObj) {
    var result = null;

    if ((0, _type.isDefined)(sourceObj)) {
      result = {
        patternFill: _excel2.default.tryCreateTag(sourceObj.patternFill)
      };

      if (fillHelper.isEmpty(result)) {
        result = null;
      }
    }

    return result;
  },
  tryCreateFillFromSimpleFormat: function tryCreateFillFromSimpleFormat() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        backgroundColor = _ref.backgroundColor,
        fillPatternType = _ref.fillPatternType,
        fillPatternColor = _ref.fillPatternColor;

    if ((0, _type.isDefined)(backgroundColor) && !((0, _type.isDefined)(fillPatternType) && (0, _type.isDefined)(fillPatternColor))) {
      return {
        patternFill: {
          patternType: 'solid',
          foregroundColor: {
            rgb: backgroundColor
          }
        }
      };
    } else if ((0, _type.isDefined)(fillPatternType) && (0, _type.isDefined)(fillPatternColor)) {
      return {
        patternFill: {
          patternType: fillPatternType,
          foregroundColor: {
            rgb: fillPatternColor
          },
          backgroundColor: {
            rgb: backgroundColor
          }
        }
      };
    }
  },
  copySimpleFormat: function copySimpleFormat(source, target) {
    if (source.backgroundColor !== undefined) {
      target.backgroundColor = source.backgroundColor;
    }

    if (source.fillPatternType !== undefined) {
      target.fillPatternType = source.fillPatternType;
    }

    if (source.fillPatternColor !== undefined) {
      target.fillPatternColor = source.fillPatternColor;
    }
  },
  copy: function copy(source) {
    var result = null;

    if ((0, _type.isDefined)(source)) {
      result = {};

      if (source.patternFill !== undefined) {
        result.patternFill = _excel2.default.copy(source.patternFill);
      }
    }

    return result;
  },
  areEqual: function areEqual(leftTag, rightTag) {
    return fillHelper.isEmpty(leftTag) && fillHelper.isEmpty(rightTag) || (0, _type.isDefined)(leftTag) && (0, _type.isDefined)(rightTag) && _excel2.default.areEqual(leftTag.patternFill, rightTag.patternFill);
  },
  isEmpty: function isEmpty(tag) {
    return !(0, _type.isDefined)(tag) || _excel2.default.isEmpty(tag.patternFill);
  },
  toXml: function toXml(tag) {
    // 18.8.20 fill (Fill), 'ECMA-376 5th edition Part 1' (http://www.ecma-international.org/publications/standards/Ecma-376.htm)
    return _excel.default.toXml('fill', {}, _excel2.default.toXml(tag.patternFill));
  }
};
var _default = fillHelper;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _type = __webpack_require__(1);

var _excel = _interopRequireDefault(__webpack_require__(86));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var colorHelper = {
  _tryConvertColor: function _tryConvertColor(source) {
    if (typeof source !== 'string') {
      return source;
    }

    var result;

    if (source.length > 0 && source[0] === '#') {
      var colorCode = source.substr(1, source.length);

      if (colorCode.length === 6) {
        // RRGGBB
        result = 'FF' + colorCode;
      } else if (colorCode.length === 8) {
        // RRGGBBAA
        result = colorCode[6] + colorCode[7] + colorCode.substr(0, 6);
      } else {
        result = colorCode;
      }
    } else {
      result = source;
    }

    return result;
  },
  tryCreateTag: function tryCreateTag(sourceObj) {
    var result = null;

    if ((0, _type.isDefined)(sourceObj)) {
      if (typeof sourceObj === 'string') {
        result = {
          rgb: this._tryConvertColor(sourceObj)
        };
      } else {
        result = {
          rgb: this._tryConvertColor(sourceObj.rgb),
          theme: sourceObj.theme
        };
      }

      if (colorHelper.isEmpty(result)) {
        result = null;
      }
    }

    return result;
  },
  copy: function copy(source) {
    var result = null;

    if ((0, _type.isDefined)(source)) {
      if (typeof source === 'string') {
        result = source;
      } else {
        result = {};

        if (source.rgb !== undefined) {
          result.rgb = source.rgb;
        }

        if (source.theme !== undefined) {
          result.theme = source.theme;
        }
      }
    }

    return result;
  },
  isEmpty: function isEmpty(tag) {
    return !(0, _type.isDefined)(tag) || !(0, _type.isDefined)(tag.rgb) && !(0, _type.isDefined)(tag.theme);
  },
  areEqual: function areEqual(leftTag, rightTag) {
    return colorHelper.isEmpty(leftTag) && colorHelper.isEmpty(rightTag) || (0, _type.isDefined)(leftTag) && (0, _type.isDefined)(rightTag) && leftTag.rgb === rightTag.rgb && leftTag.theme === rightTag.theme;
  },
  toXml: function toXml(tagName, tag) {
    // 'CT_Color', 'ECMA-376 5th edition Part 1' (http://www.ecma-international.org/publications/standards/Ecma-376.htm)
    return _excel.default.toXml(tagName, {
      rgb: tag.rgb,
      theme: tag.theme
    });
  }
};
var _default = colorHelper;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _type = __webpack_require__(1);

var _excel = _interopRequireDefault(__webpack_require__(86));

var _excel2 = _interopRequireDefault(__webpack_require__(256));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fontHelper = {
  tryCreateTag: function tryCreateTag(sourceObj) {
    var result = null;

    if ((0, _type.isDefined)(sourceObj)) {
      result = {
        size: sourceObj.size,
        name: sourceObj.name,
        family: sourceObj.family,
        scheme: sourceObj.scheme,
        bold: sourceObj.bold,
        italic: sourceObj.italic,
        underline: sourceObj.underline,
        color: _excel2.default.tryCreateTag(sourceObj.color)
      };

      if (fontHelper.isEmpty(result)) {
        result = null;
      }
    }

    return result;
  },
  copy: function copy(source) {
    var result = null;

    if ((0, _type.isDefined)(source)) {
      result = {};

      if (source.size !== undefined) {
        result.size = source.size;
      }

      if (source.name !== undefined) {
        result.name = source.name;
      }

      if (source.family !== undefined) {
        result.family = source.family;
      }

      if (source.scheme !== undefined) {
        result.scheme = source.scheme;
      }

      if (source.bold !== undefined) {
        result.bold = source.bold;
      }

      if (source.italic !== undefined) {
        result.italic = source.italic;
      }

      if (source.underline !== undefined) {
        result.underline = source.underline;
      }

      if (source.color !== undefined) {
        result.color = _excel2.default.copy(source.color);
      }
    }

    return result;
  },
  areEqual: function areEqual(leftTag, rightTag) {
    return fontHelper.isEmpty(leftTag) && fontHelper.isEmpty(rightTag) || (0, _type.isDefined)(leftTag) && (0, _type.isDefined)(rightTag) && leftTag.size === rightTag.size && leftTag.name === rightTag.name && leftTag.family === rightTag.family && leftTag.scheme === rightTag.scheme && (leftTag.bold === rightTag.bold || !leftTag.bold === !rightTag.bold) && (leftTag.italic === rightTag.italic || !leftTag.italic === !rightTag.italic) && leftTag.underline === rightTag.underline && _excel2.default.areEqual(leftTag.color, rightTag.color);
  },
  isEmpty: function isEmpty(tag) {
    return !(0, _type.isDefined)(tag) || !(0, _type.isDefined)(tag.size) && !(0, _type.isDefined)(tag.name) && !(0, _type.isDefined)(tag.family) && !(0, _type.isDefined)(tag.scheme) && (!(0, _type.isDefined)(tag.bold) || !tag.bold) && (!(0, _type.isDefined)(tag.italic) || !tag.italic) && !(0, _type.isDefined)(tag.underline) && _excel2.default.isEmpty(tag.color);
  },
  toXml: function toXml(tag) {
    var content = [(0, _type.isDefined)(tag.bold) && tag.bold ? _excel.default.toXml('b', {}) : '', // 18.8.2 b (Bold)
    (0, _type.isDefined)(tag.size) ? _excel.default.toXml('sz', {
      'val': tag.size
    }) : '', // 18.4.11 sz (Font Size)
    (0, _type.isDefined)(tag.color) ? _excel2.default.toXml('color', tag.color) : '', (0, _type.isDefined)(tag.name) ? _excel.default.toXml('name', {
      'val': tag.name
    }) : '', // 18.8.29 name (Font Name)
    (0, _type.isDefined)(tag.family) ? _excel.default.toXml('family', {
      'val': tag.family
    }) : '', // 18.8.18 family (Font Family)
    (0, _type.isDefined)(tag.scheme) ? _excel.default.toXml('scheme', {
      'val': tag.scheme
    }) : '', // 18.8.35 scheme (Scheme)
    (0, _type.isDefined)(tag.italic) && tag.italic ? _excel.default.toXml('i', {}) : '', // 18.8.26 i (Italic)
    (0, _type.isDefined)(tag.underline) ? _excel.default.toXml('u', {
      'val': tag.underline
    }) : '' // 18.4.13 u (Underline)
    ].join(''); // 18.8.22, 'font (Font)', 'ECMA-376 5th edition Part 1' (http://www.ecma-international.org/publications/standards/Ecma-376.htm)

    return _excel.default.toXml('font', {}, content);
  }
};
var _default = fontHelper;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getData = getData;
exports.testFormats = testFormats;
exports.imageCreator = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _color = _interopRequireDefault(__webpack_require__(102));

var _type = __webpack_require__(1);

var _svg = __webpack_require__(213);

var _iterator = __webpack_require__(3);

var _extend = __webpack_require__(0);

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _dom = __webpack_require__(35);

var _window = __webpack_require__(7);

var _inflector = __webpack_require__(41);

var _deferred = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var window = (0, _window.getWindow)();
var _math = Math;
var PI = _math.PI;
var _min = _math.min;
var _abs = _math.abs;
var _sqrt = _math.sqrt;
var _pow = _math.pow;
var _atan2 = _math.atan2;
var _cos = _math.cos;
var _sin = _math.sin;
var _number = Number;
var IMAGE_QUALITY = 1;
var TEXT_DECORATION_LINE_WIDTH_COEFF = 0.05;
var DEFAULT_FONT_SIZE = '10px';
var DEFAULT_FONT_FAMILY = 'sans-serif';
var DEFAULT_TEXT_COLOR = '#000';
var parseAttributes;

function createCanvas(width, height, margin) {
  var canvas = (0, _renderer.default)('<canvas>')[0];
  canvas.width = width + margin * 2;
  canvas.height = height + margin * 2;
  canvas.hidden = true;
  return canvas;
}

function getStringFromCanvas(canvas, mimeType) {
  var dataURL = canvas.toDataURL(mimeType, IMAGE_QUALITY);
  var imageData = window.atob(dataURL.substring(('data:' + mimeType + ';base64,').length));
  return imageData;
}

function arcTo(x1, y1, x2, y2, radius, largeArcFlag, clockwise, context) {
  var cBx = (x1 + x2) / 2;
  var cBy = (y1 + y2) / 2;

  var aB = _atan2(y1 - y2, x1 - x2);

  var k = largeArcFlag ? 1 : -1;
  aB += 90 * (PI / 180) * (clockwise ? 1 : -1);
  var opSide = _sqrt(_pow(x2 - x1, 2) + _pow(y2 - y1, 2)) / 2;

  var adjSide = _sqrt(_abs(_pow(radius, 2) - _pow(opSide, 2)));

  var centerX = cBx + k * (adjSide * _cos(aB));

  var centerY = cBy + k * (adjSide * _sin(aB));

  var startAngle = _atan2(y1 - centerY, x1 - centerX);

  var endAngle = _atan2(y2 - centerY, x2 - centerX);

  context.arc(centerX, centerY, radius, startAngle, endAngle, !clockwise);
}

function getElementOptions(element, rootAppended) {
  var attr = parseAttributes(element.attributes || {});
  var options = (0, _extend.extend)({}, attr, {
    text: element.textContent.replace(/\s+/g, ' '),
    textAlign: attr['text-anchor'] === 'middle' ? 'center' : attr['text-anchor']
  });
  var transform = attr.transform;
  var coords;

  if (transform) {
    coords = transform.match(/translate\(-*\d+([.]\d+)*(,*\s*-*\d+([.]\d+)*)*/);

    if (coords) {
      coords = coords[0].match(/-*\d+([.]\d+)*/g);
      options.translateX = _number(coords[0]);
      options.translateY = coords[1] ? _number(coords[1]) : 0;
    }

    coords = transform.match(/rotate\(-*\d+([.]\d+)*(,*\s*-*\d+([.]\d+)*,*\s*-*\d+([.]\d+)*)*/);

    if (coords) {
      coords = coords[0].match(/-*\d+([.]\d+)*/g);
      options.rotationAngle = _number(coords[0]);
      options.rotationX = coords[1] && _number(coords[1]);
      options.rotationY = coords[2] && _number(coords[2]);
    }

    coords = transform.match(/scale\(-*\d+([.]\d+)*(,*\s*-*\d+([.]\d+)*)*/);

    if (coords) {
      coords = coords[0].match(/-*\d+([.]\d+)*/g);
      options.scaleX = _number(coords[0]);

      if (coords.length > 1) {
        options.scaleY = _number(coords[1]);
      } else {
        options.scaleY = options.scaleX;
      }
    }
  }

  parseStyles(element, options, rootAppended);
  return options;
}

function drawRect(context, options) {
  var x = options.x;
  var y = options.y;
  var width = options.width;
  var height = options.height;
  var cornerRadius = options.rx;

  if (!cornerRadius) {
    context.rect(x, y, width, height);
  } else {
    cornerRadius = _min(cornerRadius, width / 2, height / 2);
    context.save();
    context.translate(x, y);
    context.moveTo(width / 2, 0);
    context.arcTo(width, 0, width, height, cornerRadius);
    context.arcTo(width, height, 0, height, cornerRadius);
    context.arcTo(0, height, 0, 0, cornerRadius);
    context.arcTo(0, 0, cornerRadius, 0, cornerRadius);
    context.lineTo(width / 2, 0);
    context.restore();
  }
}

function drawImage(context, options, shared) {
  var d = new _deferred.Deferred();
  var image = new window.Image();

  image.onload = function () {
    context.save();
    context.globalAlpha = options.globalAlpha;
    transformElement(context, options);
    clipElement(context, options, shared);
    context.drawImage(image, options.x, options.y, options.width, options.height);
    context.restore();
    d.resolve();
  };

  image.onerror = function () {
    d.resolve();
  };

  image.setAttribute('crossOrigin', 'anonymous');
  image.src = options['href'] || options['xlink:href'];
  return d;
}

function drawPath(context, dAttr) {
  var dArray = dAttr.replace(/,/g, ' ').split(/([A-Z])/i).filter(function (item) {
    return item.trim() !== '';
  });
  var i = 0;
  var params;
  var prevParams;
  var prevParamsLen;

  do {
    params = (dArray[i + 1] || '').trim().split(' ');

    switch (dArray[i]) {
      case 'M':
        context.moveTo(_number(params[0]), _number(params[1]));
        i += 2;
        break;

      case 'L':
        for (var j = 0; j < params.length / 2; j++) {
          context.lineTo(_number(params[j * 2]), _number(params[j * 2 + 1]));
        }

        i += 2;
        break;

      case 'C':
        context.bezierCurveTo(_number(params[0]), _number(params[1]), _number(params[2]), _number(params[3]), _number(params[4]), _number(params[5]));
        i += 2;
        break;

      case 'a':
        prevParams = dArray[i - 1].trim().split(' ');
        prevParamsLen = prevParams.length - 1;
        arcTo(_number(prevParams[prevParamsLen - 1]), _number(prevParams[prevParamsLen]), _number(prevParams[prevParamsLen - 1]) + _number(params[5]), _number(prevParams[prevParamsLen]) + _number(params[6]), _number(params[0]), _number(params[3]), _number(params[4]), context);
        i += 2;
        break;

      case 'A':
        prevParams = dArray[i - 1].trim().split(' ');
        prevParamsLen = prevParams.length - 1;
        arcTo(_number(prevParams[prevParamsLen - 1]), _number(prevParams[prevParamsLen]), _number(params[5]), _number(params[6]), _number(params[0]), _number(params[3]), _number(params[4]), context);
        i += 2;
        break;

      case 'Z':
        context.closePath();
        i += 1;
        break;

      default:
        i++;
    }
  } while (i < dArray.length);
}

function parseStyles(element, options, rootAppended) {
  var style = element.style || {};
  var field;

  for (field in style) {
    if (style[field] !== '') {
      options[(0, _inflector.camelize)(field)] = style[field];
    }
  }

  if (rootAppended && _dom_adapter.default.isElementNode(element)) {
    style = window.getComputedStyle(element);
    ['fill', 'stroke', 'stroke-width', 'font-family', 'font-size', 'font-style', 'font-weight'].forEach(function (prop) {
      if (prop in style && style[prop] !== '') {
        options[(0, _inflector.camelize)(prop)] = style[prop];
      }
    });
    ['opacity', 'fill-opacity', 'stroke-opacity'].forEach(function (prop) {
      if (prop in style && style[prop] !== '' && style[prop] !== '1') {
        options[prop] = _number(style[prop]);
      }
    });
  }

  options.textDecoration = options.textDecoration || options.textDecorationLine;
  options.globalAlpha = (0, _type.isDefined)(options.opacity) ? options.opacity : options.globalAlpha;
}

function parseUrl(urlString) {
  var matches = urlString && urlString.match(/url\(.*#(.*?)["']?\)/i);
  return matches && matches[1];
}

function setFontStyle(context, options) {
  var fontParams = [];
  options.fontSize = options.fontSize || DEFAULT_FONT_SIZE;
  options.fontFamily = options.fontFamily || DEFAULT_FONT_FAMILY;
  options.fill = options.fill || DEFAULT_TEXT_COLOR;
  options.fontStyle && fontParams.push(options.fontStyle);
  options.fontWeight && fontParams.push(options.fontWeight);
  fontParams.push(options.fontSize);
  fontParams.push(options.fontFamily);
  context.font = fontParams.join(' ');
  context.textAlign = options.textAlign;
  context.fillStyle = options.fill;
  context.globalAlpha = options.globalAlpha;
}

function drawText(context, options, shared) {
  setFontStyle(context, options);
  applyFilter(context, options, shared);
  options.text && context.fillText(options.text, options.x || 0, options.y || 0);
  strokeElement(context, options, true);
  drawTextDecoration(context, options, shared);
}

function drawTextDecoration(context, options, shared) {
  if (!options.textDecoration || options.textDecoration === 'none') {
    return;
  }

  var x = options.x;
  var textWidth = context.measureText(options.text).width;
  var textHeight = parseInt(options.fontSize, 10);
  var lineHeight = textHeight * TEXT_DECORATION_LINE_WIDTH_COEFF < 1 ? 1 : textHeight * TEXT_DECORATION_LINE_WIDTH_COEFF;
  var y = options.y;

  switch (options.textDecoration) {
    case 'line-through':
      y -= textHeight / 3 + lineHeight / 2;
      break;

    case 'overline':
      y -= textHeight - lineHeight;
      break;

    case 'underline':
      y += lineHeight;
      break;
  }

  context.rect(x, y, textWidth, lineHeight);
  fillElement(context, options, shared);
  strokeElement(context, options);
}

function aggregateOpacity(options) {
  options.strokeOpacity = options['stroke-opacity'] !== undefined ? options['stroke-opacity'] : 1;
  options.fillOpacity = options['fill-opacity'] !== undefined ? options['fill-opacity'] : 1;

  if (options.opacity !== undefined) {
    options.strokeOpacity *= options.opacity;
    options.fillOpacity *= options.opacity;
  }
}

function hasTspan(element) {
  var nodes = element.childNodes;

  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].tagName === 'tspan') {
      return true;
    }
  }

  return false;
}

function drawTextElement(childNodes, context, options, shared) {
  var lines = [];
  var line;
  var offset = 0;

  for (var i = 0; i < childNodes.length; i++) {
    var element = childNodes[i];

    if (element.tagName === undefined) {
      drawElement(element, context, options, shared);
    } else if (element.tagName === 'tspan' || element.tagName === 'text') {
      var elementOptions = getElementOptions(element, shared.rootAppended);
      var mergedOptions = (0, _extend.extend)({}, options, elementOptions);

      if (element.tagName === 'tspan' && hasTspan(element)) {
        drawTextElement(element.childNodes, context, mergedOptions, shared);
        continue;
      }

      mergedOptions.textAlign = 'start';

      if (!line || elementOptions.x !== undefined) {
        line = {
          elements: [],
          options: [],
          widths: [],
          offsets: []
        };
        lines.push(line);
      }

      if (elementOptions.y !== undefined) {
        offset = 0;
      }

      if (elementOptions.dy !== undefined) {
        offset += parseFloat(elementOptions.dy);
      }

      line.elements.push(element);
      line.options.push(mergedOptions);
      line.offsets.push(offset);
      setFontStyle(context, mergedOptions);
      line.widths.push(context.measureText(mergedOptions.text).width);
    }
  }

  lines.forEach(function (line) {
    var commonWidth = line.widths.reduce(function (commonWidth, width) {
      return commonWidth + width;
    }, 0);
    var xDiff = 0;
    var currentOffset = 0;

    if (options.textAlign === 'center') {
      xDiff = commonWidth / 2;
    }

    if (options.textAlign === 'end') {
      xDiff = commonWidth;
    }

    line.options.forEach(function (o, index) {
      var width = line.widths[index];
      o.x = o.x - xDiff + currentOffset;
      o.y += line.offsets[index];
      currentOffset += width;
    });
    line.elements.forEach(function (element, index) {
      drawTextElement(element.childNodes, context, line.options[index], shared);
    });
  });
}

function drawElement(element, context, parentOptions, shared) {
  var tagName = element.tagName;
  var isText = tagName === 'text' || tagName === 'tspan' || tagName === undefined;
  var isImage = tagName === 'image';
  var options = (0, _extend.extend)({}, parentOptions, getElementOptions(element, shared.rootAppended));

  if (options.visibility === 'hidden' || options['hidden-for-export']) {
    return;
  }

  context.save();
  !isImage && transformElement(context, options);
  clipElement(context, options, shared);
  aggregateOpacity(options);
  var promise;
  context.beginPath();

  switch (element.tagName) {
    case undefined:
      drawText(context, options, shared);
      break;

    case 'text':
    case 'tspan':
      drawTextElement(element.childNodes, context, options, shared);
      break;

    case 'image':
      promise = drawImage(context, options, shared);
      break;

    case 'path':
      drawPath(context, options.d);
      break;

    case 'rect':
      drawRect(context, options);
      context.closePath(); // for valid clipping

      break;

    case 'circle':
      context.arc(options.cx, options.cy, options.r, 0, 2 * PI, 1);
      break;
  }

  if (!isText) {
    applyFilter(context, options, shared);
    fillElement(context, options, shared);
    strokeElement(context, options);
  }

  applyGradient(context, options, shared, element);
  context.restore();
  return promise;
}

function applyGradient(context, options, _ref, element) {
  var gradients = _ref.gradients;

  if (gradients.length === 0) {
    return;
  }

  var id = parseUrl(options.fill);

  if (id && gradients[id]) {
    var box = element.getBBox();
    var gradient = context.createLinearGradient(box.x, 0, box.x + box.width, 0);
    gradients[id].forEach(function (opt) {
      var offset = parseInt(opt.offset.replace(/%/, ''));
      gradient.addColorStop(offset / 100, opt.stopColor);
    });
    context.globalAlpha = options.opacity;
    context.fillStyle = gradient;
    context.fill();
  }
}

function applyFilter(context, options, shared) {
  var filterOptions;
  var id = parseUrl(options.filter);

  if (id) {
    filterOptions = shared.filters[id];

    if (!filterOptions) {
      filterOptions = {
        offsetX: 0,
        offsetY: 0,
        blur: 0,
        color: '#000'
      };
    }

    context.shadowOffsetX = filterOptions.offsetX;
    context.shadowOffsetY = filterOptions.offsetY;
    context.shadowColor = filterOptions.color;
    context.shadowBlur = filterOptions.blur;
  }
} // translate and clip are the special attributtes, they should not be inherited by child nodes


function transformElement(context, options) {
  context.translate(options.translateX || 0, options.translateY || 0);
  options.translateX = undefined;
  options.translateY = undefined;

  if (options.rotationAngle) {
    context.translate(options.rotationX || 0, options.rotationY || 0);
    context.rotate(options.rotationAngle * PI / 180);
    context.translate(-(options.rotationX || 0), -(options.rotationY || 0));
    options.rotationAngle = undefined;
    options.rotationX = undefined;
    options.rotationY = undefined;
  }

  if (isFinite(options.scaleX)) {
    context.scale(options.scaleX, options.scaleY);
    options.scaleX = undefined;
    options.scaleY = undefined;
  }
}

function clipElement(context, options, shared) {
  if (options['clip-path']) {
    drawElement(shared.clipPaths[parseUrl(options['clip-path'])], context, {}, shared);
    context.clip();
    options['clip-path'] = undefined;
  }
}

function hex2rgba(hexColor, alpha) {
  var color = new _color.default(hexColor);
  return 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + alpha + ')';
}

function createGradient(element) {
  var options = [];
  (0, _iterator.each)(element.childNodes, function (_, _ref2) {
    var attributes = _ref2.attributes;
    options.push({
      offset: attributes.offset.value,
      stopColor: attributes['stop-color'].value
    });
  });
  return options;
}

function createFilter(element) {
  var color;
  var opacity;
  var filterOptions = {};
  (0, _iterator.each)(element.childNodes, function (_, node) {
    var attr = node.attributes;

    if (!attr.result) {
      return;
    }

    switch (attr.result.value) {
      case 'gaussianBlurResult':
        filterOptions.blur = _number(attr.stdDeviation.value);
        break;

      case 'offsetResult':
        filterOptions.offsetX = _number(attr.dx.value);
        filterOptions.offsetY = _number(attr.dy.value);
        break;

      case 'floodResult':
        color = attr['flood-color'] ? attr['flood-color'].value : '#000';
        opacity = attr['flood-opacity'] ? attr['flood-opacity'].value : 1;
        filterOptions.color = hex2rgba(color, opacity);
        break;
    }
  });
  return filterOptions;
}

function asyncEach(array, callback) {
  var d = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _deferred.Deferred();
  var i = 0;

  for (; i < array.length; i++) {
    var result = callback(array[i]);

    if ((0, _type.isPromise)(result)) {
      result.then(function () {
        asyncEach(Array.prototype.slice.call(array, i + 1), callback, d);
      });
      break;
    }
  }

  if (i === array.length) {
    d.resolve();
  }

  return d;
}

function drawCanvasElements(elements, context, parentOptions, shared) {
  return asyncEach(elements, function (element) {
    switch (element.tagName && element.tagName.toLowerCase()) {
      case 'g':
      case 'svg':
        {
          var options = (0, _extend.extend)({}, parentOptions, getElementOptions(element, shared.rootAppended));
          context.save();
          transformElement(context, options);
          clipElement(context, options, shared);

          var onDone = function onDone() {
            context.restore();
          };

          var d = drawCanvasElements(element.childNodes, context, options, shared);

          if ((0, _type.isPromise)(d)) {
            d.then(onDone);
          } else {
            onDone();
          }

          return d;
        }

      case 'defs':
        return drawCanvasElements(element.childNodes, context, {}, shared);

      case 'clippath':
        shared.clipPaths[element.attributes.id.textContent] = element.childNodes[0];
        break;

      case 'pattern':
        shared.patterns[element.attributes.id.textContent] = element;
        break;

      case 'filter':
        shared.filters[element.id] = createFilter(element);
        break;

      case 'lineargradient':
        shared.gradients[element.attributes.id.textContent] = createGradient(element);
        break;

      default:
        return drawElement(element, context, parentOptions, shared);
    }
  });
}

function setLineDash(context, options) {
  var matches = options['stroke-dasharray'] && options['stroke-dasharray'].match(/(\d+)/g);

  if (matches && matches.length) {
    matches = (0, _iterator.map)(matches, function (item) {
      return _number(item);
    });
    context.setLineDash(matches);
  }
}

function strokeElement(context, options, isText) {
  var stroke = options.stroke;

  if (stroke && stroke !== 'none' && options['stroke-width'] !== 0) {
    setLineDash(context, options);
    context.lineJoin = options['stroke-linejoin'];
    context.lineWidth = options['stroke-width'];
    context.globalAlpha = options.strokeOpacity;
    context.strokeStyle = stroke;
    isText ? context.strokeText(options.text, options.x, options.y) : context.stroke();
    context.globalAlpha = 1;
  }
}

function getPattern(context, pattern, shared) {
  var options = getElementOptions(pattern, shared.rootAppended);
  var patternCanvas = createCanvas(options.width, options.height, 0);
  var patternContext = patternCanvas.getContext('2d');
  drawCanvasElements(pattern.childNodes, patternContext, options, shared);
  return context.createPattern(patternCanvas, 'repeat');
}

function fillElement(context, options, shared) {
  var fill = options.fill;

  if (fill && fill !== 'none') {
    if (fill.search(/url/) === -1) {
      context.fillStyle = fill;
    } else {
      var pattern = shared.patterns[parseUrl(fill)];

      if (!pattern) {
        return;
      }

      context.fillStyle = getPattern(context, pattern, shared);
    }

    context.globalAlpha = options.fillOpacity;
    context.fill();
    context.globalAlpha = 1;
  }
}

parseAttributes = function parseAttributes(attributes) {
  var newAttributes = {};
  var attr;
  (0, _iterator.each)(attributes, function (index, item) {
    attr = item.textContent;

    if (isFinite(attr)) {
      attr = _number(attr);
    }

    newAttributes[item.name.toLowerCase()] = attr; // lowerCase for Edge
  });
  return newAttributes;
};

function drawBackground(context, width, height, backgroundColor, margin) {
  context.fillStyle = backgroundColor || '#ffffff';
  context.fillRect(-margin, -margin, width + margin * 2, height + margin * 2);
}

function createInvisibleDiv() {
  var invisibleDiv = _dom_adapter.default.createElement('div');

  invisibleDiv.style.left = '-9999px';
  invisibleDiv.style.position = 'absolute';
  return invisibleDiv;
}

function convertSvgToCanvas(svg, canvas, rootAppended) {
  return drawCanvasElements(svg.childNodes, canvas.getContext('2d'), {}, {
    clipPaths: {},
    patterns: {},
    filters: {},
    gradients: {},
    rootAppended: rootAppended
  });
}

function getCanvasFromSvg(markup, width, height, backgroundColor, margin, pixelRatio) {
  var svgToCanvas = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : convertSvgToCanvas;
  var canvas = createCanvas(width, height, margin);
  var context = canvas.getContext('2d');
  context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
  var svgElem = (0, _svg.getSvgElement)(markup);
  var invisibleDiv;

  var markupIsDomElement = _dom_adapter.default.isElementNode(markup);

  context.translate(margin, margin);

  _dom_adapter.default.getBody().appendChild(canvas);

  if (!markupIsDomElement) {
    invisibleDiv = createInvisibleDiv();
    invisibleDiv.appendChild(svgElem);

    _dom_adapter.default.getBody().appendChild(invisibleDiv);
  } // for rtl mode


  if (svgElem.attributes.direction) {
    canvas.dir = svgElem.attributes.direction.textContent;
  }

  drawBackground(context, width, height, backgroundColor, margin);
  return (0, _deferred.fromPromise)(svgToCanvas(svgElem, canvas, markupIsDomElement && (0, _dom.contains)(_dom_adapter.default.getBody(), markup))).then(function () {
    return canvas;
  }).always(function () {
    invisibleDiv && _dom_adapter.default.getBody().removeChild(invisibleDiv);

    _dom_adapter.default.getBody().removeChild(canvas);
  });
}

var imageCreator = {
  getImageData: function getImageData(markup, options) {
    var pixelRatio = window.devicePixelRatio || 1;
    var mimeType = 'image/' + options.format;
    var width = options.width * pixelRatio;
    var height = options.height * pixelRatio;
    var backgroundColor = options.backgroundColor; // Injection for testing T403049

    if ((0, _type.isFunction)(options.__parseAttributesFn)) {
      parseAttributes = options.__parseAttributesFn;
    }

    return getCanvasFromSvg(markup, width, height, backgroundColor, options.margin, pixelRatio, options.svgToCanvas).then(function (canvas) {
      return getStringFromCanvas(canvas, mimeType);
    });
  },
  getData: function getData(markup, options) {
    var that = this;
    return imageCreator.getImageData(markup, options).then(function (binaryData) {
      var mimeType = 'image/' + options.format;
      var data = (0, _type.isFunction)(window.Blob) && !options.forceProxy ? that._getBlob(binaryData, mimeType) : that._getBase64(binaryData);
      return data;
    });
  },
  _getBlob: function _getBlob(binaryData, mimeType) {
    var i;
    var dataArray = new Uint8Array(binaryData.length);

    for (i = 0; i < binaryData.length; i++) {
      dataArray[i] = binaryData.charCodeAt(i);
    }

    return new window.Blob([dataArray.buffer], {
      type: mimeType
    });
  },
  _getBase64: function _getBase64(binaryData) {
    return window.btoa(binaryData);
  }
};
exports.imageCreator = imageCreator;

function getData(data, options) {
  return imageCreator.getData(data, options);
}

function testFormats(formats) {
  var canvas = createCanvas(100, 100, 0);
  return formats.reduce(function (r, f) {
    var mimeType = ('image/' + f).toLowerCase();

    if (canvas.toDataURL(mimeType).indexOf(mimeType) !== -1) {
      r.supported.push(f);
    } else {
      r.unsupported.push(f);
    }

    return r;
  }, {
    supported: [],
    unsupported: []
  });
}

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Export = void 0;

var _type = __webpack_require__(1);

var _message = _interopRequireDefault(__webpack_require__(10));

var _export_format = __webpack_require__(374);

var _export_merged_ranges_manager = __webpack_require__(375);

var _extend = __webpack_require__(0);

var _window = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// docs.microsoft.com/en-us/office/troubleshoot/excel/determine-column-widths - "Description of how column widths are determined in Excel"
var MAX_DIGIT_WIDTH_IN_PIXELS = 7; // Calibri font with 11pt size
// support.office.com/en-us/article/change-the-column-width-and-row-height-72f5e3cc-994d-43e8-ae58-9774a0905f46 - "Column.Max - 255"
// support.office.com/en-us/article/excel-specifications-and-limits-1672b34d-7043-467e-8e27-269d656771c3 - "Column width limit - 255 characters"

var MAX_EXCEL_COLUMN_WIDTH = 255;
var Export = {
  getFullOptions: function getFullOptions(options) {
    var fullOptions = (0, _extend.extend)({}, options);

    if (!((0, _type.isDefined)(fullOptions.worksheet) && (0, _type.isObject)(fullOptions.worksheet))) {
      throw Error('The "worksheet" field must contain an object.');
    }

    if (!(0, _type.isDefined)(fullOptions.topLeftCell)) {
      fullOptions.topLeftCell = {
        row: 1,
        column: 1
      };
    } else if ((0, _type.isString)(fullOptions.topLeftCell)) {
      var _fullOptions$workshee = fullOptions.worksheet.getCell(fullOptions.topLeftCell),
          row = _fullOptions$workshee.row,
          col = _fullOptions$workshee.col;

      fullOptions.topLeftCell = {
        row: row,
        column: col
      };
    }

    if (!(0, _type.isDefined)(fullOptions.keepColumnWidths)) {
      fullOptions.keepColumnWidths = true;
    }

    if (!(0, _type.isDefined)(fullOptions.loadPanel)) {
      fullOptions.loadPanel = {};
    }

    if (!(0, _type.isDefined)(fullOptions.loadPanel.enabled)) {
      fullOptions.loadPanel.enabled = true;
    }

    if (!(0, _type.isDefined)(fullOptions.loadPanel.text)) {
      fullOptions.loadPanel.text = _message.default.format('dxDataGrid-exporting');
    }

    return fullOptions;
  },
  convertDateForExcelJS: function convertDateForExcelJS(date) {
    return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  },
  setNumberFormat: function setNumberFormat(excelCell, numberFormat) {
    excelCell.numFmt = numberFormat;
  },
  getCellStyles: function getCellStyles(dataProvider) {
    var _this = this;

    var styles = dataProvider.getStyles();
    styles.forEach(function (style) {
      var numberFormat = _this.tryConvertToExcelNumberFormat(style.format, style.dataType);

      if ((0, _type.isDefined)(numberFormat)) {
        numberFormat = numberFormat.replace(/&quot;/g, '"');
      }

      style.numberFormat = numberFormat;
    });
    return styles;
  },
  tryConvertToExcelNumberFormat: function tryConvertToExcelNumberFormat(format, dataType) {
    var newFormat = _export_format.ExportFormat.formatObjectConverter(format, dataType);

    var currency = newFormat.currency;
    format = newFormat.format;
    dataType = newFormat.dataType;
    return _export_format.ExportFormat.convertFormat(format, newFormat.precision, dataType, currency);
  },
  setAlignment: function setAlignment(excelCell, wrapText, horizontalAlignment) {
    excelCell.alignment = excelCell.alignment || {};

    if ((0, _type.isDefined)(wrapText)) {
      excelCell.alignment.wrapText = wrapText;
    }

    if ((0, _type.isDefined)(horizontalAlignment)) {
      excelCell.alignment.horizontal = horizontalAlignment;
    }

    excelCell.alignment.vertical = 'top';
  },
  setColumnsWidth: function setColumnsWidth(worksheet, widths, startColumnIndex) {
    if (!(0, _type.isDefined)(widths)) {
      return;
    }

    for (var i = 0; i < widths.length; i++) {
      var columnWidth = widths[i];

      if (typeof columnWidth === 'number' && isFinite(columnWidth)) {
        worksheet.getColumn(startColumnIndex + i).width = Math.min(MAX_EXCEL_COLUMN_WIDTH, Math.floor(columnWidth / MAX_DIGIT_WIDTH_IN_PIXELS * 100) / 100);
      }
    }
  },
  setLoadPanelOptions: function setLoadPanelOptions(component, options, renderLoadPanel) {
    if (!(0, _window.hasWindow)()) {
      return;
    }

    component._setOptionWithoutOptionChange('loadPanel', options);

    renderLoadPanel(component);
  },
  export: function _export(options, helpers) {
    var _component$_getIntern,
        _this2 = this;

    var customizeCell = options.customizeCell,
        component = options.component,
        worksheet = options.worksheet,
        topLeftCell = options.topLeftCell,
        autoFilterEnabled = options.autoFilterEnabled,
        keepColumnWidths = options.keepColumnWidths,
        selectedRowsOnly = options.selectedRowsOnly,
        loadPanel = options.loadPanel,
        mergeRowFieldValues = options.mergeRowFieldValues,
        mergeColumnFieldValues = options.mergeColumnFieldValues;
    var internalComponent = ((_component$_getIntern = component._getInternalInstance) === null || _component$_getIntern === void 0 ? void 0 : _component$_getIntern.call(component)) || component;
    var initialLoadPanelOptions = (0, _extend.extend)({}, internalComponent.option('loadPanel'));

    if ('animation' in internalComponent.option('loadPanel')) {
      loadPanel.animation = null;
    }

    this.setLoadPanelOptions(internalComponent, loadPanel, helpers._renderLoadPanel);
    var wrapText = !!component.option('wordWrapEnabled');
    worksheet.properties.outlineProperties = {
      summaryBelow: false,
      summaryRight: false
    };
    var cellRange = {
      from: {
        row: topLeftCell.row,
        column: topLeftCell.column
      },
      to: {
        row: topLeftCell.row,
        column: topLeftCell.column
      }
    };
    var dataProvider = component.getDataProvider(selectedRowsOnly);
    return new Promise(function (resolve) {
      dataProvider.ready().done(function () {
        var columns = dataProvider.getColumns();
        var dataRowsCount = dataProvider.getRowsCount();

        if (keepColumnWidths) {
          _this2.setColumnsWidth(worksheet, dataProvider.getColumnsWidths(), cellRange.from.column);
        }

        var mergedRangesManager = new _export_merged_ranges_manager.MergedRangesManager(dataProvider, helpers, mergeRowFieldValues, mergeColumnFieldValues);

        var styles = _this2.getCellStyles(dataProvider);

        for (var rowIndex = 0; rowIndex < dataRowsCount; rowIndex++) {
          var row = worksheet.getRow(cellRange.from.row + rowIndex);

          helpers._trySetOutlineLevel(dataProvider, row, rowIndex);

          _this2.exportRow(dataProvider, helpers, mergedRangesManager, rowIndex, columns.length, row, cellRange.from.column, customizeCell, wrapText, styles);

          if (rowIndex >= 1) {
            cellRange.to.row++;
          }
        }

        mergedRangesManager.applyMergedRages(worksheet);
        cellRange.to.column += columns.length > 0 ? columns.length - 1 : 0;
        var worksheetViewSettings = worksheet.views[0] || {};

        if (component.option('rtlEnabled')) {
          worksheetViewSettings.rightToLeft = true;
        }

        if (helpers._isFrozenZone(dataProvider)) {
          if (Object.keys(worksheetViewSettings).indexOf('state') === -1) {
            (0, _extend.extend)(worksheetViewSettings, helpers._getWorksheetFrozenState(dataProvider, cellRange));
          }

          helpers._trySetAutoFilter(dataProvider, worksheet, cellRange, autoFilterEnabled);
        }

        if (Object.keys(worksheetViewSettings).length > 0) {
          worksheet.views = [worksheetViewSettings];
        }

        resolve(cellRange);
      }).always(function () {
        _this2.setLoadPanelOptions(internalComponent, initialLoadPanelOptions, helpers._renderLoadPanel);
      });
    });
  },
  exportRow: function exportRow(dataProvider, helpers, mergedRangesManager, rowIndex, cellCount, row, startColumnIndex, customizeCell, wrapText, styles) {
    for (var cellIndex = 0; cellIndex < cellCount; cellIndex++) {
      var cellData = dataProvider.getCellData(rowIndex, cellIndex, true);
      var excelCell = row.getCell(startColumnIndex + cellIndex);
      mergedRangesManager.updateMergedRanges(excelCell, rowIndex, cellIndex);
      var cellInfo = mergedRangesManager.findMergedCellInfo(rowIndex, cellIndex);

      if ((0, _type.isDefined)(cellInfo) && excelCell !== cellInfo.masterCell) {
        excelCell.style = cellInfo.masterCell.style;
        excelCell.value = cellInfo.masterCell.value;
      } else {
        if ((0, _type.isDate)(cellData.value)) {
          excelCell.value = this.convertDateForExcelJS(cellData.value);
        } else {
          excelCell.value = cellData.value;
        }

        if ((0, _type.isDefined)(excelCell.value)) {
          var _styles$dataProvider$ = styles[dataProvider.getStyleId(rowIndex, cellIndex)],
              bold = _styles$dataProvider$.bold,
              horizontalAlignment = _styles$dataProvider$.alignment,
              numberFormat = _styles$dataProvider$.numberFormat;

          if ((0, _type.isDefined)(numberFormat)) {
            this.setNumberFormat(excelCell, numberFormat);
          } else if ((0, _type.isString)(excelCell.value) && /^[@=+-]/.test(excelCell.value)) {
            this.setNumberFormat(excelCell, '@');
          }

          helpers._trySetFont(excelCell, bold);

          this.setAlignment(excelCell, wrapText, horizontalAlignment);
        }
      }

      if ((0, _type.isFunction)(customizeCell)) {
        customizeCell(helpers._getCustomizeCellOptions(excelCell, cellData.cellSourceData));
      }
    }
  }
};
exports.Export = Export;

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.equals = void 0;

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _data = __webpack_require__(21);

var _type = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var hasNegation = function hasNegation(oldValue, newValue) {
  return 1 / oldValue === 1 / newValue;
};

var equals = function equals(oldValue, newValue) {
  oldValue = (0, _data.toComparable)(oldValue, true);
  newValue = (0, _data.toComparable)(newValue, true);

  if (oldValue && newValue && (0, _type.isRenderer)(oldValue) && (0, _type.isRenderer)(newValue)) {
    return newValue.is(oldValue);
  }

  var oldValueIsNaN = oldValue !== oldValue;
  var newValueIsNaN = newValue !== newValue;

  if (oldValueIsNaN && newValueIsNaN) {
    return true;
  }

  if (oldValue === 0 && newValue === 0) {
    return hasNegation(oldValue, newValue);
  }

  if (oldValue === null || _typeof(oldValue) !== 'object' || _dom_adapter.default.isElementNode(oldValue)) {
    return oldValue === newValue;
  }

  return false;
};

exports.equals = equals;

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.acquireTemplate = exports.acquireIntegrationTemplate = exports.defaultCreateElement = exports.templateKey = exports.validateTemplateSource = exports.getNormalizedTemplateArgs = exports.addOneRenderedCall = exports.suitableTemplatesByName = exports.findTemplates = void 0;

var _config = _interopRequireDefault(__webpack_require__(29));

var _devices = _interopRequireDefault(__webpack_require__(13));

var _errors = _interopRequireDefault(__webpack_require__(24));

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _child_default_template = __webpack_require__(164);

var _empty_template = __webpack_require__(93);

var _template = __webpack_require__(383);

var _template_base = __webpack_require__(69);

var _array = __webpack_require__(12);

var _common = __webpack_require__(4);

var _dom = __webpack_require__(35);

var _extend = __webpack_require__(0);

var _type = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var findTemplates = function findTemplates(element, name) {
  var optionsAttributeName = 'data-options';
  var templates = (0, _renderer.default)(element).contents().filter("[".concat(optionsAttributeName, "*=\"").concat(name, "\"]"));
  return [].slice.call(templates).map(function (element) {
    var optionsString = (0, _renderer.default)(element).attr(optionsAttributeName) || '';
    return {
      element: element,
      options: (0, _config.default)().optionsParser(optionsString)[name]
    };
  }).filter(function (template) {
    return !!template.options;
  });
};

exports.findTemplates = findTemplates;

var suitableTemplatesByName = function suitableTemplatesByName(rawTemplates) {
  var templatesMap = (0, _array.groupBy)(rawTemplates, function (template) {
    return template.options.name;
  });

  if (templatesMap[undefined]) {
    throw _errors.default.Error('E0023');
  }

  var result = {};
  Object.keys(templatesMap).forEach(function (name) {
    var _findBestMatches$;

    var suitableTemplate = (_findBestMatches$ = (0, _common.findBestMatches)(_devices.default.current(), templatesMap[name], function (template) {
      return template.options;
    })[0]) === null || _findBestMatches$ === void 0 ? void 0 : _findBestMatches$.element;

    if (suitableTemplate) {
      result[name] = suitableTemplate;
    }
  });
  return result;
};

exports.suitableTemplatesByName = suitableTemplatesByName;

var addOneRenderedCall = function addOneRenderedCall(template) {
  var _render = template.render.bind(template);

  return (0, _extend.extend)({}, template, {
    render: function render(options) {
      var templateResult = _render(options);

      options && options.onRendered && options.onRendered();
      return templateResult;
    }
  });
};

exports.addOneRenderedCall = addOneRenderedCall;

var getNormalizedTemplateArgs = function getNormalizedTemplateArgs(options) {
  var args = [];

  if ('model' in options) {
    args.push(options.model);
  }

  if ('index' in options) {
    args.push(options.index);
  }

  args.push(options.container);
  return args;
};

exports.getNormalizedTemplateArgs = getNormalizedTemplateArgs;

var validateTemplateSource = function validateTemplateSource(templateSource) {
  return typeof templateSource === 'string' ? (0, _dom.normalizeTemplateElement)(templateSource) : templateSource;
};

exports.validateTemplateSource = validateTemplateSource;

var templateKey = function templateKey(templateSource) {
  return (0, _type.isRenderer)(templateSource) && templateSource[0] || templateSource;
};

exports.templateKey = templateKey;

var defaultCreateElement = function defaultCreateElement(element) {
  return new _template.Template(element);
};

exports.defaultCreateElement = defaultCreateElement;

var acquireIntegrationTemplate = function acquireIntegrationTemplate(templateSource, templates, isAsyncTemplate, skipTemplates) {
  var integrationTemplate = null;

  if (!skipTemplates || skipTemplates.indexOf(templateSource) === -1) {
    integrationTemplate = templates[templateSource];

    if (integrationTemplate && !(integrationTemplate instanceof _template_base.TemplateBase) && !isAsyncTemplate) {
      integrationTemplate = addOneRenderedCall(integrationTemplate);
    }
  }

  return integrationTemplate;
};

exports.acquireIntegrationTemplate = acquireIntegrationTemplate;

var acquireTemplate = function acquireTemplate(templateSource, createTemplate, templates, isAsyncTemplate, skipTemplates, defaultTemplates) {
  if (templateSource == null) {
    return new _empty_template.EmptyTemplate();
  }

  if (templateSource instanceof _child_default_template.ChildDefaultTemplate) {
    return defaultTemplates[templateSource.name];
  }

  if (templateSource instanceof _template_base.TemplateBase) {
    return templateSource;
  } // TODO: templateSource.render is needed for angular2 integration. Try to remove it after supporting TypeScript modules.


  if ((0, _type.isFunction)(templateSource.render) && !(0, _type.isRenderer)(templateSource)) {
    return isAsyncTemplate ? templateSource : addOneRenderedCall(templateSource);
  }

  if (templateSource.nodeType || (0, _type.isRenderer)(templateSource)) {
    return createTemplate((0, _renderer.default)(templateSource));
  }

  return acquireIntegrationTemplate(templateSource, templates, isAsyncTemplate, skipTemplates) || defaultTemplates[templateSource] || createTemplate(templateSource);
};

exports.acquireTemplate = acquireTemplate;

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _devices = _interopRequireDefault(__webpack_require__(13));

var _extend = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _base = _interopRequireDefault(__webpack_require__(165));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var eventMap = {
  'dxpointerdown': 'touchstart',
  'dxpointermove': 'touchmove',
  'dxpointerup': 'touchend',
  'dxpointercancel': 'touchcancel',
  'dxpointerover': '',
  'dxpointerout': '',
  'dxpointerenter': '',
  'dxpointerleave': ''
};

var normalizeTouchEvent = function normalizeTouchEvent(e) {
  var pointers = [];
  (0, _iterator.each)(e.touches, function (_, touch) {
    pointers.push((0, _extend.extend)({
      pointerId: touch.identifier
    }, touch));
  });
  return {
    pointers: pointers,
    pointerId: e.changedTouches[0].identifier
  };
};

var skipTouchWithSameIdentifier = function skipTouchWithSameIdentifier(pointerEvent) {
  return _devices.default.real().platform === 'ios' && (pointerEvent === 'dxpointerdown' || pointerEvent === 'dxpointerup');
};

var TouchStrategy = _base.default.inherit({
  ctor: function ctor() {
    this.callBase.apply(this, arguments);
    this._pointerId = 0;
  },
  _handler: function _handler(e) {
    if (skipTouchWithSameIdentifier(this._eventName)) {
      var touch = e.changedTouches[0];

      if (this._pointerId === touch.identifier && this._pointerId !== 0) {
        return;
      }

      this._pointerId = touch.identifier;
    }

    return this.callBase.apply(this, arguments);
  },
  _fireEvent: function _fireEvent(args) {
    return this.callBase((0, _extend.extend)(normalizeTouchEvent(args.originalEvent), args));
  }
});

TouchStrategy.map = eventMap;
TouchStrategy.normalize = normalizeTouchEvent;
var _default = TouchStrategy;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _iterator = __webpack_require__(3);

var _ready_callbacks = _interopRequireDefault(__webpack_require__(51));

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var addEventsListener = function addEventsListener(events, handler) {
  _ready_callbacks.default.add(function () {
    events.split(' ').forEach(function (event) {
      _dom_adapter.default.listen(_dom_adapter.default.getDocument(), event, handler, true);
    });
  });
};

var Observer = function Observer(eventMap, pointerEquals, onPointerAdding) {
  onPointerAdding = onPointerAdding || function () {};

  var pointers = [];

  var getPointerIndex = function getPointerIndex(e) {
    var index = -1;
    (0, _iterator.each)(pointers, function (i, pointer) {
      if (!pointerEquals(e, pointer)) {
        return true;
      }

      index = i;
      return false;
    });
    return index;
  };

  var addPointer = function addPointer(e) {
    if (getPointerIndex(e) === -1) {
      onPointerAdding(e);
      pointers.push(e);
    }
  };

  var removePointer = function removePointer(e) {
    var index = getPointerIndex(e);

    if (index > -1) {
      pointers.splice(index, 1);
    }
  };

  var updatePointer = function updatePointer(e) {
    pointers[getPointerIndex(e)] = e;
  };

  addEventsListener(eventMap['dxpointerdown'], addPointer);
  addEventsListener(eventMap['dxpointermove'], updatePointer);
  addEventsListener(eventMap['dxpointerup'], removePointer);
  addEventsListener(eventMap['dxpointercancel'], removePointer);

  this.pointers = function () {
    return pointers;
  };

  this.reset = function () {
    pointers = [];
  };
};

var _default = Observer;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _extend = __webpack_require__(0);

var _base = _interopRequireDefault(__webpack_require__(165));

var _observer = _interopRequireDefault(__webpack_require__(263));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var eventMap = {
  'dxpointerdown': 'mousedown',
  'dxpointermove': 'mousemove',
  'dxpointerup': 'mouseup',
  'dxpointercancel': '',
  'dxpointerover': 'mouseover',
  'dxpointerout': 'mouseout',
  'dxpointerenter': 'mouseenter',
  'dxpointerleave': 'mouseleave'
};

var normalizeMouseEvent = function normalizeMouseEvent(e) {
  e.pointerId = 1;
  return {
    pointers: observer.pointers(),
    pointerId: 1
  };
};

var observer;
var activated = false;

var activateStrategy = function activateStrategy() {
  if (activated) {
    return;
  }

  observer = new _observer.default(eventMap, function () {
    return true;
  });
  activated = true;
};

var MouseStrategy = _base.default.inherit({
  ctor: function ctor() {
    this.callBase.apply(this, arguments);
    activateStrategy();
  },
  _fireEvent: function _fireEvent(args) {
    return this.callBase((0, _extend.extend)(normalizeMouseEvent(args.originalEvent), args));
  }
});

MouseStrategy.map = eventMap;
MouseStrategy.normalize = normalizeMouseEvent;
MouseStrategy.activate = activateStrategy;

MouseStrategy.resetObserver = function () {
  observer.reset();
};

var _default = MouseStrategy;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.queryImpl = void 0;

var _array_query = _interopRequireDefault(__webpack_require__(166));

var _remote_query = _interopRequireDefault(__webpack_require__(391));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var queryImpl = {
  array: _array_query.default,
  remote: _remote_query.default
};
exports.queryImpl = queryImpl;

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.create = createQueue;
exports.enqueue = void 0;

var _errors = _interopRequireDefault(__webpack_require__(24));

var _deferred = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createQueue(discardPendingTasks) {
  var _tasks = [];
  var _busy = false;

  function exec() {
    while (_tasks.length) {
      _busy = true;

      var task = _tasks.shift();

      var result = task();

      if (result === undefined) {
        continue;
      }

      if (result.then) {
        // NOTE: immediate "then" on the next line can reset it back to false
        (0, _deferred.when)(result).always(exec);
        return;
      }

      throw _errors.default.Error('E0015');
    }

    _busy = false;
  }

  function add(task, removeTaskCallback) {
    if (!discardPendingTasks) {
      _tasks.push(task);
    } else {
      if (_tasks[0] && removeTaskCallback) {
        removeTaskCallback(_tasks[0]);
      }

      _tasks = [task];
    }

    if (!_busy) {
      exec();
    }
  }

  function busy() {
    return _busy;
  }

  return {
    add: add,
    busy: busy
  };
}

var enqueue = createQueue().add; // Default global queue for UI sync, consider renaming

exports.enqueue = enqueue;

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.setEasing = setEasing;
exports.getEasing = getEasing;
exports.convertTransitionTimingFuncToEasing = void 0;

var _type = __webpack_require__(1);

var CSS_TRANSITION_EASING_REGEX = /cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/;
var TransitionTimingFuncMap = {
  'linear': 'cubic-bezier(0, 0, 1, 1)',
  'swing': 'cubic-bezier(0.445, 0.05, 0.55, 0.95)',
  'ease': 'cubic-bezier(0.25, 0.1, 0.25, 1)',
  'ease-in': 'cubic-bezier(0.42, 0, 1, 1)',
  'ease-out': 'cubic-bezier(0, 0, 0.58, 1)',
  'ease-in-out': 'cubic-bezier(0.42, 0, 0.58, 1)'
};

var polynomBezier = function polynomBezier(x1, y1, x2, y2) {
  var Cx = 3 * x1;
  var Bx = 3 * (x2 - x1) - Cx;
  var Ax = 1 - Cx - Bx;
  var Cy = 3 * y1;
  var By = 3 * (y2 - y1) - Cy;
  var Ay = 1 - Cy - By;

  var bezierX = function bezierX(t) {
    return t * (Cx + t * (Bx + t * Ax));
  };

  var bezierY = function bezierY(t) {
    return t * (Cy + t * (By + t * Ay));
  };

  var derivativeX = function derivativeX(t) {
    return Cx + t * (2 * Bx + t * 3 * Ax);
  };

  var findXFor = function findXFor(t) {
    var x = t;
    var i = 0;
    var z;

    while (i < 14) {
      z = bezierX(x) - t;

      if (Math.abs(z) < 1e-3) {
        break;
      }

      x = x - z / derivativeX(x);
      i++;
    }

    return x;
  };

  return function (t) {
    return bezierY(findXFor(t));
  };
};

var easing = {};

var convertTransitionTimingFuncToEasing = function convertTransitionTimingFuncToEasing(cssTransitionEasing) {
  cssTransitionEasing = TransitionTimingFuncMap[cssTransitionEasing] || cssTransitionEasing;
  var coeffs = cssTransitionEasing.match(CSS_TRANSITION_EASING_REGEX);
  var forceName;

  if (!coeffs) {
    forceName = 'linear';
    coeffs = TransitionTimingFuncMap[forceName].match(CSS_TRANSITION_EASING_REGEX);
  }

  coeffs = coeffs.slice(1, 5);

  for (var i = 0; i < coeffs.length; i++) {
    coeffs[i] = parseFloat(coeffs[i]);
  }

  var easingName = forceName || 'cubicbezier_' + coeffs.join('_').replace(/\./g, 'p');

  if (!(0, _type.isFunction)(easing[easingName])) {
    easing[easingName] = function (x, t, b, c, d) {
      return c * polynomBezier(coeffs[0], coeffs[1], coeffs[2], coeffs[3])(t / d) + b;
    };
  }

  return easingName;
};

exports.convertTransitionTimingFuncToEasing = convertTransitionTimingFuncToEasing;

function setEasing(value) {
  easing = value;
}

function getEasing(name) {
  return easing[name];
}

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _jquery = _interopRequireDefault(__webpack_require__(56));

var _version = __webpack_require__(71);

var _error = _interopRequireDefault(__webpack_require__(142));

var _use_jquery = _interopRequireDefault(__webpack_require__(87));

__webpack_require__(397);

__webpack_require__(398);

__webpack_require__(399);

__webpack_require__(400);

__webpack_require__(401);

__webpack_require__(402);

__webpack_require__(403);

__webpack_require__(404);

__webpack_require__(405);

__webpack_require__(406);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
var useJQuery = (0, _use_jquery.default)();

if (useJQuery && (0, _version.compare)(_jquery.default.fn.jquery, [1, 10]) < 0) {
  throw _error.default.Error('E0012');
}

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _errors = _interopRequireDefault(__webpack_require__(24));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Locker = function Locker() {
  var info = {};

  var currentCount = function currentCount(lockName) {
    return info[lockName] || 0;
  };

  return {
    obtain: function obtain(lockName) {
      info[lockName] = currentCount(lockName) + 1;
    },
    release: function release(lockName) {
      var count = currentCount(lockName);

      if (count < 1) {
        throw _errors.default.Error('E0014');
      }

      if (count === 1) {
        delete info[lockName];
      } else {
        info[lockName] = count - 1;
      }
    },
    locked: function locked(lockName) {
      return currentCount(lockName) > 0;
    }
  };
};

var _default = Locker;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _query = _interopRequireDefault(__webpack_require__(49));

var _common = __webpack_require__(4);

var _type = __webpack_require__(1);

var _class = _interopRequireDefault(__webpack_require__(15));

var _deferred = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = _class.default.inherit({
  ctor: function ctor(options) {
    this.options = options;

    this._setOption('disabledItemKeys', []);

    this._clearItemKeys();
  },
  _clearItemKeys: function _clearItemKeys() {
    this._setOption('addedItemKeys', []);

    this._setOption('removedItemKeys', []);

    this._setOption('removedItems', []);

    this._setOption('addedItems', []);
  },
  validate: _common.noop,
  _setOption: function _setOption(name, value) {
    this.options[name] = value;
  },
  onSelectionChanged: function onSelectionChanged() {
    var addedItemKeys = this.options.addedItemKeys;
    var removedItemKeys = this.options.removedItemKeys;
    var addedItems = this.options.addedItems;
    var removedItems = this.options.removedItems;
    var selectedItems = this.options.selectedItems;
    var selectedItemKeys = this.options.selectedItemKeys;
    var onSelectionChanged = this.options.onSelectionChanged || _common.noop;

    this._clearItemKeys();

    onSelectionChanged({
      selectedItems: selectedItems,
      selectedItemKeys: selectedItemKeys,
      addedItemKeys: addedItemKeys,
      removedItemKeys: removedItemKeys,
      addedItems: addedItems,
      removedItems: removedItems
    });
  },
  equalKeys: function equalKeys(key1, key2) {
    if (this.options.equalByReference) {
      if ((0, _type.isObject)(key1) && (0, _type.isObject)(key2)) {
        return key1 === key2;
      }
    }

    return (0, _common.equalByValue)(key1, key2);
  },
  getSelectableItems: function getSelectableItems(items) {
    return items.filter(function (item) {
      return !item.disabled;
    });
  },
  _clearSelection: function _clearSelection(keys, preserve, isDeselect, isSelectAll) {
    keys = keys || [];
    keys = Array.isArray(keys) ? keys : [keys];
    this.validate();
    return this.selectedItemKeys(keys, preserve, isDeselect, isSelectAll);
  },
  _loadFilteredData: function _loadFilteredData(remoteFilter, localFilter, select, isSelectAll) {
    var filterLength = encodeURI(JSON.stringify(remoteFilter)).length;
    var needLoadAllData = this.options.maxFilterLengthInRequest && filterLength > this.options.maxFilterLengthInRequest;
    var deferred = new _deferred.Deferred();
    var loadOptions = {
      filter: needLoadAllData ? undefined : remoteFilter,
      select: needLoadAllData ? this.options.dataFields() : select || this.options.dataFields()
    };

    if (remoteFilter && remoteFilter.length === 0) {
      deferred.resolve([]);
    } else {
      this.options.load(loadOptions).done(function (items) {
        var filteredItems = (0, _type.isPlainObject)(items) ? items.data : items;

        if (localFilter && !isSelectAll) {
          filteredItems = filteredItems.filter(localFilter);
        } else if (needLoadAllData) {
          filteredItems = (0, _query.default)(filteredItems).filter(remoteFilter).toArray();
        }

        deferred.resolve(filteredItems);
      }).fail(deferred.reject.bind(deferred));
    }

    return deferred;
  },
  updateSelectedItemKeyHash: function updateSelectedItemKeyHash(keys) {
    for (var i = 0; i < keys.length; i++) {
      var keyHash = (0, _common.getKeyHash)(keys[i]);

      if (!(0, _type.isObject)(keyHash)) {
        this.options.keyHashIndices[keyHash] = this.options.keyHashIndices[keyHash] || [];
        var keyIndices = this.options.keyHashIndices[keyHash];
        keyIndices.push(i);
      }
    }
  },
  _isAnyItemSelected: function _isAnyItemSelected(items) {
    for (var i = 0; i < items.length; i++) {
      if (this.options.isItemSelected(items[i])) {
        return undefined;
      }
    }

    return false;
  },
  _getFullSelectAllState: function _getFullSelectAllState() {
    var items = this.options.plainItems();
    var dataFilter = this.options.filter();
    var selectedItems = this.options.selectedItems;

    if (dataFilter) {
      selectedItems = (0, _query.default)(selectedItems).filter(dataFilter).toArray();
    }

    var selectedItemsLength = selectedItems.length;

    if (!selectedItemsLength) {
      return this._isAnyItemSelected(items);
    }

    if (selectedItemsLength >= this.options.totalCount() - this.options.disabledItemKeys.length) {
      return true;
    }

    return undefined;
  },
  _getVisibleSelectAllState: function _getVisibleSelectAllState() {
    var items = this.getSelectableItems(this.options.plainItems());
    var hasSelectedItems = false;
    var hasUnselectedItems = false;

    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var itemData = this.options.getItemData(item);
      var key = this.options.keyOf(itemData);

      if (this.options.isSelectableItem(item)) {
        if (this.isItemKeySelected(key)) {
          hasSelectedItems = true;
        } else {
          hasUnselectedItems = true;
        }
      }
    }

    if (hasSelectedItems) {
      return !hasUnselectedItems ? true : undefined;
    } else {
      return false;
    }
  }
});

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getClosestNodeWithContext = void 0;

var _knockout = _interopRequireDefault(__webpack_require__(62));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
var getClosestNodeWithContext = function getClosestNodeWithContext(node) {
  var context = _knockout.default.contextFor(node);

  if (!context && node.parentNode) {
    return getClosestNodeWithContext(node.parentNode);
  }

  return node;
};

exports.getClosestNodeWithContext = getClosestNodeWithContext;

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint-disable import/no-commonjs */
var DevExpress = __webpack_require__(191); /// BUNDLER_PARTS

/* Data (dx.module-core.js) */


var data = DevExpress.data = __webpack_require__(273);

data.odata = __webpack_require__(433); /// BUNDLER_PARTS_END

module.exports = data;

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint-disable import/no-commonjs */
var DevExpress = __webpack_require__(146);

var errors = __webpack_require__(24);

module.exports = DevExpress.data = DevExpress.data || {};
Object.defineProperty(DevExpress.data, 'errorHandler', {
  get: function get() {
    return __webpack_require__(37).errorHandler;
  },
  set: function set(value) {
    errors.log('W0003', 'DevExpress.data', 'errorHandler', '21.1', 'Use the \'setErrorHandler\' method instead');

    __webpack_require__(37).setErrorHandler(value);
  }
}); // TODO: try remove (plugins failed without this)

Object.defineProperty(DevExpress.data, '_errorHandler', {
  get: function get() {
    return __webpack_require__(37).handleError;
  },
  set: function set(value) {
    errors.log('W0003', 'DevExpress.data', '_errorHandler', '21.1', 'Use the \'setErrorHandler\' method instead');

    __webpack_require__(37).setErrorHandler(value);
  }
});
DevExpress.data.setErrorHandler = __webpack_require__(37).setErrorHandler;
DevExpress.data.DataSource = __webpack_require__(287);
DevExpress.data.query = __webpack_require__(49);
DevExpress.data.Store = __webpack_require__(106);
DevExpress.data.ArrayStore = __webpack_require__(84);
DevExpress.data.CustomStore = __webpack_require__(129);
DevExpress.data.LocalStore = __webpack_require__(430);
DevExpress.data.base64_encode = __webpack_require__(44).base64_encode;
DevExpress.data.applyChanges = __webpack_require__(431);
DevExpress.data.Guid = __webpack_require__(36);
DevExpress.data.utils = {};
DevExpress.data.utils.compileGetter = __webpack_require__(21).compileGetter;
DevExpress.data.utils.compileSetter = __webpack_require__(21).compileSetter;
DevExpress.EndpointSelector = __webpack_require__(432);
DevExpress.data.queryImpl = __webpack_require__(265).queryImpl;
DevExpress.data.queryAdapters = __webpack_require__(196);

var dataUtils = __webpack_require__(44);

DevExpress.data.utils.normalizeBinaryCriterion = dataUtils.normalizeBinaryCriterion;
DevExpress.data.utils.normalizeSortingInfo = dataUtils.normalizeSortingInfo;
DevExpress.data.utils.errorMessageFromXhr = dataUtils.errorMessageFromXhr;
DevExpress.data.utils.aggregators = dataUtils.aggregators;
DevExpress.data.utils.keysEqual = dataUtils.keysEqual;
DevExpress.data.utils.isDisjunctiveOperator = dataUtils.isDisjunctiveOperator;
DevExpress.data.utils.isConjunctiveOperator = dataUtils.isConjunctiveOperator;
DevExpress.data.utils.processRequestResultLock = dataUtils.processRequestResultLock;
DevExpress.data.utils.toComparable = __webpack_require__(21).toComparable;
DevExpress.data.utils.multiLevelGroup = __webpack_require__(95).multiLevelGroup;
DevExpress.data.utils.arrangeSortingInfo = __webpack_require__(95).arrangeSortingInfo;
DevExpress.data.utils.normalizeDataSourceOptions = __webpack_require__(65).normalizeDataSourceOptions;

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _type = __webpack_require__(1);

var _config = _interopRequireDefault(__webpack_require__(29));

var _utils = __webpack_require__(99);

var _errors = __webpack_require__(37);

var _query = _interopRequireDefault(__webpack_require__(49));

var _abstract_store = _interopRequireDefault(__webpack_require__(106));

var _request_dispatcher = _interopRequireDefault(__webpack_require__(275));

var _deferred = __webpack_require__(6);

__webpack_require__(168);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ANONYMOUS_KEY_NAME = '5d46402c-7899-4ea9-bd81-8b73c47c7683';

var expandKeyType = function expandKeyType(key, keyType) {
  return _defineProperty({}, key, keyType);
};

var mergeFieldTypesWithKeyType = function mergeFieldTypesWithKeyType(fieldTypes, keyType) {
  var result = {};

  for (var field in fieldTypes) {
    result[field] = fieldTypes[field];
  }

  for (var keyName in keyType) {
    if (keyName in result) {
      if (result[keyName] !== keyType[keyName]) {
        _errors.errors.log('W4001', keyName);
      }
    } else {
      result[keyName] = keyType[keyName];
    }
  }

  return result;
};

var ODataStore = _abstract_store.default.inherit({
  ctor: function ctor(options) {
    this.callBase(options);
    this._requestDispatcher = new _request_dispatcher.default(options);
    var key = this.key();
    var fieldTypes = options.fieldTypes;
    var keyType = options.keyType;

    if (keyType) {
      var keyTypeIsString = typeof keyType === 'string';

      if (!key) {
        key = keyTypeIsString ? ANONYMOUS_KEY_NAME : Object.keys(keyType);
        this._legacyAnonymousKey = key;
      }

      if (keyTypeIsString) {
        keyType = expandKeyType(key, keyType);
      }

      fieldTypes = mergeFieldTypesWithKeyType(fieldTypes, keyType);
    }

    this._fieldTypes = fieldTypes || {};

    if (this.version() === 2) {
      this._updateMethod = 'MERGE';
    } else {
      this._updateMethod = 'PATCH';
    }
  },
  _customLoadOptions: function _customLoadOptions() {
    return ['expand', 'customQueryParams'];
  },
  _byKeyImpl: function _byKeyImpl(key, extraOptions) {
    var params = {};

    if (extraOptions) {
      params['$expand'] = (0, _utils.generateExpand)(this.version(), extraOptions.expand, extraOptions.select) || undefined;
      params['$select'] = (0, _utils.generateSelect)(this.version(), extraOptions.select) || undefined;
    }

    return this._requestDispatcher.sendRequest(this._byKeyUrl(key), 'GET', params);
  },
  createQuery: function createQuery(loadOptions) {
    var _loadOptions$urlOverr;

    var url;
    var queryOptions = {
      adapter: 'odata',
      beforeSend: this._requestDispatcher.beforeSend,
      errorHandler: this._errorHandler,
      jsonp: this._requestDispatcher.jsonp,
      version: this._requestDispatcher.version,
      withCredentials: this._requestDispatcher._withCredentials,
      expand: loadOptions === null || loadOptions === void 0 ? void 0 : loadOptions.expand,
      requireTotalCount: loadOptions === null || loadOptions === void 0 ? void 0 : loadOptions.requireTotalCount,
      deserializeDates: this._requestDispatcher._deserializeDates,
      fieldTypes: this._fieldTypes
    }; // NOTE: For AppBuilder, do not remove

    url = (_loadOptions$urlOverr = loadOptions === null || loadOptions === void 0 ? void 0 : loadOptions.urlOverride) !== null && _loadOptions$urlOverr !== void 0 ? _loadOptions$urlOverr : this._requestDispatcher.url;

    if ((0, _type.isDefined)(this._requestDispatcher.filterToLower)) {
      queryOptions.filterToLower = this._requestDispatcher.filterToLower;
    }

    if (loadOptions !== null && loadOptions !== void 0 && loadOptions.customQueryParams) {
      var params = (0, _utils.escapeServiceOperationParams)(loadOptions === null || loadOptions === void 0 ? void 0 : loadOptions.customQueryParams, this.version());

      if (this.version() === 4) {
        url = (0, _utils.formatFunctionInvocationUrl)(url, params);
      } else {
        queryOptions.params = params;
      }
    }

    return (0, _query.default)(url, queryOptions);
  },
  _insertImpl: function _insertImpl(values) {
    var _this = this;

    this._requireKey();

    var d = new _deferred.Deferred();
    (0, _deferred.when)(this._requestDispatcher.sendRequest(this._requestDispatcher.url, 'POST', null, values)).done(function (serverResponse) {
      return d.resolve(serverResponse && !(0, _config.default)().useLegacyStoreResult ? serverResponse : values, _this.keyOf(serverResponse));
    }).fail(d.reject);
    return d.promise();
  },
  _updateImpl: function _updateImpl(key, values) {
    var d = new _deferred.Deferred();
    (0, _deferred.when)(this._requestDispatcher.sendRequest(this._byKeyUrl(key), this._updateMethod, null, values)).done(function (serverResponse) {
      return (0, _config.default)().useLegacyStoreResult ? d.resolve(key, values) : d.resolve(serverResponse || values, key);
    }).fail(d.reject);
    return d.promise();
  },
  _removeImpl: function _removeImpl(key) {
    var d = new _deferred.Deferred();
    (0, _deferred.when)(this._requestDispatcher.sendRequest(this._byKeyUrl(key), 'DELETE')).done(function () {
      return d.resolve(key);
    }).fail(d.reject);
    return d.promise();
  },
  _convertKey: function _convertKey(value) {
    var result = value;
    var fieldTypes = this._fieldTypes;

    var key = this.key() || this._legacyAnonymousKey;

    if (Array.isArray(key)) {
      result = {};

      for (var i = 0; i < key.length; i++) {
        var keyName = key[i];
        result[keyName] = (0, _utils.convertPrimitiveValue)(fieldTypes[keyName], value[keyName]);
      }
    } else if (fieldTypes[key]) {
      result = (0, _utils.convertPrimitiveValue)(fieldTypes[key], value);
    }

    return result;
  },
  _byKeyUrl: function _byKeyUrl(value) {
    var baseUrl = this._requestDispatcher.url;

    var convertedKey = this._convertKey(value);

    return "".concat(baseUrl, "(").concat(encodeURIComponent((0, _utils.serializeKey)(convertedKey, this.version())), ")");
  },
  version: function version() {
    return this._requestDispatcher.version;
  }
}, 'odata');

var _default = ODataStore;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _utils = __webpack_require__(99);

__webpack_require__(168);

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DEFAULT_PROTOCOL_VERSION = 2;

var RequestDispatcher = /*#__PURE__*/function () {
  function RequestDispatcher(options) {
    options = options || {};
    this._url = String(options.url).replace(/\/+$/, '');
    this._beforeSend = options.beforeSend;
    this._jsonp = options.jsonp;
    this._version = options.version || DEFAULT_PROTOCOL_VERSION;
    this._withCredentials = options.withCredentials;
    this._deserializeDates = options.deserializeDates;
    this._filterToLower = options.filterToLower;
  }

  var _proto = RequestDispatcher.prototype;

  _proto.sendRequest = function sendRequest(url, method, params, payload) {
    return (0, _utils.sendRequest)(this.version, {
      url: url,
      method: method,
      params: params || {},
      payload: payload
    }, {
      beforeSend: this._beforeSend,
      jsonp: this._jsonp,
      withCredentials: this._withCredentials,
      deserializeDates: this._deserializeDates
    });
  };

  _createClass(RequestDispatcher, [{
    key: "version",
    get: function get() {
      return this._version;
    }
  }, {
    key: "beforeSend",
    get: function get() {
      return this._beforeSend;
    }
  }, {
    key: "url",
    get: function get() {
      return this._url;
    }
  }, {
    key: "jsonp",
    get: function get() {
      return this._jsonp;
    }
  }, {
    key: "filterToLower",
    get: function get() {
      return this._filterToLower;
    }
  }]);

  return RequestDispatcher;
}();

exports.default = RequestDispatcher;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 276 */
/***/ (function(module, exports) {

module.exports = window.JSZip;

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getFormatter = getFormatter;
exports.getFormat = getFormat;

var _math = __webpack_require__(31);

var _utils = __webpack_require__(251);

var DEFAULT_CONFIG = {
  thousandsSeparator: ',',
  decimalSeparator: '.'
};
var ESCAPING_CHAR = '\'';
var MAXIMUM_NUMBER_LENGTH = 15;

function getGroupSizes(formatString) {
  return formatString.split(',').slice(1).map(function (str) {
    return str.split('').filter(function (char) {
      return char === '#' || char === '0';
    }).length;
  });
}

function getSignParts(format) {
  var signParts = format.split(';');

  if (signParts.length === 1) {
    signParts.push('-' + signParts[0]);
  }

  return signParts;
}

function reverseString(str) {
  return str.toString().split('').reverse().join('');
}

function isPercentFormat(format) {
  return format.indexOf('%') !== -1 && !format.match(/'[^']*%[^']*'/g);
}

function removeStubs(str) {
  return str.replace(/'.+'/g, '');
}

function getNonRequiredDigitCount(floatFormat) {
  if (!floatFormat) return 0;
  var format = removeStubs(floatFormat);
  return format.length - format.replace(/[#]/g, '').length;
}

function getRequiredDigitCount(floatFormat) {
  if (!floatFormat) return 0;
  var format = removeStubs(floatFormat);
  return format.length - format.replace(/[0]/g, '').length;
}

function normalizeValueString(valuePart, minDigitCount, maxDigitCount) {
  if (!valuePart) return '';

  if (valuePart.length > maxDigitCount) {
    valuePart = valuePart.substr(0, maxDigitCount);
  }

  while (valuePart.length > minDigitCount && valuePart.slice(-1) === '0') {
    valuePart = valuePart.substr(0, valuePart.length - 1);
  }

  while (valuePart.length < minDigitCount) {
    valuePart += '0';
  }

  return valuePart;
}

function applyGroups(valueString, groupSizes, thousandsSeparator) {
  if (!groupSizes.length) return valueString;
  var groups = [];
  var index = 0;

  while (valueString) {
    var groupSize = groupSizes[index];

    if (!groupSize) {
      break;
    }

    groups.push(valueString.slice(0, groupSize));
    valueString = valueString.slice(groupSize);

    if (index < groupSizes.length - 1) {
      index++;
    }
  }

  return groups.join(thousandsSeparator);
}

function formatNumberPart(format, valueString) {
  return format.split(ESCAPING_CHAR).map(function (formatPart, escapeIndex) {
    var isEscape = escapeIndex % 2;

    if (!formatPart && isEscape) {
      return ESCAPING_CHAR;
    }

    return isEscape ? formatPart : formatPart.replace(/[,#0]+/, valueString);
  }).join('');
}

function getFloatPointIndex(format) {
  var isEscape = false;

  for (var index = 0; index < format.length; index++) {
    if (format[index] === '\'') {
      isEscape = !isEscape;
    }

    if (format[index] === '.' && !isEscape) {
      return index;
    }
  }

  return format.length;
}

function getFormatter(format, config) {
  config = config || DEFAULT_CONFIG;
  return function (value) {
    if (typeof value !== 'number' || isNaN(value)) return '';
    var signFormatParts = getSignParts(format);
    var isPositiveZero = 1 / value === Infinity;
    var isPositive = value > 0 || isPositiveZero;
    var numberFormat = signFormatParts[isPositive ? 0 : 1];

    if (isPercentFormat(numberFormat)) {
      value = value * 100;
    }

    if (!isPositive) {
      value = -value;
    }

    var floatPointIndex = getFloatPointIndex(numberFormat);
    var floatFormatParts = [numberFormat.substr(0, floatPointIndex), numberFormat.substr(floatPointIndex + 1)];
    var minFloatPrecision = getRequiredDigitCount(floatFormatParts[1]);
    var maxFloatPrecision = minFloatPrecision + getNonRequiredDigitCount(floatFormatParts[1]);
    var minIntegerPrecision = getRequiredDigitCount(floatFormatParts[0]);
    var maxIntegerPrecision = getNonRequiredDigitCount(floatFormatParts[0]) || config.unlimitedIntegerDigits ? undefined : minIntegerPrecision;
    var integerLength = Math.floor(value).toString().length;
    var floatPrecision = (0, _math.fitIntoRange)(maxFloatPrecision, 0, MAXIMUM_NUMBER_LENGTH - integerLength);
    var groupSizes = getGroupSizes(floatFormatParts[0]).reverse();
    var valueParts = (0, _utils.toFixed)(value, floatPrecision < 0 ? 0 : floatPrecision).split('.');
    var valueIntegerPart = normalizeValueString(reverseString(valueParts[0]), minIntegerPrecision, maxIntegerPrecision);
    var valueFloatPart = normalizeValueString(valueParts[1], minFloatPrecision, maxFloatPrecision);
    valueIntegerPart = applyGroups(valueIntegerPart, groupSizes, config.thousandsSeparator);
    var integerString = reverseString(formatNumberPart(reverseString(floatFormatParts[0]), valueIntegerPart));
    var floatString = maxFloatPrecision ? formatNumberPart(floatFormatParts[1], valueFloatPart) : '';
    var result = integerString + (floatString.match(/\d/) ? config.decimalSeparator : '') + floatString;
    return result;
  };
}

function parseValue(text, isPercent, isNegative) {
  var value = (isPercent ? 0.01 : 1) * parseFloat(text) || 0;
  return isNegative ? -value : value;
}

function prepareValueText(valueText, formatter, isPercent, isIntegerPart) {
  var nextValueText = valueText;
  var char;
  var text;
  var nextText;

  do {
    if (nextText) {
      char = text.length === nextText.length ? '0' : '1';
      valueText = isIntegerPart ? char + valueText : valueText + char;
    }

    text = nextText || formatter(parseValue(nextValueText, isPercent));
    nextValueText = isIntegerPart ? '1' + nextValueText : nextValueText + '1';
    nextText = formatter(parseValue(nextValueText, isPercent));
  } while (text !== nextText && (isIntegerPart ? text.length === nextText.length : text.length <= nextText.length));

  if (isIntegerPart && nextText.length > text.length) {
    var hasGroups = formatter(12345).indexOf('12345') === -1;

    do {
      valueText = '1' + valueText;
    } while (hasGroups && parseValue(valueText, isPercent) < 100000);
  }

  return valueText;
}

function getFormatByValueText(valueText, formatter, isPercent, isNegative) {
  var format = formatter(parseValue(valueText, isPercent, isNegative));
  var valueTextParts = valueText.split('.');
  var valueTextWithModifiedFloat = valueTextParts[0] + '.3' + valueTextParts[1].slice(1);
  var valueWithModifiedFloat = parseValue(valueTextWithModifiedFloat, isPercent, isNegative);
  var decimalSeparatorIndex = formatter(valueWithModifiedFloat).indexOf('3') - 1;
  format = format.replace(/(\d)\D(\d)/g, '$1,$2');

  if (decimalSeparatorIndex >= 0) {
    format = format.slice(0, decimalSeparatorIndex) + '.' + format.slice(decimalSeparatorIndex + 1);
  }

  format = format.replace(/1+/, '1').replace(/1/g, '#');

  if (!isPercent) {
    format = format.replace('%', '\'%\''); // lgtm[js/incomplete-sanitization]
  }

  return format;
}

function getFormat(formatter) {
  var valueText = '.';
  var isPercent = formatter(1).indexOf('100') >= 0;
  valueText = prepareValueText(valueText, formatter, isPercent, true);
  valueText = prepareValueText(valueText, formatter, isPercent, false);
  var positiveFormat = getFormatByValueText(valueText, formatter, isPercent, false);
  var negativeFormat = getFormatByValueText(valueText, formatter, isPercent, true);
  return negativeFormat === '-' + positiveFormat ? positiveFormat : positiveFormat + ';' + negativeFormat;
}

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.sessionStorage = void 0;

var _window = __webpack_require__(7);

var window = (0, _window.getWindow)();

var getSessionStorage = function getSessionStorage() {
  var sessionStorage;

  try {
    sessionStorage = window.sessionStorage;
  } catch (e) {}

  return sessionStorage;
};

exports.sessionStorage = getSessionStorage;

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _query = _interopRequireDefault(__webpack_require__(49));

var _errors = _interopRequireDefault(__webpack_require__(24));

var _timezones_data = _interopRequireDefault(__webpack_require__(392));

var _math = __webpack_require__(31);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getConvertedUntils = function getConvertedUntils(value) {
  return value.split('|').map(function (until) {
    if (until === 'Infinity') {
      return null;
    }

    return parseInt(until, 36) * 1000;
  });
};

var parseTimezone = function parseTimezone(timeZoneConfig) {
  var offsets = timeZoneConfig.offsets;
  var offsetIndices = timeZoneConfig.offsetIndices;
  var untils = timeZoneConfig.untils;
  var offsetList = offsets.split('|').map(function (value) {
    return parseInt(value);
  });
  var offsetIndexList = offsetIndices.split('').map(function (value) {
    return parseInt(value);
  });
  var dateList = getConvertedUntils(untils).map(function (accumulator) {
    return function (value) {
      return accumulator += value;
    };
  }(0));
  return {
    offsetList: offsetList,
    offsetIndexList: offsetIndexList,
    dateList: dateList
  };
};

var TimeZoneCache = /*#__PURE__*/function () {
  function TimeZoneCache() {
    this.map = new Map();
  }

  var _proto = TimeZoneCache.prototype;

  _proto.tryGet = function tryGet(id) {
    if (!this.map.get(id)) {
      var config = timeZoneDataUtils.getTimezoneById(id);

      if (!config) {
        return false;
      }

      var timeZoneInfo = parseTimezone(config);
      this.map.set(id, timeZoneInfo);
    }

    return this.map.get(id);
  };

  return TimeZoneCache;
}();

var tzCache = new TimeZoneCache();
var timeZoneDataUtils = {
  _tzCache: tzCache,
  _timeZones: _timezones_data.default.zones,
  getDisplayedTimeZones: function getDisplayedTimeZones(timestamp) {
    var _this = this;

    var timeZones = this._timeZones.map(function (timezone) {
      var timeZoneInfo = parseTimezone(timezone);

      var offset = _this.getUtcOffset(timeZoneInfo, timestamp);

      var title = "(GMT ".concat(_this.formatOffset(offset), ") ").concat(_this.formatId(timezone.id));
      return {
        offset: offset,
        title: title,
        id: timezone.id
      };
    });

    return (0, _query.default)(timeZones).sortBy('offset').toArray();
  },
  formatOffset: function formatOffset(offset) {
    var hours = Math.floor(offset);
    var minutesInDecimal = offset - hours;
    var signString = (0, _math.sign)(offset) >= 0 ? '+' : '-';
    var hoursString = "0".concat(Math.abs(hours)).slice(-2);
    var minutesString = minutesInDecimal > 0 ? ":".concat(minutesInDecimal * 60) : ':00';
    return signString + hoursString + minutesString;
  },
  formatId: function formatId(id) {
    return id.split('/').join(' - ').split('_').join(' ');
  },
  getTimezoneById: function getTimezoneById(id) {
    if (!id) {
      return;
    }

    var tzList = this._timeZones;

    for (var i = 0; i < tzList.length; i++) {
      var currentId = tzList[i]['id'];

      if (currentId === id) {
        return tzList[i];
      }
    }

    _errors.default.log('W0009', id);

    return;
  },
  getTimeZoneOffsetById: function getTimeZoneOffsetById(id, timestamp) {
    var timeZoneInfo = tzCache.tryGet(id);
    return timeZoneInfo ? this.getUtcOffset(timeZoneInfo, timestamp) : undefined;
  },
  getTimeZoneDeclarationTuple: function getTimeZoneDeclarationTuple(id, year) {
    var timeZoneInfo = tzCache.tryGet(id);
    return timeZoneInfo ? this.getTimeZoneDeclarationTupleCore(timeZoneInfo, year) : [];
  },
  getTimeZoneDeclarationTupleCore: function getTimeZoneDeclarationTupleCore(timeZoneInfo, year) {
    var offsetList = timeZoneInfo.offsetList;
    var offsetIndexList = timeZoneInfo.offsetIndexList;
    var dateList = timeZoneInfo.dateList;
    var tupleResult = [];

    for (var i = 0; i < dateList.length; i++) {
      var currentDate = dateList[i];
      var currentYear = new Date(currentDate).getFullYear();

      if (currentYear === year) {
        var offset = offsetList[offsetIndexList[i + 1]];
        tupleResult.push({
          date: currentDate,
          offset: -offset / 60
        });
      }

      if (currentYear > year) {
        break;
      }
    }

    return tupleResult;
  },
  getUtcOffset: function getUtcOffset(timeZoneInfo, dateTimeStamp) {
    var offsetList = timeZoneInfo.offsetList;
    var offsetIndexList = timeZoneInfo.offsetIndexList;
    var dateList = timeZoneInfo.dateList;
    var infinityUntilCorrection = 1;
    var lastIntervalStartIndex = dateList.length - 1 - infinityUntilCorrection;
    var index = lastIntervalStartIndex;

    while (index >= 0 && dateTimeStamp < dateList[index]) {
      index--;
    }

    var offset = offsetList[offsetIndexList[index + 1]];
    return -offset / 60 || offset;
  }
};
var _default = timeZoneDataUtils;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.TransitionExecutor = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _class = _interopRequireDefault(__webpack_require__(15));

var _extend = __webpack_require__(0);

var _common = __webpack_require__(4);

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

var _fx = _interopRequireDefault(__webpack_require__(45));

var _presets = __webpack_require__(197);

var _deferred = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var directionPostfixes = {
  forward: ' dx-forward',
  backward: ' dx-backward',
  none: ' dx-no-direction',
  undefined: ' dx-no-direction'
};
var DX_ANIMATING_CLASS = 'dx-animating';

var TransitionExecutor = _class.default.inherit({
  ctor: function ctor() {
    this._accumulatedDelays = {
      enter: 0,
      leave: 0
    };
    this._animations = [];
    this.reset();
  },
  _createAnimations: function _createAnimations($elements, initialConfig, configModifier, type) {
    var that = this;
    var result = [];
    configModifier = configModifier || {};

    var animationConfig = this._prepareElementAnimationConfig(initialConfig, configModifier, type);

    if (animationConfig) {
      $elements.each(function () {
        var animation = that._createAnimation((0, _renderer.default)(this), animationConfig, configModifier);

        if (animation) {
          animation.element.addClass(DX_ANIMATING_CLASS);
          animation.setup();
          result.push(animation);
        }
      });
    }

    return result;
  },
  _prepareElementAnimationConfig: function _prepareElementAnimationConfig(config, configModifier, type) {
    var result;

    if (typeof config === 'string') {
      var presetName = config;
      config = _presets.presets.getPreset(presetName);
    }

    if (!config) {
      result = undefined;
    } else if ((0, _type.isFunction)(config[type])) {
      result = config[type];
    } else {
      result = (0, _extend.extend)({
        skipElementInitialStyles: true,
        cleanupWhen: this._completePromise
      }, config, configModifier);

      if (!result.type || result.type === 'css') {
        var cssClass = 'dx-' + type;
        var extraCssClasses = (result.extraCssClasses ? ' ' + result.extraCssClasses : '') + directionPostfixes[result.direction];
        result.type = 'css';
        result.from = (result.from || cssClass) + extraCssClasses;
        result.to = result.to || cssClass + '-active';
      }

      result.staggerDelay = result.staggerDelay || 0;
      result.delay = result.delay || 0;

      if (result.staggerDelay) {
        result.delay += this._accumulatedDelays[type];
        this._accumulatedDelays[type] += result.staggerDelay;
      }
    }

    return result;
  },
  _createAnimation: function _createAnimation($element, animationConfig, configModifier) {
    var result;

    if ((0, _type.isPlainObject)(animationConfig)) {
      result = _fx.default.createAnimation($element, animationConfig);
    } else if ((0, _type.isFunction)(animationConfig)) {
      result = animationConfig($element, configModifier);
    }

    return result;
  },
  _startAnimations: function _startAnimations() {
    var animations = this._animations;

    for (var i = 0; i < animations.length; i++) {
      animations[i].start();
    }
  },
  _stopAnimations: function _stopAnimations(jumpToEnd) {
    var animations = this._animations;

    for (var i = 0; i < animations.length; i++) {
      animations[i].stop(jumpToEnd);
    }
  },
  _clearAnimations: function _clearAnimations() {
    var animations = this._animations;

    for (var i = 0; i < animations.length; i++) {
      animations[i].element.removeClass(DX_ANIMATING_CLASS);
    }

    this._animations.length = 0;
  },
  reset: function reset() {
    this._accumulatedDelays.enter = 0;
    this._accumulatedDelays.leave = 0;

    this._clearAnimations();

    this._completeDeferred = new _deferred.Deferred();
    this._completePromise = this._completeDeferred.promise();
  },
  enter: function enter($elements, animationConfig, configModifier) {
    var animations = this._createAnimations($elements, animationConfig, configModifier, 'enter');

    this._animations.push.apply(this._animations, animations);
  },
  leave: function leave($elements, animationConfig, configModifier) {
    var animations = this._createAnimations($elements, animationConfig, configModifier, 'leave');

    this._animations.push.apply(this._animations, animations);
  },
  start: function start() {
    var that = this;
    var result;

    if (!this._animations.length) {
      that.reset();
      result = new _deferred.Deferred().resolve().promise();
    } else {
      var animationDeferreds = (0, _iterator.map)(this._animations, function (animation) {
        var result = new _deferred.Deferred();
        animation.deferred.always(function () {
          result.resolve();
        });
        return result.promise();
      });
      result = _deferred.when.apply(_renderer.default, animationDeferreds).always(function () {
        that._completeDeferred.resolve();

        that.reset();
      });
      (0, _common.executeAsync)(function () {
        that._startAnimations();
      });
    }

    return result;
  },
  stop: function stop(jumpToEnd) {
    this._stopAnimations(jumpToEnd);
  }
});

exports.TransitionExecutor = TransitionExecutor;

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Event = exports.triggerHandler = exports.trigger = exports.off = exports.one = exports.on = void 0;

var _events_engine = _interopRequireDefault(__webpack_require__(5));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
* @name events
*/
var on = _events_engine.default.on;
exports.on = on;
var one = _events_engine.default.one;
exports.one = one;
var off = _events_engine.default.off;
exports.off = off;
var trigger = _events_engine.default.trigger;
exports.trigger = trigger;
var triggerHandler = _events_engine.default.triggerHandler;
/**
* @name events.Event
* @type function
* @param1 source:string|event
* @param2 config:object
* @return event
* @module events
* @export Event
* @hidden
*/

exports.triggerHandler = triggerHandler;
var Event = _events_engine.default.Event;
exports.Event = Event;

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _component_registrator = _interopRequireDefault(__webpack_require__(9));

var _ui = _interopRequireDefault(__webpack_require__(64));

var _extend = __webpack_require__(0);

var _string = __webpack_require__(40);

var _position = __webpack_require__(26);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var INVALID_MESSAGE = 'dx-invalid-message';
var INVALID_MESSAGE_AUTO = 'dx-invalid-message-auto';
var INVALID_MESSAGE_ALWAYS = 'dx-invalid-message-always';
var INVALID_MESSAGE_CONTENT = 'dx-invalid-message-content';
var VALIDATION_MESSAGE_MIN_WIDTH = 100;

var ValidationMessage = _ui.default.inherit({
  _getDefaultOptions: function _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      integrationOptions: {},
      templatesRenderAsynchronously: false,
      shading: false,
      width: 'auto',
      height: 'auto',
      closeOnOutsideClick: false,
      closeOnTargetScroll: false,
      animation: null,
      visible: true,
      propagateOutsideClick: true,
      _checkParentVisibility: false,
      rtlEnabled: false,
      contentTemplate: this._renderInnerHtml,
      maxWidth: '100%',
      mode: 'auto',
      validationErrors: undefined,
      positionRequest: undefined,
      describedElement: undefined,
      boundary: undefined,
      offset: {
        h: 0,
        v: 0
      }
    });
  },
  _init: function _init() {
    this.callBase();
    this.updateMaxWidth();

    this._updatePosition();
  },
  _initMarkup: function _initMarkup() {
    this.callBase();
    this.$element().addClass(INVALID_MESSAGE);
    this.$wrapper().addClass(INVALID_MESSAGE);

    this._toggleModeClass();

    this._updateContentId();
  },
  _updateContentId: function _updateContentId() {
    var describedElement = this.option('describedElement') || this.option('container');
    var contentId = (0, _renderer.default)(describedElement).attr('aria-describedby');
    this.$content().addClass(INVALID_MESSAGE_CONTENT).attr('id', contentId);
  },
  _renderInnerHtml: function _renderInnerHtml(element) {
    var $element = element && (0, _renderer.default)(element);
    var validationErrors = this.option('validationErrors') || [];
    var validationErrorMessage = '';
    validationErrors.forEach(function (err) {
      var separator = validationErrorMessage ? '<br />' : '';
      validationErrorMessage += separator + (0, _string.encodeHtml)((err === null || err === void 0 ? void 0 : err.message) || '');
    });
    $element === null || $element === void 0 ? void 0 : $element.html(validationErrorMessage);
  },
  _toggleModeClass: function _toggleModeClass() {
    var mode = this.option('mode');
    this.$wrapper().toggleClass(INVALID_MESSAGE_AUTO, mode === 'auto').toggleClass(INVALID_MESSAGE_ALWAYS, mode === 'always');
  },
  updateMaxWidth: function updateMaxWidth() {
    var _target$outerWidth;

    var target = this.option('target');
    var targetWidth = (target === null || target === void 0 ? void 0 : (_target$outerWidth = target.outerWidth) === null || _target$outerWidth === void 0 ? void 0 : _target$outerWidth.call(target)) || (0, _renderer.default)(target).outerWidth();
    var maxWidth = '100%';

    if (targetWidth) {
      maxWidth = Math.max(targetWidth, VALIDATION_MESSAGE_MIN_WIDTH);
    }

    this.option({
      maxWidth: maxWidth
    });
  },
  _updatePosition: function _updatePosition() {
    var _this$option = this.option(),
        positionRequest = _this$option.positionRequest,
        rtlEnabled = _this$option.rtlEnabled,
        offset = _this$option.offset,
        boundary = _this$option.boundary;

    var positionSide = (0, _position.getDefaultAlignment)(rtlEnabled);
    var verticalPositions = positionRequest === 'below' ? [' top', ' bottom'] : [' bottom', ' top'];
    if (rtlEnabled) offset.h = -offset.h;
    if (positionRequest !== 'below') offset.v = -offset.v;
    this.option('position', {
      offset: offset,
      boundary: boundary,
      my: positionSide + verticalPositions[0],
      at: positionSide + verticalPositions[1],
      collision: 'none flip'
    });
  },
  _optionChanged: function _optionChanged(args) {
    var name = args.name,
        value = args.value;

    switch (name) {
      case 'target':
        this.updateMaxWidth();
        this.callBase(args);
        break;

      case 'boundary':
        this.option('position.boundary', value);
        break;

      case 'mode':
        this._toggleModeClass(value);

        break;

      case 'rtlEnabled':
      case 'offset':
      case 'positionRequest':
        this._updatePosition();

        break;

      case 'validationErrors':
        this._renderInnerHtml(this.$content());

        break;

      default:
        this.callBase(args);
    }
  }
});

(0, _component_registrator.default)('dxValidationMessage', ValidationMessage);
var _default = ValidationMessage;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.clearStack = exports.remove = exports.create = exports.base = void 0;

var _common = __webpack_require__(4);

var baseZIndex = 1500;
var zIndexStack = [];

var base = function base(ZIndex) {
  baseZIndex = (0, _common.ensureDefined)(ZIndex, baseZIndex);
  return baseZIndex;
};

exports.base = base;

var create = function create() {
  var baseIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : baseZIndex;
  var length = zIndexStack.length;
  var index = (length ? zIndexStack[length - 1] : baseIndex) + 1;
  zIndexStack.push(index);
  return index;
};

exports.create = create;

var remove = function remove(zIndex) {
  var position = zIndexStack.indexOf(zIndex);

  if (position >= 0) {
    zIndexStack.splice(position, 1);
  }
};

exports.remove = remove;

var clearStack = function clearStack() {
  zIndexStack = [];
};

exports.clearStack = clearStack;

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.SelectionFilterCreator = void 0;

var _common = __webpack_require__(4);

var _type = __webpack_require__(1);

var SelectionFilterCreator = function SelectionFilterCreator(selectedItemKeys, isSelectAll) {
  this.getLocalFilter = function (keyGetter, equalKeys, equalByReference, keyExpr) {
    equalKeys = equalKeys === undefined ? _common.equalByValue : equalKeys;
    return functionFilter.bind(this, equalKeys, keyGetter, equalByReference, keyExpr);
  };

  this.getExpr = function (keyExpr) {
    if (!keyExpr) {
      return;
    }

    var filterExpr;
    selectedItemKeys.forEach(function (key, index) {
      filterExpr = filterExpr || [];
      var filterExprPart;

      if (index > 0) {
        filterExpr.push(isSelectAll ? 'and' : 'or');
      }

      if ((0, _type.isString)(keyExpr)) {
        filterExprPart = getFilterForPlainKey(keyExpr, key);
      } else {
        filterExprPart = getFilterForCompositeKey(keyExpr, key);
      }

      filterExpr.push(filterExprPart);
    });

    if (filterExpr && filterExpr.length === 1) {
      filterExpr = filterExpr[0];
    }

    return filterExpr;
  };

  this.getCombinedFilter = function (keyExpr, dataSourceFilter) {
    var filterExpr = this.getExpr(keyExpr);
    var combinedFilter = filterExpr;

    if (isSelectAll && dataSourceFilter) {
      if (filterExpr) {
        combinedFilter = [];
        combinedFilter.push(filterExpr);
        combinedFilter.push(dataSourceFilter);
      } else {
        combinedFilter = dataSourceFilter;
      }
    }

    return combinedFilter;
  };

  var selectedItemKeyHashesMap;

  var getSelectedItemKeyHashesMap = function getSelectedItemKeyHashesMap(selectedItemKeys) {
    if (!selectedItemKeyHashesMap) {
      selectedItemKeyHashesMap = {};

      for (var i = 0; i < selectedItemKeys.length; i++) {
        selectedItemKeyHashesMap[(0, _common.getKeyHash)(selectedItemKeys[i])] = true;
      }
    }

    return selectedItemKeyHashesMap;
  };

  var normalizeKeys = function normalizeKeys(keys, keyOf, keyExpr) {
    return Array.isArray(keyExpr) ? keys.map(function (key) {
      return keyOf(key);
    }) : keys;
  };

  function functionFilter(equalKeys, keyOf, equalByReference, keyExpr, item) {
    var key = keyOf(item);
    var keyHash;
    var i;

    if (!equalByReference) {
      keyHash = (0, _common.getKeyHash)(key);

      if (!(0, _type.isObject)(keyHash)) {
        var selectedKeyHashesMap = getSelectedItemKeyHashesMap(normalizeKeys(selectedItemKeys, keyOf, keyExpr));

        if (selectedKeyHashesMap[keyHash]) {
          return !isSelectAll;
        }

        return !!isSelectAll;
      }
    }

    for (i = 0; i < selectedItemKeys.length; i++) {
      if (equalKeys(selectedItemKeys[i], key)) {
        return !isSelectAll;
      }
    }

    return !!isSelectAll;
  }

  function getFilterForPlainKey(keyExpr, keyValue) {
    if (keyValue === undefined) {
      return;
    }

    return [keyExpr, isSelectAll ? '<>' : '=', keyValue];
  }

  function getFilterForCompositeKey(keyExpr, itemKeyValue) {
    var filterExpr = [];

    for (var i = 0, length = keyExpr.length; i < length; i++) {
      var currentKeyExpr = keyExpr[i];
      var currentKeyValue = itemKeyValue && itemKeyValue[currentKeyExpr];
      var filterExprPart = getFilterForPlainKey(currentKeyExpr, currentKeyValue);

      if (!filterExprPart) {
        break;
      }

      if (i > 0) {
        filterExpr.push(isSelectAll ? 'or' : 'and');
      }

      filterExpr.push(filterExprPart);
    }

    return filterExpr;
  }
};

exports.SelectionFilterCreator = SelectionFilterCreator;

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _common = __webpack_require__(4);

var _class = _interopRequireDefault(__webpack_require__(15));

var _frame = __webpack_require__(122);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var abstract = _class.default.abstract;

var Animator = _class.default.inherit({
  ctor: function ctor() {
    this._finished = true;
    this._stopped = false;
    this._proxiedStepCore = this._stepCore.bind(this);
  },
  start: function start() {
    this._stopped = false;
    this._finished = false;

    this._stepCore();
  },
  stop: function stop() {
    this._stopped = true;
    (0, _frame.cancelAnimationFrame)(this._stepAnimationFrame);
  },
  _stepCore: function _stepCore() {
    if (this._isStopped()) {
      this._stop();

      return;
    }

    if (this._isFinished()) {
      this._finished = true;

      this._complete();

      return;
    }

    this._step();

    this._stepAnimationFrame = (0, _frame.requestAnimationFrame)(this._proxiedStepCore);
  },
  _step: abstract,
  _isFinished: _common.noop,
  _stop: _common.noop,
  _complete: _common.noop,
  _isStopped: function _isStopped() {
    return this._stopped;
  },
  inProgress: function inProgress() {
    return !(this._stopped || this._finished);
  }
});

var _default = Animator;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.rotateend = exports.rotate = exports.rotatestart = exports.pinchend = exports.pinch = exports.pinchstart = exports.zoomend = exports.zoom = exports.zoomstart = exports.translateend = exports.translate = exports.translatestart = exports.transformend = exports.transform = exports.transformstart = void 0;

var _math = __webpack_require__(31);

var iteratorUtils = _interopRequireWildcard(__webpack_require__(3));

var _index = __webpack_require__(8);

var _emitter = _interopRequireDefault(__webpack_require__(127));

var _emitter_registrator = _interopRequireDefault(__webpack_require__(104));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var DX_PREFIX = 'dx';
var TRANSFORM = 'transform';
var TRANSLATE = 'translate';
var PINCH = 'pinch';
var ROTATE = 'rotate';
var START_POSTFIX = 'start';
var UPDATE_POSTFIX = '';
var END_POSTFIX = 'end';
var eventAliases = [];

var addAlias = function addAlias(eventName, eventArgs) {
  eventAliases.push({
    name: eventName,
    args: eventArgs
  });
};

addAlias(TRANSFORM, {
  scale: true,
  deltaScale: true,
  rotation: true,
  deltaRotation: true,
  translation: true,
  deltaTranslation: true
});
addAlias(TRANSLATE, {
  translation: true,
  deltaTranslation: true
});
addAlias(PINCH, {
  scale: true,
  deltaScale: true
});
addAlias(ROTATE, {
  rotation: true,
  deltaRotation: true
});

var getVector = function getVector(first, second) {
  return {
    x: second.pageX - first.pageX,
    y: -second.pageY + first.pageY,
    centerX: (second.pageX + first.pageX) * 0.5,
    centerY: (second.pageY + first.pageY) * 0.5
  };
};

var getEventVector = function getEventVector(e) {
  var pointers = e.pointers;
  return getVector(pointers[0], pointers[1]);
};

var getDistance = function getDistance(vector) {
  return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
};

var getScale = function getScale(firstVector, secondVector) {
  return getDistance(firstVector) / getDistance(secondVector);
};

var getRotation = function getRotation(firstVector, secondVector) {
  var scalarProduct = firstVector.x * secondVector.x + firstVector.y * secondVector.y;
  var distanceProduct = getDistance(firstVector) * getDistance(secondVector);

  if (distanceProduct === 0) {
    return 0;
  }

  var sign = (0, _math.sign)(firstVector.x * secondVector.y - secondVector.x * firstVector.y);
  var angle = Math.acos((0, _math.fitIntoRange)(scalarProduct / distanceProduct, -1, 1));
  return sign * angle;
};

var getTranslation = function getTranslation(firstVector, secondVector) {
  return {
    x: firstVector.centerX - secondVector.centerX,
    y: firstVector.centerY - secondVector.centerY
  };
};

var TransformEmitter = _emitter.default.inherit({
  validatePointers: function validatePointers(e) {
    return (0, _index.hasTouches)(e) > 1;
  },
  start: function start(e) {
    this._accept(e);

    var startVector = getEventVector(e);
    this._startVector = startVector;
    this._prevVector = startVector;

    this._fireEventAliases(START_POSTFIX, e);
  },
  move: function move(e) {
    var currentVector = getEventVector(e);

    var eventArgs = this._getEventArgs(currentVector);

    this._fireEventAliases(UPDATE_POSTFIX, e, eventArgs);

    this._prevVector = currentVector;
  },
  end: function end(e) {
    var eventArgs = this._getEventArgs(this._prevVector);

    this._fireEventAliases(END_POSTFIX, e, eventArgs);
  },
  _getEventArgs: function _getEventArgs(vector) {
    return {
      scale: getScale(vector, this._startVector),
      deltaScale: getScale(vector, this._prevVector),
      rotation: getRotation(vector, this._startVector),
      deltaRotation: getRotation(vector, this._prevVector),
      translation: getTranslation(vector, this._startVector),
      deltaTranslation: getTranslation(vector, this._prevVector)
    };
  },
  _fireEventAliases: function _fireEventAliases(eventPostfix, originalEvent, eventArgs) {
    eventArgs = eventArgs || {};
    iteratorUtils.each(eventAliases, function (_, eventAlias) {
      var args = {};
      iteratorUtils.each(eventAlias.args, function (name) {
        if (name in eventArgs) {
          args[name] = eventArgs[name];
        }
      });

      this._fireEvent(DX_PREFIX + eventAlias.name + eventPostfix, originalEvent, args);
    }.bind(this));
  }
});
/**
 * @name UI Events.dxtransformstart
 * @type eventType
 * @type_function_param1 event:event
 * @type_function_param1_field1 cancel:boolean
 * @module events/transform
*/

/**
  * @name UI Events.dxtransform
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 scale:number
  * @type_function_param1_field2 deltaScale:number
  * @type_function_param1_field3 rotation:number
  * @type_function_param1_field4 deltaRotation:number
  * @type_function_param1_field5 translation:object
  * @type_function_param1_field6 deltaTranslation:object
  * @type_function_param1_field7 cancel:boolean
  * @module events/transform
*/

/**
  * @name UI Events.dxtransformend
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 scale:number
  * @type_function_param1_field2 deltaScale:number
  * @type_function_param1_field3 rotation:number
  * @type_function_param1_field4 deltaRotation:number
  * @type_function_param1_field5 translation:object
  * @type_function_param1_field6 deltaTranslation:object
  * @type_function_param1_field7 cancel:boolean
  * @module events/transform
*/

/**
 * @name UI Events.dxtranslatestart
 * @type eventType
 * @type_function_param1 event:event
 * @type_function_param1_field1 cancel:boolean
 * @module events/transform
*/

/**
  * @name UI Events.dxtranslate
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 translation:object
  * @type_function_param1_field2 deltaTranslation:object
  * @type_function_param1_field3 cancel:boolean
  * @module events/transform
*/

/**
  * @name UI Events.dxtranslateend
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 translation:object
  * @type_function_param1_field2 deltaTranslation:object
  * @type_function_param1_field3 cancel:boolean
  * @module events/transform
*/

/**
* @name UI Events.dxpinchstart
* @type eventType
* @type_function_param1 event:event
* @type_function_param1_field1 cancel:boolean
* @module events/transform
   */

/**
  * @name UI Events.dxpinch
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 scale:number
  * @type_function_param1_field2 deltaScale:number
  * @type_function_param1_field3 cancel:boolean
  * @module events/transform
*/

/**
  * @name UI Events.dxpinchend
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 scale:number
  * @type_function_param1_field2 deltaScale:number
  * @type_function_param1_field3 cancel:boolean
  * @module events/transform
*/

/**
 * @name UI Events.dxrotatestart
 * @type eventType
 * @type_function_param1 event:event
 * @type_function_param1_field1 cancel:boolean
 * @module events/transform
*/

/**
  * @name UI Events.dxrotate
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 rotation:number
  * @type_function_param1_field2 deltaRotation:number
  * @type_function_param1_field3 cancel:boolean
  * @module events/transform
*/

/**
  * @name UI Events.dxrotateend
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 rotation:number
  * @type_function_param1_field2 deltaRotation:number
  * @type_function_param1_field3 cancel:boolean
  * @module events/transform
*/


var eventNames = eventAliases.reduce(function (result, eventAlias) {
  [START_POSTFIX, UPDATE_POSTFIX, END_POSTFIX].forEach(function (eventPostfix) {
    result.push(DX_PREFIX + eventAlias.name + eventPostfix);
  });
  return result;
}, []);
(0, _emitter_registrator.default)({
  emitter: TransformEmitter,
  events: eventNames
});
var exportNames = {};
iteratorUtils.each(eventNames, function (_, eventName) {
  exportNames[eventName.substring(DX_PREFIX.length)] = eventName;
});
/* eslint-disable spellcheck/spell-checker */

var transformstart = exportNames.transformstart,
    transform = exportNames.transform,
    transformend = exportNames.transformend,
    translatestart = exportNames.translatestart,
    translate = exportNames.translate,
    translateend = exportNames.translateend,
    zoomstart = exportNames.zoomstart,
    zoom = exportNames.zoom,
    zoomend = exportNames.zoomend,
    pinchstart = exportNames.pinchstart,
    pinch = exportNames.pinch,
    pinchend = exportNames.pinchend,
    rotatestart = exportNames.rotatestart,
    rotate = exportNames.rotate,
    rotateend = exportNames.rotateend;
exports.rotateend = rotateend;
exports.rotate = rotate;
exports.rotatestart = rotatestart;
exports.pinchend = pinchend;
exports.pinch = pinch;
exports.pinchstart = pinchstart;
exports.zoomend = zoomend;
exports.zoom = zoom;
exports.zoomstart = zoomstart;
exports.translateend = translateend;
exports.translate = translate;
exports.translatestart = translatestart;
exports.transformend = transformend;
exports.transform = transform;
exports.transformstart = transformstart;

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _data_source = __webpack_require__(72);

var _default = _data_source.DataSource;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.default = void 0;

var Export = _interopRequireWildcard(__webpack_require__(118));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var _default = Export;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.BaseChart = exports.overlapping = void 0;

var _common = __webpack_require__(4);

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

var _extend = __webpack_require__(0);

var _array = __webpack_require__(12);

var _index = __webpack_require__(8);

var _base_widget = _interopRequireDefault(__webpack_require__(119));

var _legend = __webpack_require__(239);

var _data_validator = __webpack_require__(345);

var _base_series = __webpack_require__(347);

var _chart_theme_manager = __webpack_require__(590);

var _layout_manager = __webpack_require__(591);

var trackerModule = _interopRequireWildcard(__webpack_require__(1054));

var _utils = __webpack_require__(14);

var _export = __webpack_require__(118);

var _title = __webpack_require__(138);

var _data_source = __webpack_require__(186);

var _tooltip = __webpack_require__(140);

var _loading_indicator = __webpack_require__(163);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _isArray = Array.isArray;
var REINIT_REFRESH_ACTION = '_reinit';
var REINIT_DATA_SOURCE_REFRESH_ACTION = '_updateDataSource';
var DATA_INIT_REFRESH_ACTION = '_dataInit';
var FORCE_RENDER_REFRESH_ACTION = '_forceRender';
var RESIZE_REFRESH_ACTION = '_resize';
var ACTIONS_BY_PRIORITY = [REINIT_REFRESH_ACTION, REINIT_DATA_SOURCE_REFRESH_ACTION, DATA_INIT_REFRESH_ACTION, FORCE_RENDER_REFRESH_ACTION, RESIZE_REFRESH_ACTION];
var DEFAULT_OPACITY = 0.3;
var REFRESH_SERIES_DATA_INIT_ACTION_OPTIONS = ['series', 'commonSeriesSettings', 'dataPrepareSettings', 'seriesSelectionMode', 'pointSelectionMode', 'synchronizeMultiAxes', 'resolveLabelsOverlapping'];
var REFRESH_SERIES_FAMILIES_ACTION_OPTIONS = ['minBubbleSize', 'maxBubbleSize', 'barGroupPadding', 'barGroupWidth', 'negativesAsZeroes', 'negativesAsZeros' // misspelling case
];
var FORCE_RENDER_REFRESH_ACTION_OPTIONS = ['adaptiveLayout', 'crosshair', 'resolveLabelOverlapping', 'adjustOnZoom', 'stickyHovering'];
var FONT = 'font';

function checkHeightRollingStock(rollingStocks, stubCanvas) {
  var canvasSize = stubCanvas.end - stubCanvas.start;
  var size = 0;
  rollingStocks.forEach(function (rollingStock) {
    size += rollingStock.getBoundingRect().width;
  });

  while (canvasSize < size) {
    size -= findAndKillSmallValue(rollingStocks);
  }
}

function findAndKillSmallValue(rollingStocks) {
  var smallestObject = rollingStocks.reduce(function (prev, rollingStock, index) {
    if (!rollingStock) return prev;
    var value = rollingStock.value();
    return value < prev.value ? {
      value: value,
      rollingStock: rollingStock,
      index: index
    } : prev;
  }, {
    rollingStock: undefined,
    value: Infinity,
    index: undefined
  });
  smallestObject.rollingStock.getLabels()[0].draw(false);
  var width = smallestObject.rollingStock.getBoundingRect().width;
  rollingStocks[smallestObject.index] = null;
  return width;
}

function checkStackOverlap(rollingStocks) {
  var i;
  var j;
  var iLength;
  var jLength;
  var overlap = false;

  for (i = 0, iLength = rollingStocks.length - 1; i < iLength; i++) {
    for (j = i + 1, jLength = rollingStocks.length; j < jLength; j++) {
      if (i !== j && checkStacksOverlapping(rollingStocks[i], rollingStocks[j], true)) {
        overlap = true;
        break;
      }
    }

    if (overlap) break;
  }

  return overlap;
}

function resolveLabelOverlappingInOneDirection(points, canvas, isRotated, shiftFunction) {
  var customSorting = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {
    return 0;
  };
  var rollingStocks = [];
  var stubCanvas = {
    start: isRotated ? canvas.left : canvas.top,
    end: isRotated ? canvas.width - canvas.right : canvas.height - canvas.bottom
  };
  var hasStackedSeries = false;
  points.forEach(function (p) {
    if (!p) return;
    hasStackedSeries = hasStackedSeries || p.series.isStackedSeries() || p.series.isFullStackedSeries();
    p.getLabels().forEach(function (l) {
      l.isVisible() && rollingStocks.push(new RollingStock(l, isRotated, shiftFunction));
    });
  });

  if (hasStackedSeries) {
    !isRotated && rollingStocks.reverse();
  } else {
    var rollingStocksTmp = rollingStocks.slice();
    rollingStocks.sort(function (a, b) {
      return customSorting(a, b) || a.getInitialPosition() - b.getInitialPosition() || rollingStocksTmp.indexOf(a) - rollingStocksTmp.indexOf(b);
    });
  }

  if (!checkStackOverlap(rollingStocks)) return false;
  checkHeightRollingStock(rollingStocks, stubCanvas);
  prepareOverlapStacks(rollingStocks);
  rollingStocks.reverse();
  moveRollingStock(rollingStocks, stubCanvas);
  return true;
}

function checkStacksOverlapping(firstRolling, secondRolling, inTwoSides) {
  if (!firstRolling || !secondRolling) return;
  var firstRect = firstRolling.getBoundingRect();
  var secondRect = secondRolling.getBoundingRect();
  var oppositeOverlapping = inTwoSides ? firstRect.oppositeStart <= secondRect.oppositeStart && firstRect.oppositeEnd > secondRect.oppositeStart || secondRect.oppositeStart <= firstRect.oppositeStart && secondRect.oppositeEnd > firstRect.oppositeStart : true;
  return firstRect.end > secondRect.start && oppositeOverlapping;
}

function prepareOverlapStacks(rollingStocks) {
  var i;
  var currentRollingStock;
  var root;

  for (i = 0; i < rollingStocks.length - 1; i++) {
    currentRollingStock = root || rollingStocks[i];

    if (checkStacksOverlapping(currentRollingStock, rollingStocks[i + 1])) {
      currentRollingStock.toChain(rollingStocks[i + 1]);
      rollingStocks[i + 1] = null;
      root = currentRollingStock;
    } else {
      root = rollingStocks[i + 1] || currentRollingStock;
    }
  }
}

function moveRollingStock(rollingStocks, canvas) {
  var i;
  var j;
  var currentRollingStock;
  var nextRollingStock;
  var currentBBox;
  var nextBBox;

  for (i = 0; i < rollingStocks.length; i++) {
    currentRollingStock = rollingStocks[i];

    if (rollingStocksIsOut(currentRollingStock, canvas)) {
      currentBBox = currentRollingStock.getBoundingRect();

      for (j = i + 1; j < rollingStocks.length; j++) {
        nextRollingStock = rollingStocks[j];

        if (!nextRollingStock) {
          continue;
        }

        nextBBox = nextRollingStock.getBoundingRect();

        if (nextBBox.end > currentBBox.start - (currentBBox.end - canvas.end)) {
          nextRollingStock.toChain(currentRollingStock);
          rollingStocks[i] = currentRollingStock = null;
          break;
        }
      }
    }

    currentRollingStock && currentRollingStock.setRollingStockInCanvas(canvas);
  }
}

function rollingStocksIsOut(rollingStock, canvas) {
  return rollingStock && rollingStock.getBoundingRect().end > canvas.end;
}

function RollingStock(label, isRotated, shiftFunction) {
  var bBox = label.getBoundingRect();
  var x = bBox.x;
  var y = bBox.y;
  var endX = bBox.x + bBox.width;
  var endY = bBox.y + bBox.height;
  this.labels = [label];
  this.shiftFunction = shiftFunction;
  this._bBox = {
    start: isRotated ? x : y,
    width: isRotated ? bBox.width : bBox.height,
    end: isRotated ? endX : endY,
    oppositeStart: isRotated ? y : x,
    oppositeEnd: isRotated ? endY : endX
  };
  this._initialPosition = isRotated ? bBox.x : bBox.y;
  return this;
}

RollingStock.prototype = {
  toChain: function toChain(nextRollingStock) {
    var nextRollingStockBBox = nextRollingStock.getBoundingRect();
    nextRollingStock.shift(nextRollingStockBBox.start - this._bBox.end);

    this._changeBoxWidth(nextRollingStockBBox.width);

    this.labels = this.labels.concat(nextRollingStock.labels);
  },
  getBoundingRect: function getBoundingRect() {
    return this._bBox;
  },
  shift: function shift(shiftLength) {
    var shiftFunction = this.shiftFunction;
    (0, _iterator.each)(this.labels, function (index, label) {
      var bBox = label.getBoundingRect();
      var coords = shiftFunction(bBox, shiftLength);

      if (!label.hideInsideLabel(coords)) {
        label.shift(coords.x, coords.y);
      }
    });
    this._bBox.end -= shiftLength;
    this._bBox.start -= shiftLength;
  },
  setRollingStockInCanvas: function setRollingStockInCanvas(canvas) {
    if (this._bBox.end > canvas.end) {
      this.shift(this._bBox.end - canvas.end);
    }
  },
  getLabels: function getLabels() {
    return this.labels;
  },
  value: function value() {
    return this.labels[0].getData().value;
  },
  getInitialPosition: function getInitialPosition() {
    return this._initialPosition;
  },
  _changeBoxWidth: function _changeBoxWidth(width) {
    this._bBox.end += width;
    this._bBox.width += width;
  }
};

function getLegendFields(name) {
  return {
    nameField: name + 'Name',
    colorField: name + 'Color',
    indexField: name + 'Index'
  };
}

function getLegendSettings(legendDataField) {
  var formatObjectFields = getLegendFields(legendDataField);
  return {
    getFormatObject: function getFormatObject(data) {
      var res = {};
      res[formatObjectFields.indexField] = data.id;
      res[formatObjectFields.colorField] = data.states.normal.fill;
      res[formatObjectFields.nameField] = data.text;
      return res;
    },
    textField: formatObjectFields.nameField
  };
}

function checkOverlapping(firstRect, secondRect) {
  return (firstRect.x <= secondRect.x && secondRect.x <= firstRect.x + firstRect.width || firstRect.x >= secondRect.x && firstRect.x <= secondRect.x + secondRect.width) && (firstRect.y <= secondRect.y && secondRect.y <= firstRect.y + firstRect.height || firstRect.y >= secondRect.y && firstRect.y <= secondRect.y + secondRect.height);
}

var overlapping = {
  resolveLabelOverlappingInOneDirection: resolveLabelOverlappingInOneDirection
};
exports.overlapping = overlapping;

var BaseChart = _base_widget.default.inherit({
  _eventsMap: {
    onSeriesClick: {
      name: 'seriesClick'
    },
    onPointClick: {
      name: 'pointClick'
    },
    onArgumentAxisClick: {
      name: 'argumentAxisClick'
    },
    onLegendClick: {
      name: 'legendClick'
    },
    onSeriesSelectionChanged: {
      name: 'seriesSelectionChanged'
    },
    onPointSelectionChanged: {
      name: 'pointSelectionChanged'
    },
    onSeriesHoverChanged: {
      name: 'seriesHoverChanged'
    },
    onPointHoverChanged: {
      name: 'pointHoverChanged'
    },
    onDone: {
      name: 'done'
    },
    onZoomStart: {
      name: 'zoomStart'
    },
    onZoomEnd: {
      name: 'zoomEnd'
    }
  },
  _fontFields: ['legend.' + FONT, 'legend.title.' + FONT, 'legend.title.subtitle.' + FONT, 'commonSeriesSettings.label.' + FONT],
  _rootClassPrefix: 'dxc',
  _rootClass: 'dxc-chart',
  _initialChanges: ['INIT'],
  _themeDependentChanges: ['REFRESH_SERIES_REINIT'],
  _getThemeManagerOptions: function _getThemeManagerOptions() {
    var themeOptions = this.callBase.apply(this, arguments);
    themeOptions.options = this.option();
    return themeOptions;
  },
  _createThemeManager: function _createThemeManager() {
    var chartOption = this.option();
    var themeManager = new _chart_theme_manager.ThemeManager(this._getThemeManagerOptions());
    themeManager.setTheme(chartOption.theme, chartOption.rtlEnabled);
    return themeManager;
  },
  _initCore: function _initCore() {
    var that = this;
    that._canvasClipRect = that._renderer.clipRect();

    that._createHtmlStructure();

    that._createLegend();

    that._createTracker();

    that._needHandleRenderComplete = true;
    that.layoutManager = new _layout_manager.LayoutManager();

    that._createScrollBar();

    _events_engine.default.on(that._$element, 'contextmenu', function (event) {
      if ((0, _index.isTouchEvent)(event) || (0, _index.isPointerEvent)(event)) {
        event.preventDefault();
      }
    });

    _events_engine.default.on(that._$element, 'MSHoldVisual', function (event) {
      event.preventDefault();
    });
  },
  // Common functionality is overridden because Chart has its own layout logic. Nevertheless common logic should be used.
  _getLayoutItems: _common.noop,
  _layoutManagerOptions: function _layoutManagerOptions() {
    return this._themeManager.getOptions('adaptiveLayout');
  },
  _reinit: function _reinit() {
    var that = this;
    (0, _utils.setCanvasValues)(that._canvas);

    that._reinitAxes();

    that._requestChange(['DATA_SOURCE', 'DATA_INIT', 'CORRECT_AXIS', 'FULL_RENDER']);
  },
  _correctAxes: _common.noop,
  _createHtmlStructure: function _createHtmlStructure() {
    var that = this;
    var renderer = that._renderer;
    var root = renderer.root;

    var createConstantLinesGroup = function createConstantLinesGroup() {
      // TODO: Must be created in the same place where used (advanced chart)
      return renderer.g().attr({
        'class': 'dxc-constant-lines-group'
      }).linkOn(root, 'constant-lines');
    };

    that._constantLinesGroup = {
      dispose: function dispose() {
        this.under.dispose();
        this.above.dispose();
      },
      linkOff: function linkOff() {
        this.under.linkOff();
        this.above.linkOff();
      },
      clear: function clear() {
        this.under.linkRemove().clear();
        this.above.linkRemove().clear();
      },
      linkAppend: function linkAppend() {
        this.under.linkAppend();
        this.above.linkAppend();
      }
    };
    that._labelsAxesGroup = renderer.g().attr({
      'class': 'dxc-elements-axes-group'
    });

    var appendLabelsAxesGroup = function appendLabelsAxesGroup() {
      that._labelsAxesGroup.linkOn(root, 'elements');
    };

    that._backgroundRect = renderer.rect().attr({
      fill: 'gray',
      opacity: 0.0001
    }).append(root);
    that._panesBackgroundGroup = renderer.g().attr({
      'class': 'dxc-background'
    }).append(root);
    that._stripsGroup = renderer.g().attr({
      'class': 'dxc-strips-group'
    }).linkOn(root, 'strips'); // TODO: Must be created in the same place where used (advanced chart)

    that._gridGroup = renderer.g().attr({
      'class': 'dxc-grids-group'
    }).linkOn(root, 'grids'); // TODO: Must be created in the same place where used (advanced chart)

    that._panesBorderGroup = renderer.g().attr({
      'class': 'dxc-border'
    }).linkOn(root, 'border'); // TODO: Must be created in the same place where used (chart)

    that._axesGroup = renderer.g().attr({
      'class': 'dxc-axes-group'
    }).linkOn(root, 'axes'); // TODO: Must be created in the same place where used (advanced chart)

    that._executeAppendBeforeSeries(appendLabelsAxesGroup);

    that._stripLabelAxesGroup = renderer.g().attr({
      'class': 'dxc-strips-labels-group'
    }).linkOn(root, 'strips-labels'); // TODO: Must be created in the same place where used (advanced chart)

    that._constantLinesGroup.under = createConstantLinesGroup();
    that._seriesGroup = renderer.g().attr({
      'class': 'dxc-series-group'
    }).linkOn(root, 'series');

    that._executeAppendAfterSeries(appendLabelsAxesGroup);

    that._constantLinesGroup.above = createConstantLinesGroup();
    that._scaleBreaksGroup = renderer.g().attr({
      'class': 'dxc-scale-breaks'
    }).linkOn(root, 'scale-breaks');
    that._labelsGroup = renderer.g().attr({
      'class': 'dxc-labels-group'
    }).linkOn(root, 'labels');
    that._crosshairCursorGroup = renderer.g().attr({
      'class': 'dxc-crosshair-cursor'
    }).linkOn(root, 'crosshair');
    that._legendGroup = renderer.g().attr({
      'class': 'dxc-legend',
      'clip-path': that._getCanvasClipRectID()
    }).linkOn(root, 'legend').linkAppend(root).enableLinks();
    that._scrollBarGroup = renderer.g().attr({
      'class': 'dxc-scroll-bar'
    }).linkOn(root, 'scroll-bar');
  },
  _executeAppendBeforeSeries: function _executeAppendBeforeSeries() {},
  _executeAppendAfterSeries: function _executeAppendAfterSeries() {},
  _disposeObjectsInArray: function _disposeObjectsInArray(propName, fieldNames) {
    (0, _iterator.each)(this[propName] || [], function (_, item) {
      if (fieldNames && item) {
        (0, _iterator.each)(fieldNames, function (_, field) {
          item[field] && item[field].dispose();
        });
      } else {
        item && item.dispose();
      }
    });
    this[propName] = null;
  },
  _disposeCore: function _disposeCore() {
    var that = this;

    var disposeObject = function disposeObject(propName) {
      // TODO: What is the purpose of the `if` check in a private function?
      if (that[propName]) {
        that[propName].dispose();
        that[propName] = null;
      }
    };

    var unlinkGroup = function unlinkGroup(name) {
      that[name].linkOff();
    };

    var disposeObjectsInArray = this._disposeObjectsInArray;

    that._renderer.stopAllAnimations();

    disposeObjectsInArray.call(that, 'series');
    disposeObject('_tracker');
    disposeObject('_crosshair');
    that.layoutManager = that._userOptions = that._canvas = that._groupsData = null;
    unlinkGroup('_stripsGroup');
    unlinkGroup('_gridGroup');
    unlinkGroup('_axesGroup');
    unlinkGroup('_constantLinesGroup');
    unlinkGroup('_stripLabelAxesGroup');
    unlinkGroup('_panesBorderGroup');
    unlinkGroup('_seriesGroup');
    unlinkGroup('_labelsGroup');
    unlinkGroup('_crosshairCursorGroup');
    unlinkGroup('_legendGroup');
    unlinkGroup('_scrollBarGroup');
    unlinkGroup('_scaleBreaksGroup');
    disposeObject('_canvasClipRect');
    disposeObject('_panesBackgroundGroup');
    disposeObject('_backgroundRect');
    disposeObject('_stripsGroup');
    disposeObject('_gridGroup');
    disposeObject('_axesGroup');
    disposeObject('_constantLinesGroup');
    disposeObject('_stripLabelAxesGroup');
    disposeObject('_panesBorderGroup');
    disposeObject('_seriesGroup');
    disposeObject('_labelsGroup');
    disposeObject('_crosshairCursorGroup');
    disposeObject('_legendGroup');
    disposeObject('_scrollBarGroup');
    disposeObject('_scaleBreaksGroup');
  },
  _getAnimationOptions: function _getAnimationOptions() {
    return this._themeManager.getOptions('animation');
  },
  _getDefaultSize: function _getDefaultSize() {
    return {
      width: 400,
      height: 400
    };
  },
  // TODO: Theme manager should stop knowing about user options then this method can be removed
  _getOption: function _getOption(name) {
    return this._themeManager.getOptions(name);
  },
  _applySize: function _applySize(rect) {
    this._rect = rect.slice();

    if (!this._changes.has('FULL_RENDER')) {
      this._processRefreshData(RESIZE_REFRESH_ACTION);
    }
  },
  // _resize: function () {
  //    if (this._updateLockCount) {// T244164
  //        this._processRefreshData(RESIZE_REFRESH_ACTION);
  //    } else {
  //        this._render(this.__renderOptions || { animate: false, isResize: true });
  //    }
  // },
  _resize: function _resize() {
    this._doRender(this.__renderOptions || {
      animate: false,
      isResize: true
    });
  },
  _trackerType: 'ChartTracker',
  _createTracker: function _createTracker() {
    var that = this;
    that._tracker = new trackerModule[that._trackerType]({
      seriesGroup: that._seriesGroup,
      renderer: that._renderer,
      tooltip: that._tooltip,
      legend: that._legend,
      eventTrigger: that._eventTrigger
    });
  },
  _getTrackerSettings: function _getTrackerSettings() {
    return (0, _extend.extend)({
      chart: this
    }, this._getSelectionModes());
  },
  _getSelectionModes: function _getSelectionModes() {
    var themeManager = this._themeManager;
    return {
      seriesSelectionMode: themeManager.getOptions('seriesSelectionMode'),
      pointSelectionMode: themeManager.getOptions('pointSelectionMode')
    };
  },
  _updateTracker: function _updateTracker(trackerCanvases) {
    var that = this;

    that._tracker.update(that._getTrackerSettings());

    that._tracker.setCanvases({
      left: 0,
      right: that._canvas.width,
      top: 0,
      bottom: that._canvas.height
    }, trackerCanvases);
  },
  _createCanvasFromRect: function _createCanvasFromRect(rect) {
    var currentCanvas = this._canvas;
    return (0, _utils.setCanvasValues)({
      left: rect[0],
      top: rect[1],
      right: currentCanvas.width - rect[2],
      bottom: currentCanvas.height - rect[3],
      width: currentCanvas.width,
      height: currentCanvas.height
    });
  },
  _doRender: function _doRender(_options) {
    var that = this;
    if (that._canvas.width === 0 && that._canvas.height === 0) return;

    that._resetIsReady(); // T207606


    var drawOptions = that._prepareDrawOptions(_options);

    var recreateCanvas = drawOptions.recreateCanvas; // T207665

    that._preserveOriginalCanvas(); // T207665


    if (recreateCanvas) {
      that.__currentCanvas = that._canvas;
    } else {
      that._canvas = that.__currentCanvas;
    }

    recreateCanvas && that._updateCanvasClipRect(that._canvas);
    this._canvas = this._createCanvasFromRect(this._rect);

    that._renderer.stopAllAnimations(true);

    that._cleanGroups();

    var startTime = new Date();

    that._renderElements(drawOptions);

    that._lastRenderingTime = new Date() - startTime;
  },
  _preserveOriginalCanvas: function _preserveOriginalCanvas() {
    this.__originalCanvas = this._canvas;
    this._canvas = (0, _extend.extend)({}, this._canvas); // NOTE: Instance of the original canvas must be preserved
  },
  _layoutAxes: _common.noop,
  _renderElements: function _renderElements(drawOptions) {
    var that = this;

    var preparedOptions = that._prepareToRender(drawOptions);

    var isRotated = that._isRotated();

    var isLegendInside = that._isLegendInside();

    var trackerCanvases = [];
    var dirtyCanvas = (0, _extend.extend)({}, that._canvas);
    var argBusinessRange;
    var zoomMinArg;
    var zoomMaxArg;

    that._renderer.lock();

    if (drawOptions.drawLegend && that._legend) {
      that._legendGroup.linkAppend();
    }

    that.layoutManager.setOptions(that._layoutManagerOptions());

    var layoutTargets = that._getLayoutTargets();

    this._layoutAxes(function (needSpace) {
      var axisDrawOptions = needSpace ? (0, _extend.extend)({}, drawOptions, {
        animate: false,
        recreateCanvas: true
      }) : drawOptions;

      var canvas = that._renderAxes(axisDrawOptions, preparedOptions);

      that._shrinkAxes(needSpace, canvas);
    });

    that._applyClipRects(preparedOptions);

    that._appendSeriesGroups();

    that._createCrosshairCursor();

    layoutTargets.forEach(function (_ref) {
      var canvas = _ref.canvas;
      trackerCanvases.push({
        left: canvas.left,
        right: canvas.width - canvas.right,
        top: canvas.top,
        bottom: canvas.height - canvas.bottom
      });
    });

    if (that._scrollBar) {
      argBusinessRange = that._argumentAxes[0].getTranslator().getBusinessRange();

      if (argBusinessRange.axisType === 'discrete' && argBusinessRange.categories && argBusinessRange.categories.length <= 1 || argBusinessRange.axisType !== 'discrete' && argBusinessRange.min === argBusinessRange.max) {
        zoomMinArg = zoomMaxArg = undefined;
      } else {
        zoomMinArg = argBusinessRange.minVisible;
        zoomMaxArg = argBusinessRange.maxVisible;
      }

      that._scrollBar.init(argBusinessRange, !that._argumentAxes[0].getOptions().valueMarginsEnabled).setPosition(zoomMinArg, zoomMaxArg);
    }

    that._updateTracker(trackerCanvases);

    that._updateLegendPosition(drawOptions, isLegendInside);

    that._applyPointMarkersAutoHiding();

    that._renderSeries(drawOptions, isRotated, isLegendInside);

    that._renderer.unlock();
  },
  _updateLegendPosition: _common.noop,
  _createCrosshairCursor: _common.noop,
  _appendSeriesGroups: function _appendSeriesGroups() {
    this._seriesGroup.linkAppend();

    this._labelsGroup.linkAppend();

    this._appendAdditionalSeriesGroups();
  },
  _renderSeries: function _renderSeries(drawOptions, isRotated, isLegendInside) {
    this._calculateSeriesLayout(drawOptions, isRotated);

    this._renderSeriesElements(drawOptions, isLegendInside);
  },
  _calculateSeriesLayout: function _calculateSeriesLayout(drawOptions, isRotated) {
    drawOptions.hideLayoutLabels = this.layoutManager.needMoreSpaceForPanesCanvas(this._getLayoutTargets(), isRotated) && !this._themeManager.getOptions('adaptiveLayout').keepLabels;

    this._updateSeriesDimensions(drawOptions);
  },
  _getArgFilter: function _getArgFilter() {
    return function () {
      return true;
    };
  },
  _getValFilter: function _getValFilter(series) {
    return function () {
      return true;
    };
  },
  _getPointsToAnimation: function _getPointsToAnimation(series) {
    var _this = this;

    var argViewPortFilter = this._getArgFilter();

    return series.map(function (s) {
      var valViewPortFilter = _this._getValFilter(s);

      return s.getPoints().filter(function (p) {
        return p.getOptions().visible && argViewPortFilter(p.argument) && (valViewPortFilter(p.getMinValue(true)) || valViewPortFilter(p.getMaxValue(true)));
      }).length;
    });
  },
  _renderSeriesElements: function _renderSeriesElements(drawOptions, isLegendInside) {
    var that = this;
    var i;
    var series = that.series;
    var singleSeries;
    var seriesLength = series.length;

    var resolveLabelOverlapping = that._themeManager.getOptions('resolveLabelOverlapping');

    var pointsToAnimation = that._getPointsToAnimation(series);

    for (i = 0; i < seriesLength; i++) {
      singleSeries = series[i];

      that._applyExtraSettings(singleSeries, drawOptions);

      singleSeries.draw(drawOptions.animate && pointsToAnimation[i] <= drawOptions.animationPointsLimit && that._renderer.animationEnabled(), drawOptions.hideLayoutLabels, that._getLegendCallBack(singleSeries));
    }

    if (resolveLabelOverlapping === 'none') {
      that._adjustSeriesLabels(false);
    } else {
      that._locateLabels(resolveLabelOverlapping);
    }

    that._renderTrackers(isLegendInside);

    that._tracker.repairTooltip();

    that._renderExtraElements();

    that._clearCanvas();

    that._seriesElementsDrawn = true;
  },
  _changesApplied: function _changesApplied() {
    var that = this;

    if (that._seriesElementsDrawn) {
      that._seriesElementsDrawn = false;

      that._drawn();

      that._renderCompleteHandler();
    }
  },
  _locateLabels: function _locateLabels(resolveLabelOverlapping) {
    this._resolveLabelOverlapping(resolveLabelOverlapping);
  },
  _renderExtraElements: function _renderExtraElements() {},
  _clearCanvas: function _clearCanvas() {
    // T207665, T336349, T503616
    this._canvas = this.__originalCanvas;
  },
  _resolveLabelOverlapping: function _resolveLabelOverlapping(resolveLabelOverlapping) {
    var func;

    switch (resolveLabelOverlapping) {
      case 'stack':
        func = this._resolveLabelOverlappingStack;
        break;

      case 'hide':
        func = this._resolveLabelOverlappingHide;
        break;

      case 'shift':
        func = this._resolveLabelOverlappingShift;
        break;
    }

    return (0, _type.isFunction)(func) && func.call(this);
  },
  _getVisibleSeries: function _getVisibleSeries() {
    return (0, _common.grep)(this.getAllSeries(), function (series) {
      return series.isVisible();
    });
  },
  _resolveLabelOverlappingHide: function _resolveLabelOverlappingHide() {
    var labels = [];
    var currentLabel;
    var nextLabel;
    var currentLabelRect;
    var nextLabelRect;
    var i;
    var j;
    var points;

    var series = this._getVisibleSeries();

    for (i = 0; i < series.length; i++) {
      points = series[i].getVisiblePoints();

      for (j = 0; j < points.length; j++) {
        labels.push.apply(labels, points[j].getLabels());
      }
    }

    for (i = 0; i < labels.length; i++) {
      currentLabel = labels[i];

      if (!currentLabel.isVisible()) {
        continue;
      }

      currentLabelRect = currentLabel.getBoundingRect();

      for (j = i + 1; j < labels.length; j++) {
        nextLabel = labels[j];
        nextLabelRect = nextLabel.getBoundingRect();

        if (checkOverlapping(currentLabelRect, nextLabelRect)) {
          nextLabel.draw(false);
        }
      }
    }
  },
  _cleanGroups: function _cleanGroups() {
    var that = this;

    that._stripsGroup.linkRemove().clear(); // TODO: Must be removed in the same place where appended (advanced chart)


    that._gridGroup.linkRemove().clear(); // TODO: Must be removed in the same place where appended (advanced chart)


    that._axesGroup.linkRemove().clear(); // TODO: Must be removed in the same place where appended (advanced chart)


    that._constantLinesGroup.above.clear(); // TODO: Must be removed in the same place where appended (advanced chart)


    that._stripLabelAxesGroup.linkRemove().clear(); // TODO: Must be removed in the same place where appended (advanced chart)
    // that._seriesGroup.linkRemove().clear();


    that._labelsGroup.linkRemove().clear();

    that._crosshairCursorGroup.linkRemove().clear();

    that._scaleBreaksGroup.linkRemove().clear();
  },
  _allowLegendInsidePosition: function _allowLegendInsidePosition() {
    return false;
  },
  _createLegend: function _createLegend() {
    var that = this;
    var legendSettings = getLegendSettings(that._legendDataField);
    that._legend = new _legend.Legend({
      renderer: that._renderer,
      widget: that,
      group: that._legendGroup,
      backgroundClass: 'dxc-border',
      itemGroupClass: 'dxc-item',
      titleGroupClass: 'dxc-title',
      textField: legendSettings.textField,
      getFormatObject: legendSettings.getFormatObject,
      allowInsidePosition: that._allowLegendInsidePosition()
    });

    that._updateLegend();

    that._layout.add(that._legend);
  },
  _updateLegend: function _updateLegend() {
    var that = this;
    var themeManager = that._themeManager;
    var legendOptions = themeManager.getOptions('legend');

    var legendData = that._getLegendData();

    legendOptions.containerBackgroundColor = themeManager.getOptions('containerBackgroundColor');
    legendOptions._incidentOccurred = that._incidentOccurred; // TODO: Why is `_` used?

    that._legend.update(legendData, legendOptions, themeManager.theme('legend').title);

    this._change(['LAYOUT']);
  },
  _prepareDrawOptions: function _prepareDrawOptions(drawOptions) {
    var animationOptions = this._getAnimationOptions();

    var options = (0, _extend.extend)({}, {
      force: false,
      adjustAxes: true,
      drawLegend: true,
      drawTitle: true,
      animate: animationOptions.enabled,
      animationPointsLimit: animationOptions.maxPointCountSupported
    }, drawOptions, this.__renderOptions); // NOTE: This is to support `render` method options

    if (!(0, _type.isDefined)(options.recreateCanvas)) {
      options.recreateCanvas = options.adjustAxes && options.drawLegend && options.drawTitle;
    }

    return options;
  },
  _processRefreshData: function _processRefreshData(newRefreshAction) {
    var currentRefreshActionPosition = (0, _array.inArray)(this._currentRefreshData, ACTIONS_BY_PRIORITY);
    var newRefreshActionPosition = (0, _array.inArray)(newRefreshAction, ACTIONS_BY_PRIORITY);

    if (!this._currentRefreshData || currentRefreshActionPosition >= 0 && newRefreshActionPosition < currentRefreshActionPosition) {
      this._currentRefreshData = newRefreshAction; // this._invalidate();
    }

    this._requestChange(['REFRESH']);
  },
  _getLegendData: function _getLegendData() {
    return (0, _utils.map)(this._getLegendTargets(), function (item) {
      var legendData = item.legendData;
      var style = item.getLegendStyles;
      var opacity = style.normal.opacity;

      if (!item.visible) {
        if (!(0, _type.isDefined)(opacity) || opacity > DEFAULT_OPACITY) {
          opacity = DEFAULT_OPACITY;
        }

        legendData.textOpacity = DEFAULT_OPACITY;
      }

      var opacityStyle = {
        opacity: opacity
      };
      legendData.states = {
        hover: (0, _extend.extend)({}, style.hover, opacityStyle),
        selection: (0, _extend.extend)({}, style.selection, opacityStyle),
        normal: (0, _extend.extend)({}, style.normal, opacityStyle)
      };
      return legendData;
    });
  },
  _getLegendOptions: function _getLegendOptions(item) {
    return {
      legendData: {
        text: item[this._legendItemTextField],
        id: item.index,
        visible: true
      },
      getLegendStyles: item.getLegendStyles(),
      visible: item.isVisible()
    };
  },
  _disposeSeries: function _disposeSeries(seriesIndex) {
    var _that$series;

    var that = this;

    if (that.series) {
      if ((0, _type.isDefined)(seriesIndex)) {
        that.series[seriesIndex].dispose();
        that.series.splice(seriesIndex, 1);
      } else {
        (0, _iterator.each)(that.series, function (_, s) {
          return s.dispose();
        });
        that.series.length = 0;
      }
    }

    if (!((_that$series = that.series) !== null && _that$series !== void 0 && _that$series.length)) {
      that.series = [];
    }
  },
  _disposeSeriesFamilies: function _disposeSeriesFamilies() {
    var that = this;
    (0, _iterator.each)(that.seriesFamilies || [], function (_, family) {
      family.dispose();
    });
    that.seriesFamilies = null;
    that._needHandleRenderComplete = true;
  },
  _optionChanged: function _optionChanged(arg) {
    this._themeManager.resetOptions(arg.name);

    this.callBase.apply(this, arguments);
  },
  _applyChanges: function _applyChanges() {
    var that = this;

    that._themeManager.update(that._options.silent());

    that.callBase.apply(that, arguments);
  },
  _optionChangesMap: {
    animation: 'ANIMATION',
    dataSource: 'DATA_SOURCE',
    palette: 'PALETTE',
    paletteExtensionMode: 'PALETTE',
    legend: 'FORCE_DATA_INIT',
    seriesTemplate: 'FORCE_DATA_INIT',
    'export': 'FORCE_RENDER',
    valueAxis: 'AXES_AND_PANES',
    argumentAxis: 'AXES_AND_PANES',
    commonAxisSettings: 'AXES_AND_PANES',
    panes: 'AXES_AND_PANES',
    commonPaneSettings: 'AXES_AND_PANES',
    defaultPane: 'AXES_AND_PANES',
    containerBackgroundColor: 'AXES_AND_PANES',
    rotated: 'ROTATED',
    autoHidePointMarkers: 'REFRESH_SERIES_REINIT',
    customizePoint: 'REFRESH_SERIES_REINIT',
    customizeLabel: 'REFRESH_SERIES_REINIT',
    scrollBar: 'SCROLL_BAR'
  },
  _optionChangesOrder: ['ROTATED', 'PALETTE', 'REFRESH_SERIES_REINIT', 'AXES_AND_PANES', 'INIT', 'REINIT', 'DATA_SOURCE', 'REFRESH_SERIES_DATA_INIT', 'DATA_INIT', 'FORCE_DATA_INIT', 'REFRESH_AXES', 'CORRECT_AXIS'],
  _customChangesOrder: ['ANIMATION', 'REFRESH_SERIES_FAMILIES', 'FORCE_FIRST_DRAWING', 'FORCE_DRAWING', 'FORCE_RENDER', 'VISUAL_RANGE', 'SCROLL_BAR', 'REINIT', 'REFRESH', 'FULL_RENDER'],
  _change_ANIMATION: function _change_ANIMATION() {
    this._renderer.updateAnimationOptions(this._getAnimationOptions());
  },
  _change_DATA_SOURCE: function _change_DATA_SOURCE() {
    this._needHandleRenderComplete = true;

    this._updateDataSource();
  },
  _change_PALETTE: function _change_PALETTE() {
    this._themeManager.updatePalette();

    this._refreshSeries('DATA_INIT');
  },
  _change_REFRESH_SERIES_DATA_INIT: function _change_REFRESH_SERIES_DATA_INIT() {
    this._refreshSeries('DATA_INIT');
  },
  _change_DATA_INIT: function _change_DATA_INIT() {
    if ((!this.series || this.needToPopulateSeries) && !this._changes.has('FORCE_DATA_INIT')) {
      this._dataInit();
    }
  },
  _change_FORCE_DATA_INIT: function _change_FORCE_DATA_INIT() {
    this._dataInit();
  },
  _change_REFRESH_SERIES_FAMILIES: function _change_REFRESH_SERIES_FAMILIES() {
    this._processSeriesFamilies();

    this._populateBusinessRange();

    this._processRefreshData(FORCE_RENDER_REFRESH_ACTION);
  },
  _change_FORCE_RENDER: function _change_FORCE_RENDER() {
    this._processRefreshData(FORCE_RENDER_REFRESH_ACTION);
  },
  _change_AXES_AND_PANES: function _change_AXES_AND_PANES() {
    this._refreshSeries('INIT');
  },
  _change_ROTATED: function _change_ROTATED() {
    this._createScrollBar();

    this._refreshSeries('INIT');
  },
  _change_REFRESH_SERIES_REINIT: function _change_REFRESH_SERIES_REINIT() {
    this._refreshSeries('INIT');
  },
  _change_REFRESH_AXES: function _change_REFRESH_AXES() {
    var that = this;
    (0, _utils.setCanvasValues)(that._canvas);

    that._reinitAxes();

    that._requestChange(['CORRECT_AXIS', 'FULL_RENDER']);
  },
  _change_SCROLL_BAR: function _change_SCROLL_BAR() {
    this._createScrollBar();

    this._processRefreshData(FORCE_RENDER_REFRESH_ACTION);
  },
  _change_REINIT: function _change_REINIT() {
    this._processRefreshData(REINIT_REFRESH_ACTION);
  },
  _change_FORCE_DRAWING: function _change_FORCE_DRAWING() {
    this._resetComponentsAnimation();
  },
  _change_FORCE_FIRST_DRAWING: function _change_FORCE_FIRST_DRAWING() {
    this._resetComponentsAnimation(true);
  },
  _resetComponentsAnimation: function _resetComponentsAnimation(isFirstDrawing) {
    this.series.forEach(function (s) {
      s.resetApplyingAnimation(isFirstDrawing);
    });

    this._resetAxesAnimation(isFirstDrawing);
  },
  _resetAxesAnimation: _common.noop,
  _refreshSeries: function _refreshSeries(actionName) {
    this.needToPopulateSeries = true;

    this._requestChange([actionName]);
  },
  _change_CORRECT_AXIS: function _change_CORRECT_AXIS() {
    this._correctAxes();
  },
  _doRefresh: function _doRefresh() {
    var methodName = this._currentRefreshData;

    if (methodName) {
      this._currentRefreshData = null;

      this._renderer.stopAllAnimations(true);

      this[methodName]();
    }
  },
  _updateCanvasClipRect: function _updateCanvasClipRect(canvas) {
    var that = this;
    var width = Math.max(canvas.width - canvas.left - canvas.right, 0);
    var height = Math.max(canvas.height - canvas.top - canvas.bottom, 0);

    that._canvasClipRect.attr({
      x: canvas.left,
      y: canvas.top,
      width: width,
      height: height
    });

    that._backgroundRect.attr({
      x: canvas.left,
      y: canvas.top,
      width: width,
      height: height
    });
  },
  _getCanvasClipRectID: function _getCanvasClipRectID() {
    return this._canvasClipRect.id;
  },
  _dataSourceChangedHandler: function _dataSourceChangedHandler() {
    if (this._changes.has('INIT')) {
      this._requestChange(['DATA_INIT']);
    } else {
      this._requestChange(['FORCE_DATA_INIT']);
    }
  },
  _dataInit: function _dataInit() {
    this._dataSpecificInit(true);
  },
  _processSingleSeries: function _processSingleSeries(singleSeries) {
    singleSeries.createPoints(false);
  },
  _handleSeriesDataUpdated: function _handleSeriesDataUpdated() {
    var _this2 = this;

    if (this._getVisibleSeries().some(function (s) {
      return s.useAggregation();
    })) {
      this._populateMarginOptions();
    }

    this.series.forEach(function (s) {
      return _this2._processSingleSeries(s);
    }, this);
  },
  _dataSpecificInit: function _dataSpecificInit(needRedraw) {
    var that = this;

    if (!that.series || that.needToPopulateSeries) {
      that.series = that._populateSeries();
    }

    that._repopulateSeries();

    that._seriesPopulatedHandlerCore();

    that._populateBusinessRange();

    that._tracker.updateSeries(that.series, this._changes.has('INIT'));

    that._updateLegend();

    if (needRedraw) {
      this._requestChange(['FULL_RENDER']);
    } // needRedraw && that._forceRender();

  },
  _forceRender: function _forceRender() {
    this._doRender({
      force: true
    });
  },
  _repopulateSeries: function _repopulateSeries() {
    var that = this;
    var themeManager = that._themeManager;

    var data = that._dataSourceItems();

    var dataValidatorOptions = themeManager.getOptions('dataPrepareSettings');
    var seriesTemplate = themeManager.getOptions('seriesTemplate');

    if (seriesTemplate) {
      that._populateSeries(data);
    }

    that._groupSeries();

    var parsedData = (0, _data_validator.validateData)(data, that._groupsData, that._incidentOccurred, dataValidatorOptions);
    themeManager.resetPalette();
    that.series.forEach(function (singleSeries) {
      singleSeries.updateData(parsedData[singleSeries.getArgumentField()]);
    });

    that._handleSeriesDataUpdated();
  },
  _renderCompleteHandler: function _renderCompleteHandler() {
    var that = this;
    var allSeriesInited = true;

    if (that._needHandleRenderComplete) {
      (0, _iterator.each)(that.series, function (_, s) {
        allSeriesInited = allSeriesInited && s.canRenderCompleteHandle();
      });

      if (allSeriesInited) {
        that._needHandleRenderComplete = false;

        that._eventTrigger('done', {
          target: that
        });
      }
    }
  },
  _dataIsReady: function _dataIsReady() {
    // In order to support scenario when chart is created without "dataSource" and it is considered
    // as data is being loaded the check for state of "dataSource" option is added
    return (0, _type.isDefined)(this.option('dataSource')) && this._dataIsLoaded();
  },
  _populateSeriesOptions: function _populateSeriesOptions(data) {
    var that = this;
    var themeManager = that._themeManager;
    var seriesTemplate = themeManager.getOptions('seriesTemplate');
    var seriesOptions = seriesTemplate ? (0, _utils.processSeriesTemplate)(seriesTemplate, data || []) : that.option('series');
    var allSeriesOptions = _isArray(seriesOptions) ? seriesOptions : seriesOptions ? [seriesOptions] : [];

    var extraOptions = that._getExtraOptions();

    var particularSeriesOptions;
    var seriesTheme;
    var seriesThemes = [];

    var seriesVisibilityChanged = function seriesVisibilityChanged(target) {
      that._specialProcessSeries();

      that._populateBusinessRange(target && target.getValueAxis(), true);

      that._renderer.stopAllAnimations(true);

      that._updateLegend();

      that._requestChange(['FULL_RENDER']);
    };

    for (var i = 0; i < allSeriesOptions.length; i++) {
      particularSeriesOptions = (0, _extend.extend)(true, {}, allSeriesOptions[i], extraOptions);

      if (!(0, _type.isDefined)(particularSeriesOptions.name) || particularSeriesOptions.name === '') {
        particularSeriesOptions.name = 'Series ' + (i + 1).toString();
      }

      particularSeriesOptions.rotated = that._isRotated();
      particularSeriesOptions.customizePoint = themeManager.getOptions('customizePoint');
      particularSeriesOptions.customizeLabel = themeManager.getOptions('customizeLabel');
      particularSeriesOptions.visibilityChanged = seriesVisibilityChanged;
      particularSeriesOptions.incidentOccurred = that._incidentOccurred;
      seriesTheme = themeManager.getOptions('series', particularSeriesOptions, allSeriesOptions.length);

      if (that._checkPaneName(seriesTheme)) {
        seriesThemes.push(seriesTheme);
      }
    }

    return seriesThemes;
  },
  _populateSeries: function _populateSeries(data) {
    var _that$series2;

    var that = this;
    var seriesBasis = [];
    var incidentOccurred = that._incidentOccurred;

    var seriesThemes = that._populateSeriesOptions(data);

    var particularSeries;
    var disposeSeriesFamilies = false;
    that.needToPopulateSeries = false;
    (0, _iterator.each)(seriesThemes, function (_, theme) {
      var curSeries = that.series && that.series.filter(function (s) {
        return s.name === theme.name && seriesBasis.map(function (sb) {
          return sb.series;
        }).indexOf(s) === -1;
      })[0];

      if (curSeries && curSeries.type === theme.type) {
        seriesBasis.push({
          series: curSeries,
          options: theme
        });
      } else {
        seriesBasis.push({
          options: theme
        });
        disposeSeriesFamilies = true;
      }
    });
    ((_that$series2 = that.series) === null || _that$series2 === void 0 ? void 0 : _that$series2.length) !== 0 && that._tracker.clearHover();
    (0, _iterator.reverseEach)(that.series, function (index, series) {
      if (!seriesBasis.some(function (s) {
        return series === s.series;
      })) {
        that._disposeSeries(index);

        disposeSeriesFamilies = true;
      }
    });
    !disposeSeriesFamilies && (disposeSeriesFamilies = seriesBasis.some(function (sb) {
      return sb.series.name !== seriesThemes[sb.series.index].name;
    }));
    that.series = [];
    disposeSeriesFamilies && that._disposeSeriesFamilies();

    that._themeManager.resetPalette();

    var eventPipe = function eventPipe(data) {
      that.series.forEach(function (currentSeries) {
        currentSeries.notify(data);
      });
    };

    (0, _iterator.each)(seriesBasis, function (_, basis) {
      var _that$_argumentAxes$f, _that$_argumentAxes;

      var seriesTheme = basis.options;
      var argumentAxis = (_that$_argumentAxes$f = (_that$_argumentAxes = that._argumentAxes) === null || _that$_argumentAxes === void 0 ? void 0 : _that$_argumentAxes.filter(function (a) {
        return a.pane === seriesTheme.pane;
      })[0]) !== null && _that$_argumentAxes$f !== void 0 ? _that$_argumentAxes$f : that.getArgumentAxis();
      var renderSettings = {
        commonSeriesModes: that._getSelectionModes(),
        argumentAxis: argumentAxis,
        valueAxis: that._getValueAxis(seriesTheme.pane, seriesTheme.axis)
      };

      if (basis.series) {
        particularSeries = basis.series;
        particularSeries.updateOptions(seriesTheme, renderSettings);
      } else {
        particularSeries = new _base_series.Series((0, _extend.extend)({
          renderer: that._renderer,
          seriesGroup: that._seriesGroup,
          labelsGroup: that._labelsGroup,
          eventTrigger: that._eventTrigger,
          eventPipe: eventPipe,
          incidentOccurred: incidentOccurred
        }, renderSettings), seriesTheme);
      }

      if (!particularSeries.isUpdated) {
        incidentOccurred('E2101', [seriesTheme.type]);
      } else {
        particularSeries.index = that.series.length;
        that.series.push(particularSeries);
      }
    });
    return that.series;
  },
  getStackedPoints: function getStackedPoints(point) {
    var stackName = point.series.getStackName();
    return this._getVisibleSeries().reduce(function (stackPoints, series) {
      if (!(0, _type.isDefined)(series.getStackName()) || !(0, _type.isDefined)(stackName) || stackName === series.getStackName()) {
        stackPoints = stackPoints.concat(series.getPointsByArg(point.argument));
      }

      return stackPoints;
    }, []);
  },
  // API
  getAllSeries: function getAllSeries() {
    return (this.series || []).slice();
  },
  getSeriesByName: function getSeriesByName(name) {
    var found = null;
    (0, _iterator.each)(this.series, function (i, singleSeries) {
      if (singleSeries.name === name) {
        found = singleSeries;
        return false;
      }
    });
    return found;
  },
  getSeriesByPos: function getSeriesByPos(pos) {
    return (this.series || [])[pos];
  },
  clearSelection: function clearSelection() {
    this._tracker.clearSelection();
  },
  hideTooltip: function hideTooltip() {
    this._tracker._hideTooltip();
  },
  clearHover: function clearHover() {
    this._tracker.clearHover();
  },
  render: function render(renderOptions) {
    var that = this;
    that.__renderOptions = renderOptions;
    that.__forceRender = renderOptions && renderOptions.force;
    that.callBase.apply(that, arguments);
    that.__renderOptions = that.__forceRender = null;
    return that;
  },
  refresh: function refresh() {
    this._disposeSeries();

    this._disposeSeriesFamilies();

    this._requestChange(['CONTAINER_SIZE', 'REFRESH_SERIES_REINIT']);
  },
  _getMinSize: function _getMinSize() {
    var adaptiveLayout = this._layoutManagerOptions();

    return [adaptiveLayout.width, adaptiveLayout.height];
  },
  _change_REFRESH: function _change_REFRESH() {
    if (!this._changes.has('INIT')) {
      this._doRefresh();
    } else {
      this._currentRefreshData = null;
    }
  },
  _change_FULL_RENDER: function _change_FULL_RENDER() {
    this._forceRender();
  },
  _change_INIT: function _change_INIT() {
    this._reinit();
  },
  _stopCurrentHandling: function _stopCurrentHandling() {
    this._tracker.stopCurrentHandling();
  }
});

exports.BaseChart = BaseChart;
REFRESH_SERIES_DATA_INIT_ACTION_OPTIONS.forEach(function (name) {
  BaseChart.prototype._optionChangesMap[name] = 'REFRESH_SERIES_DATA_INIT';
});
FORCE_RENDER_REFRESH_ACTION_OPTIONS.forEach(function (name) {
  BaseChart.prototype._optionChangesMap[name] = 'FORCE_RENDER';
});
REFRESH_SERIES_FAMILIES_ACTION_OPTIONS.forEach(function (name) {
  BaseChart.prototype._optionChangesMap[name] = 'REFRESH_SERIES_FAMILIES';
}); // PLUGINS_SECTION

BaseChart.addPlugin(_export.plugin);
BaseChart.addPlugin(_title.plugin);
BaseChart.addPlugin(_data_source.plugin);
BaseChart.addPlugin(_tooltip.plugin);
BaseChart.addPlugin(_loading_indicator.plugin); // These are charts specifics on using title - they cannot be omitted because of charts custom layout.

var _change_TITLE = BaseChart.prototype._change_TITLE;

BaseChart.prototype._change_TITLE = function () {
  _change_TITLE.apply(this, arguments);

  this._change(['FORCE_RENDER']);
};

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.BaseThemeManager = void 0;

var _class = _interopRequireDefault(__webpack_require__(15));

var _extend2 = __webpack_require__(0);

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

var _palette = __webpack_require__(208);

var _utils = __webpack_require__(14);

var _themes = __webpack_require__(57);

__webpack_require__(1033);

__webpack_require__(1034);

__webpack_require__(1035);

__webpack_require__(1036);

__webpack_require__(1037);

__webpack_require__(1038);

__webpack_require__(1039);

__webpack_require__(1040);

__webpack_require__(1041);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _getTheme = _themes.getTheme;
var _addCacheItem = _themes.addCacheItem;
var _removeCacheItem = _themes.removeCacheItem;
var _extend = _extend2.extend;
var _each = _iterator.each; // register themes

function getThemePart(theme, path) {
  var _theme = theme;
  path && _each(path.split('.'), function (_, pathItem) {
    return _theme = _theme[pathItem];
  });
  return _theme;
}

var BaseThemeManager = _class.default.inherit({
  // TODO: test hack
  ctor: function ctor(options) {
    this._themeSection = options.themeSection;
    this._fontFields = options.fontFields || [];

    _addCacheItem(this);
  },
  dispose: function dispose() {
    var that = this;

    _removeCacheItem(that);

    that._callback = that._theme = that._font = null;
    return that;
  },
  // TODO: Move it to constructor when charts theme managers's constructor is removed
  setCallback: function setCallback(callback) {
    this._callback = callback;
    return this;
  },
  setTheme: function setTheme(theme, rtl) {
    this._current = theme;
    this._rtl = rtl;
    return this.refresh();
  },
  // Officially we do not support objects as "theme" option value - we should stop doing it in code
  refresh: function refresh() {
    var that = this;
    var current = that._current || {};

    var theme = _getTheme(current.name || current);

    that._themeName = theme.name;
    that._defaultPalette = theme.defaultPalette;
    that._font = _extend({}, theme.font, current.font);
    that._themeSection && _each(that._themeSection.split('.'), function (_, path) {
      theme = _extend(true, {}, theme[path]);
    });
    that._theme = _extend(true, {}, theme, (0, _type.isString)(current) ? {} : current);

    that._initializeTheme();

    if ((0, _utils.parseScalar)(that._rtl, that._theme.rtlEnabled)) {
      _extend(true, that._theme, that._theme._rtl);
    }

    that._callback();

    return that;
  },
  theme: function theme(path) {
    return getThemePart(this._theme, path);
  },
  themeName: function themeName() {
    return this._themeName;
  },
  // TODO: May be we need some single method for all palettes?
  createPalette: function createPalette(palette, options) {
    return (0, _palette.createPalette)(palette, options, this._defaultPalette);
  },
  createDiscretePalette: function createDiscretePalette(palette, count) {
    return (0, _palette.getDiscretePalette)(palette, count, this._defaultPalette);
  },
  createGradientPalette: function createGradientPalette(palette) {
    return (0, _palette.getGradientPalette)(palette, this._defaultPalette);
  },
  getAccentColor: function getAccentColor(palette) {
    return (0, _palette.getAccentColor)(palette, this._defaultPalette);
  },
  _initializeTheme: function _initializeTheme() {
    var that = this;

    _each(that._fontFields || [], function (_, path) {
      that._initializeFont(getThemePart(that._theme, path));
    });
  },
  _initializeFont: function _initializeFont(font) {
    _extend(font, this._font, _extend({}, font));
  }
});

exports.BaseThemeManager = BaseThemeManager;

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.LayoutElement = LayoutElement;
exports.WrapperLayoutElement = WrapperLayoutElement;

var _common = __webpack_require__(4);

var _object = __webpack_require__(52);

var _round = Math.round;
var defaultOffset = {
  horizontal: 0,
  vertical: 0
};
var alignFactors = {
  center: 0.5,
  right: 1,
  bottom: 1,
  left: 0,
  top: 0
};

function LayoutElement(options) {
  this._options = options;
}

LayoutElement.prototype = {
  constructor: LayoutElement,
  position: function position(options) {
    var that = this;
    var ofBBox = options.of.getLayoutOptions();
    var myBBox = that.getLayoutOptions();
    var at = options.at;
    var my = options.my;
    var offset = options.offset || defaultOffset;
    var shiftX = -alignFactors[my.horizontal] * myBBox.width + ofBBox.x + alignFactors[at.horizontal] * ofBBox.width + parseInt(offset.horizontal);
    var shiftY = -alignFactors[my.vertical] * myBBox.height + ofBBox.y + alignFactors[at.vertical] * ofBBox.height + parseInt(offset.vertical);
    that.shift(_round(shiftX), _round(shiftY));
  },
  getLayoutOptions: _common.noop
};

function WrapperLayoutElement(renderElement, bBox) {
  this._renderElement = renderElement;
  this._cacheBBox = bBox;
}

var wrapperLayoutElementPrototype = WrapperLayoutElement.prototype = (0, _object.clone)(LayoutElement.prototype);
wrapperLayoutElementPrototype.constructor = WrapperLayoutElement;

wrapperLayoutElementPrototype.getLayoutOptions = function () {
  return this._cacheBBox || this._renderElement.getBBox();
};

wrapperLayoutElementPrototype.shift = function (shiftX, shiftY) {
  var bBox = this.getLayoutOptions();

  this._renderElement.move(_round(shiftX - bBox.x), _round(shiftY - bBox.y));
};

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.validateData = validateData;

var _type = __webpack_require__(1);

var _extend = __webpack_require__(0);

var _utils = __webpack_require__(14);

var _parse_utils = __webpack_require__(346);

var STRING = 'string';
var NUMERIC = 'numeric';
var DATETIME = 'datetime';
var DISCRETE = 'discrete';
var SEMIDISCRETE = 'semidiscrete';
var CONTINUOUS = 'continuous';
var LOGARITHMIC = 'logarithmic';
var VALUE_TYPE = 'valueType';
var ARGUMENT_TYPE = 'argumentType';
var axisTypeParser = (0, _utils.enumParser)([STRING, NUMERIC, DATETIME]);
var _isArray = Array.isArray;

function groupingValues(data, others, valueField, index) {
  if (index >= 0) {
    data.slice(index).forEach(function (cell) {
      if ((0, _type.isDefined)(cell[valueField])) {
        others[valueField] += cell[valueField];
        cell[valueField] = undefined;
      }
    });
  }
}

function processGroups(groups) {
  groups.forEach(function (group) {
    group.valueType = group.valueAxisType = null;
    group.series.forEach(function (series) {
      series.updateDataType({});
    });
    group.valueAxis && group.valueAxis.resetTypes(VALUE_TYPE);
  });
}

function sortValues(data, asc, selector) {
  var func = asc ? function (a, b) {
    return a - b;
  } : function (a, b) {
    return b - a;
  };
  data.sort(function (a, b) {
    var valA = selector(a);
    var valB = selector(b);
    var aa = (0, _type.isDefined)(valA) ? 1 : 0;
    var bb = (0, _type.isDefined)(valB) ? 1 : 0;
    return aa && bb ? func(valA, valB) : func(aa, bb);
  });
  return data;
}

function resetArgumentAxes(axes) {
  axes && axes.forEach(function (axis) {
    axis.resetTypes(ARGUMENT_TYPE);
  });
}

function parseCategories(categories, parser) {
  var newArray = [];
  categories.forEach(function (category) {
    var parsedCategory = parser(category);
    parsedCategory !== undefined && newArray.push(parsedCategory);
  });
  return newArray;
}

function parseAxisCategories(groupsData, parsers) {
  var argumentCategories = groupsData.argumentOptions && groupsData.argumentOptions.categories;
  groupsData.groups.forEach(function (valueGroup, i) {
    var categories = valueGroup.valueOptions && valueGroup.valueOptions.categories;

    if (categories) {
      valueGroup.valueOptions.categories = parseCategories(categories, parsers[i + 1]);
    }
  });

  if (argumentCategories) {
    groupsData.argumentOptions.categories = parseCategories(argumentCategories, parsers[0]);
  }
}

function eigen(x) {
  return x;
}

function getType(unit, type) {
  var result = type;

  if (type === STRING || (0, _type.isString)(unit)) {
    result = STRING;
  } else if (type === DATETIME || (0, _type.isDate)(unit)) {
    result = DATETIME;
  } else if ((0, _type.isNumeric)(unit)) {
    result = NUMERIC;
  }

  return result;
}

function correctAxisType(type, axisType, hasCategories, incidentOccurred) {
  if (type === STRING && (axisType === CONTINUOUS || axisType === LOGARITHMIC || axisType === SEMIDISCRETE)) {
    incidentOccurred('E2002');
  }

  return axisType === LOGARITHMIC ? LOGARITHMIC : hasCategories || axisType === DISCRETE || type === STRING ? DISCRETE : axisType === SEMIDISCRETE ? SEMIDISCRETE : CONTINUOUS;
} // Do we really need this one if all it is only for logarithmic case?


function validUnit(unit, field, incidentOccurred) {
  if (unit) {
    incidentOccurred(!(0, _type.isNumeric)(unit) && !(0, _type.isDate)(unit) && !(0, _type.isString)(unit) ? 'E2003' : 'E2004', [field]);
  }
}

function createParserUnit(type, axisType, incidentOccurred) {
  var parser = type ? (0, _parse_utils.getParser)(type) : eigen;
  var filterInfinity = axisType !== DISCRETE ? function (x) {
    return isFinite(x) || x === undefined ? x : null;
  } : eigen;
  return function (unit, field) {
    var parseUnit = filterInfinity(parser(unit));

    if (parseUnit === undefined) {
      validUnit(unit, field, incidentOccurred);
    }

    return parseUnit;
  };
}

function prepareParsers(groupsData, incidentOccurred) {
  var argumentParser = createParserUnit(groupsData.argumentType, groupsData.argumentAxisType, incidentOccurred);
  var sizeParser;
  var valueParser;
  var categoryParsers = [argumentParser];
  var cache = {};
  var list = [];
  groupsData.groups.forEach(function (group, groupIndex) {
    group.series.forEach(function (series) {
      valueParser = createParserUnit(group.valueType, group.valueAxisType, incidentOccurred);
      sizeParser = createParserUnit(NUMERIC, CONTINUOUS, incidentOccurred);
      cache[series.getArgumentField()] = argumentParser;
      series.getValueFields().forEach(function (field) {
        categoryParsers[groupIndex + 1] = valueParser;
        cache[field] = valueParser;
      });

      if (series.getSizeField()) {
        cache[series.getSizeField()] = sizeParser;
      }
    });
  });

  for (var field in cache) {
    list.push([field, cache[field]]);
  }

  list.length && parseAxisCategories(groupsData, categoryParsers);
  return list;
}

function getParsedCell(cell, parsers) {
  var i;
  var ii = parsers.length;
  var obj = (0, _extend.extend)({}, cell);
  var field;
  var value;

  for (i = 0; i < ii; ++i) {
    field = parsers[i][0];
    value = cell[field];
    obj[field] = parsers[i][1](value, field);
  }

  return obj;
}

function parse(data, parsers) {
  var parsedData = [];
  var i;
  var ii = data.length;
  parsedData.length = ii;

  for (i = 0; i < ii; ++i) {
    parsedData[i] = getParsedCell(data[i], parsers);
  }

  return parsedData;
}

function findIndexByThreshold(data, valueField, threshold) {
  var i;
  var ii = data.length;
  var value;

  for (i = 0; i < ii; ++i) {
    value = data[i][valueField];

    if ((0, _type.isDefined)(value) && threshold > value) {
      break;
    }
  }

  return i;
}

function groupMinSlices(originalData, argumentField, valueField, smallValuesGrouping) {
  smallValuesGrouping = smallValuesGrouping || {};
  var mode = smallValuesGrouping.mode;
  var others = {};

  if (!mode || mode === 'none') {
    return;
  }

  others[argumentField] = String(smallValuesGrouping.groupName || 'others');
  others[valueField] = 0;
  var data = sortValues(originalData.slice(), false, function (a) {
    return a[valueField];
  });
  groupingValues(data, others, valueField, mode === 'smallValueThreshold' ? findIndexByThreshold(data, valueField, smallValuesGrouping.threshold) : smallValuesGrouping.topCount);
  others[valueField] && originalData.push(others);
}

function groupPieData(data, groupsData) {
  var firstSeries = groupsData.groups[0] && groupsData.groups[0].series[0];
  var isPie = firstSeries && (firstSeries.type === 'pie' || firstSeries.type === 'doughnut' || firstSeries.type === 'donut');

  if (!isPie) {
    return;
  }

  groupsData.groups.forEach(function (group) {
    group.series.forEach(function (series) {
      groupMinSlices(data, series.getArgumentField(), series.getValueFields()[0], series.getOptions().smallValuesGrouping);
    });
  });
}

function addUniqueItemToCollection(item, collection, itemsHash) {
  if (!itemsHash[item]) {
    collection.push(item);
    itemsHash[item] = true;
  }
}

function getUniqueArgumentFields(groupsData) {
  var uniqueArgumentFields = [];
  var hash = {};
  groupsData.groups.forEach(function (group) {
    group.series.forEach(function (series) {
      addUniqueItemToCollection(series.getArgumentField(), uniqueArgumentFields, hash);
    });
  });
  return uniqueArgumentFields;
}

function sort(a, b) {
  var result = a - b;

  if (isNaN(result)) {
    if (!(0, _type.isDefined)(a)) {
      return 1;
    }

    if (!(0, _type.isDefined)(b)) {
      return -1;
    }

    return 0;
  }

  return result;
}

function sortByArgument(data, argumentField) {
  return data.slice().sort(function (a, b) {
    return sort(a[argumentField], b[argumentField]);
  });
}

function sortByCallback(data, callback) {
  return data.slice().sort(callback);
}

function checkValueTypeOfGroup(group, cell) {
  group.series.forEach(function (series) {
    series.getValueFields().forEach(function (field) {
      group.valueType = getType(cell[field], group.valueType);
    });
  });
  return group.valueType;
}

function getSortByCategories(categories) {
  var hash = {};
  categories.forEach(function (value, i) {
    hash[value] = i;
  });
  return function (data, argumentField) {
    return sortValues(data.slice(), true, function (a) {
      return hash[a[argumentField]];
    });
  };
}

function sortData(data, groupsData, options, uniqueArgumentFields) {
  var dataByArguments = {};
  var isDiscrete = groupsData.argumentAxisType === DISCRETE;
  var userCategories = isDiscrete && groupsData.argumentOptions && groupsData.argumentOptions.categories;

  var sortFunction = function sortFunction(data) {
    return data;
  };

  var sortingMethodOption = options.sortingMethod;
  var reSortCategories;

  if (!userCategories && (0, _type.isFunction)(sortingMethodOption)) {
    data = sortByCallback(data, sortingMethodOption);
  }

  if (isDiscrete) {
    groupsData.categories = getCategories(data, uniqueArgumentFields, userCategories);
  }

  if (userCategories || !(0, _type.isFunction)(sortingMethodOption) && groupsData.argumentType === STRING && !options._skipArgumentSorting) {
    sortFunction = getSortByCategories(groupsData.categories);
  } else if (sortingMethodOption === true && groupsData.argumentType !== STRING) {
    sortFunction = sortByArgument;
    reSortCategories = isDiscrete;
  }

  uniqueArgumentFields.forEach(function (field) {
    dataByArguments[field] = sortFunction(data, field);
  });

  if (reSortCategories) {
    groupsData.categories = groupsData.categories.sort(sort);
  }

  return dataByArguments;
}

function checkItemExistence(collection, item) {
  return collection.map(function (collectionItem) {
    return collectionItem.valueOf();
  }).indexOf(item.valueOf()) === -1;
}

function getCategories(data, uniqueArgumentFields, userCategories) {
  var categories = userCategories ? userCategories.slice() : [];
  uniqueArgumentFields.forEach(function (field) {
    data.forEach(function (item) {
      var dataItem = item[field];
      (0, _type.isDefined)(dataItem) && checkItemExistence(categories, dataItem) && categories.push(dataItem);
    });
  });
  return categories;
}

function checkArgumentTypeOfGroup(series, cell, groupsData) {
  series.forEach(function (currentSeries) {
    groupsData.argumentType = getType(cell[currentSeries.getArgumentField()], groupsData.argumentType);
  });
  return groupsData.argumentType;
}

function checkType(data, groupsData, checkTypeForAllData) {
  var groupsWithUndefinedValueType = [];
  var groupsWithUndefinedArgumentType = [];
  var argumentTypeGroup = groupsData.argumentOptions && axisTypeParser(groupsData.argumentOptions.argumentType);
  var groupsIndexes;
  groupsData.groups.forEach(function (group) {
    if (!group.series.length) {
      return;
    }

    var valueTypeGroup = group.valueOptions && axisTypeParser(group.valueOptions.valueType);
    group.valueType = valueTypeGroup;
    groupsData.argumentType = argumentTypeGroup;
    !valueTypeGroup && groupsWithUndefinedValueType.push(group);
    !argumentTypeGroup && groupsWithUndefinedArgumentType.push(group);
  });

  if (groupsWithUndefinedValueType.length || groupsWithUndefinedArgumentType.length) {
    groupsIndexes = groupsWithUndefinedValueType.map(function (_, index) {
      return index;
    });
    data.some(function (cell) {
      var defineArg;
      groupsWithUndefinedValueType.forEach(function (group, groupIndex) {
        if (checkValueTypeOfGroup(group, cell) && groupsIndexes.indexOf(groupIndex) >= 0) {
          groupsIndexes.splice(groupIndex, 1);
        }
      });

      if (!defineArg) {
        groupsWithUndefinedArgumentType.forEach(function (group) {
          defineArg = checkArgumentTypeOfGroup(group.series, cell, groupsData);
        });
      }

      if (!checkTypeForAllData && defineArg && groupsIndexes.length === 0) {
        return true;
      }
    });
  }
}

function checkAxisType(groupsData, incidentOccurred) {
  var argumentOptions = groupsData.argumentOptions || {};
  var userArgumentCategories = argumentOptions && argumentOptions.categories || [];
  var argumentAxisType = correctAxisType(groupsData.argumentType, argumentOptions.type, !!userArgumentCategories.length, incidentOccurred);
  groupsData.groups.forEach(function (group) {
    var valueOptions = group.valueOptions || {};
    var valueCategories = valueOptions.categories || [];
    var valueAxisType = correctAxisType(group.valueType, valueOptions.type, !!valueCategories.length, incidentOccurred);
    group.series.forEach(function (series) {
      var optionsSeries = {};
      optionsSeries.argumentAxisType = argumentAxisType;
      optionsSeries.valueAxisType = valueAxisType;
      groupsData.argumentAxisType = groupsData.argumentAxisType || optionsSeries.argumentAxisType;
      group.valueAxisType = group.valueAxisType || optionsSeries.valueAxisType;
      optionsSeries.argumentType = groupsData.argumentType;
      optionsSeries.valueType = group.valueType;
      optionsSeries.showZero = valueOptions.showZero;
      series.updateDataType(optionsSeries);
    });
    group.valueAxisType = group.valueAxisType || valueAxisType;

    if (group.valueAxis) {
      group.valueAxis.setTypes(group.valueAxisType, group.valueType, VALUE_TYPE);
      group.valueAxis.validate();
    }
  });
  groupsData.argumentAxisType = groupsData.argumentAxisType || argumentAxisType;

  if (groupsData.argumentAxes) {
    groupsData.argumentAxes.forEach(function (axis) {
      axis.setTypes(groupsData.argumentAxisType, groupsData.argumentType, ARGUMENT_TYPE);
      axis.validate();
    });
  }
}

function verifyData(source, incidentOccurred) {
  var data = [];
  var sourceIsDefined = (0, _type.isDefined)(source);
  var hasError = sourceIsDefined && !_isArray(source);
  var i;
  var ii;
  var k;
  var item;

  if (sourceIsDefined && !hasError) {
    for (i = 0, ii = source.length, k = 0; i < ii; ++i) {
      item = source[i];

      if ((0, _type.isObject)(item)) {
        data[k++] = item;
      } else if (item) {
        // TODO: And what about `null`, `undefined` and `0`?
        hasError = true;
      }
    }
  }

  if (hasError) {
    incidentOccurred('E2001');
  }

  return data;
}

function validateData(data, groupsData, incidentOccurred, options) {
  data = verifyData(data, incidentOccurred);
  groupsData.argumentType = groupsData.argumentAxisType = null;
  processGroups(groupsData.groups);
  resetArgumentAxes(groupsData.argumentAxes);
  checkType(data, groupsData, options.checkTypeForAllData);
  checkAxisType(groupsData, incidentOccurred);

  if (options.convertToAxisDataType) {
    data = parse(data, prepareParsers(groupsData, incidentOccurred));
  }

  groupPieData(data, groupsData);
  var dataByArgumentFields = sortData(data, groupsData, options, getUniqueArgumentFields(groupsData));
  return dataByArgumentFields;
}

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.correctValueType = correctValueType;
exports.getParser = void 0;

var _common = __webpack_require__(4);

var _date_serialization = _interopRequireDefault(__webpack_require__(63));

var _type = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var parsers = {
  string: function string(val) {
    return (0, _type.isDefined)(val) ? '' + val : val;
  },
  numeric: function numeric(val) {
    if (!(0, _type.isDefined)(val)) {
      return val;
    }

    var parsedVal = Number(val);

    if (isNaN(parsedVal)) {
      parsedVal = undefined;
    }

    return parsedVal;
  },
  datetime: function datetime(val) {
    if (!(0, _type.isDefined)(val)) {
      return val;
    }

    var parsedVal;
    var numVal = Number(val);

    if (!isNaN(numVal)) {
      parsedVal = new Date(numVal);
    } else {
      parsedVal = _date_serialization.default.deserializeDate(val);
    }

    if (isNaN(Number(parsedVal))) {
      parsedVal = undefined;
    }

    return parsedVal;
  }
};

function correctValueType(type) {
  return type === 'numeric' || type === 'datetime' || type === 'string' ? type : '';
}

var getParser = function getParser(valueType) {
  return parsers[correctValueType(valueType)] || _common.noop;
};

exports.getParser = getParser;

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.Series = Series;
exports.mixins = void 0;

var _type = __webpack_require__(1);

var _extend2 = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _base_point = __webpack_require__(1044);

var _utils = __webpack_require__(14);

var _common = __webpack_require__(4);

var _consts = _interopRequireDefault(__webpack_require__(161));

var _range_data_calculator = _interopRequireDefault(__webpack_require__(241));

var scatterSeries = _interopRequireWildcard(__webpack_require__(139));

var lineSeries = _interopRequireWildcard(__webpack_require__(242));

var areaSeries = _interopRequireWildcard(__webpack_require__(209));

var barSeries = _interopRequireWildcard(__webpack_require__(185));

var _range_series = __webpack_require__(1049);

var _bubble_series = __webpack_require__(1050);

var pieSeries = _interopRequireWildcard(__webpack_require__(1051));

var financialSeries = _interopRequireWildcard(__webpack_require__(1052));

var stackedSeries = _interopRequireWildcard(__webpack_require__(1053));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var seriesNS = {};
var states = _consts.default.states;
var DISCRETE = 'discrete';
var SELECTED_STATE = states.selectedMark;
var HOVER_STATE = states.hoverMark;
var HOVER = states.hover;
var NORMAL = states.normal;
var SELECTION = states.selection;
var APPLY_SELECTED = states.applySelected;
var APPLY_HOVER = states.applyHover;
var RESET_ITEM = states.resetItem;
var NONE_MODE = 'none';
var INCLUDE_POINTS = 'includepoints';
var NEAREST_POINT = 'nearestpoint';
var SERIES_SELECTION_CHANGED = 'seriesSelectionChanged';
var POINT_SELECTION_CHANGED = 'pointSelectionChanged';
var SERIES_HOVER_CHANGED = 'seriesHoverChanged';
var POINT_HOVER_CHANGED = 'pointHoverChanged';
var ALL_SERIES_POINTS = 'allseriespoints';
var ALL_ARGUMENT_POINTS = 'allargumentpoints';
var POINT_HOVER = 'pointHover';
var CLEAR_POINT_HOVER = 'clearPointHover';
var SERIES_SELECT = 'seriesSelect';
var POINT_SELECT = 'pointSelect';
var POINT_DESELECT = 'pointDeselect';

var getEmptyBusinessRange = function getEmptyBusinessRange() {
  return {
    arg: {},
    val: {}
  };
};

function triggerEvent(element, event, point) {
  element && element.trigger(event, point);
}

seriesNS.mixins = {
  chart: {},
  pie: {},
  polar: {}
};
seriesNS.mixins.chart.scatter = scatterSeries.chart;
seriesNS.mixins.polar.scatter = scatterSeries.polar;
(0, _extend2.extend)(seriesNS.mixins.pie, pieSeries);
(0, _extend2.extend)(seriesNS.mixins.chart, lineSeries.chart, areaSeries.chart, barSeries.chart, _range_series.chart, _bubble_series.chart, financialSeries, stackedSeries.chart);
(0, _extend2.extend)(seriesNS.mixins.polar, lineSeries.polar, areaSeries.polar, barSeries.polar, stackedSeries.polar);

function includePointsMode(mode) {
  mode = (0, _utils.normalizeEnum)(mode);
  return mode === INCLUDE_POINTS || mode === ALL_SERIES_POINTS;
}

function getLabelOptions(labelOptions, defaultColor) {
  var opt = labelOptions || {};
  var labelFont = (0, _extend2.extend)({}, opt.font) || {};
  var labelBorder = opt.border || {};
  var labelConnector = opt.connector || {};
  var backgroundAttr = {
    fill: opt.backgroundColor || defaultColor,
    'stroke-width': labelBorder.visible ? labelBorder.width || 0 : 0,
    stroke: labelBorder.visible && labelBorder.width ? labelBorder.color : 'none',
    dashStyle: labelBorder.dashStyle
  };
  var connectorAttr = {
    stroke: labelConnector.visible && labelConnector.width ? labelConnector.color || defaultColor : 'none',
    'stroke-width': labelConnector.visible ? labelConnector.width || 0 : 0
  };
  labelFont.color = opt.backgroundColor === 'none' && (0, _utils.normalizeEnum)(labelFont.color) === '#ffffff' && opt.position !== 'inside' ? defaultColor : labelFont.color;
  return {
    alignment: opt.alignment,
    format: opt.format,
    argumentFormat: opt.argumentFormat,
    customizeText: (0, _type.isFunction)(opt.customizeText) ? opt.customizeText : undefined,
    attributes: {
      font: labelFont
    },
    visible: labelFont.size !== 0 ? opt.visible : false,
    showForZeroValues: opt.showForZeroValues,
    horizontalOffset: opt.horizontalOffset,
    verticalOffset: opt.verticalOffset,
    radialOffset: opt.radialOffset,
    background: backgroundAttr,
    position: opt.position,
    connector: connectorAttr,
    rotationAngle: opt.rotationAngle,
    wordWrap: opt.wordWrap,
    textOverflow: opt.textOverflow,
    cssClass: opt.cssClass
  };
}

function setPointHoverState(point, legendCallback) {
  point.fullState |= HOVER_STATE;
  point.applyView(legendCallback);
}

function releasePointHoverState(point, legendCallback) {
  point.fullState &= ~HOVER_STATE;
  point.applyView(legendCallback);
  point.releaseHoverState();
}

function setPointSelectedState(point, legendCallback) {
  point.fullState |= SELECTED_STATE;
  point.applyView(legendCallback);
}

function releasePointSelectedState(point, legendCallback) {
  point.fullState &= ~SELECTED_STATE;
  point.applyView(legendCallback);
}

function mergePointOptionsCore(base, extra) {
  var options = (0, _extend2.extend)({}, base, extra);
  options.border = (0, _extend2.extend)({}, base && base.border, extra && extra.border);
  return options;
}

function mergePointOptions(base, extra) {
  var options = mergePointOptionsCore(base, extra);
  options.image = (0, _extend2.extend)(true, {}, base.image, extra.image);
  options.selectionStyle = mergePointOptionsCore(base.selectionStyle, extra.selectionStyle);
  options.hoverStyle = mergePointOptionsCore(base.hoverStyle, extra.hoverStyle);
  return options;
}

function Series(settings, options) {
  var that = this;
  that.fullState = 0;
  that._extGroups = settings;
  that._renderer = settings.renderer;
  that._group = settings.renderer.g().attr({
    'class': 'dxc-series'
  });
  that._eventTrigger = settings.eventTrigger;
  that._eventPipe = settings.eventPipe;
  that._incidentOccurred = settings.incidentOccurred;
  that._legendCallback = _common.noop;
  that.updateOptions(options, settings);
}

function getData(pointData) {
  return pointData.data;
}

function getValueChecker(axisType, axis) {
  if (!axis || axisType !== 'logarithmic' || axis.getOptions().allowNegatives !== false) {
    return function () {
      return true;
    };
  } else {
    return function (value) {
      return value > 0;
    };
  }
}

Series.prototype = {
  constructor: Series,
  _createLegendState: _common.noop,
  getLegendStyles: function getLegendStyles() {
    return this._styles.legendStyles;
  },
  _createStyles: function _createStyles(options) {
    var that = this;
    var mainSeriesColor = options.mainSeriesColor;
    that._styles = {
      normal: that._parseStyle(options, mainSeriesColor, mainSeriesColor),
      hover: that._parseStyle(options.hoverStyle || {}, mainSeriesColor, mainSeriesColor),
      selection: that._parseStyle(options.selectionStyle || {}, mainSeriesColor, mainSeriesColor),
      legendStyles: {
        normal: that._createLegendState(options, mainSeriesColor),
        hover: that._createLegendState(options.hoverStyle || {}, mainSeriesColor),
        selection: that._createLegendState(options.selectionStyle || {}, mainSeriesColor)
      }
    };
  },
  setClippingParams: function setClippingParams(baseId, wideId, forceClipping) {
    var clipLabels = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    this._paneClipRectID = baseId;
    this._widePaneClipRectID = wideId;
    this._forceClipping = forceClipping;
    this._clipLabels = clipLabels;
  },
  applyClip: function applyClip() {
    this._group.attr({
      'clip-path': this._paneClipRectID
    });
  },
  resetClip: function resetClip() {
    this._group.attr({
      'clip-path': null
    });
  },
  getTagField: function getTagField() {
    return this._options.tagField || 'tag';
  },
  getValueFields: _common.noop,
  getSizeField: _common.noop,
  getArgumentField: _common.noop,
  getPoints: function getPoints() {
    return this._points;
  },
  getPointsInViewPort: function getPointsInViewPort() {
    return _range_data_calculator.default.getPointsInViewPort(this);
  },
  _createPoint: function _createPoint(data, index, oldPoint) {
    data.index = index;
    var that = this;
    var pointsByArgument = that.pointsByArgument;

    var options = that._getCreatingPointOptions(data);

    var arg = data.argument.valueOf();
    var point = oldPoint;

    if (point) {
      point.update(data, options);
    } else {
      point = new _base_point.Point(that, data, options);

      if (that.isSelected() && includePointsMode(that.lastSelectionMode)) {
        point.setView(SELECTION);
      }
    }

    var pointByArgument = pointsByArgument[arg];

    if (pointByArgument) {
      pointByArgument.push(point);
    } else {
      pointsByArgument[arg] = [point];
    }

    if (point.hasValue()) {
      that.customizePoint(point, data);
    }

    return point;
  },
  getRangeData: function getRangeData() {
    return this._visible ? this._getRangeData() : getEmptyBusinessRange();
  },
  getArgumentRange: function getArgumentRange() {
    return this._visible ? _range_data_calculator.default.getArgumentRange(this) : getEmptyBusinessRange();
  },
  getViewport: function getViewport() {
    return _range_data_calculator.default.getViewport(this);
  },
  _deleteGroup: function _deleteGroup(groupName) {
    var group = this[groupName];

    if (group) {
      group.dispose();
      this[groupName] = null;
    }
  },
  updateOptions: function updateOptions(newOptions, settings) {
    var that = this;
    var widgetType = newOptions.widgetType;
    var oldType = that.type;
    var newType = newOptions.type;
    that.type = newType && (0, _utils.normalizeEnum)(newType.toString());

    if (!that._checkType(widgetType) || that._checkPolarBarType(widgetType, newOptions)) {
      that.dispose();
      that.isUpdated = false;
      return;
    }

    if (oldType !== that.type) {
      that._firstDrawing = true;

      that._resetType(oldType, widgetType);

      that._setType(that.type, widgetType);
    } else {
      that._defineDrawingState();
    }

    that._options = newOptions;
    that._pointOptions = null;
    that.name = newOptions.name;
    that.pane = newOptions.pane;
    that.tag = newOptions.tag;

    if (settings) {
      that._seriesModes = settings.commonSeriesModes || that._seriesModes;
      that._valueAxis = settings.valueAxis || that._valueAxis;
      that.axis = that._valueAxis && that._valueAxis.name;
      that._argumentAxis = settings.argumentAxis || that._argumentAxis;
    }

    that._createStyles(newOptions);

    that._stackName = null;

    that._updateOptions(newOptions);

    that._visible = newOptions.visible;
    that.isUpdated = true;
    that.stack = newOptions.stack;
    that.barOverlapGroup = newOptions.barOverlapGroup;

    that._createGroups();

    that._processEmptyValue = newOptions.ignoreEmptyPoints ? function (x) {
      return x === null ? undefined : x;
    } : function (x) {
      return x;
    };
  },
  _defineDrawingState: function _defineDrawingState() {
    this._firstDrawing = true;
  },
  _disposePoints: function _disposePoints(points) {
    (0, _iterator.each)(points || [], function (_, p) {
      p.dispose();
    });
  },
  updateDataType: function updateDataType(settings) {
    var that = this;
    that.argumentType = settings.argumentType;
    that.valueType = settings.valueType;
    that.argumentAxisType = settings.argumentAxisType;
    that.valueAxisType = settings.valueAxisType;
    that.showZero = settings.showZero;
    this._argumentChecker = getValueChecker(settings.argumentAxisType, that.getArgumentAxis());
    this._valueChecker = getValueChecker(settings.valueAxisType, that.getValueAxis());
    return that;
  },
  _argumentChecker: function _argumentChecker() {
    return true;
  },
  _valueChecker: function _valueChecker() {
    return true;
  },
  getOptions: function getOptions() {
    return this._options;
  },
  _getOldPoint: function _getOldPoint(data, oldPointsByArgument, index) {
    var arg = data.argument && data.argument.valueOf();
    var point = (oldPointsByArgument[arg] || [])[0];

    if (point) {
      oldPointsByArgument[arg].splice(0, 1);
    }

    return point;
  },
  updateData: function updateData(data) {
    var that = this;
    var options = that._options;
    var nameField = options.nameField;
    data = data || [];

    if (data.length) {
      that._canRenderCompleteHandle = true;
    }

    var dataSelector = this._getPointDataSelector();

    var itemsWithoutArgument = 0;
    that._data = data.reduce(function (data, dataItem, index) {
      var pointDataItem = dataSelector(dataItem);

      if ((0, _type.isDefined)(pointDataItem.argument)) {
        if (!nameField || dataItem[nameField] === options.nameFieldValue) {
          pointDataItem.index = index;
          data.push(pointDataItem);
        }
      } else {
        itemsWithoutArgument++;
      }

      return data;
    }, []);

    if (itemsWithoutArgument && itemsWithoutArgument === data.length) {
      that._incidentOccurred('W2002', [that.name, that.getArgumentField()]);
    }

    that._endUpdateData();
  },
  _getData: function _getData() {
    var data = this._data || [];

    if (this.useAggregation()) {
      data = this._resample(this.getArgumentAxis().getAggregationInfo(this._useAllAggregatedPoints, this.argumentAxisType !== DISCRETE ? this.getArgumentRange() : {}), data);
    }

    return data;
  },
  useAggregation: function useAggregation() {
    var aggregation = this.getOptions().aggregation;
    return aggregation && aggregation.enabled;
  },
  autoHidePointMarkersEnabled: _common.noop,
  usePointsToDefineAutoHiding: _common.noop,
  createPoints: function createPoints(useAllAggregatedPoints) {
    this._normalizeUsingAllAggregatedPoints(useAllAggregatedPoints);

    this._createPoints();
  },
  _normalizeUsingAllAggregatedPoints: function _normalizeUsingAllAggregatedPoints(useAllAggregatedPoints) {
    this._useAllAggregatedPoints = this.useAggregation() && (this.argumentAxisType === DISCRETE || (this._data || []).length > 1 && !!useAllAggregatedPoints);
  },
  _createPoints: function _createPoints() {
    var that = this;
    var oldPointsByArgument = that.pointsByArgument || {};

    var data = that._getData();

    that.pointsByArgument = {};

    that._calculateErrorBars(data);

    var skippedFields = {};
    var points = data.reduce(function (points, pointDataItem) {
      if (that._checkData(pointDataItem, skippedFields)) {
        var pointIndex = points.length;

        var oldPoint = that._getOldPoint(pointDataItem, oldPointsByArgument, pointIndex);

        var point = that._createPoint(pointDataItem, pointIndex, oldPoint);

        points.push(point);
      }

      return points;
    }, []);

    for (var field in skippedFields) {
      if (skippedFields[field] === data.length) {
        that._incidentOccurred('W2002', [that.name, field]);
      }
    }

    Object.keys(oldPointsByArgument).forEach(function (key) {
      return that._disposePoints(oldPointsByArgument[key]);
    });
    that._points = points;
  },
  _removeOldSegments: function _removeOldSegments() {
    var that = this;
    var startIndex = that._segments.length;
    (0, _iterator.each)(that._graphics.splice(startIndex, that._graphics.length) || [], function (_, elem) {
      that._removeElement(elem);
    });

    if (that._trackers) {
      (0, _iterator.each)(that._trackers.splice(startIndex, that._trackers.length) || [], function (_, elem) {
        elem.remove();
      });
    }
  },
  _drawElements: function _drawElements(animationEnabled, firstDrawing, translateAllPoints) {
    var that = this;
    var points = that._points || [];

    var closeSegment = points[0] && points[0].hasValue() && that._options.closed;

    var groupForPoint = {
      markers: that._markersGroup,
      errorBars: that._errorBarGroup
    };
    that._drawnPoints = [];
    that._graphics = that._graphics || [];
    that._segments = [];
    var segments = points.reduce(function (segments, p) {
      var segment = segments[segments.length - 1];

      if (!p.translated || translateAllPoints) {
        p.translate();
        !translateAllPoints && p.setDefaultCoords();
      }

      if (p.hasValue() && p.hasCoords()) {
        translateAllPoints && that._drawPoint({
          point: p,
          groups: groupForPoint,
          hasAnimation: animationEnabled,
          firstDrawing: firstDrawing
        });
        segment.push(p);
      } else if (!p.hasValue()) {
        segment.length && segments.push([]);
      } else {
        p.setInvisibility();
      }

      return segments;
    }, [[]]);
    segments.forEach(function (segment, index) {
      if (segment.length) {
        that._drawSegment(segment, animationEnabled, index, closeSegment && index === this.length - 1);
      }
    }, segments);
    that._firstDrawing = !points.length;

    that._removeOldSegments();

    animationEnabled && that._animate(firstDrawing);
  },
  draw: function draw(animationEnabled, hideLayoutLabels, legendCallback) {
    var that = this;
    var firstDrawing = that._firstDrawing;
    that._legendCallback = legendCallback || that._legendCallback;

    if (!that._visible) {
      that._group.remove();

      return;
    }

    that._appendInGroup();

    that._applyVisibleArea();

    that._setGroupsSettings(animationEnabled, firstDrawing);

    !firstDrawing && !that._resetApplyingAnimation && that._drawElements(false, firstDrawing, false);

    that._drawElements(animationEnabled, firstDrawing, true);

    hideLayoutLabels && that.hideLabels();

    if (that.isSelected()) {
      that._changeStyle(that.lastSelectionMode, undefined, true);
    } else if (that.isHovered()) {
      that._changeStyle(that.lastHoverMode, undefined, true);
    } else {
      that._applyStyle(that._styles.normal);
    }

    that._resetApplyingAnimation = false;
  },
  _setLabelGroupSettings: function _setLabelGroupSettings(animationEnabled) {
    var settings = {
      'class': 'dxc-labels',
      'pointer-events': 'none'
    };
    this._clipLabels && this._applyElementsClipRect(settings);

    this._applyClearingSettings(settings);

    animationEnabled && (settings.opacity = 0.001);

    this._labelsGroup.attr(settings).append(this._extGroups.labelsGroup);
  },
  _checkType: function _checkType(widgetType) {
    return !!seriesNS.mixins[widgetType][this.type];
  },
  _checkPolarBarType: function _checkPolarBarType(widgetType, options) {
    return widgetType === 'polar' && options.spiderWidget && this.type.indexOf('bar') !== -1;
  },
  _resetType: function _resetType(seriesType, widgetType) {
    var methodName;
    var methods;

    if (seriesType) {
      methods = seriesNS.mixins[widgetType][seriesType];

      for (methodName in methods) {
        delete this[methodName];
      }
    }
  },
  _setType: function _setType(seriesType, widgetType) {
    var methodName;
    var methods = seriesNS.mixins[widgetType][seriesType];

    for (methodName in methods) {
      this[methodName] = methods[methodName];
    }
  },
  _setPointsView: function _setPointsView(view, target) {
    this.getPoints().forEach(function (point) {
      if (target !== point) {
        point.setView(view);
      }
    });
  },
  _resetPointsView: function _resetPointsView(view, target) {
    this.getPoints().forEach(function (point) {
      if (target !== point) {
        point.resetView(view);
      }
    });
  },
  _resetNearestPoint: function _resetNearestPoint() {
    var that = this;
    that._nearestPoint && that._nearestPoint.series !== null && that._nearestPoint.resetView(HOVER);
    that._nearestPoint = null;
  },
  _setSelectedState: function _setSelectedState(mode) {
    var that = this;
    that.lastSelectionMode = (0, _utils.normalizeEnum)(mode || that._options.selectionMode);
    that.fullState = that.fullState | SELECTED_STATE;

    that._resetNearestPoint();

    that._changeStyle(that.lastSelectionMode);

    if (that.lastSelectionMode !== NONE_MODE && that.isHovered() && includePointsMode(that.lastHoverMode)) {
      that._resetPointsView(HOVER);
    }
  },
  _releaseSelectedState: function _releaseSelectedState() {
    var that = this;
    that.fullState = that.fullState & ~SELECTED_STATE;

    that._changeStyle(that.lastSelectionMode, SELECTION);

    if (that.lastSelectionMode !== NONE_MODE && that.isHovered() && includePointsMode(that.lastHoverMode)) {
      that._setPointsView(HOVER);
    }
  },
  isFullStackedSeries: function isFullStackedSeries() {
    return this.type.indexOf('fullstacked') === 0;
  },
  isStackedSeries: function isStackedSeries() {
    return this.type.indexOf('stacked') === 0;
  },
  resetApplyingAnimation: function resetApplyingAnimation(isFirstDrawing) {
    this._resetApplyingAnimation = true;

    if (isFirstDrawing) {
      this._firstDrawing = true;
    }
  },
  isFinancialSeries: function isFinancialSeries() {
    return this.type === 'stock' || this.type === 'candlestick';
  },
  _canChangeView: function _canChangeView() {
    return !this.isSelected() && (0, _utils.normalizeEnum)(this._options.hoverMode) !== NONE_MODE;
  },
  _changeStyle: function _changeStyle(mode, resetView, skipPoints) {
    var that = this;
    var state = that.fullState;
    var styles = [NORMAL, HOVER, SELECTION, SELECTION];

    if (that.lastHoverMode === 'none') {
      state &= ~HOVER_STATE;
    }

    if (that.lastSelectionMode === 'none') {
      state &= ~SELECTED_STATE;
    }

    if (includePointsMode(mode) && !skipPoints) {
      if (!resetView) {
        that._setPointsView(styles[state]);
      } else {
        that._resetPointsView(resetView);
      }
    }

    that._legendCallback([RESET_ITEM, APPLY_HOVER, APPLY_SELECTED, APPLY_SELECTED][state]);

    that._applyStyle(that._styles[styles[state]]);
  },
  updateHover: function updateHover(x, y) {
    var that = this;
    var currentNearestPoint = that._nearestPoint;
    var point = that.isHovered() && that.lastHoverMode === NEAREST_POINT && that.getNeighborPoint(x, y);

    if (point !== currentNearestPoint && !(that.isSelected() && that.lastSelectionMode !== NONE_MODE)) {
      that._resetNearestPoint();

      if (point) {
        point.setView(HOVER);
        that._nearestPoint = point;
      }
    }
  },
  _getMainAxisName: function _getMainAxisName() {
    return this._options.rotated ? 'X' : 'Y';
  },
  areLabelsVisible: function areLabelsVisible() {
    return !(0, _type.isDefined)(this._options.maxLabelCount) || this._points.length <= this._options.maxLabelCount;
  },
  getLabelVisibility: function getLabelVisibility() {
    return this.areLabelsVisible() && this._options.label && this._options.label.visible;
  },
  customizePoint: function customizePoint(point, pointData) {
    var that = this;
    var options = that._options;
    var customizePoint = options.customizePoint;
    var customizeObject;
    var pointOptions;
    var customLabelOptions;
    var customOptions;
    var customizeLabel = options.customizeLabel;
    var useLabelCustomOptions;
    var usePointCustomOptions;

    if (customizeLabel && customizeLabel.call) {
      customizeObject = (0, _extend2.extend)({
        seriesName: that.name
      }, pointData);
      customizeObject.series = that;
      customLabelOptions = customizeLabel.call(customizeObject, customizeObject);
      useLabelCustomOptions = customLabelOptions && !(0, _type.isEmptyObject)(customLabelOptions);
      customLabelOptions = useLabelCustomOptions ? (0, _extend2.extend)(true, {}, options.label, customLabelOptions) : null;
    }

    if (customizePoint && customizePoint.call) {
      customizeObject = customizeObject || (0, _extend2.extend)({
        seriesName: that.name
      }, pointData);
      customizeObject.series = that;
      customOptions = customizePoint.call(customizeObject, customizeObject);
      usePointCustomOptions = customOptions && !(0, _type.isEmptyObject)(customOptions);
    }

    if (useLabelCustomOptions || usePointCustomOptions) {
      pointOptions = that._parsePointOptions(that._preparePointOptions(customOptions), customLabelOptions || options.label, pointData, point);
      pointOptions.styles.useLabelCustomOptions = useLabelCustomOptions;
      pointOptions.styles.usePointCustomOptions = usePointCustomOptions;
      point.updateOptions(pointOptions);
    }
  },
  show: function show() {
    if (!this._visible) {
      this._changeVisibility(true);
    }
  },
  hide: function hide() {
    if (this._visible) {
      this._changeVisibility(false);
    }
  },
  _changeVisibility: function _changeVisibility(visibility) {
    var that = this;
    that._visible = that._options.visible = visibility;

    that._updatePointsVisibility();

    that.hidePointTooltip();

    that._options.visibilityChanged(that);
  },
  // TODO. Problem related to 'point' option for bar-like series. Revisit this code once options parsing is changed
  // see T243839, T231939
  _updatePointsVisibility: _common.noop,
  hideLabels: function hideLabels() {
    (0, _iterator.each)(this._points, function (_, point) {
      point._label.draw(false);
    });
  },
  _parsePointOptions: function _parsePointOptions(pointOptions, labelOptions, data, point) {
    var that = this;
    var options = that._options;

    var styles = that._createPointStyles(pointOptions, data, point);

    var parsedOptions = (0, _extend2.extend)({}, pointOptions, {
      type: options.type,
      rotated: options.rotated,
      styles: styles,
      widgetType: options.widgetType,
      visibilityChanged: options.visibilityChanged
    });
    parsedOptions.label = getLabelOptions(labelOptions, styles.normal.fill);

    if (that.areErrorBarsVisible()) {
      parsedOptions.errorBars = options.valueErrorBar;
    }

    return parsedOptions;
  },
  _preparePointOptions: function _preparePointOptions(customOptions) {
    var pointOptions = this._getOptionsForPoint();

    return customOptions ? mergePointOptions(pointOptions, customOptions) : pointOptions;
  },
  _getMarkerGroupOptions: function _getMarkerGroupOptions() {
    return (0, _extend2.extend)(false, {}, this._getOptionsForPoint(), {
      hoverStyle: {},
      selectionStyle: {}
    });
  },
  _getAggregationMethod: function _getAggregationMethod(isDiscrete, aggregateByCategory) {
    var options = this.getOptions().aggregation;
    var method = (0, _utils.normalizeEnum)(options.method);
    var customAggregator = method === 'custom' && options.calculate;
    var aggregator;

    if (isDiscrete && !aggregateByCategory) {
      aggregator = function aggregator(_ref) {
        var data = _ref.data;
        return data[0];
      };
    } else {
      aggregator = this._aggregators[method] || this._aggregators[this._defaultAggregator];
    }

    return customAggregator || aggregator;
  },
  _resample: function _resample(_ref2, data) {
    var interval = _ref2.interval,
        ticks = _ref2.ticks,
        aggregateByCategory = _ref2.aggregateByCategory;
    var that = this;
    var isDiscrete = that.argumentAxisType === DISCRETE || that.valueAxisType === DISCRETE;
    var dataIndex = 0;

    var dataSelector = this._getPointDataSelector();

    var options = that.getOptions();

    var addAggregatedData = function addAggregatedData(target, data, aggregationInfo) {
      if (!data) {
        return;
      }

      var processData = function processData(d) {
        var pointData = d && dataSelector(d, options);

        if (pointData && that._checkData(pointData)) {
          pointData.aggregationInfo = aggregationInfo;
          target.push(pointData);
        }
      };

      if (Array.isArray(data)) {
        data.forEach(processData);
      } else {
        processData(data);
      }
    };

    var aggregationMethod = this._getAggregationMethod(isDiscrete, aggregateByCategory);

    if (isDiscrete) {
      if (aggregateByCategory) {
        var categories = this.getArgumentAxis().getTranslator().getBusinessRange().categories;
        var groups = categories.reduce(function (g, category) {
          g[category.valueOf()] = [];
          return g;
        }, {});
        data.forEach(function (dataItem) {
          groups[dataItem.argument.valueOf()].push(dataItem);
        });
        return categories.reduce(function (result, c) {
          addAggregatedData(result, aggregationMethod({
            aggregationInterval: null,
            intervalStart: c,
            intervalEnd: c,
            data: groups[c.valueOf()].map(getData)
          }, that));
          return result;
        }, []);
      } else {
        return data.reduce(function (result, dataItem, index, data) {
          result[1].push(dataItem);

          if (index === data.length - 1 || (index + 1) % interval === 0) {
            var dataInInterval = result[1];
            var aggregationInfo = {
              aggregationInterval: interval,
              data: dataInInterval.map(getData)
            };
            addAggregatedData(result[0], aggregationMethod(aggregationInfo, that));
            result[1] = [];
          }

          return result;
        }, [[], []])[0];
      }
    }

    var aggregatedData = [];

    for (var i = 1; i < ticks.length; i++) {
      var intervalEnd = ticks[i];
      var intervalStart = ticks[i - 1];
      var dataInInterval = [];

      while (data[dataIndex] && data[dataIndex].argument < intervalEnd) {
        if (data[dataIndex].argument >= intervalStart) {
          dataInInterval.push(data[dataIndex]);
        }

        dataIndex++;
      }

      var aggregationInfo = {
        intervalStart: intervalStart,
        intervalEnd: intervalEnd,
        aggregationInterval: interval,
        data: dataInInterval.map(getData)
      };
      addAggregatedData(aggregatedData, aggregationMethod(aggregationInfo, that), aggregationInfo);
    }

    that._endUpdateData();

    return aggregatedData;
  },
  canRenderCompleteHandle: function canRenderCompleteHandle() {
    var result = this._canRenderCompleteHandle;
    delete this._canRenderCompleteHandle;
    return !!result;
  },
  isHovered: function isHovered() {
    return !!(this.fullState & 1);
  },
  isSelected: function isSelected() {
    return !!(this.fullState & 2);
  },
  isVisible: function isVisible() {
    return this._visible;
  },
  getAllPoints: function getAllPoints() {
    this._createAllAggregatedPoints();

    return (this._points || []).slice();
  },
  getPointByPos: function getPointByPos(pos) {
    this._createAllAggregatedPoints();

    return (this._points || [])[pos];
  },
  getVisiblePoints: function getVisiblePoints() {
    return (this._drawnPoints || []).slice();
  },
  selectPoint: function selectPoint(point) {
    if (!point.isSelected()) {
      setPointSelectedState(point, this._legendCallback);

      this._eventPipe({
        action: POINT_SELECT,
        target: point
      });

      this._eventTrigger(POINT_SELECTION_CHANGED, {
        target: point
      });
    }
  },
  deselectPoint: function deselectPoint(point) {
    if (point.isSelected()) {
      releasePointSelectedState(point, this._legendCallback);

      this._eventPipe({
        action: POINT_DESELECT,
        target: point
      });

      this._eventTrigger(POINT_SELECTION_CHANGED, {
        target: point
      });
    }
  },
  hover: function hover(mode) {
    var that = this;
    var eventTrigger = that._eventTrigger;

    if (that.isHovered()) {
      return;
    }

    that.lastHoverMode = (0, _utils.normalizeEnum)(mode || that._options.hoverMode);
    that.fullState = that.fullState | HOVER_STATE;

    that._changeStyle(that.lastHoverMode, undefined, that.isSelected() && that.lastSelectionMode !== NONE_MODE);

    eventTrigger(SERIES_HOVER_CHANGED, {
      target: that
    });
  },
  clearHover: function clearHover() {
    var that = this;
    var eventTrigger = that._eventTrigger;

    if (!that.isHovered()) {
      return;
    }

    that._resetNearestPoint();

    that.fullState = that.fullState & ~HOVER_STATE;

    that._changeStyle(that.lastHoverMode, HOVER, that.isSelected() && that.lastSelectionMode !== NONE_MODE);

    eventTrigger(SERIES_HOVER_CHANGED, {
      target: that
    });
  },
  hoverPoint: function hoverPoint(point) {
    var that = this;

    if (!point.isHovered()) {
      point.clearHover();
      setPointHoverState(point, that._legendCallback);
      that._canChangeView() && that._applyStyle(that._styles.hover);

      that._eventPipe({
        action: POINT_HOVER,
        target: point
      });

      that._eventTrigger(POINT_HOVER_CHANGED, {
        target: point
      });
    }
  },
  clearPointHover: function clearPointHover() {
    var that = this;
    that.getPoints().some(function (currentPoint) {
      if (currentPoint.isHovered()) {
        releasePointHoverState(currentPoint, that._legendCallback);
        that._canChangeView() && that._applyStyle(that._styles.normal);

        that._eventPipe({
          action: CLEAR_POINT_HOVER,
          target: currentPoint
        });

        that._eventTrigger(POINT_HOVER_CHANGED, {
          target: currentPoint
        });

        return true;
      }

      return false;
    });
  },
  showPointTooltip: function showPointTooltip(point) {
    triggerEvent(this._extGroups.seriesGroup, 'showpointtooltip', point);
  },
  hidePointTooltip: function hidePointTooltip(point) {
    triggerEvent(this._extGroups.seriesGroup, 'hidepointtooltip', point);
  },
  select: function select() {
    var that = this;

    if (!that.isSelected()) {
      that._setSelectedState(that._options.selectionMode);

      that._eventPipe({
        action: SERIES_SELECT,
        target: that
      });

      that._group.toForeground();

      that._eventTrigger(SERIES_SELECTION_CHANGED, {
        target: that
      });
    }
  },
  clearSelection: function clearSelection() {
    var that = this;

    if (that.isSelected()) {
      that._releaseSelectedState();

      that._eventTrigger(SERIES_SELECTION_CHANGED, {
        target: that
      });
    }
  },
  getPointsByArg: function getPointsByArg(arg, skipPointsCreation) {
    var that = this;
    var argValue = arg.valueOf();
    var points = that.pointsByArgument[argValue];

    if (!points && !skipPointsCreation && that._createAllAggregatedPoints()) {
      points = that.pointsByArgument[argValue];
    }

    return points || [];
  },
  _createAllAggregatedPoints: function _createAllAggregatedPoints() {
    if (this.useAggregation() && !this._useAllAggregatedPoints) {
      this.createPoints(true);
      return true;
    }

    return false;
  },
  getPointsByKeys: function getPointsByKeys(arg) {
    return this.getPointsByArg(arg);
  },
  notify: function notify(data) {
    var that = this;
    var action = data.action;
    var seriesModes = that._seriesModes;
    var target = data.target;
    var targetOptions = target.getOptions();
    var pointHoverMode = (0, _utils.normalizeEnum)(targetOptions.hoverMode);
    var selectionModeOfPoint = (0, _utils.normalizeEnum)(targetOptions.selectionMode);

    if (action === POINT_HOVER) {
      that._hoverPointHandler(target, pointHoverMode, data.notifyLegend);
    } else if (action === CLEAR_POINT_HOVER) {
      that._clearPointHoverHandler(target, pointHoverMode, data.notifyLegend);
    } else if (action === SERIES_SELECT) {
      target !== that && seriesModes.seriesSelectionMode === 'single' && that.clearSelection();
    } else if (action === POINT_SELECT) {
      if (seriesModes.pointSelectionMode === 'single') {
        that.getPoints().some(function (currentPoint) {
          if (currentPoint !== target && currentPoint.isSelected()) {
            that.deselectPoint(currentPoint);
            return true;
          }

          return false;
        });
      }

      that._selectPointHandler(target, selectionModeOfPoint);
    } else if (action === POINT_DESELECT) {
      that._deselectPointHandler(target, selectionModeOfPoint);
    }
  },
  _selectPointHandler: function _selectPointHandler(target, mode) {
    var that = this;

    if (mode === ALL_SERIES_POINTS) {
      target.series === that && that._setPointsView(SELECTION, target);
    } else if (mode === ALL_ARGUMENT_POINTS) {
      that.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {
        currentPoint !== target && currentPoint.setView(SELECTION);
      });
    }
  },
  _deselectPointHandler: function _deselectPointHandler(target, mode) {
    if (mode === ALL_SERIES_POINTS) {
      target.series === this && this._resetPointsView(SELECTION, target);
    } else if (mode === ALL_ARGUMENT_POINTS) {
      this.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {
        currentPoint !== target && currentPoint.resetView(SELECTION);
      });
    }
  },
  _hoverPointHandler: function _hoverPointHandler(target, mode, notifyLegend) {
    var that = this;

    if (target.series !== that && mode === ALL_ARGUMENT_POINTS) {
      that.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {
        currentPoint.setView(HOVER);
      });
      notifyLegend && that._legendCallback(target);
    } else if (mode === ALL_SERIES_POINTS && target.series === that) {
      that._setPointsView(HOVER, target);
    }
  },
  _clearPointHoverHandler: function _clearPointHoverHandler(target, mode, notifyLegend) {
    var that = this;

    if (mode === ALL_ARGUMENT_POINTS) {
      target.series !== that && that.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {
        currentPoint.resetView(HOVER);
      });
      notifyLegend && that._legendCallback(target);
    } else if (mode === ALL_SERIES_POINTS && target.series === that) {
      that._resetPointsView(HOVER, target);
    }
  },
  _deletePoints: function _deletePoints() {
    var that = this;

    that._disposePoints(that._points);

    that._points = that._drawnPoints = null;
  },
  _deleteTrackers: function _deleteTrackers() {
    var that = this;
    (0, _iterator.each)(that._trackers || [], function (_, tracker) {
      tracker.remove();
    });
    that._trackersGroup && that._trackersGroup.dispose();
    that._trackers = that._trackersGroup = null;
  },
  dispose: function dispose() {
    var that = this;

    that._deletePoints();

    that._group.dispose();

    that._labelsGroup && that._labelsGroup.dispose();
    that._errorBarGroup && that._errorBarGroup.dispose();

    that._deleteTrackers();

    that._group = that._extGroups = that._markersGroup = that._elementsGroup = that._bordersGroup = that._labelsGroup = that._errorBarGroup = that._graphics = that._rangeData = that._renderer = that._styles = that._options = that._pointOptions = that._drawnPoints = that.pointsByArgument = that._segments = that._prevSeries = null;
  },
  correctPosition: _common.noop,
  drawTrackers: _common.noop,
  getNeighborPoint: _common.noop,
  areErrorBarsVisible: _common.noop,
  getMarginOptions: function getMarginOptions() {
    return this._patchMarginOptions({
      percentStick: this.isFullStackedSeries()
    });
  },
  getColor: function getColor() {
    return this.getLegendStyles().normal.fill;
  },
  getOpacity: function getOpacity() {
    return this._options.opacity;
  },
  getStackName: function getStackName() {
    return this._stackName;
  },
  getBarOverlapGroup: function getBarOverlapGroup() {
    return this._options.barOverlapGroup;
  },
  getPointByCoord: function getPointByCoord(x, y) {
    var point = this.getNeighborPoint(x, y);
    return point !== null && point !== void 0 && point.coordsIn(x, y) ? point : null;
  },
  getValueAxis: function getValueAxis() {
    return this._valueAxis;
  },
  getArgumentAxis: function getArgumentAxis() {
    return this._argumentAxis;
  },
  getMarkersGroup: function getMarkersGroup() {
    return this._markersGroup;
  },
  getRenderer: function getRenderer() {
    return this._renderer;
  }
};
var mixins = seriesNS.mixins;
exports.mixins = mixins;

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Label = Label;

var _format_helper = _interopRequireDefault(__webpack_require__(82));

var _utils = __webpack_require__(14);

var _iterator = __webpack_require__(3);

var _extend = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _format = _format_helper.default.format;
var _math = Math;
var _round = _math.round;
var _floor = _math.floor;
var _abs = _math.abs;
var CONNECTOR_LENGTH = 12;
var LABEL_BACKGROUND_PADDING_X = 8;
var LABEL_BACKGROUND_PADDING_Y = 4;

function getClosestCoord(point, coords) {
  var closestDistance = Infinity;
  var closestCoord;
  (0, _iterator.each)(coords, function (_, coord) {
    var x = point[0] - coord[0];
    var y = point[1] - coord[1];
    var distance = x * x + y * y;

    if (distance < closestDistance) {
      closestDistance = distance;
      closestCoord = coord;
    }
  });
  return [_floor(closestCoord[0]), _floor(closestCoord[1])];
}

function getCrossCoord(rect, coord, indexOffset) {
  return (coord - rect[0 + indexOffset]) / (rect[2 + indexOffset] - rect[0 + indexOffset]) * (rect[3 - indexOffset] - rect[1 - indexOffset]) + rect[1 - indexOffset];
} // We could always conside center of label as label point (with appropriate connector path clipping). In that case we do not depend neither on background nor on rotation.


var barPointStrategy = {
  isLabelInside: function isLabelInside(labelPoint, figure) {
    var xc = labelPoint.x + labelPoint.width / 2;
    var yc = labelPoint.y + labelPoint.height / 2;
    return figure.x <= xc && xc <= figure.x + figure.width && figure.y <= yc && yc <= figure.y + figure.height;
  },
  prepareLabelPoints: function prepareLabelPoints(bBox, rotatedBBox, isHorizontal, angle, figureCenter) {
    var x1 = rotatedBBox.x;
    var xc = x1 + rotatedBBox.width / 2;
    var x2 = x1 + rotatedBBox.width - 1;
    var y1 = rotatedBBox.y;
    var yc = y1 + rotatedBBox.height / 2;
    var y2 = y1 + rotatedBBox.height - 1;
    var labelPoints;
    var isRectangular = _abs(angle) % 90 === 0;

    if (figureCenter[0] > x1 && figureCenter[0] < x2) {
      if (isRectangular) {
        labelPoints = [[figureCenter[0], _abs(figureCenter[1] - y1) < _abs(figureCenter[1] - y2) ? y1 : y2]];
      } else {
        labelPoints = [[figureCenter[0], getCrossCoord([x1, y1, x2, y2], figureCenter[0], 0)]];
      }
    } else if (figureCenter[1] > y1 && figureCenter[1] < y2) {
      if (isRectangular) {
        labelPoints = [[_abs(figureCenter[0] - x1) < _abs(figureCenter[0] - x2) ? x1 : x2, figureCenter[1]]];
      } else {
        labelPoints = [[getCrossCoord([x1, y1, x2, y2], figureCenter[1], 1), figureCenter[1]]];
      }
    } else {
      if (isRectangular) {
        labelPoints = [[x1, y1], [isHorizontal ? x1 : xc, isHorizontal ? yc : y1], [x2, y1], [x1, y2], [isHorizontal ? x2 : xc, isHorizontal ? yc : y2], [x2, y2]];
      } else {
        labelPoints = [[xc, yc]];
      }
    }

    return labelPoints;
  },
  isHorizontal: function isHorizontal(bBox, figure) {
    return bBox.x > figure.x + figure.width || bBox.x + bBox.width < figure.x;
  },
  getFigureCenter: function getFigureCenter(figure) {
    return [_floor(figure.x + figure.width / 2), _floor(figure.y + figure.height / 2)];
  },
  findFigurePoint: function findFigurePoint(figure, labelPoint) {
    var figureCenter = barPointStrategy.getFigureCenter(figure);
    var point = getClosestCoord(labelPoint, [[figure.x, figureCenter[1]], [figureCenter[0], figure.y + figure.height], [figure.x + figure.width, figureCenter[1]], [figureCenter[0], figure.y]]);
    return point;
  },
  adjustPoints: function adjustPoints(points) {
    var lineIsVertical = _abs(points[1] - points[3]) <= 1;
    var lineIsHorizontal = _abs(points[0] - points[2]) <= 1;

    if (lineIsHorizontal) {
      points[0] = points[2];
    }

    if (lineIsVertical) {
      points[1] = points[3];
    }

    return points;
  }
};
var symbolPointStrategy = {
  isLabelInside: function isLabelInside() {
    return false;
  },
  prepareLabelPoints: barPointStrategy.prepareLabelPoints,
  isHorizontal: function isHorizontal(bBox, figure) {
    return bBox.x > figure.x + figure.r || bBox.x + bBox.width < figure.x - figure.r;
  },
  getFigureCenter: function getFigureCenter(figure) {
    return [figure.x, figure.y];
  },
  findFigurePoint: function findFigurePoint(figure, labelPoint) {
    var angle = Math.atan2(figure.y - labelPoint[1], labelPoint[0] - figure.x);
    return [_round(figure.x + figure.r * Math.cos(angle)), _round(figure.y - figure.r * Math.sin(angle))];
  },
  adjustPoints: barPointStrategy.adjustPoints
};
var piePointStrategy = {
  isLabelInside: function isLabelInside(_0, _1, isOutside) {
    return !isOutside;
  },
  prepareLabelPoints: function prepareLabelPoints(bBox, rotatedBBox, isHorizontal, angle) {
    var xl = bBox.x;
    var xr = xl + bBox.width;

    var xc = xl + _round(bBox.width / 2);

    var yt = bBox.y;
    var yb = yt + bBox.height;

    var yc = yt + _round(bBox.height / 2);

    var points = [[[xl, yt], [xr, yt]], [[xr, yt], [xr, yb]], [[xr, yb], [xl, yb]], [[xl, yb], [xl, yt]]];
    var cosSin = (0, _utils.getCosAndSin)(angle);

    if (angle === 0) {
      points = isHorizontal ? [[xl, yc], [xr, yc]] : [[xc, yt], [xc, yb]];
    } else {
      points = points.map(function (pair) {
        return pair.map(function (point) {
          return [_round((point[0] - xc) * cosSin.cos + (point[1] - yc) * cosSin.sin + xc), _round(-(point[0] - xc) * cosSin.sin + (point[1] - yc) * cosSin.cos + yc)];
        });
      }).reduce(function (r, pair) {
        var point1x = pair[0][0];
        var point1y = pair[0][1];
        var point2x = pair[1][0];
        var point2y = pair[1][1];

        if (isHorizontal) {
          if (point1y >= yc && yc >= point2y || point1y <= yc && yc <= point2y) {
            r.push([(yc - point1y) * (point2x - point1x) / (point2y - point1y) + point1x, yc]);
          }
        } else {
          if (point1x >= xc && xc >= point2x || point1x <= xc && xc <= point2x) {
            r.push([xc, (xc - point1x) * (point2y - point1y) / (point2x - point1x) + point1y]);
          }
        }

        return r;
      }, []);
    }

    return points;
  },
  isHorizontal: function isHorizontal(bBox, figure) {
    return bBox.x > figure.x || figure.x > bBox.x + bBox.width;
  },
  getFigureCenter: symbolPointStrategy.getFigureCenter,
  findFigurePoint: function findFigurePoint(figure, labelPoint, isHorizontal) {
    if (!isHorizontal) {
      return [figure.x, figure.y];
    }

    var labelX = labelPoint[0];

    var x = _round(figure.x + (figure.y - labelPoint[1]) / Math.tan((0, _utils.degreesToRadians)(figure.angle)));

    var points = [figure.x, figure.y, x, labelPoint[1]];

    if (!(figure.x <= x && x <= labelX) && !(labelX <= x && x <= figure.x)) {
      if (_abs(figure.x - labelX) < CONNECTOR_LENGTH) {
        points = [figure.x, figure.y];
      } else if (figure.x <= labelX) {
        points[2] = figure.x + CONNECTOR_LENGTH;
      } else {
        points[2] = figure.x - CONNECTOR_LENGTH;
      }
    }

    return points;
  },
  adjustPoints: function adjustPoints(points) {
    return points;
  }
};

function selectStrategy(figure) {
  return figure.angle !== undefined && piePointStrategy || figure.r !== undefined && symbolPointStrategy || barPointStrategy;
}

function disposeItem(obj, field) {
  obj[field] && obj[field].dispose();
  obj[field] = null;
}

function checkBackground(background) {
  return background && (background.fill && background.fill !== 'none' || background['stroke-width'] > 0 && background.stroke && background.stroke !== 'none');
}

function checkConnector(connector) {
  return connector && connector['stroke-width'] > 0 && connector.stroke && connector.stroke !== 'none';
}

function formatText(data, options) {
  var format = options.format;
  data.valueText = _format(data.value, format);
  data.argumentText = _format(data.argument, options.argumentFormat);

  if (data.percent !== undefined) {
    data.percentText = _format(data.percent, {
      type: 'percent',
      precision: format && format.percentPrecision
    });
  }

  if (data.total !== undefined) {
    data.totalText = _format(data.total, format);
  }

  if (data.openValue !== undefined) {
    data.openValueText = _format(data.openValue, format);
  }

  if (data.closeValue !== undefined) {
    data.closeValueText = _format(data.closeValue, format);
  }

  if (data.lowValue !== undefined) {
    data.lowValueText = _format(data.lowValue, format);
  }

  if (data.highValue !== undefined) {
    data.highValueText = _format(data.highValue, format);
  }

  if (data.reductionValue !== undefined) {
    data.reductionValueText = _format(data.reductionValue, format);
  }

  return options.customizeText ? options.customizeText.call(data, data) : data.valueText;
}

function Label(renderSettings) {
  this._renderer = renderSettings.renderer;
  this._container = renderSettings.labelsGroup;
  this._point = renderSettings.point;
  this._strategy = renderSettings.strategy;
  this._rowCount = 1;
}

Label.prototype = {
  constructor: Label,
  setColor: function setColor(color) {
    this._color = color;
  },
  setOptions: function setOptions(options) {
    this._options = options;
  },
  setData: function setData(data) {
    this._data = data;
  },
  setDataField: function setDataField(fieldName, fieldValue) {
    // Is this laziness really required?
    this._data = this._data || {};
    this._data[fieldName] = fieldValue;
  },
  getData: function getData() {
    return this._data;
  },
  setFigureToDrawConnector: function setFigureToDrawConnector(figure) {
    this._figure = figure;
  },
  dispose: function dispose() {
    var that = this;
    disposeItem(that, '_group');
    that._data = that._options = that._textContent = that._visible = that._insideGroup = that._text = that._background = that._connector = that._figure = null;
  },
  // The following method is required because we support partial visibility for labels
  // entire labels group can be hidden and any particular label can be visible at the same time
  // in order to do that label must have visibility:"visible" attribute
  _setVisibility: function _setVisibility(value, state) {
    this._group && this._group.attr({
      visibility: value
    });
    this._visible = state;
  },
  isVisible: function isVisible() {
    return this._visible;
  },
  hide: function hide(holdInvisible) {
    this._holdVisibility = !!holdInvisible;

    this._hide();
  },
  _hide: function _hide() {
    this._setVisibility('hidden', false);
  },
  show: function show(holdVisible) {
    var correctPosition = !this._drawn;

    if (this._point.hasValue()) {
      this._holdVisibility = !!holdVisible;

      this._show();

      correctPosition && this._point.correctLabelPosition(this);
    }
  },
  _show: function _show() {
    var that = this;
    var renderer = that._renderer;
    var container = that._container;
    var options = that._options || {};
    var text = that._textContent = formatText(that._data, that._options) || null;

    if (text) {
      if (!that._group) {
        that._group = renderer.g().append(container);
        that._insideGroup = renderer.g().append(that._group);
        that._text = renderer.text('', 0, 0).append(that._insideGroup);
      }

      that._text.css(options.attributes ? (0, _utils.patchFontOptions)(options.attributes.font) : {});

      if (checkBackground(options.background)) {
        that._background = that._background || renderer.rect().append(that._insideGroup).toBackground();

        that._background.attr(options.background); // The following is because "this._options" is shared between all labels and so cannot be modified


        that._color && that._background.attr({
          fill: that._color
        });
      } else {
        disposeItem(that, '_background');
      }

      if (checkConnector(options.connector)) {
        that._connector = that._connector || renderer.path([], 'line').sharp().append(that._group).toBackground();

        that._connector.attr(options.connector); // The following is because "this._options" is shared between all labels and so cannot be modified


        that._color && that._connector.attr({
          stroke: that._color
        });
      } else {
        disposeItem(that, '_connector');
      }

      that._text.attr({
        text: text,
        align: options.textAlignment,
        'class': options.cssClass
      });

      that._updateBackground(that._text.getBBox());

      that._setVisibility('visible', true);

      that._drawn = true;
    } else {
      that._hide();
    }
  },
  _getLabelVisibility: function _getLabelVisibility(isVisible) {
    return this._holdVisibility ? this.isVisible() : isVisible;
  },
  draw: function draw(isVisible) {
    if (this._getLabelVisibility(isVisible)) {
      this._show();

      this._point && this._point.correctLabelPosition(this);
    } else {
      this._drawn = false;

      this._hide();
    }

    return this;
  },
  _updateBackground: function _updateBackground(bBox) {
    var that = this;

    if (that._background) {
      bBox.x -= LABEL_BACKGROUND_PADDING_X;
      bBox.y -= LABEL_BACKGROUND_PADDING_Y;
      bBox.width += 2 * LABEL_BACKGROUND_PADDING_X;
      bBox.height += 2 * LABEL_BACKGROUND_PADDING_Y;

      that._background.attr(bBox);
    }

    that._bBoxWithoutRotation = (0, _extend.extend)({}, bBox);
    var rotationAngle = that._options.rotationAngle || 0;

    that._insideGroup.rotate(rotationAngle, bBox.x + bBox.width / 2, bBox.y + bBox.height / 2); // Angle is transformed from svg to right-handed cartesian space


    bBox = (0, _utils.rotateBBox)(bBox, [bBox.x + bBox.width / 2, bBox.y + bBox.height / 2], -rotationAngle);
    that._bBox = bBox;
  },
  getFigureCenter: function getFigureCenter() {
    var figure = this._figure;
    var strategy = this._strategy || selectStrategy(figure);
    return strategy.getFigureCenter(figure);
  },
  _getConnectorPoints: function _getConnectorPoints() {
    var that = this;
    var figure = that._figure;
    var options = that._options;
    var strategy = that._strategy || selectStrategy(figure);

    var bBox = that._shiftBBox(that._bBoxWithoutRotation);

    var rotatedBBox = that.getBoundingRect();
    var labelPoint;
    var points = [];
    var isHorizontal;

    if (!strategy.isLabelInside(bBox, figure, options.position !== 'inside')) {
      isHorizontal = strategy.isHorizontal(bBox, figure);
      var figureCenter = that.getFigureCenter();
      points = strategy.prepareLabelPoints(bBox, rotatedBBox, isHorizontal, -options.rotationAngle || 0, figureCenter);
      labelPoint = getClosestCoord(figureCenter, points);
      points = strategy.findFigurePoint(figure, labelPoint, isHorizontal);
      points = points.concat(labelPoint);
    }

    return strategy.adjustPoints(points);
  },
  // TODO: Should not be called when not invisible (check for "_textContent" is to be removed)
  fit: function fit(maxWidth) {
    var padding = this._background ? 2 * LABEL_BACKGROUND_PADDING_X : 0;
    var rowCountChanged = false;

    if (this._text) {
      var result = this._text.setMaxSize(maxWidth - padding, undefined, this._options);

      var rowCount = result.rowCount;

      if (rowCount === 0) {
        rowCount = 1;
      }

      if (rowCount !== this._rowCount) {
        rowCountChanged = true;
        this._rowCount = rowCount;
      }

      result.textIsEmpty && disposeItem(this, '_background');
    }

    this._updateBackground(this._text.getBBox());

    return rowCountChanged;
  },
  resetEllipsis: function resetEllipsis() {
    this._text && this._text.restoreText();

    this._updateBackground(this._text.getBBox());
  },
  setTrackerData: function setTrackerData(point) {
    this._text.data({
      'chart-data-point': point
    });

    this._background && this._background.data({
      'chart-data-point': point
    });
  },
  hideInsideLabel: function hideInsideLabel(coords) {
    return this._point.hideInsideLabel(this, coords);
  },
  getPoint: function getPoint() {
    return this._point;
  },
  // TODO: Should not be called when not invisible (check for "_textContent" is to be removed)
  shift: function shift(x, y) {
    var that = this;

    if (that._textContent) {
      that._insideGroup.attr({
        translateX: that._x = _round(x - that._bBox.x),
        translateY: that._y = _round(y - that._bBox.y)
      });

      if (that._connector) {
        that._connector.attr({
          points: that._getConnectorPoints()
        });
      }
    }

    return that;
  },
  // TODO: Should not be called when not invisible (check for "_textContent" is to be removed)
  getBoundingRect: function getBoundingRect() {
    return this._shiftBBox(this._bBox);
  },
  _shiftBBox: function _shiftBBox(bBox) {
    return this._textContent ? {
      x: bBox.x + this._x,
      y: bBox.y + this._y,
      width: bBox.width,
      height: bBox.height
    } : {};
  },
  getLayoutOptions: function getLayoutOptions() {
    var options = this._options;
    return {
      alignment: options.alignment,
      background: checkBackground(options.background),
      horizontalOffset: options.horizontalOffset,
      verticalOffset: options.verticalOffset,
      radialOffset: options.radialOffset,
      position: options.position,
      connectorOffset: (checkConnector(options.connector) ? CONNECTOR_LENGTH : 0) + (checkBackground(options.background) ? LABEL_BACKGROUND_PADDING_X : 0)
    };
  }
};

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.Axis = void 0;

var _smart_formatter = __webpack_require__(594);

var _utils = __webpack_require__(14);

var _type = __webpack_require__(1);

var _axes_constants = _interopRequireDefault(__webpack_require__(243));

var _extend = __webpack_require__(0);

var _array = __webpack_require__(12);

var _format_helper = _interopRequireDefault(__webpack_require__(82));

var _parse_utils = __webpack_require__(346);

var _tick_generator = __webpack_require__(595);

var _translator2d = __webpack_require__(350);

var _range = __webpack_require__(141);

var _tick = __webpack_require__(596);

var _math2 = __webpack_require__(31);

var _date = _interopRequireDefault(__webpack_require__(18));

var _common = __webpack_require__(4);

var _xy_axes = _interopRequireDefault(__webpack_require__(597));

var polarMethods = _interopRequireWildcard(__webpack_require__(1061));

var _constant_line = _interopRequireDefault(__webpack_require__(1062));

var _strip = _interopRequireDefault(__webpack_require__(1063));

var _deferred = __webpack_require__(6);

var _axes_utils = __webpack_require__(598);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var convertTicksToValues = _axes_constants.default.convertTicksToValues;
var _math = Math;
var _abs = _math.abs;
var _max = _math.max;
var _min = _math.min;
var _isArray = Array.isArray;
var DEFAULT_AXIS_LABEL_SPACING = 5;
var MAX_GRID_BORDER_ADHENSION = 4;
var TOP = _axes_constants.default.top;
var BOTTOM = _axes_constants.default.bottom;
var LEFT = _axes_constants.default.left;
var RIGHT = _axes_constants.default.right;
var CENTER = _axes_constants.default.center;
var KEEP = 'keep';
var SHIFT = 'shift';
var RESET = 'reset';
var ROTATE = 'rotate';
var DEFAULT_AXIS_DIVISION_FACTOR = 50;
var DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 15;
var SCROLL_THRESHOLD = 5;
var MIN_BAR_MARGIN = 5;
var MAX_MARGIN_VALUE = 0.8;
var dateIntervals = {
  day: 86400000,
  week: 604800000
};

function getTickGenerator(options, incidentOccurred, skipTickGeneration, rangeIsEmpty, adjustDivisionFactor, _ref) {
  var _options$workWeek;

  var allowNegatives = _ref.allowNegatives,
      linearThreshold = _ref.linearThreshold;
  return (0, _tick_generator.tickGenerator)({
    axisType: options.type,
    dataType: options.dataType,
    logBase: options.logarithmBase,
    allowNegatives: allowNegatives,
    linearThreshold: linearThreshold,
    axisDivisionFactor: adjustDivisionFactor(options.axisDivisionFactor || DEFAULT_AXIS_DIVISION_FACTOR),
    minorAxisDivisionFactor: adjustDivisionFactor(options.minorAxisDivisionFactor || DEFAULT_MINOR_AXIS_DIVISION_FACTOR),
    numberMultipliers: options.numberMultipliers,
    calculateMinors: options.minorTick.visible || options.minorGrid.visible || options.calculateMinors,
    allowDecimals: options.allowDecimals,
    endOnTick: options.endOnTick,
    incidentOccurred: incidentOccurred,
    firstDayOfWeek: (_options$workWeek = options.workWeek) === null || _options$workWeek === void 0 ? void 0 : _options$workWeek[0],
    skipTickGeneration: skipTickGeneration,
    skipCalculationLimits: options.skipCalculationLimits,
    generateExtraTick: options.generateExtraTick,
    minTickInterval: options.minTickInterval,
    rangeIsEmpty: rangeIsEmpty
  });
}

function createMajorTick(axis, renderer, skippedCategory) {
  var options = axis.getOptions();
  return (0, _tick.tick)(axis, renderer, options.tick, options.grid, skippedCategory, false);
}

function createMinorTick(axis, renderer) {
  var options = axis.getOptions();
  return (0, _tick.tick)(axis, renderer, options.minorTick, options.minorGrid);
}

function createBoundaryTick(axis, renderer, isFirst) {
  var options = axis.getOptions();
  return (0, _tick.tick)(axis, renderer, (0, _extend.extend)({}, options.tick, {
    visible: options.showCustomBoundaryTicks
  }), options.grid, undefined, false, isFirst ? -1 : 1);
}

function callAction(elements, action, actionArgument1, actionArgument2) {
  (elements || []).forEach(function (e) {
    return e[action](actionArgument1, actionArgument2);
  });
}

function initTickCoords(ticks) {
  callAction(ticks, 'initCoords');
}

function drawTickMarks(ticks, options) {
  callAction(ticks, 'drawMark', options);
}

function drawGrids(ticks, drawLine) {
  callAction(ticks, 'drawGrid', drawLine);
}

function updateTicksPosition(ticks, options, animate) {
  callAction(ticks, 'updateTickPosition', options, animate);
}

function updateGridsPosition(ticks, animate) {
  callAction(ticks, 'updateGridPosition', animate);
}

function cleanUpInvalidTicks(ticks) {
  var i = ticks.length - 1;

  for (i; i >= 0; i--) {
    if (!removeInvalidTick(ticks, i)) {
      break;
    }
  }

  for (i = 0; i < ticks.length; i++) {
    if (removeInvalidTick(ticks, i)) {
      i--;
    } else {
      break;
    }
  }
}

function removeInvalidTick(ticks, i) {
  if (ticks[i].coords.x === null || ticks[i].coords.y === null) {
    ticks.splice(i, 1);
    return true;
  }

  return false;
}

function validateAxisOptions(options) {
  var _labelOptions$minSpac;

  var labelOptions = options.label;
  var position = options.position;
  var defaultPosition = options.isHorizontal ? BOTTOM : LEFT;
  var secondaryPosition = options.isHorizontal ? TOP : RIGHT;
  var labelPosition = labelOptions.position;

  if (position !== defaultPosition && position !== secondaryPosition) {
    position = defaultPosition;
  }

  if (!labelPosition || labelPosition === 'outside') {
    labelPosition = position;
  } else if (labelPosition === 'inside') {
    var _TOP$BOTTOM$LEFT$RIGH;

    labelPosition = (_TOP$BOTTOM$LEFT$RIGH = {}, _defineProperty(_TOP$BOTTOM$LEFT$RIGH, TOP, BOTTOM), _defineProperty(_TOP$BOTTOM$LEFT$RIGH, BOTTOM, TOP), _defineProperty(_TOP$BOTTOM$LEFT$RIGH, LEFT, RIGHT), _defineProperty(_TOP$BOTTOM$LEFT$RIGH, RIGHT, LEFT), _TOP$BOTTOM$LEFT$RIGH)[position];
  }

  if (labelPosition !== defaultPosition && labelPosition !== secondaryPosition) {
    labelPosition = position;
  }

  if (labelOptions.alignment !== CENTER && !labelOptions.userAlignment) {
    var _TOP$BOTTOM$LEFT$RIGH2;

    labelOptions.alignment = (_TOP$BOTTOM$LEFT$RIGH2 = {}, _defineProperty(_TOP$BOTTOM$LEFT$RIGH2, TOP, CENTER), _defineProperty(_TOP$BOTTOM$LEFT$RIGH2, BOTTOM, CENTER), _defineProperty(_TOP$BOTTOM$LEFT$RIGH2, LEFT, RIGHT), _defineProperty(_TOP$BOTTOM$LEFT$RIGH2, RIGHT, LEFT), _TOP$BOTTOM$LEFT$RIGH2)[labelPosition];
  }

  options.position = position;
  labelOptions.position = labelPosition;
  options.hoverMode = options.hoverMode ? options.hoverMode.toLowerCase() : 'none';
  labelOptions.minSpacing = (_labelOptions$minSpac = labelOptions.minSpacing) !== null && _labelOptions$minSpac !== void 0 ? _labelOptions$minSpac : DEFAULT_AXIS_LABEL_SPACING;
  options.type && (options.type = options.type.toLowerCase());
  options.argumentType && (options.argumentType = options.argumentType.toLowerCase());
  options.valueType && (options.valueType = options.valueType.toLowerCase());
}

function getOptimalAngle(boxes, labelOpt) {
  var angle = _math.asin((boxes[0].height + labelOpt.minSpacing) / (boxes[1].x - boxes[0].x)) * 180 / _math.PI;

  return angle < 45 ? -45 : -90;
}

function updateLabels(ticks, step, func) {
  ticks.forEach(function (tick, index) {
    if (tick.getContentContainer()) {
      if (index % step !== 0) {
        tick.removeLabel();
      } else if (func) {
        func(tick, index);
      }
    }
  });
}

function getZoomBoundValue(optionValue, dataValue) {
  if (optionValue === undefined) {
    return dataValue;
  } else if (optionValue === null) {
    return undefined;
  } else {
    return optionValue;
  }
}

function configureGenerator(options, axisDivisionFactor, viewPort, screenDelta, minTickInterval) {
  var tickGeneratorOptions = (0, _extend.extend)({}, options, {
    endOnTick: true,
    axisDivisionFactor: axisDivisionFactor,
    skipCalculationLimits: true,
    generateExtraTick: true,
    minTickInterval: minTickInterval
  });
  return function (tickInterval, skipTickGeneration, min, max, breaks) {
    return getTickGenerator(tickGeneratorOptions, _common.noop, skipTickGeneration, viewPort.isEmpty(), function (v) {
      return v;
    }, viewPort)({
      min: min,
      max: max,
      categories: viewPort.categories,
      isSpacedMargin: viewPort.isSpacedMargin
    }, screenDelta, tickInterval, (0, _type.isDefined)(tickInterval), undefined, undefined, undefined, breaks);
  };
}

function getConstantLineSharpDirection(coord, axisCanvas) {
  return Math.max(axisCanvas.start, axisCanvas.end) !== coord ? 1 : -1;
}

var Axis = function Axis(renderSettings) {
  var that = this;
  that._renderer = renderSettings.renderer;
  that._incidentOccurred = renderSettings.incidentOccurred;
  that._eventTrigger = renderSettings.eventTrigger;
  that._stripsGroup = renderSettings.stripsGroup;
  that._stripLabelAxesGroup = renderSettings.stripLabelAxesGroup;
  that._labelsAxesGroup = renderSettings.labelsAxesGroup;
  that._constantLinesGroup = renderSettings.constantLinesGroup;
  that._scaleBreaksGroup = renderSettings.scaleBreaksGroup;
  that._axesContainerGroup = renderSettings.axesContainerGroup;
  that._gridContainerGroup = renderSettings.gridGroup;
  that._axisCssPrefix = renderSettings.widgetClass + '-' + (renderSettings.axisClass ? renderSettings.axisClass + '-' : '');

  that._setType(renderSettings.axisType, renderSettings.drawingType);

  that._createAxisGroups();

  that._translator = that._createTranslator();
  that.isArgumentAxis = renderSettings.isArgumentAxis;
  that._viewport = {};
  that._firstDrawing = true;
  that._initRange = {};
  that._getTemplate = renderSettings.getTemplate;
};

exports.Axis = Axis;
Axis.prototype = {
  constructor: Axis,
  _drawAxis: function _drawAxis() {
    var options = this._options;

    if (!options.visible) {
      return;
    }

    this._axisElement = this._createAxisElement();

    this._updateAxisElementPosition();

    this._axisElement.attr({
      'stroke-width': options.width,
      stroke: options.color,
      'stroke-opacity': options.opacity
    }).sharp(this._getSharpParam(true), this.getAxisSharpDirection()).append(this._axisLineGroup);
  },
  _createPathElement: function _createPathElement(points, attr, sharpDirection) {
    return this.sharp(this._renderer.path(points, 'line').attr(attr), sharpDirection);
  },
  sharp: function sharp(svgElement) {
    var sharpDirection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return svgElement.sharp(this._getSharpParam(), sharpDirection);
  },
  customPositionIsAvailable: function customPositionIsAvailable() {
    return false;
  },
  getOrthogonalAxis: _common.noop,
  getCustomPosition: _common.noop,
  getCustomBoundaryPosition: _common.noop,
  resolveOverlappingForCustomPositioning: _common.noop,
  hasNonBoundaryPosition: function hasNonBoundaryPosition() {
    return false;
  },
  customPositionIsBoundaryOrthogonalAxis: function customPositionIsBoundaryOrthogonalAxis() {
    return false;
  },
  getResolvedBoundaryPosition: function getResolvedBoundaryPosition() {
    return this.getOptions().position;
  },
  getAxisSharpDirection: function getAxisSharpDirection() {
    var position = this.getResolvedBoundaryPosition();
    return this.hasNonBoundaryPosition() || position !== BOTTOM && position !== RIGHT ? 1 : -1;
  },
  getSharpDirectionByCoords: function getSharpDirectionByCoords(coords) {
    var canvas = this._getCanvasStartEnd();

    var maxCoord = Math.max(canvas.start, canvas.end);
    return this.getRadius ? 0 : maxCoord !== coords[this._isHorizontal ? 'x' : 'y'] ? 1 : -1;
  },
  _getGridLineDrawer: function _getGridLineDrawer() {
    var that = this;
    return function (tick, gridStyle) {
      var grid = that._getGridPoints(tick.coords);

      if (grid.points) {
        return that._createPathElement(grid.points, gridStyle, that.getSharpDirectionByCoords(tick.coords));
      }

      return null;
    };
  },
  _getGridPoints: function _getGridPoints(coords) {
    var that = this;
    var isHorizontal = this._isHorizontal;
    var tickPositionField = isHorizontal ? 'x' : 'y';
    var orthogonalPositions = this._orthogonalPositions;
    var positionFrom = orthogonalPositions.start;
    var positionTo = orthogonalPositions.end;
    var borderOptions = that.borderOptions;
    var canvasStart = isHorizontal ? LEFT : TOP;
    var canvasEnd = isHorizontal ? RIGHT : BOTTOM;
    var axisCanvas = that.getCanvas();
    var canvas = {
      left: axisCanvas.left,
      right: axisCanvas.width - axisCanvas.right,
      top: axisCanvas.top,
      bottom: axisCanvas.height - axisCanvas.bottom
    };
    var firstBorderLinePosition = borderOptions.visible && borderOptions[canvasStart] ? canvas[canvasStart] : undefined;
    var lastBorderLinePosition = borderOptions.visible && borderOptions[canvasEnd] ? canvas[canvasEnd] : undefined;
    var minDelta = MAX_GRID_BORDER_ADHENSION + firstBorderLinePosition;
    var maxDelta = lastBorderLinePosition - MAX_GRID_BORDER_ADHENSION;

    if (that.areCoordsOutsideAxis(coords) || coords[tickPositionField] === undefined || coords[tickPositionField] < minDelta || coords[tickPositionField] > maxDelta) {
      return {
        points: null
      };
    }

    return {
      points: isHorizontal ? coords[tickPositionField] !== null ? [coords[tickPositionField], positionFrom, coords[tickPositionField], positionTo] : null : coords[tickPositionField] !== null ? [positionFrom, coords[tickPositionField], positionTo, coords[tickPositionField]] : null
    };
  },
  _getConstantLinePos: function _getConstantLinePos(parsedValue, canvasStart, canvasEnd) {
    var value = this._getTranslatedCoord(parsedValue);

    if (!(0, _type.isDefined)(value) || value < _min(canvasStart, canvasEnd) || value > _max(canvasStart, canvasEnd)) {
      return undefined;
    }

    return value;
  },
  _getConstantLineGraphicAttributes: function _getConstantLineGraphicAttributes(value) {
    var positionFrom = this._orthogonalPositions.start;
    var positionTo = this._orthogonalPositions.end;
    return {
      points: this._isHorizontal ? [value, positionFrom, value, positionTo] : [positionFrom, value, positionTo, value]
    };
  },
  _createConstantLine: function _createConstantLine(value, attr) {
    return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr, getConstantLineSharpDirection(value, this._getCanvasStartEnd()));
  },
  _drawConstantLineLabelText: function _drawConstantLineLabelText(text, x, y, _ref2, group) {
    var font = _ref2.font,
        cssClass = _ref2.cssClass;
    return this._renderer.text(text, x, y).css((0, _utils.patchFontOptions)((0, _extend.extend)({}, this._options.label.font, font))).attr({
      align: 'center',
      'class': cssClass
    }).append(group);
  },
  _drawConstantLineLabels: function _drawConstantLineLabels(parsedValue, lineLabelOptions, value, group) {
    var _text;

    var that = this;
    var text = lineLabelOptions.text;
    var options = that._options;
    var labelOptions = options.label;

    that._checkAlignmentConstantLineLabels(lineLabelOptions);

    text = (_text = text) !== null && _text !== void 0 ? _text : that.formatLabel(parsedValue, labelOptions);

    var coords = that._getConstantLineLabelsCoords(value, lineLabelOptions);

    return that._drawConstantLineLabelText(text, coords.x, coords.y, lineLabelOptions, group);
  },
  _getStripPos: function _getStripPos(startValue, endValue, canvasStart, canvasEnd, range) {
    var isContinuous = !!(range.minVisible || range.maxVisible);
    var categories = (range.categories || []).reduce(function (result, cat) {
      result.push(cat.valueOf());
      return result;
    }, []);
    var start;
    var end;
    var swap;
    var startCategoryIndex;
    var endCategoryIndex;

    if (!isContinuous) {
      if ((0, _type.isDefined)(startValue) && (0, _type.isDefined)(endValue)) {
        var parsedStartValue = this.parser(startValue);
        var parsedEndValue = this.parser(endValue);
        startCategoryIndex = (0, _array.inArray)((0, _type.isDefined)(parsedStartValue) ? parsedStartValue.valueOf() : undefined, categories);
        endCategoryIndex = (0, _array.inArray)((0, _type.isDefined)(parsedEndValue) ? parsedEndValue.valueOf() : undefined, categories);

        if (startCategoryIndex === -1 || endCategoryIndex === -1) {
          return {
            from: 0,
            to: 0,
            outOfCanvas: true
          };
        }

        if (startCategoryIndex > endCategoryIndex) {
          swap = endValue;
          endValue = startValue;
          startValue = swap;
        }
      }
    }

    if ((0, _type.isDefined)(startValue)) {
      startValue = this.validateUnit(startValue, 'E2105', 'strip');
      start = this._getTranslatedCoord(startValue, -1);
    } else {
      start = canvasStart;
    }

    if ((0, _type.isDefined)(endValue)) {
      endValue = this.validateUnit(endValue, 'E2105', 'strip');
      end = this._getTranslatedCoord(endValue, 1);
    } else {
      end = canvasEnd;
    }

    var stripPosition = start < end ? {
      from: start,
      to: end
    } : {
      from: end,
      to: start
    };
    var visibleArea = this.getVisibleArea();

    if (stripPosition.from <= visibleArea[0] && stripPosition.to <= visibleArea[0] || stripPosition.from >= visibleArea[1] && stripPosition.to >= visibleArea[1]) {
      stripPosition.outOfCanvas = true;
    }

    return stripPosition;
  },
  _getStripGraphicAttributes: function _getStripGraphicAttributes(fromPoint, toPoint) {
    var x;
    var y;
    var width;
    var height;
    var orthogonalPositions = this._orthogonalPositions;
    var positionFrom = orthogonalPositions.start;
    var positionTo = orthogonalPositions.end;

    if (this._isHorizontal) {
      x = fromPoint;
      y = _min(positionFrom, positionTo);
      width = toPoint - fromPoint;
      height = _abs(positionFrom - positionTo);
    } else {
      x = _min(positionFrom, positionTo);
      y = fromPoint;
      width = _abs(positionFrom - positionTo);
      height = _abs(fromPoint - toPoint);
    }

    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  },
  _createStrip: function _createStrip(attrs) {
    return this._renderer.rect(attrs.x, attrs.y, attrs.width, attrs.height);
  },
  _adjustStripLabels: function _adjustStripLabels() {
    var that = this;

    this._strips.forEach(function (strip) {
      if (strip.label) {
        strip.label.attr(that._getAdjustedStripLabelCoords(strip));
      }
    });
  },
  _adjustLabelsCoord: function _adjustLabelsCoord(offset, maxWidth, checkCanvas) {
    var _this = this;

    var that = this;

    var getContainerAttrs = function getContainerAttrs(tick) {
      return _this._getLabelAdjustedCoord(tick, offset + (tick.labelOffset || 0), maxWidth, checkCanvas);
    };

    that._majorTicks.forEach(function (tick) {
      if (tick.label) {
        tick.updateMultilineTextAlignment();
        tick.label.attr(getContainerAttrs(tick));
      } else {
        tick.templateContainer && tick.templateContainer.attr(getContainerAttrs(tick));
      }
    });
  },
  _adjustLabels: function _adjustLabels(offset) {
    var that = this;
    var options = that.getOptions();
    var positionsAreConsistent = options.position === options.label.position;

    var maxSize = that._majorTicks.reduce(function (size, tick) {
      if (!tick.getContentContainer()) return size;
      var bBox = tick.labelRotationAngle ? (0, _utils.rotateBBox)(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle) : tick.labelBBox;
      return {
        width: _max(size.width || 0, bBox.width),
        height: _max(size.height || 0, bBox.height),
        offset: _max(size.offset || 0, tick.labelOffset || 0)
      };
    }, {});

    var additionalOffset = positionsAreConsistent ? that._isHorizontal ? maxSize.height : maxSize.width : 0;

    that._adjustLabelsCoord(offset, maxSize.width);

    return offset + additionalOffset + (additionalOffset && that._options.label.indentFromAxis) + (positionsAreConsistent ? maxSize.offset : 0);
  },
  _getLabelAdjustedCoord: function _getLabelAdjustedCoord(tick, offset, maxWidth) {
    offset = offset || 0;
    var that = this;
    var options = that._options;
    var templateBox = tick.templateContainer && tick.templateContainer.getBBox();
    var box = templateBox || (0, _utils.rotateBBox)(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle || 0);
    var textAlign = tick.labelAlignment || options.label.alignment;
    var isDiscrete = that._options.type === 'discrete';
    var isFlatLabel = tick.labelRotationAngle % 90 === 0;
    var indentFromAxis = options.label.indentFromAxis;
    var labelPosition = options.label.position;
    var axisPosition = that._axisPosition;
    var labelCoords = tick.labelCoords;
    var labelX = labelCoords.x;
    var translateX;
    var translateY;

    if (that._isHorizontal) {
      if (labelPosition === BOTTOM) {
        translateY = axisPosition + indentFromAxis - box.y + offset;
      } else {
        translateY = axisPosition - indentFromAxis - (box.y + box.height) - offset;
      }

      if (textAlign === RIGHT) {
        translateX = isDiscrete && isFlatLabel ? tick.coords.x - (box.x + box.width) : labelX - box.x - box.width;
      } else if (textAlign === LEFT) {
        translateX = isDiscrete && isFlatLabel ? labelX - box.x - (tick.coords.x - labelX) : labelX - box.x;
      } else {
        translateX = labelX - box.x - box.width / 2;
      }
    } else {
      translateY = labelCoords.y - box.y - box.height / 2;

      if (labelPosition === LEFT) {
        if (textAlign === LEFT) {
          translateX = axisPosition - indentFromAxis - maxWidth - box.x;
        } else if (textAlign === CENTER) {
          translateX = axisPosition - indentFromAxis - maxWidth / 2 - box.x - box.width / 2;
        } else {
          translateX = axisPosition - indentFromAxis - box.x - box.width;
        }

        translateX -= offset;
      } else {
        if (textAlign === RIGHT) {
          translateX = axisPosition + indentFromAxis + maxWidth - box.x - box.width;
        } else if (textAlign === CENTER) {
          translateX = axisPosition + indentFromAxis + maxWidth / 2 - box.x - box.width / 2;
        } else {
          translateX = axisPosition + indentFromAxis - box.x;
        }

        translateX += offset;
      }
    }

    return {
      translateX: translateX,
      translateY: translateY
    };
  },
  _createAxisConstantLineGroups: function _createAxisConstantLineGroups() {
    var that = this;
    var renderer = that._renderer;
    var classSelector = that._axisCssPrefix;
    var constantLinesClass = classSelector + 'constant-lines';
    var insideGroup = renderer.g().attr({
      'class': constantLinesClass
    });
    var outsideGroup1 = renderer.g().attr({
      'class': constantLinesClass
    });
    var outsideGroup2 = renderer.g().attr({
      'class': constantLinesClass
    });
    return {
      inside: insideGroup,
      outside1: outsideGroup1,
      left: outsideGroup1,
      top: outsideGroup1,
      outside2: outsideGroup2,
      right: outsideGroup2,
      bottom: outsideGroup2,
      remove: function remove() {
        this.inside.remove();
        this.outside1.remove();
        this.outside2.remove();
      },
      clear: function clear() {
        this.inside.clear();
        this.outside1.clear();
        this.outside2.clear();
      }
    };
  },
  _createAxisGroups: function _createAxisGroups() {
    var that = this;
    var renderer = that._renderer;
    var classSelector = that._axisCssPrefix;
    that._axisGroup = renderer.g().attr({
      'class': classSelector + 'axis'
    }).enableLinks();
    that._axisStripGroup = renderer.g().attr({
      'class': classSelector + 'strips'
    });
    that._axisGridGroup = renderer.g().attr({
      'class': classSelector + 'grid'
    });
    that._axisElementsGroup = renderer.g().attr({
      'class': classSelector + 'elements'
    });
    that._axisLineGroup = renderer.g().attr({
      'class': classSelector + 'line'
    }).linkOn(that._axisGroup, 'axisLine').linkAppend();
    that._axisTitleGroup = renderer.g().attr({
      'class': classSelector + 'title'
    }).append(that._axisGroup);
    that._axisConstantLineGroups = {
      above: that._createAxisConstantLineGroups(),
      under: that._createAxisConstantLineGroups()
    };
    that._axisStripLabelGroup = renderer.g().attr({
      'class': classSelector + 'axis-labels'
    });
  },
  _clearAxisGroups: function _clearAxisGroups() {
    var that = this;

    that._axisGroup.remove();

    that._axisStripGroup.remove();

    that._axisStripLabelGroup.remove();

    that._axisConstantLineGroups.above.remove();

    that._axisConstantLineGroups.under.remove();

    that._axisGridGroup.remove();

    that._axisTitleGroup.clear();

    if (!that._options.label.template || !that.isRendered()) {
      // for react async templates
      that._axisElementsGroup.remove();

      that._axisElementsGroup.clear();
    }

    that._axisLineGroup && that._axisLineGroup.clear();
    that._axisStripGroup && that._axisStripGroup.clear();
    that._axisGridGroup && that._axisGridGroup.clear();

    that._axisConstantLineGroups.above.clear();

    that._axisConstantLineGroups.under.clear();

    that._axisStripLabelGroup && that._axisStripLabelGroup.clear();
  },
  _getLabelFormatObject: function _getLabelFormatObject(value, labelOptions, range, point, tickInterval, ticks) {
    range = range || this._getViewportRange();
    var formatObject = {
      value: value,
      valueText: (0, _smart_formatter.smartFormatter)(value, {
        labelOptions: labelOptions,
        ticks: ticks || convertTicksToValues(this._majorTicks),
        tickInterval: tickInterval !== null && tickInterval !== void 0 ? tickInterval : this._tickInterval,
        dataType: this._options.dataType,
        logarithmBase: this._options.logarithmBase,
        type: this._options.type,
        showTransition: !this._options.marker.visible,
        point: point
      }) || '',
      // B252346
      min: range.minVisible,
      max: range.maxVisible
    }; // for crosshair's customizeText

    if (point) {
      formatObject.point = point;
    }

    return formatObject;
  },
  formatLabel: function formatLabel(value, labelOptions, range, point, tickInterval, ticks) {
    var formatObject = this._getLabelFormatObject(value, labelOptions, range, point, tickInterval, ticks);

    return (0, _type.isFunction)(labelOptions.customizeText) ? labelOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText;
  },
  formatHint: function formatHint(value, labelOptions, range) {
    var formatObject = this._getLabelFormatObject(value, labelOptions, range);

    return (0, _type.isFunction)(labelOptions.customizeHint) ? labelOptions.customizeHint.call(formatObject, formatObject) : undefined;
  },
  formatRange: function formatRange(startValue, endValue, interval) {
    return (0, _smart_formatter.formatRange)(startValue, endValue, interval, this.getOptions());
  },
  _setTickOffset: function _setTickOffset() {
    var options = this._options;
    var discreteAxisDivisionMode = options.discreteAxisDivisionMode;
    this._tickOffset = +(discreteAxisDivisionMode !== 'crossLabels' || !discreteAxisDivisionMode);
  },
  resetApplyingAnimation: function resetApplyingAnimation(isFirstDrawing) {
    this._resetApplyingAnimation = true;

    if (isFirstDrawing) {
      this._firstDrawing = true;
    }
  },
  isFirstDrawing: function isFirstDrawing() {
    return this._firstDrawing;
  },
  getMargins: function getMargins() {
    var that = this;
    var _that$_options = that._options,
        position = _that$_options.position,
        offset = _that$_options.offset,
        customPosition = _that$_options.customPosition,
        placeholderSize = _that$_options.placeholderSize,
        grid = _that$_options.grid,
        tick = _that$_options.tick,
        crosshairMargin = _that$_options.crosshairMargin;
    var isDefinedCustomPositionOption = (0, _type.isDefined)(customPosition);
    var boundaryPosition = that.getResolvedBoundaryPosition();
    var canvas = that.getCanvas();
    var cLeft = canvas.left;
    var cTop = canvas.top;
    var cRight = canvas.width - canvas.right;
    var cBottom = canvas.height - canvas.bottom;

    var edgeMarginCorrection = _max(grid.visible && grid.width || 0, tick.visible && tick.width || 0);

    var constantLineAboveSeries = that._axisConstantLineGroups.above;
    var constantLineUnderSeries = that._axisConstantLineGroups.under;
    var boxes = [that._axisElementsGroup, constantLineAboveSeries.outside1, constantLineAboveSeries.outside2, constantLineUnderSeries.outside1, constantLineUnderSeries.outside2, that._axisLineGroup].map(function (group) {
      return group && group.getBBox();
    }).concat(function (group) {
      var box = group && group.getBBox();

      if (!box || box.isEmpty) {
        return box;
      }

      if (that._isHorizontal) {
        box.x = cLeft;
        box.width = cRight - cLeft;
      } else {
        box.y = cTop;
        box.height = cBottom - cTop;
      }

      return box;
    }(that._axisTitleGroup));
    var margins = (0, _axes_utils.calculateCanvasMargins)(boxes, canvas);
    margins[position] += crosshairMargin;

    if (that.hasNonBoundaryPosition() && isDefinedCustomPositionOption) {
      margins[boundaryPosition] = 0;
    }

    if (placeholderSize) {
      margins[position] = placeholderSize;
    }

    if (edgeMarginCorrection) {
      if (that._isHorizontal && canvas.right < edgeMarginCorrection && margins.right < edgeMarginCorrection) {
        margins.right = edgeMarginCorrection;
      }

      if (!that._isHorizontal && canvas.bottom < edgeMarginCorrection && margins.bottom < edgeMarginCorrection) {
        margins.bottom = edgeMarginCorrection;
      }
    }

    if (!isDefinedCustomPositionOption && (0, _type.isDefined)(offset)) {
      var moveByOffset = that.customPositionIsBoundary() && (offset > 0 && (boundaryPosition === LEFT || boundaryPosition === TOP) || offset < 0 && (boundaryPosition === RIGHT || boundaryPosition === BOTTOM));
      margins[boundaryPosition] -= moveByOffset ? offset : 0;
    }

    return margins;
  },
  validateUnit: function validateUnit(unit, idError, parameters) {
    var that = this;
    unit = that.parser(unit);

    if (unit === undefined && idError) {
      that._incidentOccurred(idError, [parameters]);
    }

    return unit;
  },
  _setType: function _setType(axisType, drawingType) {
    var that = this;
    var axisTypeMethods;

    switch (axisType) {
      case 'xyAxes':
        axisTypeMethods = _xy_axes.default;
        break;

      case 'polarAxes':
        axisTypeMethods = polarMethods;
        break;
    }

    (0, _extend.extend)(that, axisTypeMethods[drawingType]);
  },
  _getSharpParam: function _getSharpParam() {
    return true;
  },
  _disposeBreaksGroup: _common.noop,
  // public
  dispose: function dispose() {
    var that = this;
    [that._axisElementsGroup, that._axisStripGroup, that._axisGroup].forEach(function (g) {
      g.dispose();
    });
    that._strips = that._title = null;
    that._axisStripGroup = that._axisConstantLineGroups = that._axisStripLabelGroup = that._axisBreaksGroup = null;
    that._axisLineGroup = that._axisElementsGroup = that._axisGridGroup = null;
    that._axisGroup = that._axisTitleGroup = null;
    that._axesContainerGroup = that._stripsGroup = that._constantLinesGroup = that._labelsAxesGroup = null;
    that._renderer = that._options = that._textOptions = that._textFontStyles = null;
    that._translator = null;
    that._majorTicks = that._minorTicks = null;

    that._disposeBreaksGroup();

    that._templatesRendered && that._templatesRendered.reject();
  },
  getOptions: function getOptions() {
    return this._options;
  },
  setPane: function setPane(pane) {
    this.pane = pane;
    this._options.pane = pane;
  },
  setTypes: function setTypes(type, axisType, typeSelector) {
    this._options.type = type || this._options.type;
    this._options[typeSelector] = axisType || this._options[typeSelector];

    this._updateTranslator();
  },
  resetTypes: function resetTypes(typeSelector) {
    this._options.type = this._initTypes.type;
    this._options[typeSelector] = this._initTypes[typeSelector];
  },
  getTranslator: function getTranslator() {
    return this._translator;
  },
  updateOptions: function updateOptions(options) {
    var that = this;
    var labelOpt = options.label;
    validateAxisOptions(options);
    that._options = options;
    options.tick = options.tick || {};
    options.minorTick = options.minorTick || {};
    options.grid = options.grid || {};
    options.minorGrid = options.minorGrid || {};
    options.title = options.title || {};
    options.marker = options.marker || {};
    that._initTypes = {
      type: options.type,
      argumentType: options.argumentType,
      valueType: options.valueType
    };

    that._setTickOffset();

    that._isHorizontal = options.isHorizontal;
    that.pane = options.pane;
    that.name = options.name;
    that.priority = options.priority;
    that._hasLabelFormat = labelOpt.format !== '' && (0, _type.isDefined)(labelOpt.format);
    that._textOptions = {
      opacity: labelOpt.opacity,
      align: 'center',
      'class': labelOpt.cssClass
    };
    that._textFontStyles = (0, _utils.patchFontOptions)(labelOpt.font);

    if (options.type === _axes_constants.default.logarithmic) {
      if (options.logarithmBaseError) {
        that._incidentOccurred('E2104');

        delete options.logarithmBaseError;
      }
    }

    that._updateTranslator();

    that._createConstantLines();

    that._strips = (options.strips || []).map(function (o) {
      return (0, _strip.default)(that, o);
    });
    that._majorTicks = that._minorTicks = null;
    that._firstDrawing = true;
  },
  calculateInterval: function calculateInterval(value, prevValue) {
    var options = this._options;

    if (!options || options.type !== _axes_constants.default.logarithmic) {
      return _abs(value - prevValue);
    }

    var _Range = new _range.Range(this.getTranslator().getBusinessRange()),
        allowNegatives = _Range.allowNegatives,
        linearThreshold = _Range.linearThreshold;

    return _abs((0, _utils.getLogExt)(value, options.logarithmBase, allowNegatives, linearThreshold) - (0, _utils.getLogExt)(prevValue, options.logarithmBase, allowNegatives, linearThreshold));
  },
  getCanvasRange: function getCanvasRange() {
    var translator = this._translator;
    return {
      startValue: translator.from(translator.translate('canvas_position_start')),
      endValue: translator.from(translator.translate('canvas_position_end'))
    };
  },
  _processCanvas: function _processCanvas(canvas) {
    return canvas;
  },
  updateCanvas: function updateCanvas(canvas, canvasRedesign) {
    if (!canvasRedesign) {
      var positions = this._orthogonalPositions = {
        start: !this._isHorizontal ? canvas.left : canvas.top,
        end: !this._isHorizontal ? canvas.width - canvas.right : canvas.height - canvas.bottom
      };
      positions.center = positions.start + (positions.end - positions.start) / 2;
    } else {
      this._orthogonalPositions = null;
    }

    this._canvas = canvas;

    this._translator.updateCanvas(this._processCanvas(canvas));

    this._initAxisPositions();
  },
  getCanvas: function getCanvas() {
    return this._canvas;
  },
  getAxisShift: function getAxisShift() {
    return this._axisShift || 0;
  },
  hideTitle: function hideTitle() {
    var that = this;

    if (that._options.title.text) {
      that._incidentOccurred('W2105', [that._isHorizontal ? 'horizontal' : 'vertical']);

      that._axisTitleGroup.clear();
    }
  },
  getTitle: function getTitle() {
    return this._title;
  },
  hideOuterElements: function hideOuterElements() {
    var that = this;
    var options = that._options;

    if ((options.label.visible || that._outsideConstantLines.length) && !that._translator.getBusinessRange().isEmpty()) {
      that._incidentOccurred('W2106', [that._isHorizontal ? 'horizontal' : 'vertical']);

      that._axisElementsGroup.clear();

      callAction(that._outsideConstantLines, 'removeLabel');
    }
  },
  _resolveLogarithmicOptionsForRange: function _resolveLogarithmicOptionsForRange(range) {
    var options = this._options;

    if (options.type === _axes_constants.default.logarithmic) {
      range.addRange({
        allowNegatives: options.allowNegatives !== undefined ? options.allowNegatives : range.min <= 0
      });

      if (!isNaN(options.linearThreshold)) {
        range.linearThreshold = options.linearThreshold;
      }
    }
  },
  adjustViewport: function adjustViewport(businessRange) {
    var that = this;
    var options = that._options;
    var isDiscrete = options.type === _axes_constants.default.discrete;
    var categories = that._seriesData && that._seriesData.categories || [];
    var wholeRange = that.adjustRange((0, _utils.getVizRangeObject)(options.wholeRange));
    var visualRange = that.getViewport() || {};
    var result = new _range.Range(businessRange);

    that._addConstantLinesToRange(result, 'minVisible', 'maxVisible');

    var minDefined = (0, _type.isDefined)(visualRange.startValue);
    var maxDefined = (0, _type.isDefined)(visualRange.endValue);

    if (!isDiscrete) {
      minDefined = minDefined && (!(0, _type.isDefined)(wholeRange.endValue) || visualRange.startValue < wholeRange.endValue);
      maxDefined = maxDefined && (!(0, _type.isDefined)(wholeRange.startValue) || visualRange.endValue > wholeRange.startValue);
    }

    var minVisible = minDefined ? visualRange.startValue : result.minVisible;
    var maxVisible = maxDefined ? visualRange.endValue : result.maxVisible;

    if (!isDiscrete) {
      var _wholeRange$startValu, _wholeRange$endValue;

      result.min = (_wholeRange$startValu = wholeRange.startValue) !== null && _wholeRange$startValu !== void 0 ? _wholeRange$startValu : result.min;
      result.max = (_wholeRange$endValue = wholeRange.endValue) !== null && _wholeRange$endValue !== void 0 ? _wholeRange$endValue : result.max;
    } else {
      var categoriesInfo = (0, _utils.getCategoriesInfo)(categories, wholeRange.startValue, wholeRange.endValue);
      categories = categoriesInfo.categories;
      result.categories = categories;
    }

    var adjustedVisualRange = (0, _utils.adjustVisualRange)({
      axisType: options.type,
      dataType: options.dataType,
      base: options.logarithmBase
    }, {
      startValue: minDefined ? visualRange.startValue : undefined,
      endValue: maxDefined ? visualRange.endValue : undefined,
      length: visualRange.length
    }, {
      categories: categories,
      min: wholeRange.startValue,
      max: wholeRange.endValue
    }, {
      categories: categories,
      min: minVisible,
      max: maxVisible
    });
    result.minVisible = adjustedVisualRange.startValue;
    result.maxVisible = adjustedVisualRange.endValue;
    !(0, _type.isDefined)(result.min) && (result.min = result.minVisible);
    !(0, _type.isDefined)(result.max) && (result.max = result.maxVisible);
    result.addRange({}); // controlValuesByVisibleBounds

    that._resolveLogarithmicOptionsForRange(result);

    return result;
  },
  adjustRange: function adjustRange(range) {
    range = range || {};
    var isDiscrete = this._options.type === _axes_constants.default.discrete;
    var isLogarithmic = this._options.type === _axes_constants.default.logarithmic;
    var disabledNegatives = this._options.allowNegatives === false;

    if (isLogarithmic) {
      range.startValue = disabledNegatives && range.startValue <= 0 ? null : range.startValue;
      range.endValue = disabledNegatives && range.endValue <= 0 ? null : range.endValue;
    }

    if (!isDiscrete && (0, _type.isDefined)(range.startValue) && (0, _type.isDefined)(range.endValue) && range.startValue > range.endValue) {
      var tmp = range.endValue;
      range.endValue = range.startValue;
      range.startValue = tmp;
    }

    return range;
  },
  _getVisualRangeUpdateMode: function _getVisualRangeUpdateMode(viewport, newRange, oppositeValue) {
    var value = this._options.visualRangeUpdateMode;
    var translator = this._translator;
    var range = this._seriesData;

    if (this.isArgumentAxis) {
      if ([SHIFT, KEEP, RESET].indexOf(value) === -1) {
        if (range.axisType === _axes_constants.default.discrete) {
          var categories = range.categories;
          var newCategories = newRange.categories;
          var visualRange = this.visualRange();

          if (categories && newCategories && categories.length && newCategories.map(function (c) {
            return c.valueOf();
          }).join(',').indexOf(categories.map(function (c) {
            return c.valueOf();
          }).join(',')) !== -1 && (visualRange.startValue.valueOf() !== categories[0].valueOf() || visualRange.endValue.valueOf() !== categories[categories.length - 1].valueOf())) {
            value = KEEP;
          } else {
            value = RESET;
          }
        } else {
          var minPoint = translator.translate(range.min);
          var minVisiblePoint = translator.translate(viewport.startValue);
          var maxPoint = translator.translate(range.max);
          var maxVisiblePoint = translator.translate(viewport.endValue);

          if (minPoint === minVisiblePoint && maxPoint === maxVisiblePoint) {
            value = RESET;
          } else if (minPoint !== minVisiblePoint && maxPoint === maxVisiblePoint) {
            value = SHIFT;
          } else {
            value = KEEP;
          }
        }
      }
    } else {
      if ([KEEP, RESET].indexOf(value) === -1) {
        if (oppositeValue === KEEP) {
          value = KEEP;
        } else {
          value = RESET;
        }
      }
    }

    return value;
  },
  _handleBusinessRangeChanged: function _handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, newRange) {
    var that = this;
    var visualRange = this.visualRange();

    if (axisReinitialized || that._translator.getBusinessRange().isEmpty()) {
      return;
    }

    var visualRangeUpdateMode = that._lastVisualRangeUpdateMode = that._getVisualRangeUpdateMode(visualRange, newRange, oppositeVisualRangeUpdateMode);

    if (!that.isArgumentAxis) {
      var viewport = that.getViewport();

      if (!(0, _type.isDefined)(viewport.startValue) && !(0, _type.isDefined)(viewport.endValue) && !(0, _type.isDefined)(viewport.length)) {
        visualRangeUpdateMode = RESET;
      }
    }

    that._prevDataWasEmpty && (visualRangeUpdateMode = KEEP);

    if (visualRangeUpdateMode === KEEP) {
      that._setVisualRange([visualRange.startValue, visualRange.endValue]);
    }

    if (visualRangeUpdateMode === RESET) {
      that._setVisualRange([null, null]);
    }

    if (visualRangeUpdateMode === SHIFT) {
      that._setVisualRange({
        length: that.getVisualRangeLength()
      });
    }
  },
  getVisualRangeLength: function getVisualRangeLength(range) {
    var currentBusinessRange = range || this._translator.getBusinessRange();

    var type = this._options.type;
    var length;

    if (type === _axes_constants.default.logarithmic) {
      length = (0, _math2.adjust)(this.calculateInterval(currentBusinessRange.maxVisible, currentBusinessRange.minVisible));
    } else if (type === _axes_constants.default.discrete) {
      var categoriesInfo = (0, _utils.getCategoriesInfo)(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);
      length = categoriesInfo.categories.length;
    } else {
      length = currentBusinessRange.maxVisible - currentBusinessRange.minVisible;
    }

    return length;
  },
  getVisualRangeCenter: function getVisualRangeCenter(range, useMerge) {
    var translator = this.getTranslator();
    var businessRange = translator.getBusinessRange();
    var currentBusinessRange = useMerge ? (0, _extend.extend)(true, {}, businessRange, range || {}) : range || businessRange;
    var _this$_options = this._options,
        type = _this$_options.type,
        logarithmBase = _this$_options.logarithmBase;
    var center;

    if (!(0, _type.isDefined)(currentBusinessRange.minVisible) || !(0, _type.isDefined)(currentBusinessRange.maxVisible)) {
      return;
    }

    if (type === _axes_constants.default.logarithmic) {
      var allowNegatives = currentBusinessRange.allowNegatives,
          linearThreshold = currentBusinessRange.linearThreshold,
          minVisible = currentBusinessRange.minVisible,
          maxVisible = currentBusinessRange.maxVisible;
      center = (0, _utils.raiseToExt)((0, _math2.adjust)((0, _utils.getLogExt)(maxVisible, logarithmBase, allowNegatives, linearThreshold) + (0, _utils.getLogExt)(minVisible, logarithmBase, allowNegatives, linearThreshold)) / 2, logarithmBase, allowNegatives, linearThreshold);
    } else if (type === _axes_constants.default.discrete) {
      var categoriesInfo = (0, _utils.getCategoriesInfo)(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);
      var index = Math.ceil(categoriesInfo.categories.length / 2) - 1;
      center = businessRange.categories.indexOf(categoriesInfo.categories[index]);
    } else {
      center = translator.toValue((currentBusinessRange.maxVisible.valueOf() + currentBusinessRange.minVisible.valueOf()) / 2);
    }

    return center;
  },
  setBusinessRange: function setBusinessRange(range, axisReinitialized, oppositeVisualRangeUpdateMode, argCategories) {
    var _that$_seriesData$min, _that$_seriesData$max;

    var that = this;
    var options = that._options;
    var isDiscrete = options.type === _axes_constants.default.discrete;

    that._handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, range);

    that._seriesData = new _range.Range(range);

    var dataIsEmpty = that._seriesData.isEmpty();

    that._prevDataWasEmpty = dataIsEmpty;

    that._seriesData.addRange({
      categories: options.categories,
      dataType: options.dataType,
      axisType: options.type,
      base: options.logarithmBase,
      invert: options.inverted
    });

    that._resolveLogarithmicOptionsForRange(that._seriesData);

    if (!isDiscrete) {
      if (!(0, _type.isDefined)(that._seriesData.min) && !(0, _type.isDefined)(that._seriesData.max)) {
        var visualRange = that.getViewport();
        visualRange && that._seriesData.addRange({
          min: visualRange.startValue,
          max: visualRange.endValue
        });
      }

      var synchronizedValue = options.synchronizedValue;

      if ((0, _type.isDefined)(synchronizedValue)) {
        that._seriesData.addRange({
          min: synchronizedValue,
          max: synchronizedValue
        });
      }
    }

    that._seriesData.minVisible = (_that$_seriesData$min = that._seriesData.minVisible) !== null && _that$_seriesData$min !== void 0 ? _that$_seriesData$min : that._seriesData.min;
    that._seriesData.maxVisible = (_that$_seriesData$max = that._seriesData.maxVisible) !== null && _that$_seriesData$max !== void 0 ? _that$_seriesData$max : that._seriesData.max;

    if (!that.isArgumentAxis && options.showZero) {
      that._seriesData.correctValueZeroLevel();
    }

    that._seriesData.sortCategories(that.getCategoriesSorter(argCategories));

    that._seriesData.userBreaks = that._seriesData.isEmpty() ? [] : that._getScaleBreaks(options, that._seriesData, that._series, that.isArgumentAxis);

    that._translator.updateBusinessRange(that._getViewportRange());
  },
  _addConstantLinesToRange: function _addConstantLinesToRange(dataRange, minValueField, maxValueField) {
    this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(function (cl) {
      if (cl.options.extendAxis) {
        var _dataRange$addRange;

        var value = cl.getParsedValue();
        dataRange.addRange((_dataRange$addRange = {}, _defineProperty(_dataRange$addRange, minValueField, value), _defineProperty(_dataRange$addRange, maxValueField, value), _dataRange$addRange));
      }
    });
  },
  setGroupSeries: function setGroupSeries(series) {
    this._series = series;
  },
  getLabelsPosition: function getLabelsPosition() {
    var that = this;
    var options = that._options;
    var position = options.position;
    var labelShift = options.label.indentFromAxis + (that._axisShift || 0) + that._constantLabelOffset;
    var axisPosition = that._axisPosition;
    return position === TOP || position === LEFT ? axisPosition - labelShift : axisPosition + labelShift;
  },
  getFormattedValue: function getFormattedValue(value, options, point) {
    var labelOptions = this._options.label;
    return (0, _type.isDefined)(value) ? this.formatLabel(value, (0, _extend.extend)(true, {}, labelOptions, options), undefined, point) : null;
  },
  _getBoundaryTicks: function _getBoundaryTicks(majors, viewPort) {
    var that = this;
    var length = majors.length;
    var options = that._options;
    var customBounds = options.customBoundTicks;
    var min = viewPort.minVisible;
    var max = viewPort.maxVisible;
    var addMinMax = options.showCustomBoundaryTicks ? that._boundaryTicksVisibility : {};
    var boundaryTicks = [];

    if (options.type === _axes_constants.default.discrete) {
      if (that._tickOffset && majors.length !== 0) {
        boundaryTicks = [majors[0], majors[majors.length - 1]];
      }
    } else {
      if (customBounds) {
        if (addMinMax.min && (0, _type.isDefined)(customBounds[0])) {
          boundaryTicks.push(customBounds[0]);
        }

        if (addMinMax.max && (0, _type.isDefined)(customBounds[1])) {
          boundaryTicks.push(customBounds[1]);
        }
      } else {
        if (addMinMax.min && (length === 0 || majors[0] > min)) {
          boundaryTicks.push(min);
        }

        if (addMinMax.max && (length === 0 || majors[length - 1] < max)) {
          boundaryTicks.push(max);
        }
      }
    }

    return boundaryTicks;
  },
  setPercentLabelFormat: function setPercentLabelFormat() {
    if (!this._hasLabelFormat) {
      this._options.label.format = 'percent';
    }
  },
  resetAutoLabelFormat: function resetAutoLabelFormat() {
    if (!this._hasLabelFormat) {
      delete this._options.label.format;
    }
  },
  getMultipleAxesSpacing: function getMultipleAxesSpacing() {
    return this._options.multipleAxesSpacing || 0;
  },
  getTicksValues: function getTicksValues() {
    return {
      majorTicksValues: convertTicksToValues(this._majorTicks),
      minorTicksValues: convertTicksToValues(this._minorTicks)
    };
  },
  estimateTickInterval: function estimateTickInterval(canvas) {
    var that = this;
    that.updateCanvas(canvas);
    return that._tickInterval !== that._getTicks(that._getViewportRange(), _common.noop, true).tickInterval;
  },
  setTicks: function setTicks(ticks) {
    var majors = ticks.majorTicks || [];
    this._majorTicks = majors.map(createMajorTick(this, this._renderer, this._getSkippedCategory(majors)));
    this._minorTicks = (ticks.minorTicks || []).map(createMinorTick(this, this._renderer));
    this._isSynchronized = true;
  },
  _adjustDivisionFactor: function _adjustDivisionFactor(val) {
    return val;
  },
  _getTicks: function _getTicks(viewPort, incidentOccurred, skipTickGeneration) {
    var that = this;
    var options = that._options;
    var customTicks = options.customTicks;
    var customMinorTicks = options.customMinorTicks;
    return getTickGenerator(options, incidentOccurred || that._incidentOccurred, skipTickGeneration, that._translator.getBusinessRange().isEmpty(), that._adjustDivisionFactor.bind(that), viewPort)({
      min: viewPort.minVisible,
      max: viewPort.maxVisible,
      categories: viewPort.categories,
      isSpacedMargin: viewPort.isSpacedMargin
    }, that._getScreenDelta(), options.tickInterval, options.label.overlappingBehavior === 'ignore' || options.forceUserTickInterval, {
      majors: customTicks,
      minors: customMinorTicks
    }, options.minorTickInterval, options.minorTickCount, that._initialBreaks);
  },
  _createTicksAndLabelFormat: function _createTicksAndLabelFormat(range, incidentOccurred) {
    var options = this._options;

    var ticks = this._getTicks(range, incidentOccurred, false);

    if (!range.isEmpty() && options.type === _axes_constants.default.discrete && options.dataType === 'datetime' && !this._hasLabelFormat && ticks.ticks.length) {
      options.label.format = _format_helper.default.getDateFormatByTicks(ticks.ticks);
    }

    return ticks;
  },
  getAggregationInfo: function getAggregationInfo(useAllAggregatedPoints, range) {
    var _visualRange$startVal, _visualRange$endValue, _that$_seriesData;

    var that = this;
    var options = that._options;
    var marginOptions = that._marginOptions;
    var businessRange = new _range.Range(that.getTranslator().getBusinessRange()).addRange(range);
    var visualRange = that.getViewport();
    var minVisible = (_visualRange$startVal = visualRange === null || visualRange === void 0 ? void 0 : visualRange.startValue) !== null && _visualRange$startVal !== void 0 ? _visualRange$startVal : businessRange.minVisible;
    var maxVisible = (_visualRange$endValue = visualRange === null || visualRange === void 0 ? void 0 : visualRange.endValue) !== null && _visualRange$endValue !== void 0 ? _visualRange$endValue : businessRange.maxVisible;
    var ticks = [];

    if (options.type === _axes_constants.default.discrete && options.aggregateByCategory) {
      return {
        aggregateByCategory: true
      };
    }

    var aggregationInterval = options.aggregationInterval;
    var aggregationGroupWidth = options.aggregationGroupWidth;

    if (!aggregationGroupWidth && marginOptions) {
      if (marginOptions.checkInterval) {
        aggregationGroupWidth = options.axisDivisionFactor;
      }

      if (marginOptions.sizePointNormalState) {
        aggregationGroupWidth = Math.min(marginOptions.sizePointNormalState, options.axisDivisionFactor);
      }
    }

    var minInterval = !options.aggregationGroupWidth && !aggregationInterval && range.interval;
    var generateTicks = configureGenerator(options, aggregationGroupWidth, businessRange, that._getScreenDelta(), minInterval);
    var tickInterval = generateTicks(aggregationInterval, true, minVisible, maxVisible, (_that$_seriesData = that._seriesData) === null || _that$_seriesData === void 0 ? void 0 : _that$_seriesData.breaks).tickInterval;

    if (options.type !== _axes_constants.default.discrete) {
      var min = useAllAggregatedPoints ? businessRange.min : minVisible;
      var max = useAllAggregatedPoints ? businessRange.max : maxVisible;

      if ((0, _type.isDefined)(min) && (0, _type.isDefined)(max)) {
        var add = (0, _utils.getAddFunction)({
          base: options.logarithmBase,
          axisType: options.type,
          dataType: options.dataType
        }, false);
        var start = min;
        var end = max;

        if (!useAllAggregatedPoints) {
          var maxMinDistance = Math.max(that.calculateInterval(max, min), options.dataType === 'datetime' ? _date.default.dateToMilliseconds(tickInterval) : tickInterval);
          start = add(min, maxMinDistance, -1);
          end = add(max, maxMinDistance);
        }

        start = start < businessRange.min ? businessRange.min : start;
        end = end > businessRange.max ? businessRange.max : end;

        var breaks = that._getScaleBreaks(options, {
          minVisible: start,
          maxVisible: end
        }, that._series, that.isArgumentAxis);

        var filteredBreaks = that._filterBreaks(breaks, {
          minVisible: start,
          maxVisible: end
        }, options.breakStyle);

        ticks = generateTicks(tickInterval, false, start, end, filteredBreaks).ticks;
      }
    }

    that._aggregationInterval = tickInterval;
    return {
      interval: tickInterval,
      ticks: ticks
    };
  },
  getTickInterval: function getTickInterval() {
    return this._tickInterval;
  },
  getAggregationInterval: function getAggregationInterval() {
    return this._aggregationInterval;
  },
  createTicks: function createTicks(canvas) {
    var that = this;
    var renderer = that._renderer;
    var options = that._options;

    if (!canvas) {
      return;
    }

    that._isSynchronized = false;
    that.updateCanvas(canvas);

    var range = that._getViewportRange();

    that._initialBreaks = range.breaks = this._seriesData.breaks = that._filterBreaks(this._seriesData.userBreaks, range, options.breakStyle);
    that._estimatedTickInterval = that._getTicks(that.adjustViewport(this._seriesData), _common.noop, true).tickInterval; // tickInterval calculation

    var margins = this._calculateValueMargins();

    range.addRange({
      minVisible: margins.minValue,
      maxVisible: margins.maxValue,
      isSpacedMargin: margins.isSpacedMargin
    });

    var ticks = that._createTicksAndLabelFormat(range);

    var boundaryTicks = that._getBoundaryTicks(ticks.ticks, that._getViewportRange());

    if (options.showCustomBoundaryTicks && boundaryTicks.length) {
      that._boundaryTicks = [boundaryTicks[0]].map(createBoundaryTick(that, renderer, true));

      if (boundaryTicks.length > 1) {
        that._boundaryTicks = that._boundaryTicks.concat([boundaryTicks[1]].map(createBoundaryTick(that, renderer, false)));
      }
    } else {
      that._boundaryTicks = [];
    }

    var minors = (ticks.minorTicks || []).filter(function (minor) {
      return !boundaryTicks.some(function (boundary) {
        return (0, _utils.valueOf)(boundary) === (0, _utils.valueOf)(minor);
      });
    });
    that._tickInterval = ticks.tickInterval;
    that._minorTickInterval = ticks.minorTickInterval;
    var oldMajorTicks = that._majorTicks || [];
    var majorTicksByValues = oldMajorTicks.reduce(function (r, t) {
      r[t.value.valueOf()] = t;
      return r;
    }, {});
    var sameType = (0, _type.type)(ticks.ticks[0]) === (0, _type.type)(oldMajorTicks[0] && oldMajorTicks[0].value);

    var skippedCategory = that._getSkippedCategory(ticks.ticks);

    var majorTicks = ticks.ticks.map(function (v) {
      var tick = majorTicksByValues[v.valueOf()];

      if (tick && sameType) {
        delete majorTicksByValues[v.valueOf()];
        tick.setSkippedCategory(skippedCategory);
        return tick;
      } else {
        return createMajorTick(that, renderer, skippedCategory)(v);
      }
    });
    that._majorTicks = majorTicks;
    var oldMinorTicks = that._minorTicks || [];
    that._minorTicks = minors.map(function (v, i) {
      var minorTick = oldMinorTicks[i];

      if (minorTick) {
        minorTick.updateValue(v);
        return minorTick;
      }

      return createMinorTick(that, renderer)(v);
    });
    that._ticksToRemove = Object.keys(majorTicksByValues).map(function (k) {
      return majorTicksByValues[k];
    }).concat(oldMinorTicks.slice(that._minorTicks.length, oldMinorTicks.length));

    that._ticksToRemove.forEach(function (t) {
      var _t$label;

      return (_t$label = t.label) === null || _t$label === void 0 ? void 0 : _t$label.removeTitle();
    });

    if (ticks.breaks) {
      that._seriesData.breaks = ticks.breaks;
    }

    that._reinitTranslator(that._getViewportRange());
  },
  _reinitTranslator: function _reinitTranslator(range) {
    var that = this;
    var translator = that._translator;

    if (that._isSynchronized) {
      return;
    }

    translator.updateBusinessRange(range);
  },
  _getViewportRange: function _getViewportRange() {
    return this.adjustViewport(this._seriesData);
  },
  setMarginOptions: function setMarginOptions(options) {
    this._marginOptions = options;
  },
  getMarginOptions: function getMarginOptions() {
    var _this$_marginOptions;

    return (_this$_marginOptions = this._marginOptions) !== null && _this$_marginOptions !== void 0 ? _this$_marginOptions : {};
  },
  _calculateRangeInterval: function _calculateRangeInterval(interval) {
    var isDateTime = this._options.dataType === 'datetime';
    var minArgs = [];

    var addToArgs = function addToArgs(value) {
      (0, _type.isDefined)(value) && minArgs.push(isDateTime ? _date.default.dateToMilliseconds(value) : value);
    };

    addToArgs(this._tickInterval);
    addToArgs(this._estimatedTickInterval);
    (0, _type.isDefined)(interval) && minArgs.push(interval);
    addToArgs(this._aggregationInterval);
    return this._calculateWorkWeekInterval(_min.apply(this, minArgs));
  },
  _calculateWorkWeekInterval: function _calculateWorkWeekInterval(businessInterval) {
    var options = this._options;

    if (options.dataType === 'datetime' && options.workdaysOnly && businessInterval) {
      var workWeek = options.workWeek.length * dateIntervals.day;
      var weekend = dateIntervals.week - workWeek;

      if (workWeek !== businessInterval && weekend < businessInterval) {
        var weekendsCount = Math.ceil(businessInterval / dateIntervals.week);
        businessInterval = businessInterval - weekend * weekendsCount;
      } else if (weekend >= businessInterval && businessInterval > dateIntervals.day) {
        businessInterval = dateIntervals.day;
      }
    }

    return businessInterval;
  },
  _getConvertIntervalCoefficient: function _getConvertIntervalCoefficient(intervalInPx, screenDelta) {
    var ratioOfCanvasRange = this._translator.ratioOfCanvasRange();

    return ratioOfCanvasRange / (ratioOfCanvasRange * screenDelta / (intervalInPx + screenDelta));
  },
  _calculateValueMargins: function _calculateValueMargins(ticks) {
    this._resetMargins();

    var that = this;
    var margins = that.getMarginOptions();
    var marginSize = (margins.size || 0) / 2;
    var options = that._options;

    var dataRange = that._getViewportRange();

    var viewPort = that.getViewport();

    var screenDelta = that._getScreenDelta();

    var isDiscrete = (options.type || '').indexOf(_axes_constants.default.discrete) !== -1;
    var valueMarginsEnabled = options.valueMarginsEnabled && !isDiscrete && !that.customPositionIsBoundaryOrthogonalAxis();
    var translator = that._translator;
    var minValueMargin = options.minValueMargin;
    var maxValueMargin = options.maxValueMargin;
    var minPadding = 0;
    var maxPadding = 0;
    var interval = 0;
    var rangeInterval;

    if (dataRange.stubData || !screenDelta) {
      return {
        startPadding: 0,
        endPadding: 0
      };
    }

    if (that.isArgumentAxis && margins.checkInterval) {
      rangeInterval = that._calculateRangeInterval(dataRange.interval);
      var pxInterval = translator.getInterval(rangeInterval);

      if (isFinite(pxInterval)) {
        interval = Math.ceil(pxInterval / (2 * that._getConvertIntervalCoefficient(pxInterval, screenDelta)));
      } else {
        rangeInterval = 0;
      }
    }

    var minPercentPadding;
    var maxPercentPadding;
    var maxPaddingValue = screenDelta * MAX_MARGIN_VALUE / 2;

    if (valueMarginsEnabled) {
      if ((0, _type.isDefined)(minValueMargin)) {
        minPercentPadding = isFinite(minValueMargin) ? minValueMargin : 0;
      } else if (!that.isArgumentAxis && margins.checkInterval && (0, _utils.valueOf)(dataRange.minVisible) > 0 && (0, _utils.valueOf)(dataRange.minVisible) === (0, _utils.valueOf)(dataRange.min)) {
        minPadding = MIN_BAR_MARGIN;
      } else {
        minPadding = Math.max(marginSize, interval);
        minPadding = Math.min(maxPaddingValue, minPadding);
      }

      if ((0, _type.isDefined)(maxValueMargin)) {
        maxPercentPadding = isFinite(maxValueMargin) ? maxValueMargin : 0;
      } else if (!that.isArgumentAxis && margins.checkInterval && (0, _utils.valueOf)(dataRange.maxVisible) < 0 && (0, _utils.valueOf)(dataRange.maxVisible) === (0, _utils.valueOf)(dataRange.max)) {
        maxPadding = MIN_BAR_MARGIN;
      } else {
        maxPadding = Math.max(marginSize, interval);
        maxPadding = Math.min(maxPaddingValue, maxPadding);
      }
    }

    var percentStick = margins.percentStick && !this.isArgumentAxis;

    if (percentStick) {
      if (_abs(dataRange.max) === 1) {
        maxPadding = 0;
      }

      if (_abs(dataRange.min) === 1) {
        minPadding = 0;
      }
    }

    var canvasStartEnd = that._getCanvasStartEnd();

    var commonMargin = 1 + (minPercentPadding || 0) + (maxPercentPadding || 0);
    var screenDeltaWithMargins = (screenDelta - minPadding - maxPadding) / commonMargin || screenDelta;

    if (minPercentPadding !== undefined || maxPercentPadding !== undefined) {
      if (minPercentPadding !== undefined) {
        minPadding = screenDeltaWithMargins * minPercentPadding;
      }

      if (maxPercentPadding !== undefined) {
        maxPadding = screenDeltaWithMargins * maxPercentPadding;
      }
    }

    var minValue;
    var maxValue;

    if (options.type !== _axes_constants.default.discrete && ticks && ticks.length > 1 && !options.skipViewportExtending && !viewPort.action && options.endOnTick !== false) {
      var length = ticks.length;
      var firstTickPosition = translator.translate(ticks[0].value);
      var lastTickPosition = translator.translate(ticks[length - 1].value);
      var invertMultiplier = firstTickPosition > lastTickPosition ? -1 : 1;

      var minTickPadding = _max(invertMultiplier * (canvasStartEnd.start - firstTickPosition), 0);

      var maxTickPadding = _max(invertMultiplier * (lastTickPosition - canvasStartEnd.end), 0);

      if (minTickPadding > minPadding || maxTickPadding > maxPadding) {
        var commonPadding = maxTickPadding + minTickPadding;

        var coeff = that._getConvertIntervalCoefficient(commonPadding, screenDelta);

        if (minTickPadding >= minPadding) {
          minValue = ticks[0].value;
        }

        if (maxTickPadding >= maxPadding) {
          maxValue = ticks[length - 1].value;
        }

        minPadding = _max(minTickPadding, minPadding) / coeff;
        maxPadding = _max(maxTickPadding, maxPadding) / coeff;
      }
    }

    minPercentPadding = minPercentPadding === undefined ? minPadding / screenDeltaWithMargins : minPercentPadding;
    maxPercentPadding = maxPercentPadding === undefined ? maxPadding / screenDeltaWithMargins : maxPercentPadding;

    if (!isDiscrete) {
      if (this._translator.isInverted()) {
        var _minValue, _maxValue;

        minValue = (_minValue = minValue) !== null && _minValue !== void 0 ? _minValue : translator.from(canvasStartEnd.start + screenDelta * minPercentPadding, -1);
        maxValue = (_maxValue = maxValue) !== null && _maxValue !== void 0 ? _maxValue : translator.from(canvasStartEnd.end - screenDelta * maxPercentPadding, 1);
      } else {
        var _minValue2, _maxValue2;

        minValue = (_minValue2 = minValue) !== null && _minValue2 !== void 0 ? _minValue2 : translator.from(canvasStartEnd.start - screenDelta * minPercentPadding, -1);
        maxValue = (_maxValue2 = maxValue) !== null && _maxValue2 !== void 0 ? _maxValue2 : translator.from(canvasStartEnd.end + screenDelta * maxPercentPadding, 1);
      }
    }

    var _that$getCorrectedVal = that.getCorrectedValuesToZero(minValue, maxValue),
        correctedMin = _that$getCorrectedVal.correctedMin,
        correctedMax = _that$getCorrectedVal.correctedMax,
        start = _that$getCorrectedVal.start,
        end = _that$getCorrectedVal.end;

    minPadding = start !== null && start !== void 0 ? start : minPadding;
    maxPadding = end !== null && end !== void 0 ? end : maxPadding;
    return {
      startPadding: translator.isInverted() ? maxPadding : minPadding,
      endPadding: translator.isInverted() ? minPadding : maxPadding,
      minValue: correctedMin !== null && correctedMin !== void 0 ? correctedMin : minValue,
      maxValue: correctedMax !== null && correctedMax !== void 0 ? correctedMax : maxValue,
      interval: rangeInterval,
      isSpacedMargin: minPadding === maxPadding && minPadding !== 0
    };
  },
  getCorrectedValuesToZero: function getCorrectedValuesToZero(minValue, maxValue) {
    var that = this;
    var translator = that._translator;

    var canvasStartEnd = that._getCanvasStartEnd();

    var dataRange = that._getViewportRange();

    var screenDelta = that._getScreenDelta();

    var options = that._options;
    var start;
    var end;
    var correctedMin;
    var correctedMax;

    var correctZeroLevel = function correctZeroLevel(minPoint, maxPoint) {
      var minExpectedPadding = _abs(canvasStartEnd.start - minPoint);

      var maxExpectedPadding = _abs(canvasStartEnd.end - maxPoint);

      var coeff = that._getConvertIntervalCoefficient(minExpectedPadding + maxExpectedPadding, screenDelta);

      start = minExpectedPadding / coeff;
      end = maxExpectedPadding / coeff;
    };

    if (!that.isArgumentAxis && options.dataType !== 'datetime') {
      if (minValue * dataRange.min <= 0 && minValue * dataRange.minVisible <= 0) {
        correctZeroLevel(translator.translate(0), translator.translate(maxValue));
        correctedMin = 0;
      }

      if (maxValue * dataRange.max <= 0 && maxValue * dataRange.maxVisible <= 0) {
        correctZeroLevel(translator.translate(minValue), translator.translate(0));
        correctedMax = 0;
      }
    }

    return {
      start: isFinite(start) ? start : null,
      end: isFinite(end) ? end : null,
      correctedMin: correctedMin,
      correctedMax: correctedMax
    };
  },
  applyMargins: function applyMargins() {
    if (this._isSynchronized) {
      return;
    }

    var margins = this._calculateValueMargins(this._majorTicks);

    var canvas = (0, _extend.extend)({}, this._canvas, {
      startPadding: margins.startPadding,
      endPadding: margins.endPadding
    });

    this._translator.updateCanvas(this._processCanvas(canvas));

    if (isFinite(margins.interval)) {
      var br = this._translator.getBusinessRange();

      br.addRange({
        interval: margins.interval
      });

      this._translator.updateBusinessRange(br);
    }
  },
  _resetMargins: function _resetMargins() {
    this._reinitTranslator(this._getViewportRange());

    if (this._canvas) {
      this._translator.updateCanvas(this._processCanvas(this._canvas));
    }
  },
  _createConstantLines: function _createConstantLines() {
    var _this2 = this;

    var constantLines = (this._options.constantLines || []).map(function (o) {
      return (0, _constant_line.default)(_this2, o);
    });
    this._outsideConstantLines = constantLines.filter(function (l) {
      return l.labelPosition === 'outside';
    });
    this._insideConstantLines = constantLines.filter(function (l) {
      return l.labelPosition === 'inside';
    });
  },
  draw: function draw(canvas, borderOptions) {
    var that = this;
    var options = this._options;
    that.borderOptions = borderOptions || {
      visible: false
    };

    that._resetMargins();

    that.createTicks(canvas);
    that.applyMargins();

    that._clearAxisGroups();

    initTickCoords(that._majorTicks);
    initTickCoords(that._minorTicks);
    initTickCoords(that._boundaryTicks);

    that._axisGroup.append(that._axesContainerGroup);

    that._drawAxis();

    that._drawTitle();

    drawTickMarks(that._majorTicks, options.tick);
    drawTickMarks(that._minorTicks, options.minorTick);
    drawTickMarks(that._boundaryTicks, options.tick);

    var drawGridLine = that._getGridLineDrawer();

    drawGrids(that._majorTicks, drawGridLine);
    drawGrids(that._minorTicks, drawGridLine);
    callAction(that._majorTicks, 'drawLabel', that._getViewportRange(), that._getTemplate(options.label.template));
    that._templatesRendered && that._templatesRendered.reject();
    that._templatesRendered = new _deferred.Deferred();

    _deferred.when.apply(this, that._majorTicks.map(function (tick) {
      return tick.getTemplateDeferred();
    })).done(function () {
      that._templatesRendered.resolve();
    });

    that._majorTicks.forEach(function (tick) {
      tick.labelRotationAngle = 0;
      tick.labelAlignment = undefined;
      tick.labelOffset = 0;
    });

    callAction(that._outsideConstantLines.concat(that._insideConstantLines), 'draw');
    callAction(that._strips, 'draw');
    that._dateMarkers = that._drawDateMarkers() || [];
    that._stripLabelAxesGroup && that._axisStripLabelGroup.append(that._stripLabelAxesGroup);
    that._gridContainerGroup && that._axisGridGroup.append(that._gridContainerGroup);
    that._stripsGroup && that._axisStripGroup.append(that._stripsGroup);
    that._labelsAxesGroup && that._axisElementsGroup.append(that._labelsAxesGroup);

    if (that._constantLinesGroup) {
      that._axisConstantLineGroups.above.inside.append(that._constantLinesGroup.above);

      that._axisConstantLineGroups.above.outside1.append(that._constantLinesGroup.above);

      that._axisConstantLineGroups.above.outside2.append(that._constantLinesGroup.above);

      that._axisConstantLineGroups.under.inside.append(that._constantLinesGroup.under);

      that._axisConstantLineGroups.under.outside1.append(that._constantLinesGroup.under);

      that._axisConstantLineGroups.under.outside2.append(that._constantLinesGroup.under);
    }

    that._measureTitle();

    (0, _axes_utils.measureLabels)(that._majorTicks);
    !options.label.template && that._applyWordWrap();
    (0, _axes_utils.measureLabels)(that._outsideConstantLines);
    (0, _axes_utils.measureLabels)(that._insideConstantLines);
    (0, _axes_utils.measureLabels)(that._strips);
    (0, _axes_utils.measureLabels)(that._dateMarkers);

    that._adjustConstantLineLabels(that._insideConstantLines);

    that._adjustStripLabels();

    var offset = that._constantLabelOffset = that._adjustConstantLineLabels(that._outsideConstantLines);

    if (!that._translator.getBusinessRange().isEmpty()) {
      that._setLabelsPlacement();

      offset = that._adjustLabels(offset);
    }

    offset = that._adjustDateMarkers(offset);

    that._adjustTitle(offset);
  },
  getTemplatesDef: function getTemplatesDef() {
    return this._templatesRendered;
  },
  setRenderedState: function setRenderedState(state) {
    this._drawn = state;
  },
  isRendered: function isRendered() {
    return this._drawn;
  },
  _applyWordWrap: function _applyWordWrap() {
    var that = this;
    var convertedTickInterval;
    var textWidth;
    var textHeight;
    var options = this._options;
    var tickInterval = that._tickInterval;

    if ((0, _type.isDefined)(tickInterval)) {
      convertedTickInterval = that.getTranslator().getInterval(options.dataType === 'datetime' ? _date.default.dateToMilliseconds(tickInterval) : tickInterval);
    }

    var displayMode = that._validateDisplayMode(options.label.displayMode);

    var overlappingMode = that._validateOverlappingMode(options.label.overlappingBehavior, displayMode);

    var wordWrapMode = options.label.wordWrap || 'none';
    var overflowMode = options.label.textOverflow || 'none';

    if ((wordWrapMode !== 'none' || overflowMode !== 'none') && displayMode !== ROTATE && overlappingMode !== ROTATE && overlappingMode !== 'auto') {
      var usefulSpace = (0, _type.isDefined)(options.placeholderSize) ? options.placeholderSize - options.label.indentFromAxis : undefined;

      if (that._isHorizontal) {
        textWidth = convertedTickInterval;
        textHeight = usefulSpace;
      } else {
        textWidth = usefulSpace;
        textHeight = convertedTickInterval;
      }

      var correctByWidth = false;
      var correctByHeight = false;

      if (textWidth) {
        if (that._majorTicks.some(function (tick) {
          return tick.labelBBox.width > textWidth;
        })) {
          correctByWidth = true;
        }
      }

      if (textHeight) {
        if (that._majorTicks.some(function (tick) {
          return tick.labelBBox.height > textHeight;
        })) {
          correctByHeight = true;
        }
      }

      if (correctByWidth || correctByHeight) {
        that._majorTicks.forEach(function (tick) {
          tick.label && tick.label.setMaxSize(textWidth, textHeight, options.label);
        });

        (0, _axes_utils.measureLabels)(that._majorTicks);
      }
    }
  },
  _measureTitle: _common.noop,
  animate: function animate() {
    callAction(this._majorTicks, 'animateLabels');
  },
  updateSize: function updateSize(canvas, animate) {
    var updateTitle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var that = this;
    that.updateCanvas(canvas);

    if (updateTitle) {
      that._checkTitleOverflow();

      that._measureTitle();

      that._updateTitleCoords();
    }

    that._reinitTranslator(that._getViewportRange());

    that.applyMargins();
    var animationEnabled = !that._firstDrawing && animate;
    var options = that._options;
    initTickCoords(that._majorTicks);
    initTickCoords(that._minorTicks);
    initTickCoords(that._boundaryTicks);

    if (that._resetApplyingAnimation && !that._firstDrawing) {
      that._resetStartCoordinates();
    }

    cleanUpInvalidTicks(that._majorTicks);
    cleanUpInvalidTicks(that._minorTicks);
    cleanUpInvalidTicks(that._boundaryTicks);

    if (that._axisElement) {
      that._updateAxisElementPosition();
    }

    updateTicksPosition(that._majorTicks, options.tick, animationEnabled);
    updateTicksPosition(that._minorTicks, options.minorTick, animationEnabled);
    updateTicksPosition(that._boundaryTicks, options.tick);
    callAction(that._majorTicks, 'updateLabelPosition', animationEnabled);

    that._outsideConstantLines.concat(that._insideConstantLines || []).forEach(function (l) {
      return l.updatePosition(animationEnabled);
    });

    callAction(that._strips, 'updatePosition', animationEnabled);
    updateGridsPosition(that._majorTicks, animationEnabled);
    updateGridsPosition(that._minorTicks, animationEnabled);

    if (animationEnabled) {
      callAction(that._ticksToRemove || [], 'fadeOutElements');
    }

    that.prepareAnimation();
    that._ticksToRemove = null;

    if (!that._translator.getBusinessRange().isEmpty()) {
      that._firstDrawing = false;
    }

    that._resetApplyingAnimation = false;

    that._updateLabelsPosition();
  },
  _updateLabelsPosition: _common.noop,
  prepareAnimation: function prepareAnimation() {
    var that = this;
    var action = 'saveCoords';
    callAction(that._majorTicks, action);
    callAction(that._minorTicks, action);
    callAction(that._insideConstantLines, action);
    callAction(that._outsideConstantLines, action);
    callAction(that._strips, action);
  },
  _resetStartCoordinates: function _resetStartCoordinates() {
    var that = this;
    var action = 'resetCoordinates';
    callAction(that._majorTicks, action);
    callAction(that._minorTicks, action);
    callAction(that._insideConstantLines, action);
    callAction(that._outsideConstantLines, action);
    callAction(that._strips, action);
  },
  applyClipRects: function applyClipRects(elementsClipID, canvasClipID) {
    this._axisGroup.attr({
      'clip-path': canvasClipID
    });

    this._axisStripGroup.attr({
      'clip-path': elementsClipID
    });

    this._axisElementsGroup.attr({
      'clip-path': canvasClipID
    });
  },
  _validateVisualRange: function _validateVisualRange(optionValue) {
    var range = (0, _utils.getVizRangeObject)(optionValue);

    if (range.startValue !== undefined) {
      range.startValue = this.validateUnit(range.startValue);
    }

    if (range.endValue !== undefined) {
      range.endValue = this.validateUnit(range.endValue);
    }

    return (0, _utils.convertVisualRangeObject)(range, !_isArray(optionValue));
  },
  _validateOptions: function _validateOptions(options) {
    var that = this;
    options.wholeRange = that._validateVisualRange(options.wholeRange);
    options.visualRange = options._customVisualRange = that._validateVisualRange(options._customVisualRange);

    that._setVisualRange(options._customVisualRange);
  },
  validate: function validate() {
    var that = this;
    var options = that._options;
    var dataType = that.isArgumentAxis ? options.argumentType : options.valueType;
    var parser = dataType ? (0, _parse_utils.getParser)(dataType) : function (unit) {
      return unit;
    };
    that.parser = parser;
    options.dataType = dataType;

    that._validateOptions(options);
  },
  resetVisualRange: function resetVisualRange(isSilent) {
    this._seriesData.minVisible = this._seriesData.min;
    this._seriesData.maxVisible = this._seriesData.max;
    this.handleZooming([null, null], {
      start: !!isSilent,
      end: !!isSilent
    });
  },
  _setVisualRange: function _setVisualRange(visualRange, allowPartialUpdate) {
    var range = this.adjustRange((0, _utils.getVizRangeObject)(visualRange));

    if (allowPartialUpdate) {
      (0, _type.isDefined)(range.startValue) && (this._viewport.startValue = range.startValue);
      (0, _type.isDefined)(range.endValue) && (this._viewport.endValue = range.endValue);
    } else {
      this._viewport = range;
    }
  },
  _applyZooming: function _applyZooming(visualRange, allowPartialUpdate) {
    var that = this;

    that._resetVisualRangeOption();

    that._setVisualRange(visualRange, allowPartialUpdate);

    var viewPort = that.getViewport();
    that._seriesData.userBreaks = that._getScaleBreaks(that._options, {
      minVisible: viewPort.startValue,
      maxVisible: viewPort.endValue
    }, that._series, that.isArgumentAxis);

    that._translator.updateBusinessRange(that._getViewportRange());
  },
  getZoomStartEventArg: function getZoomStartEventArg(event, actionType) {
    return {
      axis: this,
      range: this.visualRange(),
      cancel: false,
      event: event,
      actionType: actionType
    };
  },
  _getZoomEndEventArg: function _getZoomEndEventArg(previousRange, event, actionType, zoomFactor, shift) {
    var newRange = this.visualRange();
    return {
      axis: this,
      previousRange: previousRange,
      range: newRange,
      cancel: false,
      event: event,
      actionType: actionType,
      zoomFactor: zoomFactor,
      shift: shift,
      // backwards
      rangeStart: newRange.startValue,
      rangeEnd: newRange.endValue
    };
  },
  getZoomBounds: function getZoomBounds() {
    var wholeRange = (0, _utils.getVizRangeObject)(this._options.wholeRange);
    var range = this.getTranslator().getBusinessRange();
    var secondPriorityRange = {
      startValue: getZoomBoundValue(this._initRange.startValue, range.min),
      endValue: getZoomBoundValue(this._initRange.endValue, range.max)
    };
    return {
      startValue: getZoomBoundValue(wholeRange.startValue, secondPriorityRange.startValue),
      endValue: getZoomBoundValue(wholeRange.endValue, secondPriorityRange.endValue)
    };
  },
  setInitRange: function setInitRange() {
    this._initRange = {};

    if (Object.keys(this._options.wholeRange || {}).length === 0) {
      this._initRange = this.getZoomBounds();
    }
  },
  _resetVisualRangeOption: function _resetVisualRangeOption() {
    this._options._customVisualRange = {};
  },
  getTemplatesGroups: function getTemplatesGroups() {
    var ticks = this._majorTicks;

    if (ticks) {
      return this._majorTicks.map(function (tick) {
        return tick.templateContainer;
      }).filter(function (item) {
        return (0, _type.isDefined)(item);
      });
    } else {
      return [];
    }
  },
  setCustomVisualRange: function setCustomVisualRange(range) {
    this._options._customVisualRange = range;
  },
  // API
  visualRange: function visualRange() {
    var that = this;
    var args = arguments;
    var visualRange;

    if (args.length === 0) {
      var adjustedRange = that._getAdjustedBusinessRange();

      var startValue = adjustedRange.minVisible;
      var endValue = adjustedRange.maxVisible;

      if (that._options.type === _axes_constants.default.discrete) {
        var _startValue, _endValue;

        startValue = (_startValue = startValue) !== null && _startValue !== void 0 ? _startValue : adjustedRange.categories[0];
        endValue = (_endValue = endValue) !== null && _endValue !== void 0 ? _endValue : adjustedRange.categories[adjustedRange.categories.length - 1];
        return {
          startValue: startValue,
          endValue: endValue,
          categories: (0, _utils.getCategoriesInfo)(adjustedRange.categories, startValue, endValue).categories
        };
      }

      return {
        startValue: startValue,
        endValue: endValue
      };
    } else if (_isArray(args[0])) {
      visualRange = args[0];
    } else if ((0, _type.isPlainObject)(args[0])) {
      visualRange = (0, _extend.extend)({}, args[0]);
    } else {
      visualRange = [args[0], args[1]];
    }

    var zoomResults = that.handleZooming(visualRange, args[1]);

    if (!zoomResults.isPrevented) {
      that._visualRange(that, zoomResults);
    }
  },
  handleZooming: function handleZooming(visualRange, preventEvents, domEvent, action) {
    var that = this;
    preventEvents = preventEvents || {};

    if ((0, _type.isDefined)(visualRange)) {
      visualRange = that._validateVisualRange(visualRange);
      visualRange.action = action;
    }

    var zoomStartEvent = that.getZoomStartEventArg(domEvent, action);
    var previousRange = zoomStartEvent.range;
    !preventEvents.start && that._eventTrigger('zoomStart', zoomStartEvent);
    var zoomResults = {
      isPrevented: zoomStartEvent.cancel,
      skipEventRising: preventEvents.skipEventRising,
      range: visualRange || zoomStartEvent.range
    };

    if (!zoomStartEvent.cancel) {
      (0, _type.isDefined)(visualRange) && that._applyZooming(visualRange, preventEvents.allowPartialUpdate);

      if (!(0, _type.isDefined)(that._storedZoomEndParams)) {
        that._storedZoomEndParams = {
          startRange: previousRange,
          type: this.getOptions().type
        };
      }

      that._storedZoomEndParams.event = domEvent;
      that._storedZoomEndParams.action = action;
      that._storedZoomEndParams.prevent = !!preventEvents.end;
    }

    return zoomResults;
  },
  handleZoomEnd: function handleZoomEnd() {
    var that = this;

    if ((0, _type.isDefined)(that._storedZoomEndParams) && !that._storedZoomEndParams.prevent) {
      var previousRange = that._storedZoomEndParams.startRange;
      var domEvent = that._storedZoomEndParams.event;
      var action = that._storedZoomEndParams.action;
      var previousBusinessRange = {
        minVisible: previousRange.startValue,
        maxVisible: previousRange.endValue,
        categories: previousRange.categories
      };

      var typeIsNotChanged = that.getOptions().type === that._storedZoomEndParams.type;

      var shift = typeIsNotChanged ? (0, _math2.adjust)(that.getVisualRangeCenter() - that.getVisualRangeCenter(previousBusinessRange, false)) : NaN;
      var zoomFactor = typeIsNotChanged ? +(Math.round(that.getVisualRangeLength(previousBusinessRange) / (that.getVisualRangeLength() || 1) + 'e+2') + 'e-2') : NaN;

      var zoomEndEvent = that._getZoomEndEventArg(previousRange, domEvent, action, zoomFactor, shift);

      zoomEndEvent.cancel = that.checkZoomingLowerLimitOvercome(zoomFactor === 1 ? 'pan' : 'zoom', zoomFactor).stopInteraction;

      that._eventTrigger('zoomEnd', zoomEndEvent);

      if (zoomEndEvent.cancel) {
        that._restorePreviousVisualRange(previousRange);
      }

      that._storedZoomEndParams = null;
    }
  },
  _restorePreviousVisualRange: function _restorePreviousVisualRange(previousRange) {
    var that = this;
    that._storedZoomEndParams = null;

    that._applyZooming(previousRange);

    that._visualRange(that, previousRange);
  },
  checkZoomingLowerLimitOvercome: function checkZoomingLowerLimitOvercome(actionType, zoomFactor, range) {
    var that = this;
    var options = that._options;
    var translator = that._translator;
    var minZoom = options.minVisualRangeLength;
    var correctedRange = range;
    var visualRange;
    var isOvercoming = actionType === 'zoom' && zoomFactor >= 1;
    var businessRange = translator.getBusinessRange();

    if (range) {
      visualRange = that.adjustRange((0, _utils.getVizRangeObject)(range));
      visualRange = {
        minVisible: visualRange.startValue,
        maxVisible: visualRange.endValue,
        categories: businessRange.categories
      };
    }

    var beforeVisualRangeLength = that.getVisualRangeLength(businessRange);
    var afterVisualRangeLength = that.getVisualRangeLength(visualRange);

    if ((0, _type.isDefined)(minZoom) || options.type === 'discrete') {
      minZoom = translator.convert(minZoom);

      if (visualRange && minZoom < beforeVisualRangeLength && minZoom >= afterVisualRangeLength) {
        correctedRange = (0, _utils.getVizRangeObject)(translator.getRangeByMinZoomValue(minZoom, visualRange));
        isOvercoming = false;
      } else {
        isOvercoming &= minZoom > afterVisualRangeLength;
      }
    } else {
      var canvasLength = that._translator.canvasLength;
      var fullRange = {
        minVisible: businessRange.min,
        maxVisible: businessRange.max,
        categories: businessRange.categories
      };
      isOvercoming &= that.getVisualRangeLength(fullRange) / canvasLength >= afterVisualRangeLength;
    }

    return {
      stopInteraction: !!isOvercoming,
      correctedRange: correctedRange
    };
  },
  isExtremePosition: function isExtremePosition(isMax) {
    var extremeDataValue;
    var seriesData;

    if (this._options.type === 'discrete') {
      seriesData = this._translator.getBusinessRange();
      extremeDataValue = isMax ? seriesData.categories[seriesData.categories.length - 1] : seriesData.categories[0];
    } else {
      seriesData = this.getZoomBounds(); // T702708

      extremeDataValue = isMax ? seriesData.endValue : seriesData.startValue;
    }

    var translator = this.getTranslator();
    var extremePoint = translator.translate(extremeDataValue);
    var visualRange = this.visualRange();
    var visualRangePoint = isMax ? translator.translate(visualRange.endValue) : translator.translate(visualRange.startValue);
    return _abs(visualRangePoint - extremePoint) < SCROLL_THRESHOLD;
  },
  getViewport: function getViewport() {
    return this._viewport;
  },
  getFullTicks: function getFullTicks() {
    var majors = this._majorTicks || [];

    if (this._options.type === _axes_constants.default.discrete) {
      return convertTicksToValues(majors);
    } else {
      return convertTicksToValues(majors.concat(this._minorTicks, this._boundaryTicks)).sort(function (a, b) {
        return (0, _utils.valueOf)(a) - (0, _utils.valueOf)(b);
      });
    }
  },
  measureLabels: function measureLabels(canvas, withIndents) {
    var that = this;
    var options = that._options;
    var widthAxis = options.visible ? options.width : 0;
    var ticks;
    var indent = withIndents ? options.label.indentFromAxis + options.tick.length * 0.5 : 0;
    var tickInterval;

    var viewportRange = that._getViewportRange();

    if (viewportRange.isEmpty() || !options.label.visible || !that._axisElementsGroup) {
      return {
        height: widthAxis,
        width: widthAxis,
        x: 0,
        y: 0
      };
    }

    if (that._majorTicks) {
      ticks = convertTicksToValues(that._majorTicks);
    } else {
      that.updateCanvas(canvas);
      ticks = that._createTicksAndLabelFormat(viewportRange, _common.noop);
      tickInterval = ticks.tickInterval;
      ticks = ticks.ticks;
    }

    var maxText = ticks.reduce(function (prevLabel, tick, index) {
      var label = that.formatLabel(tick, options.label, viewportRange, undefined, tickInterval, ticks);

      if (prevLabel.length < label.length) {
        return label;
      } else {
        return prevLabel;
      }
    }, that.formatLabel(ticks[0], options.label, viewportRange, undefined, tickInterval, ticks));

    var text = that._renderer.text(maxText, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(that._renderer.root);

    var box = text.getBBox();
    text.remove();
    return {
      x: box.x,
      y: box.y,
      width: box.width + indent,
      height: box.height + indent
    };
  },
  _setLabelsPlacement: function _setLabelsPlacement() {
    if (!this._options.label.visible) {
      return;
    }

    var that = this;
    var labelOpt = that._options.label;

    var displayMode = that._validateDisplayMode(labelOpt.displayMode);

    var overlappingMode = that._validateOverlappingMode(labelOpt.overlappingBehavior, displayMode);

    var ignoreOverlapping = overlappingMode === 'none' || overlappingMode === 'ignore';
    var behavior = {
      rotationAngle: labelOpt.rotationAngle,
      staggeringSpacing: labelOpt.staggeringSpacing
    };
    var notRecastStep;

    var boxes = that._majorTicks.map(function (tick) {
      return tick.labelBBox;
    });

    var step = that._getStep(boxes);

    switch (displayMode) {
      case ROTATE:
        if (ignoreOverlapping) {
          notRecastStep = true;
          step = 1;
        }

        that._applyLabelMode(displayMode, step, boxes, labelOpt, notRecastStep);

        break;

      case 'stagger':
        if (ignoreOverlapping) {
          step = 2;
        }

        that._applyLabelMode(displayMode, _max(step, 2), boxes, labelOpt);

        break;

      default:
        that._applyLabelOverlapping(boxes, overlappingMode, step, behavior);

    }
  },
  _applyLabelOverlapping: function _applyLabelOverlapping(boxes, mode, step, behavior) {
    var that = this;
    var labelOpt = that._options.label;
    var majorTicks = that._majorTicks;

    if (mode === 'none' || mode === 'ignore') {
      return;
    }

    var checkLabels = function checkLabels(box, index, array) {
      if (index === 0) {
        return false;
      }

      return _axes_constants.default.areLabelsOverlap(box, array[index - 1], labelOpt.minSpacing, labelOpt.alignment);
    };

    if (step > 1 && boxes.some(checkLabels)) {
      that._applyLabelMode(mode, step, boxes, behavior);
    }

    that._checkBoundedLabelsOverlapping(majorTicks, boxes, mode);

    that._checkShiftedLabels(majorTicks, boxes, labelOpt.minSpacing, labelOpt.alignment);
  },
  _applyLabelMode: function _applyLabelMode(mode, step, boxes, behavior, notRecastStep) {
    var that = this;
    var majorTicks = that._majorTicks;
    var labelOpt = that._options.label;
    var angle = behavior.rotationAngle;
    var labelHeight;
    var alignment;
    var func;

    switch (mode) {
      case ROTATE:
        if (!labelOpt.userAlignment) {
          alignment = angle < 0 ? RIGHT : LEFT;

          if (angle % 90 === 0) {
            alignment = CENTER;
          }
        }

        step = notRecastStep ? step : that._getStep(boxes, angle);

        func = function func(tick) {
          var contentContainer = tick.getContentContainer();

          if (!contentContainer) {
            return;
          }

          contentContainer.rotate(angle);
          tick.labelRotationAngle = angle;
          alignment && (tick.labelAlignment = alignment);
        };

        updateLabels(majorTicks, step, func);
        break;

      case 'stagger':
        labelHeight = that._getMaxLabelHeight(boxes, behavior.staggeringSpacing);

        func = function func(tick, index) {
          if (index / (step - 1) % 2 !== 0) {
            tick.labelOffset = labelHeight;
          }
        };

        updateLabels(majorTicks, step - 1, func);
        break;

      case 'auto':
      case '_auto':
        if (step === 2) {
          that._applyLabelMode('stagger', step, boxes, behavior);
        } else {
          that._applyLabelMode(ROTATE, step, boxes, {
            rotationAngle: getOptimalAngle(boxes, labelOpt)
          });
        }

        break;

      default:
        updateLabels(majorTicks, step);
        break;
    }
  },
  getMarkerTrackers: _common.noop,
  _drawDateMarkers: _common.noop,
  _adjustDateMarkers: _common.noop,
  coordsIn: _common.noop,
  areCoordsOutsideAxis: _common.noop,
  _getSkippedCategory: _common.noop,
  _initAxisPositions: _common.noop,
  _drawTitle: _common.noop,
  _updateTitleCoords: _common.noop,
  _adjustConstantLineLabels: _common.noop,
  _createTranslator: function _createTranslator() {
    return new _translator2d.Translator2D({}, {}, {});
  },
  _updateTranslator: function _updateTranslator() {
    var translator = this._translator;
    translator.update(translator.getBusinessRange(), this._canvas || {}, this._getTranslatorOptions());
  },
  _getTranslatorOptions: function _getTranslatorOptions() {
    var _options$workWeek2, _options$breakStyle$w, _options$breakStyle;

    var options = this._options;
    return {
      isHorizontal: this._isHorizontal,
      shiftZeroValue: !this.isArgumentAxis,
      interval: options.semiDiscreteInterval,
      firstDayOfWeek: (_options$workWeek2 = options.workWeek) === null || _options$workWeek2 === void 0 ? void 0 : _options$workWeek2[0],
      stick: this._getStick(),
      breaksSize: (_options$breakStyle$w = (_options$breakStyle = options.breakStyle) === null || _options$breakStyle === void 0 ? void 0 : _options$breakStyle.width) !== null && _options$breakStyle$w !== void 0 ? _options$breakStyle$w : 0
    };
  },
  getVisibleArea: function getVisibleArea() {
    var canvas = this._getCanvasStartEnd();

    return [canvas.start, canvas.end].sort(function (a, b) {
      return a - b;
    });
  },
  _getCanvasStartEnd: function _getCanvasStartEnd() {
    var isHorizontal = this._isHorizontal;
    var canvas = this._canvas || {};

    var invert = this._translator.getBusinessRange().invert;

    var coords = isHorizontal ? [canvas.left, canvas.width - canvas.right] : [canvas.height - canvas.bottom, canvas.top];
    invert && coords.reverse();
    return {
      start: coords[0],
      end: coords[1]
    };
  },
  _getScreenDelta: function _getScreenDelta() {
    var that = this;

    var canvas = that._getCanvasStartEnd();

    var breaks = that._seriesData ? that._seriesData.breaks || [] : [];
    var breaksLength = breaks.length;

    var screenDelta = _abs(canvas.start - canvas.end);

    return screenDelta - (breaksLength ? breaks[breaksLength - 1].cumulativeWidth : 0);
  },
  _getScaleBreaks: function _getScaleBreaks() {
    return [];
  },
  _filterBreaks: function _filterBreaks() {
    return [];
  },
  _adjustTitle: _common.noop,
  _checkTitleOverflow: _common.noop,
  getSpiderTicks: _common.noop,
  setSpiderTicks: _common.noop,
  _checkBoundedLabelsOverlapping: _common.noop,
  _checkShiftedLabels: _common.noop,
  drawScaleBreaks: _common.noop,
  _visualRange: _common.noop,
  _rotateConstantLine: _common.noop,
  applyVisualRangeSetter: function applyVisualRangeSetter(visualRangeSetter) {
    this._visualRange = visualRangeSetter;
  },
  // T642779, T714928, T810801
  getCategoriesSorter: function getCategoriesSorter(argCategories) {
    var sort;

    if (this.isArgumentAxis) {
      sort = argCategories;
    } else {
      var categoriesSortingMethod = this._options.categoriesSortingMethod;
      sort = categoriesSortingMethod !== null && categoriesSortingMethod !== void 0 ? categoriesSortingMethod : this._options.categories;
    }

    return sort;
  },
  _getAdjustedBusinessRange: function _getAdjustedBusinessRange() {
    return this.adjustViewport(this._translator.getBusinessRange());
  }
};

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Translator2D = void 0;

var _extend = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _range = __webpack_require__(141);

var _category_translator = _interopRequireDefault(__webpack_require__(1056));

var _interval_translator = _interopRequireDefault(__webpack_require__(1057));

var _datetime_translator = _interopRequireDefault(__webpack_require__(1058));

var _logarithmic_translator = _interopRequireDefault(__webpack_require__(1059));

var _utils = __webpack_require__(14);

var _type = __webpack_require__(1);

var _math = __webpack_require__(31);

var _date = _interopRequireDefault(__webpack_require__(18));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _abs = Math.abs;
var CANVAS_PROP = ['width', 'height', 'left', 'top', 'bottom', 'right'];
var dummyTranslator = {
  to: function to(value) {
    var coord = this._canvasOptions.startPoint + (this._options.conversionValue ? value : Math.round(value));
    return coord > this._canvasOptions.endPoint ? this._canvasOptions.endPoint : coord;
  },
  from: function from(value) {
    return value - this._canvasOptions.startPoint;
  }
};

var validateCanvas = function validateCanvas(canvas) {
  (0, _iterator.each)(CANVAS_PROP, function (_, prop) {
    canvas[prop] = parseInt(canvas[prop]) || 0;
  });
  return canvas;
};

var makeCategoriesToPoints = function makeCategoriesToPoints(categories) {
  var categoriesToPoints = {};
  categories.forEach(function (item, i) {
    categoriesToPoints[item.valueOf()] = i;
  });
  return categoriesToPoints;
};

var validateBusinessRange = function validateBusinessRange(businessRange) {
  if (!(businessRange instanceof _range.Range)) {
    businessRange = new _range.Range(businessRange);
  }

  function validate(valueSelector, baseValueSelector) {
    if (!(0, _type.isDefined)(businessRange[valueSelector]) && (0, _type.isDefined)(businessRange[baseValueSelector])) {
      businessRange[valueSelector] = businessRange[baseValueSelector];
    }
  }

  validate('minVisible', 'min');
  validate('maxVisible', 'max');
  return businessRange;
};

function prepareBreaks(breaks, range) {
  var transform = range.axisType === 'logarithmic' ? function (value) {
    return (0, _utils.getLogExt)(value, range.base);
  } : function (value) {
    return value;
  };
  var array = [];
  var br;
  var transformFrom;
  var transformTo;
  var i;
  var length = breaks.length;
  var sum = 0;

  for (i = 0; i < length; i++) {
    br = breaks[i];
    transformFrom = transform(br.from);
    transformTo = transform(br.to);
    sum += transformTo - transformFrom;
    array.push({
      trFrom: transformFrom,
      trTo: transformTo,
      from: br.from,
      to: br.to,
      length: sum,
      cumulativeWidth: br.cumulativeWidth
    });
  }

  return array;
}

function getCanvasBounds(range) {
  var min = range.min;
  var max = range.max;
  var minVisible = range.minVisible;
  var maxVisible = range.maxVisible;
  var isLogarithmic = range.axisType === 'logarithmic';

  if (isLogarithmic) {
    maxVisible = (0, _utils.getLogExt)(maxVisible, range.base, range.allowNegatives, range.linearThreshold);
    minVisible = (0, _utils.getLogExt)(minVisible, range.base, range.allowNegatives, range.linearThreshold);
    min = (0, _utils.getLogExt)(min, range.base, range.allowNegatives, range.linearThreshold);
    max = (0, _utils.getLogExt)(max, range.base, range.allowNegatives, range.linearThreshold);
  }

  return {
    base: range.base,
    rangeMin: min,
    rangeMax: max,
    rangeMinVisible: minVisible,
    rangeMaxVisible: maxVisible
  };
}

function getCheckingMethodsAboutBreaks(inverted) {
  return {
    isStartSide: !inverted ? function (pos, breaks, start, end) {
      return pos < breaks[0][start];
    } : function (pos, breaks, start, end) {
      return pos <= breaks[breaks.length - 1][end];
    },
    isEndSide: !inverted ? function (pos, breaks, start, end) {
      return pos >= breaks[breaks.length - 1][end];
    } : function (pos, breaks, start, end) {
      return pos > breaks[0][start];
    },
    isInBreak: !inverted ? function (pos, br, start, end) {
      return pos >= br[start] && pos < br[end];
    } : function (pos, br, start, end) {
      return pos > br[end] && pos <= br[start];
    },
    isBetweenBreaks: !inverted ? function (pos, br, prevBreak, start, end) {
      return pos < br[start] && pos >= prevBreak[end];
    } : function (pos, br, prevBreak, start, end) {
      return pos >= br[end] && pos < prevBreak[start];
    },
    getLength: !inverted ? function (br) {
      return br.length;
    } : function (br, lastBreak) {
      return lastBreak.length - br.length;
    },
    getBreaksSize: !inverted ? function (br) {
      return br.cumulativeWidth;
    } : function (br, lastBreak) {
      return lastBreak.cumulativeWidth - br.cumulativeWidth;
    }
  };
}

var _Translator2d = function _Translator2d(businessRange, canvas, options) {
  this.update(businessRange, canvas, options);
};

exports.Translator2D = _Translator2d;
_Translator2d.prototype = {
  constructor: _Translator2d,
  reinit: function reinit() {
    // TODO: parseInt canvas
    var that = this;
    var options = that._options;
    var range = that._businessRange;
    var categories = range.categories || [];
    var script = {};

    var canvasOptions = that._prepareCanvasOptions();

    var visibleCategories = (0, _utils.getCategoriesInfo)(categories, range.minVisible, range.maxVisible).categories;
    var categoriesLength = visibleCategories.length;

    if (range.isEmpty()) {
      script = dummyTranslator;
    } else {
      switch (range.axisType) {
        case 'logarithmic':
          script = _logarithmic_translator.default;
          break;

        case 'semidiscrete':
          script = _interval_translator.default;
          canvasOptions.ratioOfCanvasRange = canvasOptions.canvasLength / (_date.default.addInterval(canvasOptions.rangeMaxVisible, options.interval) - canvasOptions.rangeMinVisible);
          break;

        case 'discrete':
          script = _category_translator.default;
          that._categories = categories;
          canvasOptions.interval = that._getDiscreteInterval(options.addSpiderCategory ? categoriesLength + 1 : categoriesLength, canvasOptions);
          that._categoriesToPoints = makeCategoriesToPoints(categories);

          if (categoriesLength) {
            canvasOptions.startPointIndex = that._categoriesToPoints[visibleCategories[0].valueOf()];
            that.visibleCategories = visibleCategories;
          }

          break;

        default:
          if (range.dataType === 'datetime') {
            script = _datetime_translator.default;
          }

      }
    }

    (that._oldMethods || []).forEach(function (methodName) {
      delete that[methodName];
    });
    that._oldMethods = Object.keys(script);
    (0, _extend.extend)(that, script);
    that._conversionValue = options.conversionValue ? function (value) {
      return value;
    } : function (value) {
      return Math.round(value);
    };
    that.sc = {};
    that._checkingMethodsAboutBreaks = [getCheckingMethodsAboutBreaks(false), getCheckingMethodsAboutBreaks(that.isInverted())];

    that._translateBreaks();

    that._calculateSpecialValues();
  },
  _translateBreaks: function _translateBreaks() {
    var breaks = this._breaks;
    var size = this._options.breaksSize;
    var i;
    var b;
    var end;
    var length;

    if (breaks === undefined) {
      return;
    }

    for (i = 0, length = breaks.length; i < length; i++) {
      b = breaks[i];
      end = this.translate(b.to);
      b.end = end;
      b.start = !b.gapSize ? !this.isInverted() ? end - size : end + size : end;
    }
  },
  _checkValueAboutBreaks: function _checkValueAboutBreaks(breaks, pos, start, end, methods) {
    var i;
    var length;
    var prop = {
      length: 0,
      breaksSize: undefined,
      inBreak: false
    };
    var br;
    var prevBreak;
    var lastBreak = breaks[breaks.length - 1];

    if (methods.isStartSide(pos, breaks, start, end)) {
      return prop;
    } else if (methods.isEndSide(pos, breaks, start, end)) {
      return {
        length: lastBreak.length,
        breaksSize: lastBreak.cumulativeWidth,
        inBreak: false
      };
    }

    for (i = 0, length = breaks.length; i < length; i++) {
      br = breaks[i];
      prevBreak = breaks[i - 1];

      if (methods.isInBreak(pos, br, start, end)) {
        prop.inBreak = true;
        prop.break = br;
        break;
      }

      if (prevBreak && methods.isBetweenBreaks(pos, br, prevBreak, start, end)) {
        prop = {
          length: methods.getLength(prevBreak, lastBreak),
          breaksSize: methods.getBreaksSize(prevBreak, lastBreak),
          inBreak: false
        };
        break;
      }
    }

    return prop;
  },
  isInverted: function isInverted() {
    return !(this._options.isHorizontal ^ this._businessRange.invert);
  },
  _getDiscreteInterval: function _getDiscreteInterval(categoriesLength, canvasOptions) {
    var correctedCategoriesCount = categoriesLength - (this._options.stick ? 1 : 0);
    return correctedCategoriesCount > 0 ? canvasOptions.canvasLength / correctedCategoriesCount : canvasOptions.canvasLength;
  },
  _prepareCanvasOptions: function _prepareCanvasOptions() {
    var that = this;
    var businessRange = that._businessRange;
    var canvasOptions = that._canvasOptions = getCanvasBounds(businessRange);
    var canvas = that._canvas;
    var breaks = that._breaks;
    var length;
    canvasOptions.startPadding = canvas.startPadding || 0;
    canvasOptions.endPadding = canvas.endPadding || 0;

    if (that._options.isHorizontal) {
      canvasOptions.startPoint = canvas.left + canvasOptions.startPadding;
      length = canvas.width;
      canvasOptions.endPoint = canvas.width - canvas.right - canvasOptions.endPadding;
      canvasOptions.invert = businessRange.invert;
    } else {
      canvasOptions.startPoint = canvas.top + canvasOptions.startPadding;
      length = canvas.height;
      canvasOptions.endPoint = canvas.height - canvas.bottom - canvasOptions.endPadding;
      canvasOptions.invert = !businessRange.invert; // axis inverted because display drawn to bottom
    }

    that.canvasLength = canvasOptions.canvasLength = canvasOptions.endPoint - canvasOptions.startPoint;
    canvasOptions.rangeDoubleError = Math.pow(10, (0, _utils.getPower)(canvasOptions.rangeMax - canvasOptions.rangeMin) - (0, _utils.getPower)(length) - 2); // B253861

    canvasOptions.ratioOfCanvasRange = canvasOptions.canvasLength / (canvasOptions.rangeMaxVisible - canvasOptions.rangeMinVisible);

    if (breaks !== undefined) {
      canvasOptions.ratioOfCanvasRange = (canvasOptions.canvasLength - breaks[breaks.length - 1].cumulativeWidth) / (canvasOptions.rangeMaxVisible - canvasOptions.rangeMinVisible - breaks[breaks.length - 1].length);
    }

    return canvasOptions;
  },
  updateCanvas: function updateCanvas(canvas) {
    this._canvas = validateCanvas(canvas);
    this.reinit();
  },
  updateBusinessRange: function updateBusinessRange(businessRange) {
    var that = this;
    var breaks = businessRange.breaks || [];
    that._userBreaks = businessRange.userBreaks || [];
    that._businessRange = validateBusinessRange(businessRange);
    that._breaks = breaks.length ? prepareBreaks(breaks, that._businessRange) : undefined;
    that.reinit();
  },
  update: function update(businessRange, canvas, options) {
    var that = this;
    that._options = (0, _extend.extend)(that._options || {}, options);
    that._canvas = validateCanvas(canvas);
    that.updateBusinessRange(businessRange);
  },
  getBusinessRange: function getBusinessRange() {
    return this._businessRange;
  },
  getEventScale: function getEventScale(zoomEvent) {
    return zoomEvent.deltaScale || 1;
  },
  getCanvasVisibleArea: function getCanvasVisibleArea() {
    return {
      min: this._canvasOptions.startPoint,
      max: this._canvasOptions.endPoint
    };
  },
  _calculateSpecialValues: function _calculateSpecialValues() {
    var that = this;
    var canvasOptions = that._canvasOptions;
    var startPoint = canvasOptions.startPoint - canvasOptions.startPadding;
    var endPoint = canvasOptions.endPoint + canvasOptions.endPadding;
    var range = that._businessRange;
    var minVisible = range.minVisible;
    var maxVisible = range.maxVisible;
    var canvas_position_center_middle = startPoint + canvasOptions.canvasLength / 2;
    var canvas_position_default;

    if (minVisible < 0 && maxVisible > 0 && minVisible !== maxVisible) {
      canvas_position_default = that.translate(0, 1);
    }

    if (!(0, _type.isDefined)(canvas_position_default)) {
      var invert = range.invert ^ (minVisible < 0 && maxVisible <= 0);

      if (that._options.isHorizontal) {
        canvas_position_default = invert ? endPoint : startPoint;
      } else {
        canvas_position_default = invert ? startPoint : endPoint;
      }
    }

    that.sc = {
      'canvas_position_default': canvas_position_default,
      'canvas_position_left': startPoint,
      'canvas_position_top': startPoint,
      'canvas_position_center': canvas_position_center_middle,
      'canvas_position_middle': canvas_position_center_middle,
      'canvas_position_right': endPoint,
      'canvas_position_bottom': endPoint,
      'canvas_position_start': canvasOptions.invert ? endPoint : startPoint,
      'canvas_position_end': canvasOptions.invert ? startPoint : endPoint
    };
  },
  translateSpecialCase: function translateSpecialCase(value) {
    return this.sc[value];
  },
  _calculateProjection: function _calculateProjection(distance) {
    var canvasOptions = this._canvasOptions;
    return canvasOptions.invert ? canvasOptions.endPoint - distance : canvasOptions.startPoint + distance;
  },
  _calculateUnProjection: function _calculateUnProjection(distance) {
    var canvasOptions = this._canvasOptions;
    this._businessRange.dataType === 'datetime' && (distance = Math.round(distance));
    return canvasOptions.invert ? canvasOptions.rangeMaxVisible.valueOf() - distance : canvasOptions.rangeMinVisible.valueOf() + distance;
  },
  getMinBarSize: function getMinBarSize(minBarSize) {
    var visibleArea = this.getCanvasVisibleArea();
    var minValue = this.from(visibleArea.min + minBarSize);
    return _abs(this.from(visibleArea.min) - (!(0, _type.isDefined)(minValue) ? this.from(visibleArea.max) : minValue));
  },
  checkMinBarSize: function checkMinBarSize(value, minShownValue, stackValue) {
    return _abs(value) < minShownValue ? value >= 0 ? minShownValue : -minShownValue : value;
  },
  translate: function translate(bp, direction) {
    var specialValue = this.translateSpecialCase(bp);

    if ((0, _type.isDefined)(specialValue)) {
      return Math.round(specialValue);
    }

    if (isNaN(bp)) {
      return null;
    }

    return this.to(bp, direction);
  },
  getInterval: function getInterval(interval) {
    var _interval;

    var canvasOptions = this._canvasOptions;
    interval = (_interval = interval) !== null && _interval !== void 0 ? _interval : this._businessRange.interval;

    if (interval) {
      return Math.round(canvasOptions.ratioOfCanvasRange * interval);
    }

    return Math.round(canvasOptions.endPoint - canvasOptions.startPoint);
  },
  zoom: function zoom(translate, scale, wholeRange) {
    var canvasOptions = this._canvasOptions;

    if (canvasOptions.rangeMinVisible.valueOf() === canvasOptions.rangeMaxVisible.valueOf() && translate !== 0) {
      return this.zoomZeroLengthRange(translate, scale);
    }

    var startPoint = canvasOptions.startPoint;
    var endPoint = canvasOptions.endPoint;
    var isInverted = this.isInverted();
    var newStart = (startPoint + translate) / scale;
    var newEnd = (endPoint + translate) / scale;
    wholeRange = wholeRange || {};
    var minPoint = this.to(isInverted ? wholeRange.endValue : wholeRange.startValue);
    var maxPoint = this.to(isInverted ? wholeRange.startValue : wholeRange.endValue);
    var min;
    var max;

    if (minPoint > newStart) {
      newEnd -= newStart - minPoint;
      newStart = minPoint;
      min = isInverted ? wholeRange.endValue : wholeRange.startValue;
    }

    if (maxPoint < newEnd) {
      newStart -= newEnd - maxPoint;
      newEnd = maxPoint;
      max = isInverted ? wholeRange.startValue : wholeRange.endValue;
    }

    if (maxPoint - minPoint < newEnd - newStart) {
      newStart = minPoint;
      newEnd = maxPoint;
    }

    translate = (endPoint - startPoint) * newStart / (newEnd - newStart) - startPoint;
    scale = (startPoint + translate) / newStart || 1;
    min = (0, _type.isDefined)(min) ? min : (0, _math.adjust)(this.from(newStart, 1));
    max = (0, _type.isDefined)(max) ? max : (0, _math.adjust)(this.from(newEnd, -1));

    if (scale <= 1) {
      min = this._correctValueAboutBreaks(min, scale === 1 ? translate : -1);
      max = this._correctValueAboutBreaks(max, scale === 1 ? translate : 1);
    }

    if (min > max) {
      min = min > wholeRange.endValue ? wholeRange.endValue : min;
      max = max < wholeRange.startValue ? wholeRange.startValue : max;
    } else {
      min = min < wholeRange.startValue ? wholeRange.startValue : min;
      max = max > wholeRange.endValue ? wholeRange.endValue : max;
    }

    return {
      min: min,
      max: max,
      translate: (0, _math.adjust)(translate),
      scale: (0, _math.adjust)(scale)
    };
  },
  _correctValueAboutBreaks: function _correctValueAboutBreaks(value, direction) {
    var br = this._userBreaks.filter(function (br) {
      return value >= br.from && value <= br.to;
    });

    if (br.length) {
      return direction > 0 ? br[0].to : br[0].from;
    } else {
      return value;
    }
  },
  zoomZeroLengthRange: function zoomZeroLengthRange(translate, scale) {
    var canvasOptions = this._canvasOptions;
    var min = canvasOptions.rangeMin;
    var max = canvasOptions.rangeMax;
    var correction = (max.valueOf() !== min.valueOf() ? max.valueOf() - min.valueOf() : _abs(canvasOptions.rangeMinVisible.valueOf() - min.valueOf())) / canvasOptions.canvasLength;
    var isDateTime = (0, _type.isDate)(max) || (0, _type.isDate)(min);
    var isLogarithmic = this._businessRange.axisType === 'logarithmic';
    var newMin = canvasOptions.rangeMinVisible.valueOf() - correction;
    var newMax = canvasOptions.rangeMaxVisible.valueOf() + correction;
    newMin = isLogarithmic ? (0, _math.adjust)((0, _utils.raiseToExt)(newMin, canvasOptions.base)) : isDateTime ? new Date(newMin) : newMin;
    newMax = isLogarithmic ? (0, _math.adjust)((0, _utils.raiseToExt)(newMax, canvasOptions.base)) : isDateTime ? new Date(newMax) : newMax;
    return {
      min: newMin,
      max: newMax,
      translate: translate,
      scale: scale
    };
  },
  getMinScale: function getMinScale(zoom) {
    var _this$_businessRange = this._businessRange,
        dataType = _this$_businessRange.dataType,
        interval = _this$_businessRange.interval;

    if (dataType === 'datetime' && interval === 1) {
      return this.getDateTimeMinScale(zoom);
    }

    return zoom ? 1.1 : 0.9;
  },
  getDateTimeMinScale: function getDateTimeMinScale(zoom) {
    var canvasOptions = this._canvasOptions;
    var length = canvasOptions.canvasLength / canvasOptions.ratioOfCanvasRange;
    length += (parseInt(length * 0.1) || 1) * (zoom ? -2 : 2);
    return canvasOptions.canvasLength / (Math.max(length, 1) * canvasOptions.ratioOfCanvasRange);
  },
  getScale: function getScale(val1, val2) {
    var canvasOptions = this._canvasOptions;

    if (canvasOptions.rangeMax === canvasOptions.rangeMin) {
      return 1;
    }

    val1 = (0, _type.isDefined)(val1) ? this.fromValue(val1) : canvasOptions.rangeMin;
    val2 = (0, _type.isDefined)(val2) ? this.fromValue(val2) : canvasOptions.rangeMax;
    return (canvasOptions.rangeMax - canvasOptions.rangeMin) / Math.abs(val1 - val2);
  },
  // dxRangeSelector
  isValid: function isValid(value) {
    var co = this._canvasOptions;
    value = this.fromValue(value);
    return value !== null && !isNaN(value) && value.valueOf() + co.rangeDoubleError >= co.rangeMin && value.valueOf() - co.rangeDoubleError <= co.rangeMax;
  },
  getCorrectValue: function getCorrectValue(value, direction) {
    var that = this;
    var breaks = that._breaks;
    var prop;
    value = that.fromValue(value);

    if (that._breaks) {
      prop = that._checkValueAboutBreaks(breaks, value, 'trFrom', 'trTo', that._checkingMethodsAboutBreaks[0]);

      if (prop.inBreak === true) {
        return that.toValue(direction > 0 ? prop.break.trTo : prop.break.trFrom);
      }
    }

    return that.toValue(value);
  },
  to: function to(bp, direction) {
    var range = this.getBusinessRange();

    if ((0, _type.isDefined)(range.maxVisible) && (0, _type.isDefined)(range.minVisible) && range.maxVisible.valueOf() === range.minVisible.valueOf()) {
      if (!(0, _type.isDefined)(bp) || range.maxVisible.valueOf() !== bp.valueOf()) {
        return null;
      }

      return this.translateSpecialCase(bp === 0 && this._options.shiftZeroValue ? 'canvas_position_default' : 'canvas_position_middle');
    }

    bp = this.fromValue(bp);
    var that = this;
    var canvasOptions = that._canvasOptions;
    var breaks = that._breaks;
    var prop = {
      length: 0
    };
    var commonBreakSize = 0;

    if (breaks !== undefined) {
      prop = that._checkValueAboutBreaks(breaks, bp, 'trFrom', 'trTo', that._checkingMethodsAboutBreaks[0]);
      commonBreakSize = (0, _type.isDefined)(prop.breaksSize) ? prop.breaksSize : 0;
    }

    if (prop.inBreak === true) {
      if (direction > 0) {
        return prop.break.start;
      } else if (direction < 0) {
        return prop.break.end;
      } else {
        return null;
      }
    }

    return that._conversionValue(that._calculateProjection((bp - canvasOptions.rangeMinVisible - prop.length) * canvasOptions.ratioOfCanvasRange + commonBreakSize));
  },
  from: function from(pos, direction) {
    var that = this;
    var breaks = that._breaks;
    var prop = {
      length: 0
    };
    var canvasOptions = that._canvasOptions;
    var startPoint = canvasOptions.startPoint;
    var commonBreakSize = 0;

    if (breaks !== undefined) {
      prop = that._checkValueAboutBreaks(breaks, pos, 'start', 'end', that._checkingMethodsAboutBreaks[1]);
      commonBreakSize = (0, _type.isDefined)(prop.breaksSize) ? prop.breaksSize : 0;
    }

    if (prop.inBreak === true) {
      if (direction > 0) {
        return that.toValue(prop.break.trTo);
      } else if (direction < 0) {
        return that.toValue(prop.break.trFrom);
      } else {
        return null;
      }
    }

    return that.toValue(that._calculateUnProjection((pos - startPoint - commonBreakSize) / canvasOptions.ratioOfCanvasRange + prop.length));
  },
  isValueProlonged: false,
  // dxRangeSelector specific
  // TODO: Rename to getValueRange
  getRange: function getRange() {
    return [this.toValue(this._canvasOptions.rangeMin), this.toValue(this._canvasOptions.rangeMax)];
  },
  getScreenRange: function getScreenRange() {
    return [this._canvasOptions.startPoint, this._canvasOptions.endPoint];
  },
  add: function add(value, diff, dir) {
    return this._add(value, diff, (this._businessRange.invert ? -1 : +1) * dir);
  },
  _add: function _add(value, diff, coeff) {
    return this.toValue(this.fromValue(value) + diff * coeff);
  },
  fromValue: function fromValue(value) {
    return value !== null ? Number(value) : null;
  },
  toValue: function toValue(value) {
    return value !== null ? Number(value) : null;
  },
  ratioOfCanvasRange: function ratioOfCanvasRange() {
    return this._canvasOptions.ratioOfCanvasRange;
  },
  convert: function convert(value) {
    return value;
  },
  getRangeByMinZoomValue: function getRangeByMinZoomValue(minZoom, visualRange) {
    if (visualRange.minVisible + minZoom <= this._businessRange.max) {
      return [visualRange.minVisible, visualRange.minVisible + minZoom];
    } else {
      return [visualRange.maxVisible - minZoom, visualRange.maxVisible];
    }
  }
};

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.BaseRangeBar = exports.BaseTextCloudMarker = exports.BaseIndicator = exports.BaseElement = void 0;

var _common = __webpack_require__(4);

var _iterator = __webpack_require__(3);

var _base_gauge = __webpack_require__(210);

var _utils = __webpack_require__(14);

var _extend = __webpack_require__(0);

var _class = _interopRequireDefault(__webpack_require__(15));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _isFinite = isFinite;
var _Number = Number;
var _round = Math.round;
var _formatValue = _base_gauge.formatValue;
var _getSampleText = _base_gauge.getSampleText;

var BaseElement = _class.default.inherit({
  ctor: function ctor(parameters) {
    var that = this;
    (0, _iterator.each)(parameters, function (name, value) {
      that['_' + name] = value;
    });

    that._init();
  },
  dispose: function dispose() {
    var that = this;

    that._dispose();

    (0, _iterator.each)(that, function (name) {
      that[name] = null;
    });
    return that;
  },
  getOffset: function getOffset() {
    return _Number(this._options.offset) || 0;
  }
});

exports.BaseElement = BaseElement;
var BaseIndicator = BaseElement.inherit({
  _init: function _init() {
    var that = this;
    that._rootElement = that._createRoot().linkOn(that._owner, {
      name: 'value-indicator',
      after: 'core'
    });
    that._trackerElement = that._createTracker();
  },
  _dispose: function _dispose() {
    this._rootElement.linkOff();
  },
  _setupAnimation: function _setupAnimation() {
    var that = this;

    if (that._options.animation) {
      that._animation = {
        step: function step(pos) {
          that._actualValue = that._animation.start + that._animation.delta * pos;
          that._actualPosition = that._translator.translate(that._actualValue);

          that._move();
        },
        duration: that._options.animation.duration > 0 ? _Number(that._options.animation.duration) : 0,
        easing: that._options.animation.easing
      };
    }
  },
  _runAnimation: function _runAnimation(value) {
    var that = this;
    var animation = that._animation;
    animation.start = that._actualValue;
    animation.delta = value - that._actualValue;

    that._rootElement.animate({
      _: 0
    }, {
      step: animation.step,
      duration: animation.duration,
      easing: animation.easing
    });
  },
  _createRoot: function _createRoot() {
    return this._renderer.g().attr({
      'class': this._className
    });
  },
  _createTracker: function _createTracker() {
    return this._renderer.path([], 'area');
  },
  _getTrackerSettings: _common.noop,
  clean: function clean() {
    var that = this;
    that._animation && that._rootElement.stopAnimation();

    that._rootElement.linkRemove().clear();

    that._clear();

    that._tracker.detach(that._trackerElement);

    that._options = that.enabled = that._animation = null;
    return that;
  },
  render: function render(options) {
    var that = this;
    that.type = options.type;
    that._options = options;
    that._actualValue = that._currentValue = that._translator.adjust(that._options.currentValue);
    that.enabled = that._isEnabled();

    if (that.enabled) {
      that._setupAnimation();

      that._rootElement.attr({
        fill: that._options.color
      }).linkAppend();

      that._tracker.attach(that._trackerElement, that, that._trackerInfo);
    }

    return that;
  },
  resize: function resize(layout) {
    var that = this;

    that._rootElement.clear();

    that._clear();

    that.visible = that._isVisible(layout);

    if (that.visible) {
      (0, _extend.extend)(that._options, layout);
      that._actualPosition = that._translator.translate(that._actualValue);

      that._render();

      that._trackerElement.attr(that._getTrackerSettings());

      that._move();
    }

    return that;
  },
  value: function value(arg, _noAnimation) {
    var that = this;
    var val;
    var rootElement = this._rootElement;
    var visibility = null;

    if (arg === undefined) {
      return that._currentValue;
    }

    if (arg === null) {
      visibility = 'hidden';
      that._currentValue = arg;
    } else {
      val = that._translator.adjust(arg);

      if (that._currentValue !== val && _isFinite(val)) {
        that._currentValue = val;

        if (that.visible) {
          if (that._animation && !_noAnimation) {
            that._runAnimation(val);
          } else {
            that._actualValue = val;
            that._actualPosition = that._translator.translate(val);

            that._move();
          }
        }
      }
    }

    rootElement.attr({
      visibility: visibility
    });
    return that;
  },
  _isEnabled: null,
  _isVisible: null,
  _render: null,
  _clear: null,
  _move: null
}); // The following is from baseMarker.js

exports.BaseIndicator = BaseIndicator;
var COEFFICIENTS_MAP = {};
COEFFICIENTS_MAP['right-bottom'] = COEFFICIENTS_MAP['rb'] = [0, -1, -1, 0, 0, 1, 1, 0];
COEFFICIENTS_MAP['bottom-right'] = COEFFICIENTS_MAP['br'] = [-1, 0, 0, -1, 1, 0, 0, 1];
COEFFICIENTS_MAP['left-bottom'] = COEFFICIENTS_MAP['lb'] = [0, -1, 1, 0, 0, 1, -1, 0];
COEFFICIENTS_MAP['bottom-left'] = COEFFICIENTS_MAP['bl'] = [1, 0, 0, -1, -1, 0, 0, 1];
COEFFICIENTS_MAP['left-top'] = COEFFICIENTS_MAP['lt'] = [0, 1, 1, 0, 0, -1, -1, 0];
COEFFICIENTS_MAP['top-left'] = COEFFICIENTS_MAP['tl'] = [1, 0, 0, 1, -1, 0, 0, -1];
COEFFICIENTS_MAP['right-top'] = COEFFICIENTS_MAP['rt'] = [0, 1, -1, 0, 0, -1, 1, 0];
COEFFICIENTS_MAP['top-right'] = COEFFICIENTS_MAP['tr'] = [-1, 0, 0, 1, 1, 0, 0, -1];

function getTextCloudInfo(options) {
  var x = options.x;
  var y = options.y;
  var type = COEFFICIENTS_MAP[options.type];
  var cloudWidth = options.cloudWidth;
  var cloudHeight = options.cloudHeight;
  var tailWidth;
  var tailHeight;
  var cx = x;
  var cy = y;
  tailWidth = tailHeight = options.tailLength;

  if (type[0] & 1) {
    tailHeight = Math.min(tailHeight, cloudHeight / 3);
  } else {
    tailWidth = Math.min(tailWidth, cloudWidth / 3);
  }

  return {
    cx: _round(cx + type[0] * tailWidth + (type[0] + type[2]) * cloudWidth / 2),
    cy: _round(cy + type[1] * tailHeight + (type[1] + type[3]) * cloudHeight / 2),
    points: [_round(x), _round(y), _round(x += type[0] * (cloudWidth + tailWidth)), _round(y += type[1] * (cloudHeight + tailHeight)), _round(x += type[2] * cloudWidth), _round(y += type[3] * cloudHeight), _round(x += type[4] * cloudWidth), _round(y += type[5] * cloudHeight), _round(x += type[6] * (cloudWidth - tailWidth)), _round(y += type[7] * (cloudHeight - tailHeight))]
  };
}

var BaseTextCloudMarker = BaseIndicator.inherit({
  _move: function _move() {
    var that = this;
    var options = that._options;

    var textCloudOptions = that._getTextCloudOptions();

    var text = _formatValue(that._actualValue, options.text);

    that._text.attr({
      text: text
    });

    var bBox = that._text.getBBox();

    var x = textCloudOptions.x;
    var y = textCloudOptions.y;
    var cloudWidth = (bBox.width || text.length * that._textUnitWidth) + 2 * options.horizontalOffset;
    var cloudHeight = (bBox.height || that._textHeight) + 2 * options.verticalOffset;
    var info = getTextCloudInfo({
      x: x,
      y: y,
      cloudWidth: cloudWidth,
      cloudHeight: cloudHeight,
      tailLength: options.arrowLength,
      type: that._correctCloudType(textCloudOptions.type, {
        x: x,
        y: y
      }, {
        width: cloudWidth,
        height: cloudHeight
      })
    });

    that._text.attr({
      x: info.cx,
      y: info.cy + that._textVerticalOffset
    });

    that._cloud.attr({
      points: info.points
    });

    that._trackerElement && that._trackerElement.attr({
      points: info.points
    });
  },
  _measureText: function _measureText() {
    var that = this;
    var root;
    var text;
    var bBox;
    var sampleText;

    if (!that._textVerticalOffset) {
      root = that._createRoot().append(that._owner);
      sampleText = _getSampleText(that._translator, that._options.text);
      text = that._renderer.text(sampleText, 0, 0).attr({
        align: 'center'
      }).css((0, _utils.patchFontOptions)(that._options.text.font)).append(root);
      bBox = text.getBBox();
      root.remove();
      that._textVerticalOffset = -bBox.y - bBox.height / 2;
      that._textWidth = bBox.width;
      that._textHeight = bBox.height;
      that._textUnitWidth = that._textWidth / sampleText.length;
      that._textFullWidth = that._textWidth + 2 * that._options.horizontalOffset;
      that._textFullHeight = that._textHeight + 2 * that._options.verticalOffset;
    }
  },
  _render: function _render() {
    var that = this;

    that._measureText();

    that._cloud = that._cloud || that._renderer.path([], 'area').append(that._rootElement);
    that._text = that._text || that._renderer.text().append(that._rootElement);

    that._text.attr({
      align: 'center'
    }).css((0, _utils.patchFontOptions)(that._options.text.font));
  },
  _clear: function _clear() {
    delete this._cloud;
    delete this._text;
  },
  getTooltipParameters: function getTooltipParameters() {
    var position = this._getTextCloudOptions();

    return {
      x: position.x,
      y: position.y,
      value: this._currentValue,
      color: this._options.color
    };
  },
  _correctCloudType: function _correctCloudType(type) {
    return type;
  }
}); // The following is from baseRangeBar.js

exports.BaseTextCloudMarker = BaseTextCloudMarker;
var BaseRangeBar = BaseIndicator.inherit({
  _measureText: function _measureText() {
    var that = this;
    var root;
    var text;
    var bBox;
    that._hasText = that._isTextVisible();

    if (that._hasText && !that._textVerticalOffset) {
      root = that._createRoot().append(that._owner);
      text = that._renderer.text(_getSampleText(that._translator, that._options.text), 0, 0).attr({
        'class': 'dxg-text',
        align: 'center'
      }).css((0, _utils.patchFontOptions)(that._options.text.font)).append(root);
      bBox = text.getBBox();
      root.remove();
      that._textVerticalOffset = -bBox.y - bBox.height / 2;
      that._textWidth = bBox.width;
      that._textHeight = bBox.height;
    }
  },
  _move: function _move() {
    var that = this;

    that._updateBarItemsPositions();

    if (that._hasText) {
      that._text.attr({
        text: _formatValue(that._actualValue, that._options.text)
      });

      that._updateTextPosition();

      that._updateLinePosition();
    }
  },
  _updateBarItems: function _updateBarItems() {
    var that = this;
    var options = that._options;
    var spaceColor;
    var translator = that._translator;

    that._setBarSides();

    that._startPosition = translator.translate(translator.getDomainStart());
    that._endPosition = translator.translate(translator.getDomainEnd());
    that._basePosition = translator.translate(options.baseValue);
    that._space = that._getSpace();
    var backgroundColor = options.backgroundColor || 'none';

    if (backgroundColor !== 'none' && that._space > 0) {
      spaceColor = options.containerBackgroundColor || 'none';
    } else {
      that._space = 0;
      spaceColor = 'none';
    }

    that._backItem1.attr({
      fill: backgroundColor
    });

    that._backItem2.attr({
      fill: backgroundColor
    });

    that._spaceItem1.attr({
      fill: spaceColor
    });

    that._spaceItem2.attr({
      fill: spaceColor
    });
  },
  _getSpace: function _getSpace() {
    return 0;
  },
  _updateTextItems: function _updateTextItems() {
    var that = this;

    if (that._hasText) {
      that._line = that._line || that._renderer.path([], 'line').attr({
        'class': 'dxg-main-bar',
        'stroke-linecap': 'square'
      }).append(that._rootElement);
      that._text = that._text || that._renderer.text('', 0, 0).attr({
        'class': 'dxg-text'
      }).append(that._rootElement);

      that._text.attr({
        align: that._getTextAlign()
      }).css(that._getFontOptions());

      that._setTextItemsSides();
    } else {
      if (that._line) {
        that._line.remove();

        delete that._line;
      }

      if (that._text) {
        that._text.remove();

        delete that._text;
      }
    }
  },
  _isTextVisible: function _isTextVisible() {
    return false;
  },
  _getTextAlign: function _getTextAlign() {
    return 'center';
  },
  _getFontOptions: function _getFontOptions() {
    var options = this._options;
    var font = options.text.font;

    if (!font || !font.color) {
      font = (0, _extend.extend)({}, font, {
        color: options.color
      });
    }

    return (0, _utils.patchFontOptions)(font);
  },
  _updateBarItemsPositions: function _updateBarItemsPositions() {
    var that = this;

    var positions = that._getPositions();

    that._backItem1.attr(that._buildItemSettings(positions.start, positions.back1));

    that._backItem2.attr(that._buildItemSettings(positions.back2, positions.end));

    that._spaceItem1.attr(that._buildItemSettings(positions.back1, positions.main1));

    that._spaceItem2.attr(that._buildItemSettings(positions.main2, positions.back2));

    that._mainItem.attr(that._buildItemSettings(positions.main1, positions.main2));

    that._trackerElement && that._trackerElement.attr(that._buildItemSettings(positions.main1, positions.main2));
  },
  _render: function _render() {
    var that = this;

    that._measureText();

    if (!that._backItem1) {
      that._backItem1 = that._createBarItem();

      that._backItem1.attr({
        'class': 'dxg-back-bar'
      });
    }

    if (!that._backItem2) {
      that._backItem2 = that._createBarItem();

      that._backItem2.attr({
        'class': 'dxg-back-bar'
      });
    }

    if (!that._spaceItem1) {
      that._spaceItem1 = that._createBarItem();

      that._spaceItem1.attr({
        'class': 'dxg-space-bar'
      });
    }

    if (!that._spaceItem2) {
      that._spaceItem2 = that._createBarItem();

      that._spaceItem2.attr({
        'class': 'dxg-space-bar'
      });
    }

    if (!that._mainItem) {
      that._mainItem = that._createBarItem();

      that._mainItem.attr({
        'class': 'dxg-main-bar'
      });
    }

    that._updateBarItems();

    that._updateTextItems();
  },
  _clear: function _clear() {
    var that = this;
    delete that._backItem1;
    delete that._backItem2;
    delete that._spaceItem1;
    delete that._spaceItem2;
    delete that._mainItem;
    delete that._hasText;
    delete that._line;
    delete that._text;
  },
  getTooltipParameters: function getTooltipParameters() {
    var position = this._getTooltipPosition();

    return {
      x: position.x,
      y: position.y,
      value: this._currentValue,
      color: this._options.color,
      offset: 0
    };
  }
});
exports.BaseRangeBar = BaseRangeBar;

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.buildRectAppearance = buildRectAppearance;
exports.buildTextAppearance = buildTextAppearance;

var _utils = __webpack_require__(14);

function buildRectAppearance(option) {
  var border = option.border || {};
  return {
    fill: option.color,
    opacity: option.opacity,
    'stroke': border.color,
    'stroke-width': border.width,
    'stroke-opacity': border.opacity,
    hatching: option.hatching
  };
}

function buildTextAppearance(options, filter) {
  return {
    attr: {
      filter: filter
    },
    css: (0, _utils.patchFontOptions)(options.font)
  };
}

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Tracker = Tracker;

var _index = __webpack_require__(8);

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _click = __webpack_require__(23);

var _pointer = _interopRequireDefault(__webpack_require__(25));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var downPointerEventName = _pointer.default.down;
var movePointerEventName = _pointer.default.move;

function Tracker(parameters) {
  this._initHandlers(parameters);
}

Tracker.prototype = {
  constructor: Tracker,
  _initHandlers: function _initHandlers(parameters) {
    var document = _dom_adapter.default.getDocument();

    parameters.getCoords = function (e) {
      // TODO: Looks like "eventData" just returns e.pageX, e.pageY. Investigate and use just e.pageX, e.pageY is possible. Don't forget about touch.
      var data = (0, _index.eventData)(e);

      var offset = parameters.widget._renderer.getRootOffset();

      return [data.x - offset.left, data.y - offset.top];
    };

    parameters.root.on(_click.name, clickHandler);
    parameters.root.on(downPointerEventName, downHandler);

    _events_engine.default.on(document, downPointerEventName, downHandler);

    _events_engine.default.on(document, movePointerEventName, moveHandler);

    this._disposeHandlers = function () {
      parameters.root.off(_click.name, clickHandler);
      parameters.root.off(downPointerEventName, downHandler);

      _events_engine.default.off(document, downPointerEventName, downHandler);

      _events_engine.default.off(document, movePointerEventName, moveHandler);
    };

    function clickHandler(e) {
      processClick(e, parameters);
    } // Previously "stopPropagation" was called from the "downHandler" - so event triggered on "root" is not then triggered on "document".
    // Unfortunately it occurred (during T396917) that on touch devices calling "stopPropagation" prevents the following "dxclick" event.
    // Generally I think it would be better to use only (dxpointerdown, dxpointermove, dxpointerup) events (of course click is then implemented manually).
    // But for now removing "stopPropagation" will suffice - it can be implemented faster and with less changes, there are no known drawbacks in it.
    // We use "stopPropagation" to prevent unexpected scrolling or zooming when widget has some own scrolling behavior and is located inside another widget
    // (like dxScrollable) with its own scrolling behavior - dxTreeMap does not have own scrolling behavior.


    var isRootDown = false;

    function downHandler(e) {
      if (isRootDown) {
        isRootDown = false;
      } else {
        if (parameters.getData(e) !== undefined) {
          isRootDown = true;
        }

        moveHandler(e);
      }
    }

    function moveHandler(e) {
      processHover(e, parameters);
      parameters.widget._getOption('tooltip').enabled && processTooltip(e, parameters);
    }
  },
  dispose: function dispose() {
    this._disposeHandlers();
  }
};

function processClick(e, params) {
  var id = params.getData(e);

  if (id >= 0) {
    params.click({
      node: params.getNode(id),
      coords: params.getCoords(e),
      event: e
    });
  }
}

function processHover(e, params) {
  var id = params.getData(e);

  if (id >= 0) {
    params.getNode(id).setHover();
  } else {
    params.widget.clearHover();
  }
}

function processTooltip(e, params) {
  var id = params.getData(e, true);
  var coords;

  if (id >= 0) {
    coords = (0, _index.eventData)(e);
    params.getNode(id).showTooltip([coords.x, coords.y]);
  } else {
    params.widget.hideTooltip();
  }
}

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Options = void 0;

var _type = __webpack_require__(1);

var _common = __webpack_require__(4);

var _option_manager = __webpack_require__(380);

var _object = __webpack_require__(52);

var _data = __webpack_require__(21);

var _utils = __webpack_require__(126);

var _extend = __webpack_require__(0);

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Options = /*#__PURE__*/function () {
  function Options(options, defaultOptions, optionsByReference, deprecatedOptions) {
    var _this = this;

    this._deprecatedCallback;
    this._startChangeCallback;
    this._endChangeCallback;
    this._default = defaultOptions;
    this._deprecated = deprecatedOptions;
    this._deprecatedNames = [];

    this._initDeprecatedNames();

    this._optionManager = new _option_manager.OptionManager(options, optionsByReference);

    this._optionManager.onRelevantNamesPrepared(function (options, name, value, silent) {
      return _this._setRelevantNames(options, name, value, silent);
    });

    this._cachedOptions = {};
    this._rules = [];
  }

  var _proto = Options.prototype;

  _proto._initDeprecatedNames = function _initDeprecatedNames() {
    for (var optionName in this._deprecated) {
      this._deprecatedNames.push(optionName);
    }
  };

  _proto._getByRules = function _getByRules(rules) {
    rules = Array.isArray(rules) ? this._rules.concat(rules) : this._rules;
    return (0, _utils.convertRulesToOptions)(rules);
  };

  _proto._notifyDeprecated = function _notifyDeprecated(option) {
    var info = this._deprecated[option];

    if (info) {
      this._deprecatedCallback(option, info);
    }
  };

  _proto._setRelevantNames = function _setRelevantNames(options, name, value, silent) {
    if (name) {
      var normalizedName = this._normalizeName(name, silent);

      if (normalizedName && normalizedName !== name) {
        this._setField(options, normalizedName, value);

        this._clearField(options, name);
      }
    }
  };

  _proto._setField = function _setField(options, fullName, value) {
    var fieldName = '';
    var fieldObject = null;

    do {
      fieldName = fieldName ? ".".concat(fieldName) : '';
      fieldName = (0, _utils.getFieldName)(fullName) + fieldName;
      fullName = (0, _utils.getParentName)(fullName);
      fieldObject = fullName ? this._optionManager.get(options, fullName, false) : options;
    } while (!fieldObject);

    fieldObject[fieldName] = value;
  };

  _proto._clearField = function _clearField(options, name) {
    delete options[name];
    var previousFieldName = (0, _utils.getParentName)(name);
    var fieldObject = previousFieldName ? this._optionManager.get(options, previousFieldName, false) : options;

    if (fieldObject) {
      delete fieldObject[(0, _utils.getFieldName)(name)];
    }
  };

  _proto._normalizeName = function _normalizeName(name, silent) {
    if (this._deprecatedNames.length && name) {
      for (var i = 0; i < this._deprecatedNames.length; i++) {
        if (this._deprecatedNames[i] === name) {
          var deprecate = this._deprecated[name];

          if (deprecate) {
            !silent && this._notifyDeprecated(name);
            return deprecate.alias || name;
          }
        }
      }
    }

    return name;
  };

  _proto.addRules = function addRules(rules) {
    this._rules = rules.concat(this._rules);
  };

  _proto.applyRules = function applyRules(rules) {
    var options = this._getByRules(rules);

    this.silent(options);
  };

  _proto.dispose = function dispose() {
    this._deprecatedCallback = _common.noop;
    this._startChangeCallback = _common.noop;
    this._endChangeCallback = _common.noop;

    this._optionManager.dispose();
  };

  _proto.onChanging = function onChanging(callBack) {
    this._optionManager.onChanging(callBack);
  };

  _proto.onChanged = function onChanged(callBack) {
    this._optionManager.onChanged(callBack);
  };

  _proto.onDeprecated = function onDeprecated(callBack) {
    this._deprecatedCallback = callBack;
  };

  _proto.onStartChange = function onStartChange(callBack) {
    this._startChangeCallback = callBack;
  };

  _proto.onEndChange = function onEndChange(callBack) {
    this._endChangeCallback = callBack;
  };

  _proto.isInitial = function isInitial(name) {
    var value = this.silent(name);
    var initialValue = this.initial(name);
    var areFunctions = (0, _type.isFunction)(value) && (0, _type.isFunction)(initialValue);
    return areFunctions ? value.toString() === initialValue.toString() : (0, _common.equalByValue)(value, initialValue);
  };

  _proto.initial = function initial(name) {
    return (0, _utils.getNestedOptionValue)(this._initial, name);
  };

  _proto.option = function option(options, value) {
    var isGetter = arguments.length < 2 && (0, _type.type)(options) !== 'object';

    if (isGetter) {
      return this._optionManager.get(undefined, this._normalizeName(options));
    } else {
      this._startChangeCallback();

      try {
        this._optionManager.set(options, value);
      } finally {
        this._endChangeCallback();
      }
    }
  };

  _proto.silent = function silent(options, value) {
    var isGetter = arguments.length < 2 && (0, _type.type)(options) !== 'object';

    if (isGetter) {
      return this._optionManager.get(undefined, options, undefined, true);
    } else {
      this._optionManager.set(options, value, undefined, true);
    }
  };

  _proto.reset = function reset(name) {
    var _this2 = this;

    if (name) {
      var fullPath = (0, _data.getPathParts)(name);
      var value = fullPath.reduce(function (value, field) {
        return value ? value[field] : _this2.initial(field);
      }, null);
      var defaultValue = (0, _type.isObject)(value) ? (0, _object.clone)(value) : value;

      this._optionManager.set(name, defaultValue, false);
    }
  };

  _proto.getAliasesByName = function getAliasesByName(name) {
    var _this3 = this;

    return Object.keys(this._deprecated).filter(function (aliasName) {
      return name === _this3._deprecated[aliasName].alias;
    });
  };

  _proto.isDeprecated = function isDeprecated(name) {
    return Object.prototype.hasOwnProperty.call(this._deprecated, name);
  };

  _proto.cache = function cache(name, options) {
    var isGetter = arguments.length < 2;

    if (isGetter) {
      return this._cachedOptions[name];
    } else {
      this._cachedOptions[name] = (0, _extend.extend)(this._cachedOptions[name], options);
    }
  };

  _createClass(Options, [{
    key: "_initial",
    get: function get() {
      if (!this._initialOptions) {
        var rulesOptions = this._getByRules(this.silent('defaultOptionsRules'));

        this._initialOptions = this._default;

        this._optionManager._setByReference(this._initialOptions, rulesOptions);
      }

      return this._initialOptions;
    },
    set: function set(value) {
      this._initialOptions = value;
    }
  }]);

  return Options;
}();

exports.Options = Options;

/***/ }),
/* 355 */,
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getData = getData;
exports.ExcelCreator = void 0;

var _class = _interopRequireDefault(__webpack_require__(15));

var _window = __webpack_require__(7);

var _type = __webpack_require__(1);

var _extend = __webpack_require__(0);

var _ui = _interopRequireDefault(__webpack_require__(19));

var _string = __webpack_require__(40);

var _jszip = _interopRequireDefault(__webpack_require__(276));

var _file_saver = __webpack_require__(189);

var _excel_format_converter = _interopRequireDefault(__webpack_require__(250));

var _excel = _interopRequireDefault(__webpack_require__(363));

var _deferred = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var XML_TAG = '<?xml version="1.0" encoding="utf-8"?>';
var GROUP_SHEET_PR_XML = '<sheetPr><outlinePr summaryBelow="0"/></sheetPr>';
var SINGLE_SHEET_PR_XML = '<sheetPr/>';
var BASE_STYLE_XML2 = '<borders count="1"><border><left style="thin"><color rgb="FFD3D3D3"/></left><right style="thin">' + '<color rgb="FFD3D3D3"/></right><top style="thin"><color rgb="FFD3D3D3"/></top><bottom style="thin"><color rgb="FFD3D3D3"/>' + '</bottom></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>';
var OPEN_XML_FORMAT_URL = 'http://schemas.openxmlformats.org';
var RELATIONSHIP_PART_NAME = 'rels';
var XL_FOLDER_NAME = 'xl';
var WORKBOOK_FILE_NAME = 'workbook.xml';
var CONTENTTYPES_FILE_NAME = '[Content_Types].xml';
var SHAREDSTRING_FILE_NAME = 'sharedStrings.xml';
var STYLE_FILE_NAME = 'styles.xml';
var WORKSHEETS_FOLDER = 'worksheets';
var WORKSHEET_FILE_NAME = 'sheet1.xml';
var WORKSHEET_HEADER_XML = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" ' + 'xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" ' + 'mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">';
var VALID_TYPES = {
  // 18.18.11, ST_CellType (Cell Type)
  'boolean': 'b',
  'date': 'd',
  'number': 'n',
  'string': 's'
};
var EXCEL_START_TIME = Date.UTC(1899, 11, 30);
var DAYS_COUNT_BEFORE_29_FEB_1900 = 60;
var MAX_DIGIT_WIDTH_IN_PIXELS = 7; // Calibri font with 11pt size

var UNSUPPORTED_FORMAT_MAPPING = {
  quarter: 'shortDate',
  quarterAndYear: 'shortDate',
  minute: 'longTime',
  millisecond: 'longTime'
};

var ExcelCreator = _class.default.inherit({
  _getXMLTag: function _getXMLTag(tagName, attributes, content) {
    var result = '<' + tagName;
    var i;
    var length = attributes.length;
    var attr;

    for (i = 0; i < length; i++) {
      attr = attributes[i];

      if (attr.value !== undefined) {
        result = result + ' ' + attr.name + '="' + attr.value + '"';
      }
    }

    return (0, _type.isDefined)(content) ? result + '>' + content + '</' + tagName + '>' : result + ' />';
  },
  _convertToExcelCellRef: function _convertToExcelCellRef(zeroBasedRowIndex, zeroBasedCellIndex) {
    // pass (0, 0) to get 'A1'
    var columnName = '';
    var max = 26;
    var charCode;
    var isCellIndexFound;

    while (!isCellIndexFound) {
      charCode = 65 + (zeroBasedCellIndex >= max ? zeroBasedCellIndex % max : Math.ceil(zeroBasedCellIndex));
      columnName = String.fromCharCode(charCode) + columnName;

      if (zeroBasedCellIndex >= max) {
        zeroBasedCellIndex = Math.floor(zeroBasedCellIndex / max) - 1;
      } else {
        isCellIndexFound = true;
      }
    }

    return columnName + (zeroBasedRowIndex + 1);
  },
  _convertToExcelCellRefAndTrackMaxIndex: function _convertToExcelCellRefAndTrackMaxIndex(rowIndex, cellIndex) {
    if (this._maxRowIndex < Number(rowIndex)) {
      this._maxRowIndex = Number(rowIndex);
    }

    if (this._maxColumnIndex < Number(cellIndex)) {
      this._maxColumnIndex = Number(cellIndex);
    }

    return this._convertToExcelCellRef(rowIndex, cellIndex);
  },
  _getDataType: function _getDataType(dataType) {
    return VALID_TYPES[dataType] || VALID_TYPES.string;
  },
  _tryGetExcelCellDataType: function _tryGetExcelCellDataType(object) {
    if ((0, _type.isDefined)(object)) {
      if (typeof object === 'number') {
        if (isFinite(object)) {
          return VALID_TYPES['number'];
        } else {
          return VALID_TYPES['string'];
        }
      } else if ((0, _type.isString)(object)) {
        return VALID_TYPES['string'];
      } else if ((0, _type.isDate)(object)) {
        return VALID_TYPES['number'];
      } else if ((0, _type.isBoolean)(object)) {
        return VALID_TYPES['boolean'];
      }
    }
  },
  _formatObjectConverter: function _formatObjectConverter(format, dataType) {
    var result = {
      format: format,
      precision: format && format.precision,
      dataType: dataType
    };

    if ((0, _type.isObject)(format)) {
      return (0, _extend.extend)(result, format, {
        format: format.formatter || format.type,
        currency: format.currency
      });
    }

    return result;
  },
  _tryConvertToExcelNumberFormat: function _tryConvertToExcelNumberFormat(format, dataType) {
    var newFormat = this._formatObjectConverter(format, dataType);

    format = newFormat.format;
    var currency = newFormat.currency;
    dataType = newFormat.dataType;

    if ((0, _type.isDefined)(format) && dataType === 'date') {
      format = UNSUPPORTED_FORMAT_MAPPING[format && format.type || format] || format;
    }

    return _excel_format_converter.default.convertFormat(format, newFormat.precision, dataType, currency);
  },
  _appendString: function _appendString(value) {
    if ((0, _type.isDefined)(value)) {
      value = String(value);

      if (value.length) {
        value = (0, _string.encodeHtml)(value);

        if (this._stringHash[value] === undefined) {
          this._stringHash[value] = this._stringArray.length;

          this._stringArray.push(value);
        }

        return this._stringHash[value];
      }
    }
  },
  _tryGetExcelDateValue: function _tryGetExcelDateValue(date) {
    var days;
    var totalTime;

    if ((0, _type.isDate)(date)) {
      days = Math.floor((Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) - EXCEL_START_TIME) / (1000 * 60 * 60 * 24));

      if (days < DAYS_COUNT_BEFORE_29_FEB_1900) {
        days--;
      }

      totalTime = (date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds()) / (24 * 3600);
      return days + totalTime;
    }
  },
  _prepareValue: function _prepareValue(rowIndex, cellIndex) {
    var dataProvider = this._dataProvider;

    var _ref = dataProvider.getCellData(rowIndex, cellIndex) || {},
        cellSourceData = _ref.cellSourceData;

    var _ref2 = dataProvider.getCellData(rowIndex, cellIndex) || {},
        value = _ref2.value;

    var sourceValue;

    var type = this._getDataType(dataProvider.getCellType(rowIndex, cellIndex));

    if (type === VALID_TYPES.date && !(0, _type.isDate)(value)) {
      type = VALID_TYPES.string;
    }

    switch (type) {
      case VALID_TYPES.string:
        sourceValue = value;
        value = this._appendString(value);
        break;

      case VALID_TYPES.date:
        sourceValue = value;
        value = this._tryGetExcelDateValue(value);
        type = VALID_TYPES.number;
        break;
    }

    return {
      value: value,
      type: type,
      sourceValue: sourceValue,
      cellSourceData: cellSourceData
    };
  },
  _callCustomizeExcelCell: function _callCustomizeExcelCell(_ref3) {
    var dataProvider = _ref3.dataProvider,
        value = _ref3.value,
        style = _ref3.style,
        sourceData = _ref3.sourceData;

    var styleCopy = _excel.default.copyCellFormat(style);

    var args = {
      value: value,
      numberFormat: styleCopy.numberFormat,
      clearStyle: function clearStyle() {
        this.horizontalAlignment = null;
        this.verticalAlignment = null;
        this.wrapTextEnabled = null;
        this.font = null;
        this.numberFormat = null;
      }
    };

    if ((0, _type.isDefined)(styleCopy)) {
      if ((0, _type.isDefined)(styleCopy.alignment)) {
        args.horizontalAlignment = styleCopy.alignment.horizontal;
        args.verticalAlignment = styleCopy.alignment.vertical;
        args.wrapTextEnabled = styleCopy.alignment.wrapText;
      }

      args.backgroundColor = styleCopy.backgroundColor;
      args.fillPatternType = styleCopy.fillPatternType;
      args.fillPatternColor = styleCopy.fillPatternColor;
      args.font = styleCopy.font;
    }

    dataProvider.customizeExcelCell(args, sourceData);
    var newStyle = styleCopy || {};
    newStyle.font = args.font;
    newStyle.alignment = newStyle.alignment || {};
    newStyle.alignment.horizontal = args.horizontalAlignment;
    newStyle.alignment.vertical = args.verticalAlignment;
    newStyle.alignment.wrapText = args.wrapTextEnabled;
    newStyle.backgroundColor = args.backgroundColor;
    newStyle.fillPatternType = args.fillPatternType;
    newStyle.fillPatternColor = args.fillPatternColor;
    newStyle.numberFormat = args.numberFormat;
    return {
      value: args.value,
      style: newStyle
    };
  },
  _getDataArray: function _getDataArray() {
    var that = this;
    var rowIndex;
    var cellIndex;
    var cellsArray;
    var cellData;
    var result = [];
    var dataProvider = that._dataProvider;
    var rowsLength = dataProvider.getRowsCount();
    var columns = dataProvider.getColumns();
    var cellsLength;

    for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
      cellsArray = [];
      cellsLength = columns.length;

      for (cellIndex = 0; cellIndex !== cellsLength; cellIndex++) {
        cellData = that._prepareValue(rowIndex, cellIndex);
        var styleArrayIndex = dataProvider.getStyleId(rowIndex, cellIndex);
        var cellStyleId = this._styleArrayIndexToCellStyleIdMap[styleArrayIndex];

        if (dataProvider.hasCustomizeExcelCell && dataProvider.hasCustomizeExcelCell()) {
          var value = cellData.sourceValue || cellData.value;

          var modifiedExcelCell = this._callCustomizeExcelCell({
            dataProvider: dataProvider,
            value: value,
            style: that._styleArray[styleArrayIndex],
            sourceData: cellData.cellSourceData
          });

          if (modifiedExcelCell.value !== value) {
            if (_typeof(modifiedExcelCell.value) !== _typeof(value) || typeof modifiedExcelCell.value === 'number' && !isFinite(modifiedExcelCell.value)) {
              var cellDataType = this._tryGetExcelCellDataType(modifiedExcelCell.value);

              if ((0, _type.isDefined)(cellDataType)) {
                cellData.type = cellDataType;
              }
            } // 18.18.11 ST_CellType (Cell Type)


            switch (cellData.type) {
              case VALID_TYPES.string:
                cellData.value = this._appendString(modifiedExcelCell.value);
                break;

              case VALID_TYPES.date:
                cellData.value = modifiedExcelCell.value;
                break;

              case VALID_TYPES.number:
                {
                  var newValue = modifiedExcelCell.value;

                  var excelDateValue = this._tryGetExcelDateValue(newValue);

                  if ((0, _type.isDefined)(excelDateValue)) {
                    newValue = excelDateValue;
                  }

                  cellData.value = newValue;
                  break;
                }

              default:
                cellData.value = modifiedExcelCell.value;
            }
          }

          cellStyleId = this._excelFile.registerCellFormat(modifiedExcelCell.style);
        }

        cellsArray.push({
          style: cellStyleId,
          value: cellData.value,
          type: cellData.type
        });
      }

      if (!that._needSheetPr && dataProvider.getGroupLevel(rowIndex) > 0) {
        that._needSheetPr = true;
      }

      result.push(cellsArray);
    }

    return result;
  },
  _calculateWidth: function _calculateWidth(pixelsWidth) {
    pixelsWidth = parseInt(pixelsWidth, 10);
    if (!pixelsWidth || pixelsWidth < 5) pixelsWidth = 100;
    return Math.min(255, Math.floor((pixelsWidth - 5) / MAX_DIGIT_WIDTH_IN_PIXELS * 100 + 0.5) / 100);
  },
  _prepareStyleData: function _prepareStyleData() {
    var _this = this;

    var that = this;

    var styles = that._dataProvider.getStyles();

    that._dataProvider.getColumns().forEach(function (column) {
      that._colsArray.push(that._calculateWidth(column.width));
    });

    var fonts = [{
      size: 11,
      color: {
        theme: 1
      },
      name: 'Calibri',
      family: 2,
      scheme: 'minor',
      bold: false
    }, {
      size: 11,
      color: {
        theme: 1
      },
      name: 'Calibri',
      family: 2,
      scheme: 'minor',
      bold: true
    }];

    this._excelFile.registerFont(fonts[0]);

    this._excelFile.registerFont(fonts[1]);

    styles.forEach(function (style) {
      var numberFormat = that._tryConvertToExcelNumberFormat(style.format, style.dataType);

      if (!(0, _type.isDefined)(numberFormat)) {
        numberFormat = 0;
      }

      that._styleArray.push({
        font: fonts[Number(!!style.bold)],
        numberFormat: numberFormat,
        alignment: {
          vertical: 'top',
          wrapText: !!style.wrapText,
          horizontal: style.alignment || 'left'
        }
      });
    });
    that._styleArrayIndexToCellStyleIdMap = that._styleArray.map(function (item) {
      return _this._excelFile.registerCellFormat(item);
    });
  },
  _prepareCellData: function _prepareCellData() {
    this._cellsArray = this._getDataArray();
  },
  _createXMLRelationships: function _createXMLRelationships(xmlRelationships) {
    return this._getXMLTag('Relationships', [{
      name: 'xmlns',
      value: OPEN_XML_FORMAT_URL + '/package/2006/relationships'
    }], xmlRelationships);
  },
  _createXMLRelationship: function _createXMLRelationship(id, type, target) {
    return this._getXMLTag('Relationship', [{
      name: 'Id',
      value: 'rId' + id
    }, {
      name: 'Type',
      value: OPEN_XML_FORMAT_URL + '/officeDocument/2006/relationships/' + type
    }, {
      name: 'Target',
      value: target
    }]);
  },
  _getWorkbookContent: function _getWorkbookContent() {
    var content = '<bookViews><workbookView xWindow="0" yWindow="0" windowWidth="0" windowHeight="0"/>' + '</bookViews><sheets><sheet name="Sheet" sheetId="1" r:id="rId1" /></sheets><definedNames>' + '<definedName name="_xlnm.Print_Titles" localSheetId="0">Sheet!$1:$1</definedName>' + '<definedName name="_xlnm._FilterDatabase" hidden="0" localSheetId="0">Sheet!$A$1:$F$6332</definedName></definedNames>';
    return XML_TAG + this._getXMLTag('workbook', [{
      name: 'xmlns:r',
      value: OPEN_XML_FORMAT_URL + '/officeDocument/2006/relationships'
    }, {
      name: 'xmlns',
      value: OPEN_XML_FORMAT_URL + '/spreadsheetml/2006/main'
    }], content);
  },
  _getContentTypesContent: function _getContentTypesContent() {
    return XML_TAG + '<Types xmlns="' + OPEN_XML_FORMAT_URL + '/package/2006/content-types"><Default Extension="rels" ' + 'ContentType="application/vnd.openxmlformats-package.relationships+xml" /><Default Extension="xml" ' + 'ContentType="application/xml" /><Override PartName="/xl/worksheets/sheet1.xml" ' + 'ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" />' + '<Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml" />' + '<Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml" />' + '<Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" /></Types>';
  },
  _generateStylesXML: function _generateStylesXML() {
    var that = this;

    var folder = that._zip.folder(XL_FOLDER_NAME);

    var XML = '';
    XML = XML + this._excelFile.generateNumberFormatsXml();
    XML = XML + this._excelFile.generateFontsXml();
    XML = XML + this._excelFile.generateFillsXml();
    XML = XML + BASE_STYLE_XML2;
    XML = XML + this._excelFile.generateCellFormatsXml();
    XML = XML + that._getXMLTag('cellStyles', [{
      name: 'count',
      value: 1
    }], that._getXMLTag('cellStyle', [{
      name: 'name',
      value: 'Normal'
    }, {
      name: 'xfId',
      value: 0
    }, {
      name: 'builtinId',
      value: 0
    }]));
    XML = XML_TAG + that._getXMLTag('styleSheet', [{
      name: 'xmlns',
      value: OPEN_XML_FORMAT_URL + '/spreadsheetml/2006/main'
    }], XML);
    folder.file(STYLE_FILE_NAME, XML);
    that._styleArray = [];
  },
  _generateStringsXML: function _generateStringsXML() {
    var folder = this._zip.folder(XL_FOLDER_NAME);

    var stringIndex;
    var stringsLength = this._stringArray.length;
    var sharedStringXml = XML_TAG;

    for (stringIndex = 0; stringIndex < stringsLength; stringIndex++) {
      this._stringArray[stringIndex] = this._getXMLTag('si', [], this._getXMLTag('t', [], this._stringArray[stringIndex]));
    }

    sharedStringXml = sharedStringXml + this._getXMLTag('sst', [{
      name: 'xmlns',
      value: OPEN_XML_FORMAT_URL + '/spreadsheetml/2006/main'
    }, {
      name: 'count',
      value: this._stringArray.length
    }, {
      name: 'uniqueCount',
      value: this._stringArray.length
    }], this._stringArray.join(''));
    folder.file(SHAREDSTRING_FILE_NAME, sharedStringXml);
    this._stringArray = [];
  },
  _getPaneXML: function _getPaneXML() {
    var attributes = [{
      name: 'activePane',
      value: 'bottomLeft'
    }, {
      name: 'state',
      value: 'frozen'
    }];

    var frozenArea = this._dataProvider.getFrozenArea();

    if (!(frozenArea.x || frozenArea.y)) return '';

    if (frozenArea.x) {
      attributes.push({
        name: 'xSplit',
        value: frozenArea.x
      });
    }

    if (frozenArea.y) {
      attributes.push({
        name: 'ySplit',
        value: frozenArea.y
      });
    }

    attributes.push({
      name: 'topLeftCell',
      value: this._convertToExcelCellRefAndTrackMaxIndex(frozenArea.y, frozenArea.x)
    });
    return this._getXMLTag('pane', attributes);
  },
  _getAutoFilterXML: function _getAutoFilterXML(maxCellIndex) {
    if (this._options.autoFilterEnabled) {
      // 18.3.1.2 autoFilter (AutoFilter Settings)
      return '<autoFilter ref="A' + this._dataProvider.getHeaderRowCount() + ':' + maxCellIndex + '" />';
    }

    return '';
  },
  _getIgnoredErrorsXML: function _getIgnoredErrorsXML(maxCellIndex) {
    if (this._options.ignoreErrors) {
      return '<ignoredErrors><ignoredError sqref="A1:' + maxCellIndex + '" numberStoredAsText="1" /></ignoredErrors>';
    }

    return '';
  },
  _generateWorksheetXML: function _generateWorksheetXML() {
    var colIndex;
    var rowIndex;
    var cellData;
    var xmlCells;
    var xmlRows = [];
    var rowsLength = this._cellsArray.length;
    var cellsLength;
    var colsLength = this._colsArray.length;
    var rSpans = '1:' + colsLength;
    var headerRowCount = this._dataProvider.getHeaderRowCount ? this._dataProvider.getHeaderRowCount() : 1;
    var xmlResult = [WORKSHEET_HEADER_XML];
    xmlResult.push(this._needSheetPr ? GROUP_SHEET_PR_XML : SINGLE_SHEET_PR_XML);
    xmlResult.push('<dimension ref="A1:C1"/>'); // 18.3.1.35 dimension (Worksheet Dimensions)

    xmlResult.push('<sheetViews><sheetView ');
    xmlResult.push(this._rtlEnabled ? 'rightToLeft="1" ' : '');
    xmlResult.push('tabSelected="1" workbookViewId="0">');
    xmlResult.push(this._getPaneXML());
    xmlResult.push('</sheetView></sheetViews>');
    xmlResult.push('<sheetFormatPr defaultRowHeight="15"');
    xmlResult.push(' outlineLevelRow="' + (this._dataProvider.getRowsCount() > 0 ? this._dataProvider.getGroupLevel(0) : 0) + '"');
    xmlResult.push(' x14ac:dyDescent="0.25"/>');

    for (colIndex = 0; colIndex < colsLength; colIndex++) {
      this._colsArray[colIndex] = this._getXMLTag('col', [{
        name: 'width',
        value: this._colsArray[colIndex]
      }, {
        name: 'min',
        value: Number(colIndex) + 1
      }, {
        name: 'max',
        value: Number(colIndex) + 1
      }, {
        name: 'customWidth',
        value: 1
      }]);
    }

    xmlResult.push(this._getXMLTag('cols', [], this._colsArray.join('')) + '<sheetData>');

    for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
      xmlCells = [];
      cellsLength = this._cellsArray[rowIndex].length;

      for (colIndex = 0; colIndex < cellsLength; colIndex++) {
        rowIndex = Number(rowIndex);
        cellData = this._cellsArray[rowIndex][colIndex];
        xmlCells.push(this._getXMLTag('c', [// 18.3.1.4 c (Cell)
        {
          name: 'r',
          value: this._convertToExcelCellRefAndTrackMaxIndex(rowIndex, colIndex)
        }, {
          name: 's',
          value: cellData.style
        }, {
          name: 't',
          value: cellData.type
        } // 18.18.11 ST_CellType (Cell Type)
        ], (0, _type.isDefined)(cellData.value) ? this._getXMLTag('v', [], cellData.value) : null));
      }

      xmlRows.push(this._getXMLTag('row', [{
        name: 'r',
        value: Number(rowIndex) + 1
      }, {
        name: 'spans',
        value: rSpans
      }, {
        name: 'outlineLevel',
        value: rowIndex >= headerRowCount ? this._dataProvider.getGroupLevel(rowIndex) : 0
      }, {
        name: 'x14ac:dyDescent',
        value: '0.25'
      }], xmlCells.join('')));
      this._cellsArray[rowIndex] = null;

      if (xmlRows.length > 10000) {
        xmlResult.push(xmlRows.join(''));
        xmlRows = [];
      }
    }

    xmlResult.push(xmlRows.join(''));
    xmlRows = [];

    var rightBottomCellRef = this._convertToExcelCellRef(this._maxRowIndex, this._maxColumnIndex);

    xmlResult.push('</sheetData>' + this._getAutoFilterXML(rightBottomCellRef) + this._generateMergingXML() + this._getIgnoredErrorsXML(rightBottomCellRef) + '</worksheet>');

    this._zip.folder(XL_FOLDER_NAME).folder(WORKSHEETS_FOLDER).file(WORKSHEET_FILE_NAME, xmlResult.join(''));

    this._colsArray = [];
    this._cellsArray = [];
    xmlResult = [];
  },
  _generateMergingXML: function _generateMergingXML() {
    var k;
    var l;
    var cellIndex;
    var rowIndex;
    var rowsLength = (0, _type.isDefined)(this._dataProvider.getHeaderRowCount) ? this._dataProvider.getHeaderRowCount() : this._dataProvider.getRowsCount();

    var columnsLength = this._dataProvider.getColumns().length;

    var usedArea = [];
    var mergeArray = [];
    var mergeIndex;
    var mergeXML = '';

    for (rowIndex = 0; rowIndex < rowsLength; rowIndex++) {
      for (cellIndex = 0; cellIndex !== columnsLength; cellIndex++) {
        if (!(0, _type.isDefined)(usedArea[rowIndex]) || !(0, _type.isDefined)(usedArea[rowIndex][cellIndex])) {
          var cellMerge = this._dataProvider.getCellMerging(rowIndex, cellIndex);

          if (cellMerge.colspan || cellMerge.rowspan) {
            mergeArray.push({
              start: this._convertToExcelCellRefAndTrackMaxIndex(rowIndex, cellIndex),
              end: this._convertToExcelCellRefAndTrackMaxIndex(rowIndex + (cellMerge.rowspan || 0), cellIndex + (cellMerge.colspan || 0))
            });

            for (k = rowIndex; k <= rowIndex + cellMerge.rowspan || 0; k++) {
              for (l = cellIndex; l <= cellIndex + cellMerge.colspan || 0; l++) {
                if (!(0, _type.isDefined)(usedArea[k])) {
                  usedArea[k] = [];
                }

                usedArea[k][l] = true;
              }
            }
          }
        }
      }
    }

    var mergeArrayLength = mergeArray.length;

    for (mergeIndex = 0; mergeIndex < mergeArrayLength; mergeIndex++) {
      mergeXML = mergeXML + this._getXMLTag('mergeCell', [{
        name: 'ref',
        value: mergeArray[mergeIndex].start + ':' + mergeArray[mergeIndex].end
      }]);
    }

    return mergeXML.length ? this._getXMLTag('mergeCells', [{
      name: 'count',
      value: mergeArrayLength
    }], mergeXML) : '';
  },
  _generateCommonXML: function _generateCommonXML() {
    var relsFileContent = XML_TAG + this._createXMLRelationships(this._createXMLRelationship(1, 'officeDocument', 'xl/' + WORKBOOK_FILE_NAME));

    var folder = this._zip.folder(XL_FOLDER_NAME);

    var relsXML = XML_TAG;

    this._zip.folder('_' + RELATIONSHIP_PART_NAME).file('.' + RELATIONSHIP_PART_NAME, relsFileContent);

    var xmlRelationships = this._createXMLRelationship(1, 'worksheet', 'worksheets/' + WORKSHEET_FILE_NAME) + this._createXMLRelationship(2, 'styles', STYLE_FILE_NAME) + this._createXMLRelationship(3, 'sharedStrings', SHAREDSTRING_FILE_NAME);

    relsXML = relsXML + this._createXMLRelationships(xmlRelationships);
    folder.folder('_' + RELATIONSHIP_PART_NAME).file(WORKBOOK_FILE_NAME + '.rels', relsXML);
    folder.file(WORKBOOK_FILE_NAME, this._getWorkbookContent());

    this._zip.file(CONTENTTYPES_FILE_NAME, this._getContentTypesContent());
  },
  _generateContent: function _generateContent() {
    this._prepareStyleData();

    this._prepareCellData();

    this._generateWorkXML();

    this._generateCommonXML();
  },
  _generateWorkXML: function _generateWorkXML() {
    this._generateStylesXML();

    this._generateStringsXML();

    this._generateWorksheetXML();
  },
  ctor: function ctor(dataProvider, options) {
    this._rtlEnabled = options && !!options.rtlEnabled;
    this._options = options;
    this._maxRowIndex = 0;
    this._maxColumnIndex = 0;
    this._stringArray = [];
    this._stringHash = {};
    this._styleArray = [];
    this._colsArray = [];
    this._cellsArray = [];
    this._needSheetPr = false;
    this._dataProvider = dataProvider;
    this._excelFile = new _excel.default();

    if ((0, _type.isDefined)(ExcelCreator.JSZip)) {
      this._zip = new ExcelCreator.JSZip();
    } else {
      this._zip = null;
    }
  },
  _checkZipState: function _checkZipState() {
    if (!this._zip) {
      throw _ui.default.Error('E1041', 'JSZip');
    }
  },
  ready: function ready() {
    return this._dataProvider.ready();
  },
  getData: function getData(isBlob) {
    var options = {
      type: isBlob ? 'blob' : 'base64',
      compression: 'DEFLATE',
      mimeType: _file_saver.MIME_TYPES['EXCEL']
    };
    var deferred = new _deferred.Deferred();

    this._checkZipState();

    this._generateContent();

    if (this._zip.generateAsync) {
      this._zip.generateAsync(options).then(deferred.resolve);
    } else {
      deferred.resolve(this._zip.generate(options));
    }

    return deferred;
  }
});

exports.ExcelCreator = ExcelCreator;
ExcelCreator.JSZip = _jszip.default;

function getData(data, options) {
  // TODO: Looks like there is no need to export ExcelCreator any more?
  var excelCreator = new ExcelCreator(data, options);

  excelCreator._checkZipState();

  return excelCreator.ready().then(function () {
    return excelCreator.getData((0, _type.isFunction)((0, _window.getWindow)().Blob));
  });
}

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _config = _interopRequireDefault(__webpack_require__(29));

var _core = _interopRequireDefault(__webpack_require__(85));

var _open_xml_currency_format = _interopRequireDefault(__webpack_require__(252));

var _accounting_formats = _interopRequireDefault(__webpack_require__(360));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* globals Intl */
var detectCurrencySymbolRegex = /([^\s0]+)?(\s*)0*[.,]*0*(\s*)([^\s0]+)?/;
var formattersCache = {};

var getFormatter = function getFormatter(format) {
  var key = _core.default.locale() + '/' + JSON.stringify(format);

  if (!formattersCache[key]) {
    formattersCache[key] = new Intl.NumberFormat(_core.default.locale(), format).format;
  }

  return formattersCache[key];
};

var getCurrencyFormatter = function getCurrencyFormatter(currency) {
  return new Intl.NumberFormat(_core.default.locale(), {
    style: 'currency',
    currency: currency
  });
};

var _default = {
  engine: function engine() {
    return 'intl';
  },
  _formatNumberCore: function _formatNumberCore(value, format, formatConfig) {
    if (format === 'exponential') {
      return this.callBase.apply(this, arguments);
    }

    return getFormatter(this._normalizeFormatConfig(format, formatConfig, value))(value);
  },
  _normalizeFormatConfig: function _normalizeFormatConfig(format, formatConfig, value) {
    var config;

    if (format === 'decimal') {
      config = {
        minimumIntegerDigits: formatConfig.precision || undefined,
        useGrouping: false,
        maximumFractionDigits: String(value).length,
        round: value < 0 ? 'ceil' : 'floor'
      };
    } else {
      config = this._getPrecisionConfig(formatConfig.precision);
    }

    if (format === 'percent') {
      config.style = 'percent';
    } else if (format === 'currency') {
      config.style = 'currency';
      config.currency = formatConfig.currency || (0, _config.default)().defaultCurrency;
    }

    return config;
  },
  _getPrecisionConfig: function _getPrecisionConfig(precision) {
    var config;

    if (precision === null) {
      config = {
        minimumFractionDigits: 0,
        maximumFractionDigits: 20
      };
    } else {
      config = {
        minimumFractionDigits: precision || 0,
        maximumFractionDigits: precision || 0
      };
    }

    return config;
  },
  format: function format(value, _format) {
    if ('number' !== typeof value) {
      return value;
    }

    _format = this._normalizeFormat(_format);

    if (_format.currency === 'default') {
      _format.currency = (0, _config.default)().defaultCurrency;
    }

    if (!_format || 'function' !== typeof _format && !_format.type && !_format.formatter) {
      return getFormatter(_format)(value);
    }

    return this.callBase.apply(this, arguments);
  },
  _getCurrencySymbolInfo: function _getCurrencySymbolInfo(currency) {
    var formatter = getCurrencyFormatter(currency);
    return this._extractCurrencySymbolInfo(formatter.format(0));
  },
  _extractCurrencySymbolInfo: function _extractCurrencySymbolInfo(currencyValueString) {
    var match = detectCurrencySymbolRegex.exec(currencyValueString) || [];
    var position = match[1] ? 'before' : 'after';
    var symbol = match[1] || match[4] || '';
    var delimiter = match[2] || match[3] || '';
    return {
      position: position,
      symbol: symbol,
      delimiter: delimiter
    };
  },
  getCurrencySymbol: function getCurrencySymbol(currency) {
    if (!currency) {
      currency = (0, _config.default)().defaultCurrency;
    }

    var symbolInfo = this._getCurrencySymbolInfo(currency);

    return {
      'symbol': symbolInfo.symbol
    };
  },
  getOpenXmlCurrencyFormat: function getOpenXmlCurrencyFormat(currency) {
    var targetCurrency = currency || (0, _config.default)().defaultCurrency;

    var currencySymbol = this._getCurrencySymbolInfo(targetCurrency).symbol;

    var closestAccountingFormat = _core.default.getValueByClosestLocale(function (locale) {
      return _accounting_formats.default[locale];
    });

    return (0, _open_xml_currency_format.default)(currencySymbol, closestAccountingFormat);
  }
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

/* eslint-disable node/no-unsupported-features/es-syntax */
// !!! AUTO-GENERATED FILE, DO NOT EDIT
var _default = {
  "en-150": "en-001",
  "en-AG": "en-001",
  "en-AI": "en-001",
  "en-AU": "en-001",
  "en-BB": "en-001",
  "en-BM": "en-001",
  "en-BS": "en-001",
  "en-BW": "en-001",
  "en-BZ": "en-001",
  "en-CA": "en-001",
  "en-CC": "en-001",
  "en-CK": "en-001",
  "en-CM": "en-001",
  "en-CX": "en-001",
  "en-CY": "en-001",
  "en-DG": "en-001",
  "en-DM": "en-001",
  "en-ER": "en-001",
  "en-FJ": "en-001",
  "en-FK": "en-001",
  "en-FM": "en-001",
  "en-GB": "en-001",
  "en-GD": "en-001",
  "en-GG": "en-001",
  "en-GH": "en-001",
  "en-GI": "en-001",
  "en-GM": "en-001",
  "en-GY": "en-001",
  "en-HK": "en-001",
  "en-IE": "en-001",
  "en-IL": "en-001",
  "en-IM": "en-001",
  "en-IN": "en-001",
  "en-IO": "en-001",
  "en-JE": "en-001",
  "en-JM": "en-001",
  "en-KE": "en-001",
  "en-KI": "en-001",
  "en-KN": "en-001",
  "en-KY": "en-001",
  "en-LC": "en-001",
  "en-LR": "en-001",
  "en-LS": "en-001",
  "en-MG": "en-001",
  "en-MO": "en-001",
  "en-MS": "en-001",
  "en-MT": "en-001",
  "en-MU": "en-001",
  "en-MW": "en-001",
  "en-MY": "en-001",
  "en-NA": "en-001",
  "en-NF": "en-001",
  "en-NG": "en-001",
  "en-NR": "en-001",
  "en-NU": "en-001",
  "en-NZ": "en-001",
  "en-PG": "en-001",
  "en-PH": "en-001",
  "en-PK": "en-001",
  "en-PN": "en-001",
  "en-PW": "en-001",
  "en-RW": "en-001",
  "en-SB": "en-001",
  "en-SC": "en-001",
  "en-SD": "en-001",
  "en-SG": "en-001",
  "en-SH": "en-001",
  "en-SL": "en-001",
  "en-SS": "en-001",
  "en-SX": "en-001",
  "en-SZ": "en-001",
  "en-TC": "en-001",
  "en-TK": "en-001",
  "en-TO": "en-001",
  "en-TT": "en-001",
  "en-TV": "en-001",
  "en-TZ": "en-001",
  "en-UG": "en-001",
  "en-VC": "en-001",
  "en-VG": "en-001",
  "en-VU": "en-001",
  "en-WS": "en-001",
  "en-ZA": "en-001",
  "en-ZM": "en-001",
  "en-ZW": "en-001",
  "en-AT": "en-150",
  "en-BE": "en-150",
  "en-CH": "en-150",
  "en-DE": "en-150",
  "en-DK": "en-150",
  "en-FI": "en-150",
  "en-NL": "en-150",
  "en-SE": "en-150",
  "en-SI": "en-150",
  "es-AR": "es-419",
  "es-BO": "es-419",
  "es-BR": "es-419",
  "es-BZ": "es-419",
  "es-CL": "es-419",
  "es-CO": "es-419",
  "es-CR": "es-419",
  "es-CU": "es-419",
  "es-DO": "es-419",
  "es-EC": "es-419",
  "es-GT": "es-419",
  "es-HN": "es-419",
  "es-MX": "es-419",
  "es-NI": "es-419",
  "es-PA": "es-419",
  "es-PE": "es-419",
  "es-PR": "es-419",
  "es-PY": "es-419",
  "es-SV": "es-419",
  "es-US": "es-419",
  "es-UY": "es-419",
  "es-VE": "es-419",
  "nb": "no",
  "nn": "no",
  "pt-AO": "pt-PT",
  "pt-CH": "pt-PT",
  "pt-CV": "pt-PT",
  "pt-FR": "pt-PT",
  "pt-GQ": "pt-PT",
  "pt-GW": "pt-PT",
  "pt-LU": "pt-PT",
  "pt-MO": "pt-PT",
  "pt-MZ": "pt-PT",
  "pt-ST": "pt-PT",
  "pt-TL": "pt-PT",
  "az-Arab": "root",
  "az-Cyrl": "root",
  "blt-Latn": "root",
  "bm-Nkoo": "root",
  "bs-Cyrl": "root",
  "byn-Latn": "root",
  "cu-Glag": "root",
  "dje-Arab": "root",
  "dyo-Arab": "root",
  "en-Dsrt": "root",
  "en-Shaw": "root",
  "ff-Adlm": "root",
  "ff-Arab": "root",
  "ha-Arab": "root",
  "hi-Latn": "root",
  "iu-Latn": "root",
  "kk-Arab": "root",
  "ks-Deva": "root",
  "ku-Arab": "root",
  "ky-Arab": "root",
  "ky-Latn": "root",
  "ml-Arab": "root",
  "mn-Mong": "root",
  "mni-Mtei": "root",
  "ms-Arab": "root",
  "pa-Arab": "root",
  "sat-Deva": "root",
  "sd-Deva": "root",
  "sd-Khoj": "root",
  "sd-Sind": "root",
  "shi-Latn": "root",
  "so-Arab": "root",
  "sr-Latn": "root",
  "sw-Arab": "root",
  "tg-Arab": "root",
  "ug-Cyrl": "root",
  "uz-Arab": "root",
  "uz-Cyrl": "root",
  "vai-Latn": "root",
  "wo-Arab": "root",
  "yo-Arab": "root",
  "yue-Hans": "root",
  "zh-Hant": "root",
  "zh-Hant-MO": "zh-Hant-HK"
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

/* eslint-disable import/no-commonjs */
var PARENT_LOCALE_SEPARATOR = '-';

var _default = function _default(parentLocales, locale) {
  var parentLocale = parentLocales[locale];

  if (parentLocale) {
    return parentLocale !== 'root' && parentLocale;
  }

  return locale.substr(0, locale.lastIndexOf(PARENT_LOCALE_SEPARATOR));
};

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

/* eslint-disable node/no-unsupported-features/es-syntax */
// !!! AUTO-GENERATED FILE, DO NOT EDIT
var _default = {
  "af": "#,##0.00;(#,##0.00)",
  "af-NA": "#,##0.00;(#,##0.00)",
  "agq": "#,##0.00",
  "ak": "#,##0.00",
  "am": "#,##0.00;(#,##0.00)",
  "ar": "#,##0.00;(#,##0.00)",
  "ar-AE": "#,##0.00;(#,##0.00)",
  "ar-BH": "#,##0.00;(#,##0.00)",
  "ar-DJ": "#,##0.00;(#,##0.00)",
  "ar-DZ": "#,##0.00;(#,##0.00)",
  "ar-EG": "#,##0.00;(#,##0.00)",
  "ar-EH": "#,##0.00;(#,##0.00)",
  "ar-ER": "#,##0.00;(#,##0.00)",
  "ar-IL": "#,##0.00;(#,##0.00)",
  "ar-IQ": "#,##0.00;(#,##0.00)",
  "ar-JO": "#,##0.00;(#,##0.00)",
  "ar-KM": "#,##0.00;(#,##0.00)",
  "ar-KW": "#,##0.00;(#,##0.00)",
  "ar-LB": "#,##0.00;(#,##0.00)",
  "ar-LY": "#,##0.00;(#,##0.00)",
  "ar-MA": "#,##0.00;(#,##0.00)",
  "ar-MR": "#,##0.00;(#,##0.00)",
  "ar-OM": "#,##0.00;(#,##0.00)",
  "ar-PS": "#,##0.00;(#,##0.00)",
  "ar-QA": "#,##0.00;(#,##0.00)",
  "ar-SA": "#,##0.00;(#,##0.00)",
  "ar-SD": "#,##0.00;(#,##0.00)",
  "ar-SO": "#,##0.00;(#,##0.00)",
  "ar-SS": "#,##0.00;(#,##0.00)",
  "ar-SY": "#,##0.00;(#,##0.00)",
  "ar-TD": "#,##0.00;(#,##0.00)",
  "ar-TN": "#,##0.00;(#,##0.00)",
  "ar-YE": "#,##0.00;(#,##0.00)",
  "as": "#,##,##0.00",
  "asa": "#,##0.00",
  "ast": "#,##0.00",
  "az": "#,##0.00",
  "az-Cyrl": "#,##0.00",
  "az-Latn": "#,##0.00",
  "bas": "#,##0.00",
  "be": "#,##0.00",
  "bem": "#,##0.00;(#,##0.00)",
  "bez": "#,##0.00",
  "bg": "0.00;(0.00)",
  "bm": "#,##0.00;(#,##0.00)",
  "bn": "#,##,##0.00;(#,##,##0.00)",
  "bn-IN": "#,##,##0.00;(#,##,##0.00)",
  "bo": "#,##0.00",
  "bo-IN": "#,##0.00",
  "br": "#,##0.00",
  "brx": "#,##,##0.00",
  "bs": "#,##0.00",
  "bs-Cyrl": "#,##0.00",
  "bs-Latn": "#,##0.00",
  "ca": "#,##0.00;(#,##0.00)",
  "ca-AD": "#,##0.00;(#,##0.00)",
  "ca-ES-VALENCIA": "#,##0.00;(#,##0.00)",
  "ca-FR": "#,##0.00;(#,##0.00)",
  "ca-IT": "#,##0.00;(#,##0.00)",
  "ccp": "#,##,##0.00;(#,##,##0.00)",
  "ccp-IN": "#,##,##0.00;(#,##,##0.00)",
  "ce": "#,##0.00",
  "ceb": "#,##0.00;(#,##0.00)",
  "cgg": "#,##0.00",
  "chr": "#,##0.00;(#,##0.00)",
  "ckb": "#,##0.00",
  "ckb-IR": "#,##0.00",
  "cs": "#,##0.00",
  "cy": "#,##0.00;(#,##0.00)",
  "da": "#,##0.00",
  "da-GL": "#,##0.00",
  "dav": "#,##0.00;(#,##0.00)",
  "de": "#,##0.00",
  "de-AT": "#,##0.00",
  "de-BE": "#,##0.00",
  "de-CH": "#,##0.00",
  "de-IT": "#,##0.00",
  "de-LI": "#,##0.00",
  "de-LU": "#,##0.00",
  "dje": "#,##0.00",
  "doi": "#,##0.00",
  "dsb": "#,##0.00",
  "dua": "#,##0.00",
  "dyo": "#,##0.00",
  "dz": "#,##,##0.00",
  "ebu": "#,##0.00;(#,##0.00)",
  "ee": "#,##0.00;(#,##0.00)",
  "ee-TG": "#,##0.00;(#,##0.00)",
  "el": "#,##0.00",
  "el-CY": "#,##0.00",
  "en": "#,##0.00;(#,##0.00)",
  "en-001": "#,##0.00;(#,##0.00)",
  "en-150": "#,##0.00",
  "en-AE": "#,##0.00;(#,##0.00)",
  "en-AG": "#,##0.00;(#,##0.00)",
  "en-AI": "#,##0.00;(#,##0.00)",
  "en-AS": "#,##0.00;(#,##0.00)",
  "en-AT": "#,##0.00",
  "en-AU": "#,##0.00;(#,##0.00)",
  "en-BB": "#,##0.00;(#,##0.00)",
  "en-BE": "#,##0.00",
  "en-BI": "#,##0.00;(#,##0.00)",
  "en-BM": "#,##0.00;(#,##0.00)",
  "en-BS": "#,##0.00;(#,##0.00)",
  "en-BW": "#,##0.00;(#,##0.00)",
  "en-BZ": "#,##0.00;(#,##0.00)",
  "en-CA": "#,##0.00;(#,##0.00)",
  "en-CC": "#,##0.00;(#,##0.00)",
  "en-CH": "#,##0.00;-#,##0.00",
  "en-CK": "#,##0.00;(#,##0.00)",
  "en-CM": "#,##0.00;(#,##0.00)",
  "en-CX": "#,##0.00;(#,##0.00)",
  "en-CY": "#,##0.00;(#,##0.00)",
  "en-DE": "#,##0.00",
  "en-DG": "#,##0.00;(#,##0.00)",
  "en-DK": "#,##0.00",
  "en-DM": "#,##0.00;(#,##0.00)",
  "en-ER": "#,##0.00;(#,##0.00)",
  "en-FI": "#,##0.00",
  "en-FJ": "#,##0.00;(#,##0.00)",
  "en-FK": "#,##0.00;(#,##0.00)",
  "en-FM": "#,##0.00;(#,##0.00)",
  "en-GB": "#,##0.00;(#,##0.00)",
  "en-GD": "#,##0.00;(#,##0.00)",
  "en-GG": "#,##0.00;(#,##0.00)",
  "en-GH": "#,##0.00;(#,##0.00)",
  "en-GI": "#,##0.00;(#,##0.00)",
  "en-GM": "#,##0.00;(#,##0.00)",
  "en-GU": "#,##0.00;(#,##0.00)",
  "en-GY": "#,##0.00;(#,##0.00)",
  "en-HK": "#,##0.00;(#,##0.00)",
  "en-IE": "#,##0.00;(#,##0.00)",
  "en-IL": "#,##0.00;(#,##0.00)",
  "en-IM": "#,##0.00;(#,##0.00)",
  "en-IN": "#,##0.00;(#,##0.00)",
  "en-IO": "#,##0.00;(#,##0.00)",
  "en-JE": "#,##0.00;(#,##0.00)",
  "en-JM": "#,##0.00;(#,##0.00)",
  "en-KE": "#,##0.00;(#,##0.00)",
  "en-KI": "#,##0.00;(#,##0.00)",
  "en-KN": "#,##0.00;(#,##0.00)",
  "en-KY": "#,##0.00;(#,##0.00)",
  "en-LC": "#,##0.00;(#,##0.00)",
  "en-LR": "#,##0.00;(#,##0.00)",
  "en-LS": "#,##0.00;(#,##0.00)",
  "en-MG": "#,##0.00;(#,##0.00)",
  "en-MH": "#,##0.00;(#,##0.00)",
  "en-MO": "#,##0.00;(#,##0.00)",
  "en-MP": "#,##0.00;(#,##0.00)",
  "en-MS": "#,##0.00;(#,##0.00)",
  "en-MT": "#,##0.00;(#,##0.00)",
  "en-MU": "#,##0.00;(#,##0.00)",
  "en-MW": "#,##0.00;(#,##0.00)",
  "en-MY": "#,##0.00;(#,##0.00)",
  "en-NA": "#,##0.00;(#,##0.00)",
  "en-NF": "#,##0.00;(#,##0.00)",
  "en-NG": "#,##0.00;(#,##0.00)",
  "en-NL": "#,##0.00;(#,##0.00)",
  "en-NR": "#,##0.00;(#,##0.00)",
  "en-NU": "#,##0.00;(#,##0.00)",
  "en-NZ": "#,##0.00;(#,##0.00)",
  "en-PG": "#,##0.00;(#,##0.00)",
  "en-PH": "#,##0.00;(#,##0.00)",
  "en-PK": "#,##0.00;(#,##0.00)",
  "en-PN": "#,##0.00;(#,##0.00)",
  "en-PR": "#,##0.00;(#,##0.00)",
  "en-PW": "#,##0.00;(#,##0.00)",
  "en-RW": "#,##0.00;(#,##0.00)",
  "en-SB": "#,##0.00;(#,##0.00)",
  "en-SC": "#,##0.00;(#,##0.00)",
  "en-SD": "#,##0.00;(#,##0.00)",
  "en-SE": "#,##0.00",
  "en-SG": "#,##0.00;(#,##0.00)",
  "en-SH": "#,##0.00;(#,##0.00)",
  "en-SI": "#,##0.00;(#,##0.00)",
  "en-SL": "#,##0.00;(#,##0.00)",
  "en-SS": "#,##0.00;(#,##0.00)",
  "en-SX": "#,##0.00;(#,##0.00)",
  "en-SZ": "#,##0.00;(#,##0.00)",
  "en-TC": "#,##0.00;(#,##0.00)",
  "en-TK": "#,##0.00;(#,##0.00)",
  "en-TO": "#,##0.00;(#,##0.00)",
  "en-TT": "#,##0.00;(#,##0.00)",
  "en-TV": "#,##0.00;(#,##0.00)",
  "en-TZ": "#,##0.00;(#,##0.00)",
  "en-UG": "#,##0.00;(#,##0.00)",
  "en-UM": "#,##0.00;(#,##0.00)",
  "en-US-POSIX": "#,##0.00;(#,##0.00)",
  "en-VC": "#,##0.00;(#,##0.00)",
  "en-VG": "#,##0.00;(#,##0.00)",
  "en-VI": "#,##0.00;(#,##0.00)",
  "en-VU": "#,##0.00;(#,##0.00)",
  "en-WS": "#,##0.00;(#,##0.00)",
  "en-ZA": "#,##0.00;(#,##0.00)",
  "en-ZM": "#,##0.00;(#,##0.00)",
  "en-ZW": "#,##0.00;(#,##0.00)",
  "eo": "#,##0.00",
  "es": "#,##0.00",
  "es-419": "#,##0.00",
  "es-AR": "#,##0.00;(#,##0.00)",
  "es-BO": "#,##0.00",
  "es-BR": "#,##0.00",
  "es-BZ": "#,##0.00",
  "es-CL": "#,##0.00",
  "es-CO": "#,##0.00",
  "es-CR": "#,##0.00",
  "es-CU": "#,##0.00",
  "es-DO": "#,##0.00;(#,##0.00)",
  "es-EA": "#,##0.00",
  "es-EC": "#,##0.00",
  "es-GQ": "#,##0.00",
  "es-GT": "#,##0.00",
  "es-HN": "#,##0.00",
  "es-IC": "#,##0.00",
  "es-MX": "#,##0.00",
  "es-NI": "#,##0.00",
  "es-PA": "#,##0.00",
  "es-PE": "#,##0.00",
  "es-PH": "#,##0.00",
  "es-PR": "#,##0.00",
  "es-PY": "#,##0.00",
  "es-SV": "#,##0.00",
  "es-US": "#,##0.00",
  "es-UY": "#,##0.00;(#,##0.00)",
  "es-VE": "#,##0.00",
  "et": "#,##0.00;(#,##0.00)",
  "eu": "#,##0.00;(#,##0.00)",
  "ewo": "#,##0.00",
  "fa": "#,##0.00;(#,##0.00)",
  "fa-AF": "#,##0.00;(#,##0.00)",
  "ff": "#,##0.00",
  "ff-Adlm": "#,##0.00",
  "ff-Adlm-BF": "#,##0.00",
  "ff-Adlm-CM": "#,##0.00",
  "ff-Adlm-GH": "#,##0.00",
  "ff-Adlm-GM": "#,##0.00",
  "ff-Adlm-GW": "#,##0.00",
  "ff-Adlm-LR": "#,##0.00",
  "ff-Adlm-MR": "#,##0.00",
  "ff-Adlm-NE": "#,##0.00",
  "ff-Adlm-NG": "#,##0.00",
  "ff-Adlm-SL": "#,##0.00",
  "ff-Adlm-SN": "#,##0.00",
  "ff-Latn": "#,##0.00",
  "ff-Latn-BF": "#,##0.00",
  "ff-Latn-CM": "#,##0.00",
  "ff-Latn-GH": "#,##0.00",
  "ff-Latn-GM": "#,##0.00",
  "ff-Latn-GN": "#,##0.00",
  "ff-Latn-GW": "#,##0.00",
  "ff-Latn-LR": "#,##0.00",
  "ff-Latn-MR": "#,##0.00",
  "ff-Latn-NE": "#,##0.00",
  "ff-Latn-NG": "#,##0.00",
  "ff-Latn-SL": "#,##0.00",
  "fi": "#,##0.00",
  "fil": "#,##0.00;(#,##0.00)",
  "fo": "#,##0.00;(#,##0.00)",
  "fo-DK": "#,##0.00;(#,##0.00)",
  "fr": "#,##0.00;(#,##0.00)",
  "fr-BE": "#,##0.00;(#,##0.00)",
  "fr-BF": "#,##0.00;(#,##0.00)",
  "fr-BI": "#,##0.00;(#,##0.00)",
  "fr-BJ": "#,##0.00;(#,##0.00)",
  "fr-BL": "#,##0.00;(#,##0.00)",
  "fr-CA": "#,##0.00;(#,##0.00)",
  "fr-CD": "#,##0.00;(#,##0.00)",
  "fr-CF": "#,##0.00;(#,##0.00)",
  "fr-CG": "#,##0.00;(#,##0.00)",
  "fr-CH": "#,##0.00;(#,##0.00)",
  "fr-CI": "#,##0.00;(#,##0.00)",
  "fr-CM": "#,##0.00;(#,##0.00)",
  "fr-DJ": "#,##0.00;(#,##0.00)",
  "fr-DZ": "#,##0.00;(#,##0.00)",
  "fr-GA": "#,##0.00;(#,##0.00)",
  "fr-GF": "#,##0.00;(#,##0.00)",
  "fr-GN": "#,##0.00;(#,##0.00)",
  "fr-GP": "#,##0.00;(#,##0.00)",
  "fr-GQ": "#,##0.00;(#,##0.00)",
  "fr-HT": "#,##0.00;(#,##0.00)",
  "fr-KM": "#,##0.00;(#,##0.00)",
  "fr-LU": "#,##0.00;(#,##0.00)",
  "fr-MA": "#,##0.00;(#,##0.00)",
  "fr-MC": "#,##0.00;(#,##0.00)",
  "fr-MF": "#,##0.00;(#,##0.00)",
  "fr-MG": "#,##0.00;(#,##0.00)",
  "fr-ML": "#,##0.00;(#,##0.00)",
  "fr-MQ": "#,##0.00;(#,##0.00)",
  "fr-MR": "#,##0.00;(#,##0.00)",
  "fr-MU": "#,##0.00;(#,##0.00)",
  "fr-NC": "#,##0.00;(#,##0.00)",
  "fr-NE": "#,##0.00;(#,##0.00)",
  "fr-PF": "#,##0.00;(#,##0.00)",
  "fr-PM": "#,##0.00;(#,##0.00)",
  "fr-RE": "#,##0.00;(#,##0.00)",
  "fr-RW": "#,##0.00;(#,##0.00)",
  "fr-SC": "#,##0.00;(#,##0.00)",
  "fr-SN": "#,##0.00;(#,##0.00)",
  "fr-SY": "#,##0.00;(#,##0.00)",
  "fr-TD": "#,##0.00;(#,##0.00)",
  "fr-TG": "#,##0.00;(#,##0.00)",
  "fr-TN": "#,##0.00;(#,##0.00)",
  "fr-VU": "#,##0.00;(#,##0.00)",
  "fr-WF": "#,##0.00;(#,##0.00)",
  "fr-YT": "#,##0.00;(#,##0.00)",
  "fur": "#,##0.00",
  "fy": "#,##0.00;(#,##0.00)",
  "ga": "#,##0.00;(#,##0.00)",
  "ga-GB": "#,##0.00;(#,##0.00)",
  "gd": "#,##0.00;(#,##0.00)",
  "gl": "#,##0.00",
  "gsw": "#,##0.00",
  "gsw-FR": "#,##0.00",
  "gsw-LI": "#,##0.00",
  "gu": "#,##,##0.00;(#,##,##0.00)",
  "guz": "#,##0.00;(#,##0.00)",
  "gv": "#,##0.00",
  "ha": "#,##0.00",
  "ha-GH": "#,##0.00",
  "ha-NE": "#,##0.00",
  "haw": "#,##0.00;(#,##0.00)",
  "he": "#,##0.00",
  "hi": "#,##,##0.00",
  "hr": "#,##0.00",
  "hr-BA": "#,##0.00",
  "hsb": "#,##0.00",
  "hu": "#,##0.00",
  "hy": "#,##0.00",
  "ia": "#,##0.00;(#,##0.00)",
  "id": "#,##0.00",
  "ig": "#,##0.00;(#,##0.00)",
  "ii": "#,##0.00",
  "is": "#,##0.00",
  "it": "#,##0.00",
  "it-CH": "#,##0.00",
  "it-SM": "#,##0.00",
  "it-VA": "#,##0.00",
  "ja": "#,##0.00;(#,##0.00)",
  "jgo": "#,##0.00",
  "jmc": "#,##0.00",
  "jv": "#,##0.00",
  "ka": "#,##0.00",
  "kab": "#,##0.00",
  "kam": "#,##0.00;(#,##0.00)",
  "kde": "#,##0.00;(#,##0.00)",
  "kea": "#,##0.00;(#,##0.00)",
  "khq": "#,##0.00",
  "ki": "#,##0.00;(#,##0.00)",
  "kk": "#,##0.00",
  "kkj": "#,##0.00",
  "kl": "#,##0.00;-#,##0.00",
  "kln": "#,##0.00;(#,##0.00)",
  "km": "#,##0.00;(#,##0.00)",
  "kn": "#,##0.00;(#,##0.00)",
  "ko": "#,##0.00;(#,##0.00)",
  "ko-KP": "#,##0.00;(#,##0.00)",
  "kok": "#,##0.00;(#,##0.00)",
  "ks": "#,##,##0.00",
  "ks-Arab": "#,##,##0.00",
  "ksb": "#,##0.00",
  "ksf": "#,##0.00",
  "ksh": "#,##0.00",
  "ku": "#,##0.00;(#,##0.00)",
  "kw": "#,##0.00",
  "ky": "#,##0.00",
  "lag": "#,##0.00",
  "lb": "#,##0.00",
  "lg": "#,##0.00",
  "lkt": "#,##0.00",
  "ln": "#,##0.00",
  "ln-AO": "#,##0.00",
  "ln-CF": "#,##0.00",
  "ln-CG": "#,##0.00",
  "lo": "#,##0.00;-#,##0.00",
  "lrc": "#,##0.00",
  "lrc-IQ": "#,##0.00",
  "lt": "#,##0.00",
  "lu": "#,##0.00",
  "luo": "#,##0.00",
  "luy": "#,##0.00;-#,##0.00",
  "lv": "#,##0.00",
  "mai": "#,##0.00",
  "mas": "#,##0.00;(#,##0.00)",
  "mas-TZ": "#,##0.00;(#,##0.00)",
  "mer": "#,##0.00;(#,##0.00)",
  "mfe": "#,##0.00",
  "mg": "#,##0.00",
  "mgh": "#,##0.00",
  "mgo": "#,##0.00",
  "mi": "#,##0.00",
  "mk": "#,##0.00",
  "ml": "#,##0.00;(#,##0.00)",
  "mn": "#,##0.00",
  "mni": "#,##0.00",
  "mni-Beng": "#,##0.00",
  "mr": "#,##0.00;(#,##0.00)",
  "ms": "#,##0.00;(#,##0.00)",
  "ms-BN": "#,##0.00;(#,##0.00)",
  "ms-ID": "#,##0.00",
  "ms-SG": "#,##0.00;(#,##0.00)",
  "mt": "#,##0.00",
  "mua": "#,##0.00;(#,##0.00)",
  "my": "#,##0.00",
  "mzn": "#,##0.00",
  "naq": "#,##0.00",
  "nb": "#,##0.00",
  "nb-SJ": "#,##0.00",
  "nd": "#,##0.00;(#,##0.00)",
  "nds": "#,##0.00",
  "nds-NL": "#,##0.00",
  "ne": "#,##,##0.00",
  "ne-IN": "#,##,##0.00",
  "nl": "#,##0.00;(#,##0.00)",
  "nl-AW": "#,##0.00;(#,##0.00)",
  "nl-BE": "#,##0.00;(#,##0.00)",
  "nl-BQ": "#,##0.00;(#,##0.00)",
  "nl-CW": "#,##0.00;(#,##0.00)",
  "nl-SR": "#,##0.00;(#,##0.00)",
  "nl-SX": "#,##0.00;(#,##0.00)",
  "nmg": "#,##0.00",
  "nn": "#,##0.00",
  "nnh": "#,##0.00",
  "no": "#,##0.00",
  "nus": "#,##0.00;(#,##0.00)",
  "nyn": "#,##0.00",
  "om": "#,##0.00",
  "om-KE": "#,##0.00",
  "or": "#,##0.00;(#,##0.00)",
  "os": "#,##0.00",
  "os-RU": "#,##0.00",
  "pa": "#,##0.00",
  "pa-Arab": "#,##0.00",
  "pa-Guru": "#,##0.00",
  "pcm": "#,##0.00",
  "pl": "#,##0.00;(#,##0.00)",
  "ps": "#,##0.00;(#,##0.00)",
  "ps-PK": "#,##0.00;(#,##0.00)",
  "pt": "#,##0.00",
  "pt-AO": "#,##0.00;(#,##0.00)",
  "pt-CH": "#,##0.00;(#,##0.00)",
  "pt-CV": "#,##0.00;(#,##0.00)",
  "pt-GQ": "#,##0.00;(#,##0.00)",
  "pt-GW": "#,##0.00;(#,##0.00)",
  "pt-LU": "#,##0.00;(#,##0.00)",
  "pt-MO": "#,##0.00;(#,##0.00)",
  "pt-MZ": "#,##0.00;(#,##0.00)",
  "pt-PT": "#,##0.00;(#,##0.00)",
  "pt-ST": "#,##0.00;(#,##0.00)",
  "pt-TL": "#,##0.00;(#,##0.00)",
  "qu": "#,##0.00",
  "qu-BO": "#,##0.00",
  "qu-EC": "#,##0.00",
  "rm": "#,##0.00",
  "rn": "#,##0.00",
  "ro": "#,##0.00;(#,##0.00)",
  "ro-MD": "#,##0.00;(#,##0.00)",
  "rof": "#,##0.00",
  "root": "#,##0.00",
  "ru": "#,##0.00",
  "ru-BY": "#,##0.00",
  "ru-KG": "#,##0.00",
  "ru-KZ": "#,##0.00",
  "ru-MD": "#,##0.00",
  "ru-UA": "#,##0.00",
  "rw": "#,##0.00",
  "rwk": "#,##0.00",
  "sa": "#,##0.00",
  "sah": "#,##0.00",
  "saq": "#,##0.00;(#,##0.00)",
  "sat": "#,##0.00",
  "sat-Olck": "#,##0.00",
  "sbp": "#,##0.00",
  "sd": "#,##0.00",
  "sd-Arab": "#,##0.00",
  "sd-Deva": "#,##0.00",
  "se": "#,##0.00",
  "se-FI": "#,##0.00",
  "se-SE": "#,##0.00",
  "seh": "#,##0.00",
  "ses": "#,##0.00",
  "sg": "#,##0.00;-#,##0.00",
  "shi": "#,##0.00",
  "shi-Latn": "#,##0.00",
  "shi-Tfng": "#,##0.00",
  "si": "#,##0.00;(#,##0.00)",
  "sk": "#,##0.00;(#,##0.00)",
  "sl": "#,##0.00;(#,##0.00)",
  "smn": "#,##0.00",
  "sn": "#,##0.00;(#,##0.00)",
  "so": "#,##0.00;(#,##0.00)",
  "so-DJ": "#,##0.00;(#,##0.00)",
  "so-ET": "#,##0.00;(#,##0.00)",
  "so-KE": "#,##0.00;(#,##0.00)",
  "sq": "#,##0.00;(#,##0.00)",
  "sq-MK": "#,##0.00;(#,##0.00)",
  "sq-XK": "#,##0.00;(#,##0.00)",
  "sr": "#,##0.00;(#,##0.00)",
  "sr-Cyrl": "#,##0.00;(#,##0.00)",
  "sr-Cyrl-BA": "#,##0.00;(#,##0.00)",
  "sr-Cyrl-ME": "#,##0.00;(#,##0.00)",
  "sr-Cyrl-XK": "#,##0.00;(#,##0.00)",
  "sr-Latn": "#,##0.00;(#,##0.00)",
  "sr-Latn-BA": "#,##0.00;(#,##0.00)",
  "sr-Latn-ME": "#,##0.00;(#,##0.00)",
  "sr-Latn-XK": "#,##0.00;(#,##0.00)",
  "su": "#,##0.00",
  "su-Latn": "#,##0.00",
  "sv": "#,##0.00",
  "sv-AX": "#,##0.00",
  "sv-FI": "#,##0.00",
  "sw": "#,##0.00",
  "sw-CD": "#,##0.00",
  "sw-KE": "#,##0.00",
  "sw-UG": "#,##0.00",
  "ta": "#,##0.00;(#,##0.00)",
  "ta-LK": "#,##0.00;(#,##0.00)",
  "ta-MY": "#,##0.00;(#,##0.00)",
  "ta-SG": "#,##0.00;(#,##0.00)",
  "te": "#,##0.00;(#,##0.00)",
  "teo": "#,##0.00;(#,##0.00)",
  "teo-KE": "#,##0.00;(#,##0.00)",
  "tg": "#,##0.00",
  "th": "#,##0.00;(#,##0.00)",
  "ti": "#,##0.00",
  "ti-ER": "#,##0.00",
  "tk": "#,##0.00",
  "to": "#,##0.00",
  "tr": "#,##0.00;(#,##0.00)",
  "tr-CY": "#,##0.00;(#,##0.00)",
  "tt": "#,##0.00",
  "twq": "#,##0.00",
  "tzm": "#,##0.00",
  "ug": "#,##0.00;(#,##0.00)",
  "uk": "#,##0.00",
  "ur": "#,##0.00;(#,##0.00)",
  "ur-IN": "#,##0.00;(#,##0.00)",
  "uz": "#,##0.00",
  "uz-Arab": "#,##0.00",
  "uz-Cyrl": "#,##0.00",
  "uz-Latn": "#,##0.00",
  "vai": "#,##0.00;(#,##0.00)",
  "vai-Latn": "#,##0.00;(#,##0.00)",
  "vai-Vaii": "#,##0.00;(#,##0.00)",
  "vi": "#,##0.00",
  "vun": "#,##0.00",
  "wae": "#,##0.00",
  "wo": "#,##0.00",
  "xh": "#,##0.00",
  "xog": "#,##0.00",
  "yav": "#,##0.00;(#,##0.00)",
  "yi": "#,##0.00",
  "yo": "#,##0.00;(#,##0.00)",
  "yo-BJ": "#,##0.00;(#,##0.00)",
  "yue": "#,##0.00;(#,##0.00)",
  "yue-Hans": "#,##0.00;(#,##0.00)",
  "yue-Hant": "#,##0.00;(#,##0.00)",
  "zgh": "#,##0.00",
  "zh": "#,##0.00;(#,##0.00)",
  "zh-Hans": "#,##0.00;(#,##0.00)",
  "zh-Hans-HK": "#,##0.00;(#,##0.00)",
  "zh-Hans-MO": "#,##0.00;(#,##0.00)",
  "zh-Hans-SG": "#,##0.00;(#,##0.00)",
  "zh-Hant": "#,##0.00;(#,##0.00)",
  "zh-Hant-HK": "#,##0.00;(#,##0.00)",
  "zh-Hant-MO": "#,##0.00;(#,##0.00)",
  "zu": "#,##0.00;(#,##0.00)"
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

/* eslint-disable node/no-unsupported-features/es-syntax */
// !!! AUTO-GENERATED FILE, DO NOT EDIT
var _default = {
  "af-NA": 1,
  "agq": 1,
  "ak": 1,
  "ar": 6,
  "ar-EH": 1,
  "ar-ER": 1,
  "ar-KM": 1,
  "ar-LB": 1,
  "ar-MA": 1,
  "ar-MR": 1,
  "ar-PS": 1,
  "ar-SO": 1,
  "ar-SS": 1,
  "ar-TD": 1,
  "ar-TN": 1,
  "asa": 1,
  "ast": 1,
  "az": 1,
  "az-Cyrl": 1,
  "bas": 1,
  "be": 1,
  "bem": 1,
  "bez": 1,
  "bg": 1,
  "bm": 1,
  "br": 1,
  "bs": 1,
  "bs-Cyrl": 1,
  "ca": 1,
  "ce": 1,
  "cgg": 1,
  "ckb": 6,
  "cs": 1,
  "cy": 1,
  "da": 1,
  "de": 1,
  "dje": 1,
  "dsb": 1,
  "dua": 1,
  "dyo": 1,
  "ee": 1,
  "el": 1,
  "en-001": 1,
  "en-AE": 6,
  "en-BI": 1,
  "en-MP": 1,
  "en-SD": 6,
  "eo": 1,
  "es": 1,
  "et": 1,
  "eu": 1,
  "ewo": 1,
  "fa": 6,
  "ff": 1,
  "ff-Adlm": 1,
  "fi": 1,
  "fo": 1,
  "fr": 1,
  "fr-DJ": 6,
  "fr-DZ": 6,
  "fr-SY": 6,
  "fur": 1,
  "fy": 1,
  "ga": 1,
  "gd": 1,
  "gl": 1,
  "gsw": 1,
  "gv": 1,
  "ha": 1,
  "hr": 1,
  "hsb": 1,
  "hu": 1,
  "hy": 1,
  "ia": 1,
  "ig": 1,
  "is": 1,
  "it": 1,
  "jgo": 1,
  "jmc": 1,
  "ka": 1,
  "kab": 6,
  "kde": 1,
  "kea": 1,
  "khq": 1,
  "kk": 1,
  "kkj": 1,
  "kl": 1,
  "ko-KP": 1,
  "ksb": 1,
  "ksf": 1,
  "ksh": 1,
  "ku": 1,
  "kw": 1,
  "ky": 1,
  "lag": 1,
  "lb": 1,
  "lg": 1,
  "ln": 1,
  "lrc": 6,
  "lt": 1,
  "lu": 1,
  "lv": 1,
  "mas-TZ": 1,
  "mfe": 1,
  "mg": 1,
  "mgo": 1,
  "mi": 1,
  "mk": 1,
  "mn": 1,
  "ms": 1,
  "mua": 1,
  "mzn": 6,
  "naq": 1,
  "nds": 1,
  "nl": 1,
  "nmg": 1,
  "nnh": 1,
  "no": 1,
  "nus": 1,
  "nyn": 1,
  "os": 1,
  "pcm": 1,
  "pl": 1,
  "ps": 6,
  "pt-AO": 1,
  "pt-CH": 1,
  "pt-CV": 1,
  "pt-GQ": 1,
  "pt-GW": 1,
  "pt-LU": 1,
  "pt-ST": 1,
  "pt-TL": 1,
  "qu-BO": 1,
  "qu-EC": 1,
  "rm": 1,
  "rn": 1,
  "ro": 1,
  "rof": 1,
  "ru": 1,
  "rw": 1,
  "rwk": 1,
  "sah": 1,
  "sbp": 1,
  "se": 1,
  "ses": 1,
  "sg": 1,
  "shi": 1,
  "shi-Latn": 1,
  "si": 1,
  "sk": 1,
  "sl": 1,
  "smn": 1,
  "so": 1,
  "so-DJ": 6,
  "sq": 1,
  "sr": 1,
  "sr-Latn": 1,
  "sv": 1,
  "sw": 1,
  "ta-LK": 1,
  "ta-MY": 1,
  "teo": 1,
  "tg": 1,
  "ti-ER": 1,
  "tk": 1,
  "to": 1,
  "tr": 1,
  "tt": 1,
  "twq": 1,
  "tzm": 1,
  "uk": 1,
  "uz": 1,
  "uz-Arab": 6,
  "uz-Cyrl": 1,
  "vai": 1,
  "vai-Latn": 1,
  "vi": 1,
  "vun": 1,
  "wae": 1,
  "wo": 1,
  "xog": 1,
  "yav": 1,
  "yi": 1,
  "yo": 1,
  "zgh": 1
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _extend = __webpack_require__(0);

var _core = _interopRequireDefault(__webpack_require__(85));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var SYMBOLS_TO_REMOVE_REGEX = /[\u200E\u200F]/g;

var getIntlFormatter = function getIntlFormatter(format) {
  return function (date) {
    // NOTE: Intl in some browsers formates dates with timezone offset which was at the moment for this date.
    // But the method "new Date" creates date using current offset. So, we decided to format dates in the UTC timezone.
    if (!format.timeZoneName) {
      var year = date.getFullYear(); // NOTE: new Date(99,0,1) will return 1999 year, but 99 expected

      var recognizableAsTwentyCentury = String(year).length < 3;
      var safeYearShift = 400;
      var temporaryYearValue = recognizableAsTwentyCentury ? year + safeYearShift : year;
      var utcDate = new Date(Date.UTC(temporaryYearValue, date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));

      if (recognizableAsTwentyCentury) {
        utcDate.setFullYear(year);
      }

      var utcFormat = (0, _extend.extend)({
        timeZone: 'UTC'
      }, format);
      return formatDateTime(utcDate, utcFormat);
    }

    return formatDateTime(date, format);
  };
};

var formattersCache = {};

var getFormatter = function getFormatter(format) {
  var key = _core.default.locale() + '/' + JSON.stringify(format);

  if (!formattersCache[key]) {
    formattersCache[key] = new Intl.DateTimeFormat(_core.default.locale(), format).format;
  }

  return formattersCache[key];
};

function formatDateTime(date, format) {
  return getFormatter(format)(date).replace(SYMBOLS_TO_REMOVE_REGEX, '');
}

var formatNumber = function formatNumber(number) {
  return new Intl.NumberFormat(_core.default.locale()).format(number);
};

var getAlternativeNumeralsMap = function () {
  var numeralsMapCache = {};
  return function (locale) {
    if (!(locale in numeralsMapCache)) {
      if (formatNumber(0) === '0') {
        numeralsMapCache[locale] = false;
        return false;
      }

      numeralsMapCache[locale] = {};

      for (var i = 0; i < 10; ++i) {
        numeralsMapCache[locale][formatNumber(i)] = i;
      }
    }

    return numeralsMapCache[locale];
  };
}();

var normalizeNumerals = function normalizeNumerals(dateString) {
  var alternativeNumeralsMap = getAlternativeNumeralsMap(_core.default.locale());

  if (!alternativeNumeralsMap) {
    return dateString;
  }

  return dateString.split('').map(function (sign) {
    return sign in alternativeNumeralsMap ? String(alternativeNumeralsMap[sign]) : sign;
  }).join('');
};

var removeLeadingZeroes = function removeLeadingZeroes(str) {
  return str.replace(/(\D)0+(\d)/g, '$1$2');
};

var dateStringEquals = function dateStringEquals(actual, expected) {
  return removeLeadingZeroes(actual) === removeLeadingZeroes(expected);
};

var normalizeMonth = function normalizeMonth(text) {
  return text.replace("d\u2019", 'de '); // NOTE: For "ca" locale
};

var intlFormats = {
  'day': {
    day: 'numeric'
  },
  'dayofweek': {
    weekday: 'long'
  },
  'longdate': {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  },
  'longdatelongtime': {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric',
    second: 'numeric'
  },
  'longtime': {
    hour: 'numeric',
    minute: 'numeric',
    second: 'numeric'
  },
  'month': {
    month: 'long'
  },
  'monthandday': {
    month: 'long',
    day: 'numeric'
  },
  'monthandyear': {
    year: 'numeric',
    month: 'long'
  },
  'shortdate': {},
  'shorttime': {
    hour: 'numeric',
    minute: 'numeric'
  },
  'shortyear': {
    year: '2-digit'
  },
  'year': {
    year: 'numeric'
  }
};
Object.defineProperty(intlFormats, 'shortdateshorttime', {
  get: function get() {
    var defaultOptions = Intl.DateTimeFormat(_core.default.locale()).resolvedOptions();
    return {
      year: defaultOptions.year,
      month: defaultOptions.month,
      day: defaultOptions.day,
      hour: 'numeric',
      minute: 'numeric'
    };
  }
});

var getIntlFormat = function getIntlFormat(format) {
  return typeof format === 'string' && intlFormats[format.toLowerCase()];
};

var monthNameStrategies = {
  standalone: function standalone(monthIndex, monthFormat) {
    var date = new Date(1999, monthIndex, 13, 1);
    var dateString = getIntlFormatter({
      month: monthFormat
    })(date);
    return dateString;
  },
  format: function format(monthIndex, monthFormat) {
    var date = new Date(0, monthIndex, 13, 1);
    var dateString = normalizeMonth(getIntlFormatter({
      day: 'numeric',
      month: monthFormat
    })(date));
    var parts = dateString.split(' ').filter(function (part) {
      return part.indexOf('13') < 0;
    });

    if (parts.length === 1) {
      return parts[0];
    } else if (parts.length === 2) {
      return parts[0].length > parts[1].length ? parts[0] : parts[1]; // NOTE: For "lt" locale
    }

    return monthNameStrategies.standalone(monthIndex, monthFormat);
  }
};
var _default = {
  engine: function engine() {
    return 'intl';
  },
  getMonthNames: function getMonthNames(format, type) {
    var intlFormats = {
      wide: 'long',
      abbreviated: 'short',
      narrow: 'narrow'
    };
    var monthFormat = intlFormats[format || 'wide'];
    type = type === 'format' ? type : 'standalone';
    return Array.apply(null, new Array(12)).map(function (_, monthIndex) {
      return monthNameStrategies[type](monthIndex, monthFormat);
    });
  },
  getDayNames: function getDayNames(format) {
    var intlFormats = {
      wide: 'long',
      abbreviated: 'short',
      short: 'narrow',
      narrow: 'narrow'
    };

    var getIntlDayNames = function getIntlDayNames(format) {
      return Array.apply(null, new Array(7)).map(function (_, dayIndex) {
        return getIntlFormatter({
          weekday: format
        })(new Date(0, 0, dayIndex));
      });
    };

    var result = getIntlDayNames(intlFormats[format || 'wide']);
    return result;
  },
  getPeriodNames: function getPeriodNames() {
    var hour12Formatter = getIntlFormatter({
      hour: 'numeric',
      hour12: true
    });
    return [1, 13].map(function (hours) {
      var hourNumberText = formatNumber(1); // NOTE: For "bn" locale

      var timeParts = hour12Formatter(new Date(0, 0, 1, hours)).split(hourNumberText);

      if (timeParts.length !== 2) {
        return '';
      }

      var biggerPart = timeParts[0].length > timeParts[1].length ? timeParts[0] : timeParts[1];
      return biggerPart.trim();
    });
  },
  format: function format(date, _format) {
    if (!date) {
      return;
    }

    if (!_format) {
      return date;
    } // TODO: refactor (extract code form base)


    if (typeof _format !== 'function' && !_format.formatter) {
      _format = _format.type || _format;
    }

    var intlFormat = getIntlFormat(_format);

    if (intlFormat) {
      return getIntlFormatter(intlFormat)(date);
    }

    var formatType = _typeof(_format);

    if (_format.formatter || formatType === 'function' || formatType === 'string') {
      return this.callBase.apply(this, arguments);
    }

    return getIntlFormatter(_format)(date);
  },
  parse: function parse(dateString, format) {
    var _this = this;

    var formatter;

    if (format && !format.parser && typeof dateString === 'string') {
      dateString = normalizeMonth(dateString);

      formatter = function formatter(date) {
        return normalizeMonth(_this.format(date, format));
      };
    }

    return this.callBase(dateString, formatter || format);
  },
  _parseDateBySimpleFormat: function _parseDateBySimpleFormat(dateString, format) {
    var _this2 = this;

    dateString = normalizeNumerals(dateString);
    var formatParts = this.getFormatParts(format);
    var dateParts = dateString.split(/\D+/).filter(function (part) {
      return part.length > 0;
    });

    if (formatParts.length !== dateParts.length) {
      return;
    }

    var dateArgs = this._generateDateArgs(formatParts, dateParts);

    var constructDate = function constructDate(dateArgs, ampmShift) {
      var hoursShift = ampmShift ? 12 : 0;
      return new Date(dateArgs.year, dateArgs.month, dateArgs.day, (dateArgs.hours + hoursShift) % 24, dateArgs.minutes, dateArgs.seconds);
    };

    var constructValidDate = function constructValidDate(ampmShift) {
      var parsedDate = constructDate(dateArgs, ampmShift);

      if (dateStringEquals(normalizeNumerals(_this2.format(parsedDate, format)), dateString)) {
        return parsedDate;
      }
    };

    return constructValidDate(false) || constructValidDate(true);
  },
  _generateDateArgs: function _generateDateArgs(formatParts, dateParts) {
    var currentDate = new Date();
    var dateArgs = {
      year: currentDate.getFullYear(),
      month: currentDate.getMonth(),
      day: currentDate.getDate(),
      hours: 0,
      minutes: 0,
      seconds: 0
    };
    formatParts.forEach(function (formatPart, index) {
      var datePart = dateParts[index];
      var parsed = parseInt(datePart, 10);

      if (formatPart === 'month') {
        parsed = parsed - 1;
      }

      dateArgs[formatPart] = parsed;
    });
    return dateArgs;
  },
  formatUsesMonthName: function formatUsesMonthName(format) {
    if (_typeof(format) === 'object' && !(format.type || format.format)) {
      return format.month === 'long';
    }

    return this.callBase.apply(this, arguments);
  },
  formatUsesDayName: function formatUsesDayName(format) {
    if (_typeof(format) === 'object' && !(format.type || format.format)) {
      return format.weekday === 'long';
    }

    return this.callBase.apply(this, arguments);
  },
  getTimeSeparator: function getTimeSeparator() {
    var formatOptions = {
      hour: 'numeric',
      minute: 'numeric',
      hour12: false
    };
    return normalizeNumerals(formatDateTime(new Date(2001, 1, 1, 11, 11), formatOptions)).replace(/\d/g, '');
  },
  getFormatParts: function getFormatParts(format) {
    if (typeof format === 'string') {
      return this.callBase(format);
    }

    var intlFormat = (0, _extend.extend)({}, intlFormats[format.toLowerCase()]);
    var date = new Date(2001, 2, 4, 5, 6, 7);
    var formattedDate = getIntlFormatter(intlFormat)(date);
    formattedDate = normalizeNumerals(formattedDate);
    var formatParts = [{
      name: 'year',
      value: 1
    }, {
      name: 'month',
      value: 3
    }, {
      name: 'day',
      value: 4
    }, {
      name: 'hours',
      value: 5
    }, {
      name: 'minutes',
      value: 6
    }, {
      name: 'seconds',
      value: 7
    }];
    return formatParts.map(function (part) {
      return {
        name: part.name,
        index: formattedDate.indexOf(part.value)
      };
    }).filter(function (part) {
      return part.index > -1;
    }).sort(function (a, b) {
      return a.index - b.index;
    }).map(function (part) {
      return part.name;
    });
  }
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _type = __webpack_require__(1);

var _excel = _interopRequireDefault(__webpack_require__(86));

var _excel2 = _interopRequireDefault(__webpack_require__(364));

var _excel3 = _interopRequireDefault(__webpack_require__(255));

var _excel4 = _interopRequireDefault(__webpack_require__(257));

var _excel5 = _interopRequireDefault(__webpack_require__(367));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ExcelFile = /*#__PURE__*/function () {
  function ExcelFile() {
    this._cellFormatTags = [];
    this._fillTags = [];
    this._fontTags = [];
    this._numberFormatTags = []; // the [0, 1] indexes are reserved:
    // - https://stackoverflow.com/questions/11116176/cell-styles-in-openxml-spreadsheet-spreadsheetml
    // - https://social.msdn.microsoft.com/Forums/office/en-US/a973335c-9f9b-4e70-883a-02a0bcff43d2/coloring-cells-in-excel-sheet-using-openxml-in-c

    this._fillTags.push(_excel3.default.tryCreateTag({
      patternFill: {
        patternType: 'none'
      }
    }));
  }

  var _proto = ExcelFile.prototype;

  _proto.registerCellFormat = function registerCellFormat(cellFormat) {
    var result;

    var cellFormatTag = _excel2.default.tryCreateTag(cellFormat, {
      registerFill: this.registerFill.bind(this),
      registerFont: this.registerFont.bind(this),
      registerNumberFormat: this.registerNumberFormat.bind(this)
    });

    if ((0, _type.isDefined)(cellFormatTag)) {
      for (var i = 0; i < this._cellFormatTags.length; i++) {
        if (_excel2.default.areEqual(this._cellFormatTags[i], cellFormatTag)) {
          result = i;
          break;
        }
      }

      if (result === undefined) {
        result = this._cellFormatTags.push(cellFormatTag) - 1;
      }
    }

    return result;
  };

  ExcelFile.copyCellFormat = function copyCellFormat(source) {
    return _excel2.default.copy(source);
  };

  _proto.generateCellFormatsXml = function generateCellFormatsXml() {
    // 18.8.10 cellXfs (Cell Formats), 'ECMA-376 5th edition Part 1' (http://www.ecma-international.org/publications/standards/Ecma-376.htm)
    var cellFormatTagsAsXmlStringsArray = this._cellFormatTags.map(function (tag) {
      return _excel2.default.toXml(tag);
    });

    return _excel.default.toXml('cellXfs', {
      count: cellFormatTagsAsXmlStringsArray.length
    }, cellFormatTagsAsXmlStringsArray.join(''));
  };

  _proto.registerFill = function registerFill(fill) {
    var result;

    var fillTag = _excel3.default.tryCreateTag(fill);

    if ((0, _type.isDefined)(fillTag)) {
      for (var i = 0; i < this._fillTags.length; i++) {
        if (_excel3.default.areEqual(this._fillTags[i], fillTag)) {
          result = i;
          break;
        }
      }

      if (result === undefined) {
        if (this._fillTags.length < 2) {
          // the [0, 1] indexes are reserved:
          // - https://stackoverflow.com/questions/11116176/cell-styles-in-openxml-spreadsheet-spreadsheetml
          // - https://social.msdn.microsoft.com/Forums/office/en-US/a973335c-9f9b-4e70-883a-02a0bcff43d2/coloring-cells-in-excel-sheet-using-openxml-in-c
          this._fillTags.push(_excel3.default.tryCreateTag({
            patternFill: {
              patternType: 'Gray125'
            }
          })); // Index 1 - reserved

        }

        result = this._fillTags.push(fillTag) - 1;
      }
    }

    return result;
  };

  _proto.generateFillsXml = function generateFillsXml() {
    // 18.8.21, 'fills (Fills)', 'ECMA-376 5th edition Part 1' (http://www.ecma-international.org/publications/standards/Ecma-376.htm)
    var tagsAsXmlStringsArray = this._fillTags.map(function (tag) {
      return _excel3.default.toXml(tag);
    });

    return _excel.default.toXml('fills', {
      count: tagsAsXmlStringsArray.length
    }, tagsAsXmlStringsArray.join(''));
  };

  _proto.registerFont = function registerFont(font) {
    var result;

    var fontTag = _excel4.default.tryCreateTag(font);

    if ((0, _type.isDefined)(fontTag)) {
      for (var i = 0; i < this._fontTags.length; i++) {
        if (_excel4.default.areEqual(this._fontTags[i], fontTag)) {
          result = i;
          break;
        }
      }

      if (result === undefined) {
        result = this._fontTags.push(fontTag) - 1;
      }
    }

    return result;
  };

  _proto.generateFontsXml = function generateFontsXml() {
    // 18.8.23, 'fonts (Fonts)', 'ECMA-376 5th edition Part 1' (http://www.ecma-international.org/publications/standards/Ecma-376.htm)
    var xmlStringsArray = this._fontTags.map(function (tag) {
      return _excel4.default.toXml(tag);
    });

    return _excel.default.toXml('fonts', {
      count: xmlStringsArray.length
    }, xmlStringsArray.join(''));
  };

  _proto._convertNumberFormatIndexToId = function _convertNumberFormatIndexToId(index) {
    // Number format ids less than 164 (magic const) represent builtin formats.
    // 18.8.30 numFmt (Number Format), 'ECMA-376 5th edition Part 1' (http://www.ecma-international.org/publications/standards/Ecma-376.htm)
    var CUSTOM_FORMAT_ID_START_VALUE = 165;
    return CUSTOM_FORMAT_ID_START_VALUE + index;
  };

  _proto.registerNumberFormat = function registerNumberFormat(numberFormat) {
    var result;

    var tag = _excel5.default.tryCreateTag(numberFormat);

    if ((0, _type.isDefined)(tag)) {
      for (var i = 0; i < this._numberFormatTags.length; i++) {
        if (_excel5.default.areEqual(this._numberFormatTags[i], tag)) {
          result = this._numberFormatTags[i][_excel5.default.ID_PROPERTY_NAME];
          break;
        }
      }

      if (result === undefined) {
        tag[_excel5.default.ID_PROPERTY_NAME] = this._convertNumberFormatIndexToId(this._numberFormatTags.length);
        result = tag[_excel5.default.ID_PROPERTY_NAME];

        this._numberFormatTags.push(tag);
      }
    }

    return result;
  };

  _proto.generateNumberFormatsXml = function generateNumberFormatsXml() {
    if (this._numberFormatTags.length > 0) {
      // 18.8.31 numFmts (Number Formats)
      var xmlStringsArray = this._numberFormatTags.map(function (tag) {
        return _excel5.default.toXml(tag);
      });

      return _excel.default.toXml('numFmts', {
        count: xmlStringsArray.length
      }, xmlStringsArray.join(''));
    } else {
      return '';
    }
  };

  return ExcelFile;
}();

exports.default = ExcelFile;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _type = __webpack_require__(1);

var _excel = _interopRequireDefault(__webpack_require__(86));

var _excel2 = _interopRequireDefault(__webpack_require__(365));

var _excel3 = _interopRequireDefault(__webpack_require__(255));

var _excel4 = _interopRequireDefault(__webpack_require__(257));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cellFormatHelper = {
  tryCreateTag: function tryCreateTag(sourceObj, sharedItemsContainer) {
    var result = null;

    if ((0, _type.isDefined)(sourceObj)) {
      var numberFormatId;

      if (typeof sourceObj.numberFormat === 'number') {
        numberFormatId = sourceObj.numberFormat;
      } else {
        numberFormatId = sharedItemsContainer.registerNumberFormat(sourceObj.numberFormat);
      }

      var fill = sourceObj.fill;

      if (!(0, _type.isDefined)(fill)) {
        fill = _excel3.default.tryCreateFillFromSimpleFormat(sourceObj);
      }

      result = {
        numberFormatId: numberFormatId,
        alignment: _excel2.default.tryCreateTag(sourceObj.alignment),
        fontId: sharedItemsContainer.registerFont(sourceObj.font),
        fillId: sharedItemsContainer.registerFill(fill)
      };

      if (cellFormatHelper.isEmpty(result)) {
        result = null;
      }
    }

    return result;
  },
  copy: function copy(source) {
    var result;

    if (source === null) {
      result = null;
    } else if ((0, _type.isDefined)(source)) {
      result = {};

      if (source.numberFormat !== undefined) {
        result.numberFormat = source.numberFormat;
      }

      if (source.fill !== undefined) {
        result.fill = _excel3.default.copy(source.fill);
      } else {
        _excel3.default.copySimpleFormat(source, result);
      }

      if (source.alignment !== undefined) {
        result.alignment = _excel2.default.copy(source.alignment);
      }

      if (source.font !== undefined) {
        result.font = _excel4.default.copy(source.font);
      }
    }

    return result;
  },
  areEqual: function areEqual(leftTag, rightTag) {
    return cellFormatHelper.isEmpty(leftTag) && cellFormatHelper.isEmpty(rightTag) || (0, _type.isDefined)(leftTag) && (0, _type.isDefined)(rightTag) && leftTag.fontId === rightTag.fontId && leftTag.numberFormatId === rightTag.numberFormatId && leftTag.fillId === rightTag.fillId && _excel2.default.areEqual(leftTag.alignment, rightTag.alignment);
  },
  isEmpty: function isEmpty(tag) {
    return !(0, _type.isDefined)(tag) || !(0, _type.isDefined)(tag.fontId) && !(0, _type.isDefined)(tag.numberFormatId) && !(0, _type.isDefined)(tag.fillId) && _excel2.default.isEmpty(tag.alignment);
  },
  toXml: function toXml(tag) {
    var isAlignmentEmpty = _excel2.default.isEmpty(tag.alignment);

    var applyNumberFormat;

    if ((0, _type.isDefined)(tag.numberFormatId)) {
      applyNumberFormat = tag.numberFormatId > 0 ? 1 : 0;
    } // 18.8.45 xf (Format), 'ECMA-376 5th edition Part 1' (http://www.ecma-international.org/publications/standards/Ecma-376.htm)


    return _excel.default.toXml('xf', {
      'xfId': 0,
      applyAlignment: isAlignmentEmpty ? null : 1,
      fontId: tag.fontId,
      applyNumberFormat: applyNumberFormat,
      fillId: tag.fillId,
      'numFmtId': tag.numberFormatId
    }, isAlignmentEmpty ? null : _excel2.default.toXml(tag.alignment));
  }
};
var _default = cellFormatHelper;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _type = __webpack_require__(1);

var _excel = _interopRequireDefault(__webpack_require__(86));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cellAlignmentHelper = {
  tryCreateTag: function tryCreateTag(sourceObj) {
    var result = null;

    if ((0, _type.isDefined)(sourceObj)) {
      result = {
        vertical: sourceObj.vertical,
        wrapText: sourceObj.wrapText,
        horizontal: sourceObj.horizontal
      };

      if (cellAlignmentHelper.isEmpty(result)) {
        result = null;
      }
    }

    return result;
  },
  copy: function copy(source) {
    var result = null;

    if ((0, _type.isDefined)(source)) {
      result = {};

      if (source.horizontal !== undefined) {
        result.horizontal = source.horizontal;
      }

      if (source.vertical !== undefined) {
        result.vertical = source.vertical;
      }

      if (source.wrapText !== undefined) {
        result.wrapText = source.wrapText;
      }
    }

    return result;
  },
  areEqual: function areEqual(leftTag, rightTag) {
    return cellAlignmentHelper.isEmpty(leftTag) && cellAlignmentHelper.isEmpty(rightTag) || (0, _type.isDefined)(leftTag) && (0, _type.isDefined)(rightTag) && leftTag.vertical === rightTag.vertical && leftTag.wrapText === rightTag.wrapText && leftTag.horizontal === rightTag.horizontal;
  },
  isEmpty: function isEmpty(tag) {
    return !(0, _type.isDefined)(tag) || !(0, _type.isDefined)(tag.vertical) && !(0, _type.isDefined)(tag.wrapText) && !(0, _type.isDefined)(tag.horizontal);
  },
  toXml: function toXml(tag) {
    // 18.8.1 alignment (Alignment), 'ECMA-376 5th edition Part 1' (http://www.ecma-international.org/publications/standards/Ecma-376.htm)
    return _excel.default.toXml('alignment', {
      vertical: tag.vertical,
      // 18.18.88 ST_VerticalAlignment (Vertical Alignment Types)
      wrapText: (0, _type.isDefined)(tag.wrapText) ? Number(tag.wrapText) : undefined,
      horizontal: tag.horizontal // 18.18.40 ST_HorizontalAlignment (Horizontal Alignment Type)

    });
  }
};
var _default = cellAlignmentHelper;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _type = __webpack_require__(1);

var _excel = _interopRequireDefault(__webpack_require__(86));

var _excel2 = _interopRequireDefault(__webpack_require__(256));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var patternFillHelper = {
  tryCreateTag: function tryCreateTag(sourceObj) {
    var result = null;

    if ((0, _type.isDefined)(sourceObj)) {
      result = {
        patternType: sourceObj.patternType,
        backgroundColor: _excel2.default.tryCreateTag(sourceObj.backgroundColor),
        foregroundColor: _excel2.default.tryCreateTag(sourceObj.foregroundColor)
      };

      if (patternFillHelper.isEmpty(result)) {
        result = null;
      }
    }

    return result;
  },
  copy: function copy(source) {
    var result = null;

    if ((0, _type.isDefined)(source)) {
      result = {};

      if (source.patternType !== undefined) {
        result.patternType = source.patternType;
      }

      if (source.backgroundColor !== undefined) {
        result.backgroundColor = _excel2.default.copy(source.backgroundColor);
      }

      if (source.foregroundColor !== undefined) {
        result.foregroundColor = _excel2.default.copy(source.foregroundColor);
      }
    }

    return result;
  },
  areEqual: function areEqual(leftTag, rightTag) {
    return patternFillHelper.isEmpty(leftTag) && patternFillHelper.isEmpty(rightTag) || (0, _type.isDefined)(leftTag) && (0, _type.isDefined)(rightTag) && leftTag.patternType === rightTag.patternType && _excel2.default.areEqual(leftTag.backgroundColor, rightTag.backgroundColor) && _excel2.default.areEqual(leftTag.foregroundColor, rightTag.foregroundColor);
  },
  isEmpty: function isEmpty(tag) {
    return !(0, _type.isDefined)(tag) || !(0, _type.isDefined)(tag.patternType);
  },
  toXml: function toXml(tag) {
    var content = [(0, _type.isDefined)(tag.foregroundColor) ? _excel2.default.toXml('fgColor', tag.foregroundColor) : '', // 18.8.19 fgColor (Foreground Color)
    (0, _type.isDefined)(tag.backgroundColor) ? _excel2.default.toXml('bgColor', tag.backgroundColor) : '' // 18.8.3 bgColor (Background Color)
    ].join(''); // 18.8.32 patternFill (Pattern), 'ECMA-376 5th edition Part 1' (http://www.ecma-international.org/publications/standards/Ecma-376.htm)

    return _excel.default.toXml('patternFill', {
      patternType: tag.patternType
    }, // 18.18.55 ST_PatternType (Pattern Type)
    content);
  }
};
var _default = patternFillHelper;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _type = __webpack_require__(1);

var _excel = _interopRequireDefault(__webpack_require__(86));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var numberFormatHelper = {
  ID_PROPERTY_NAME: 'id',
  tryCreateTag: function tryCreateTag(sourceObj) {
    var result = null;

    if (typeof sourceObj === 'string') {
      result = {
        formatCode: sourceObj
      };

      if (numberFormatHelper.isEmpty(result)) {
        result = null;
      }
    }

    return result;
  },
  areEqual: function areEqual(leftTag, rightTag) {
    return numberFormatHelper.isEmpty(leftTag) && numberFormatHelper.isEmpty(rightTag) || (0, _type.isDefined)(leftTag) && (0, _type.isDefined)(rightTag) && leftTag.formatCode === rightTag.formatCode;
  },
  isEmpty: function isEmpty(tag) {
    return !(0, _type.isDefined)(tag) || !(0, _type.isDefined)(tag.formatCode) || tag.formatCode === '';
  },
  toXml: function toXml(tag) {
    // 18.8.30 numFmt (Number Format)
    return _excel.default.toXml('numFmt', {
      'numFmtId': tag[numberFormatHelper.ID_PROPERTY_NAME],
      formatCode: tag.formatCode // 21.2.2.71 formatCode (Format Code), 18.8.31 numFmts (Number Formats)

    });
  }
};
var _default = numberFormatHelper;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getData = getData;
exports.svgCreator = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _ajax = _interopRequireDefault(__webpack_require__(80));

var _window = __webpack_require__(7);

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

var _svg = __webpack_require__(213);

var _deferred = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var window = (0, _window.getWindow)();
var svgCreator = {
  _markup: '',
  _imageArray: {},
  _imageDeferreds: [],
  _getBinaryFile: function _getBinaryFile(src, callback) {
    _ajax.default.sendRequest({
      url: src,
      method: 'GET',
      responseType: 'arraybuffer'
    }).done(callback).fail(function () {
      callback(false);
    });
  },
  _loadImages: function _loadImages() {
    var that = this;
    (0, _iterator.each)(that._imageArray, function (src) {
      var deferred = new _deferred.Deferred();

      that._imageDeferreds.push(deferred);

      that._getBinaryFile(src, function (response) {
        if (!response) {
          delete that._imageArray[src]; // ToDo Warning

          deferred.resolve();
          return;
        }

        var i;
        var binary = '';
        var bytes = new Uint8Array(response);
        var length = bytes.byteLength;

        for (i = 0; i < length; i++) {
          binary += String.fromCharCode(bytes[i]);
        }

        that._imageArray[src] = 'data:image/png;base64,' + window.btoa(binary);
        deferred.resolve();
      });
    });
  },
  _parseImages: function _parseImages(element) {
    var href;
    var that = this;

    if (element.tagName === 'image') {
      href = (0, _renderer.default)(element).attr('href') || (0, _renderer.default)(element).attr('xlink:href');

      if (!that._imageArray[href]) {
        that._imageArray[href] = '';
      }
    }

    (0, _iterator.each)(element.childNodes, function (_, element) {
      that._parseImages(element);
    });
  },
  _prepareImages: function _prepareImages(svgElem) {
    this._parseImages(svgElem);

    this._loadImages();

    return _deferred.when.apply(_renderer.default, this._imageDeferreds);
  },
  getData: function getData(data, options) {
    var markup;
    var that = this;
    var xmlVersion = '<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>';
    var svgElem = (0, _svg.getSvgElement)(data);
    var $svgObject = (0, _renderer.default)(svgElem);
    markup = xmlVersion + (0, _svg.getSvgMarkup)($svgObject.get(0), options.backgroundColor);
    return that._prepareImages(svgElem).then(function () {
      (0, _iterator.each)(that._imageArray, function (href, dataURI) {
        var regexpString = "href=['|\"]".concat(href, "['|\"]");
        markup = markup.replace(new RegExp(regexpString, 'gi'), "href=\"".concat(dataURI, "\""));
      });
      return (0, _type.isFunction)(window.Blob) ? that._getBlob(markup) : that._getBase64(markup);
    });
  },
  _getBlob: function _getBlob(markup) {
    return new window.Blob([markup], {
      type: 'image/svg+xml'
    });
  },
  _getBase64: function _getBase64(markup) {
    return window.btoa(markup);
  }
};
exports.svgCreator = svgCreator;

function getData(data, options) {
  return svgCreator.getData(data, options);
}

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _window = __webpack_require__(7);

var _dependency_injector = _interopRequireDefault(__webpack_require__(55));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var window = (0, _window.getWindow)();
var nativeXMLHttpRequest = {
  getXhr: function getXhr() {
    return new window.XMLHttpRequest();
  }
};

var _default = (0, _dependency_injector.default)(nativeXMLHttpRequest);

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getData = getData;

var _version = __webpack_require__(169);

var _window = __webpack_require__(7);

var _image_creator = __webpack_require__(258);

var _type = __webpack_require__(1);

var _extend = __webpack_require__(0);

var window = (0, _window.getWindow)();
var mainPageTemplate = '%PDF-1.3\r\n2 0 obj\r\n<</ProcSet[/PDF/ImageB/ImageC/ImageI]/XObject<</I0 5 0 R>>>>\r\nendobj\r\n4 0 obj\r\n<</Type/Pages/Kids[1 0 R]/Count 1>>\r\nendobj\r\n7 0 obj\r\n<</OpenAction[1 0 R /FitH null]/Type/Catalog/Pages 4 0 R/PageLayout/OneColumn>>\r\nendobj\r\n1 0 obj\r\n<</Type/Page/Resources 2 0 R/MediaBox[0 0 _width_ _height_]/Contents 3 0 R/Parent 4 0 R>>\r\nendobj\r\n';
var contentTemplate = '3 0 obj\r\n<</Length 52>>stream\r\n0.20 w\n0 G\nq _width_ 0 0 _height_ 0.00 0.00 cm /I0 Do Q\r\nendstream\r\nendobj\r\n';
var infoTemplate = '6 0 obj\r\n<</CreationDate _date_/Producer(DevExtreme _version_)>>\r\nendobj\r\n';
var imageStartTemplate = '5 0 obj\r\n<</Type/XObject/Subtype/Image/Width _width_/Height _height_/ColorSpace/DeviceRGB/BitsPerComponent 8/Filter/DCTDecode/Length _length_>>stream\r\n';
var imageEndTemplate = '\r\nendstream\r\nendobj\r\n';
var trailerTemplate = 'trailer\r\n<<\r\n/Size 8\r\n/Root 7 0 R\r\n/Info 6 0 R\r\n>>\r\nstartxref\r\n_length_\r\n%%EOF';
var xrefTemplate = 'xref\r\n0 8\r\n0000000000 65535 f\r\n0000000241 00000 n\r\n0000000010 00000 n\r\n_main_ 00000 n\r\n0000000089 00000 n\r\n_image_ 00000 n\r\n_info_ 00000 n\r\n0000000143 00000 n\r\n';

var pad = function pad(str, len) {
  return str.length < len ? pad('0' + str, len) : str;
};

var composePdfString = function composePdfString(imageString, options, curDate) {
  var margin = (options.margin || 0) * 2;
  var width = options.width + margin;
  var height = options.height + margin;
  var widthPt = (width * 0.75).toFixed(2);
  var heightPt = (height * 0.75).toFixed(2);
  var mainPage = mainPageTemplate.replace('_width_', widthPt).replace('_height_', heightPt);
  var content = contentTemplate.replace('_width_', widthPt).replace('_height_', heightPt);
  var info = infoTemplate.replace('_date_', curDate).replace('_version_', _version.version);
  var image = imageStartTemplate.replace('_width_', width).replace('_height_', height).replace('_length_', imageString.length) + imageString + imageEndTemplate;
  var xref = getXref(mainPage.length, content.length, info.length);
  var mainContent = mainPage + content + info + image;
  var trailer = trailerTemplate.replace('_length_', mainContent.length);
  return mainContent + xref + trailer;
};

function getXref(mainPageLength, contentLength, infoLength) {
  return xrefTemplate.replace('_main_', pad(mainPageLength + '', 10)).replace('_info_', pad(mainPageLength + contentLength + '', 10)).replace('_image_', pad(mainPageLength + contentLength + infoLength + '', 10));
}

var getCurDate = function getCurDate() {
  return new Date();
};

var getBlob = function getBlob(binaryData) {
  var i = 0;
  var dataArray = new Uint8Array(binaryData.length);

  for (; i < binaryData.length; i++) {
    dataArray[i] = binaryData.charCodeAt(i);
  }

  return new window.Blob([dataArray.buffer], {
    type: 'application/pdf'
  });
};

var getBase64 = function getBase64(binaryData) {
  return window.btoa(binaryData);
};

function getData(data, options) {
  return _image_creator.imageCreator.getImageData(data, (0, _extend.extend)({}, options, {
    format: 'JPEG'
  })).then(function (imageString) {
    var binaryData = composePdfString(imageString, options, getCurDate());
    var pdfData = (0, _type.isFunction)(window.Blob) ? getBlob(binaryData) : getBase64(binaryData);
    return pdfData;
  });
}

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "exportDataGrid", {
  enumerable: true,
  get: function get() {
    return _export_data_grid.exportDataGrid;
  }
});
Object.defineProperty(exports, "exportPivotGrid", {
  enumerable: true,
  get: function get() {
    return _export_pivot_grid.exportPivotGrid;
  }
});

var _export_data_grid = __webpack_require__(372);

var _export_pivot_grid = __webpack_require__(376);

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.exportDataGrid = exportDataGrid;

var _type = __webpack_require__(1);

var _export = __webpack_require__(259);

var _errors = _interopRequireDefault(__webpack_require__(24));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var helpers = {
  _trySetAutoFilter: function _trySetAutoFilter(dataProvider, worksheet, cellRange, autoFilterEnabled) {
    if (autoFilterEnabled) {
      if (!(0, _type.isDefined)(worksheet.autoFilter) && dataProvider.getRowsCount() > 0) {
        var dataRange = {
          from: {
            row: cellRange.from.row + dataProvider.getHeaderRowCount() - 1,
            column: cellRange.from.column
          },
          to: cellRange.to
        };
        worksheet.autoFilter = dataRange;
      }
    }
  },
  _trySetFont: function _trySetFont(excelCell, bold) {
    if ((0, _type.isDefined)(bold)) {
      excelCell.font = excelCell.font || {};
      excelCell.font.bold = bold;
    }
  },
  _getWorksheetFrozenState: function _getWorksheetFrozenState(dataProvider, cellRange) {
    return {
      state: 'frozen',
      ySplit: cellRange.from.row + dataProvider.getFrozenArea().y - 1
    };
  },
  _trySetOutlineLevel: function _trySetOutlineLevel(dataProvider, row, rowIndex) {
    if (rowIndex >= dataProvider.getHeaderRowCount()) {
      row.outlineLevel = dataProvider.getGroupLevel(rowIndex);
    }
  },
  _getCustomizeCellOptions: function _getCustomizeCellOptions(excelCell, gridCell) {
    var options = {
      excelCell: excelCell,
      gridCell: gridCell
    };
    Object.defineProperty(options, 'cell', {
      get: function get() {
        _errors.default.log('W0003', 'CustomizeCell handler argument', 'cell', '20.1', 'Use the \'excelCell\' field instead');

        return excelCell;
      }
    });
    return options;
  },
  _isFrozenZone: function _isFrozenZone(dataProvider) {
    return dataProvider.getHeaderRowCount() > 0;
  },
  _isHeaderCell: function _isHeaderCell(dataProvider, rowIndex) {
    return rowIndex < dataProvider.getHeaderRowCount();
  },
  _allowToMergeRange: function _allowToMergeRange() {
    return true;
  },
  _renderLoadPanel: function _renderLoadPanel(component) {
    var rowsView = component.getView('rowsView');

    rowsView._renderLoadPanel(rowsView.element(), rowsView.element().parent());
  }
};

function exportDataGrid(options) {
  return _export.Export.export(_getFullOptions(options), helpers);
}

function _getFullOptions(options) {
  if (!((0, _type.isDefined)(options) && (0, _type.isObject)(options))) {
    throw Error('The "exportDataGrid" method requires a configuration object.');
  }

  if (!((0, _type.isDefined)(options.component) && (0, _type.isObject)(options.component) && options.component.NAME === 'dxDataGrid')) {
    throw Error('The "component" field must contain a DataGrid instance.');
  }

  if (!(0, _type.isDefined)(options.selectedRowsOnly)) {
    options.selectedRowsOnly = false;
  }

  if (!(0, _type.isDefined)(options.autoFilterEnabled)) {
    options.autoFilterEnabled = false;
  }

  return _export.Export.getFullOptions(options);
}

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.defaultMessages = void 0;

/* eslint-disable node/no-unsupported-features/es-syntax */
// !!! AUTO-GENERATED FILE, DO NOT EDIT
var defaultMessages = {
  "en": {
    "Yes": "Yes",
    "No": "No",
    "Cancel": "Cancel",
    "Clear": "Clear",
    "Done": "Done",
    "Loading": "Loading...",
    "Select": "Select...",
    "Search": "Search",
    "Back": "Back",
    "OK": "OK",
    "dxCollectionWidget-noDataText": "No data to display",
    "dxDropDownEditor-selectLabel": "Select",
    "validation-required": "Required",
    "validation-required-formatted": "{0} is required",
    "validation-numeric": "Value must be a number",
    "validation-numeric-formatted": "{0} must be a number",
    "validation-range": "Value is out of range",
    "validation-range-formatted": "{0} is out of range",
    "validation-stringLength": "The length of the value is not correct",
    "validation-stringLength-formatted": "The length of {0} is not correct",
    "validation-custom": "Value is invalid",
    "validation-custom-formatted": "{0} is invalid",
    "validation-async": "Value is invalid",
    "validation-async-formatted": "{0} is invalid",
    "validation-compare": "Values do not match",
    "validation-compare-formatted": "{0} does not match",
    "validation-pattern": "Value does not match pattern",
    "validation-pattern-formatted": "{0} does not match pattern",
    "validation-email": "Email is invalid",
    "validation-email-formatted": "{0} is invalid",
    "validation-mask": "Value is invalid",
    "dxLookup-searchPlaceholder": "Minimum character number: {0}",
    "dxList-pullingDownText": "Pull down to refresh...",
    "dxList-pulledDownText": "Release to refresh...",
    "dxList-refreshingText": "Refreshing...",
    "dxList-pageLoadingText": "Loading...",
    "dxList-nextButtonText": "More",
    "dxList-selectAll": "Select All",
    "dxListEditDecorator-delete": "Delete",
    "dxListEditDecorator-more": "More",
    "dxScrollView-pullingDownText": "Pull down to refresh...",
    "dxScrollView-pulledDownText": "Release to refresh...",
    "dxScrollView-refreshingText": "Refreshing...",
    "dxScrollView-reachBottomText": "Loading...",
    "dxDateBox-simulatedDataPickerTitleTime": "Select time",
    "dxDateBox-simulatedDataPickerTitleDate": "Select date",
    "dxDateBox-simulatedDataPickerTitleDateTime": "Select date and time",
    "dxDateBox-validation-datetime": "Value must be a date or time",
    "dxFileUploader-selectFile": "Select file",
    "dxFileUploader-dropFile": "or Drop file here",
    "dxFileUploader-bytes": "bytes",
    "dxFileUploader-kb": "kb",
    "dxFileUploader-Mb": "Mb",
    "dxFileUploader-Gb": "Gb",
    "dxFileUploader-upload": "Upload",
    "dxFileUploader-uploaded": "Uploaded",
    "dxFileUploader-readyToUpload": "Ready to upload",
    "dxFileUploader-uploadAbortedMessage": "Upload cancelled",
    "dxFileUploader-uploadFailedMessage": "Upload failed",
    "dxFileUploader-invalidFileExtension": "File type is not allowed",
    "dxFileUploader-invalidMaxFileSize": "File is too large",
    "dxFileUploader-invalidMinFileSize": "File is too small",
    "dxRangeSlider-ariaFrom": "From",
    "dxRangeSlider-ariaTill": "Till",
    "dxSwitch-switchedOnText": "ON",
    "dxSwitch-switchedOffText": "OFF",
    "dxForm-optionalMark": "optional",
    "dxForm-requiredMessage": "{0} is required",
    "dxNumberBox-invalidValueMessage": "Value must be a number",
    "dxNumberBox-noDataText": "No data",
    "dxDataGrid-columnChooserTitle": "Column Chooser",
    "dxDataGrid-columnChooserEmptyText": "Drag a column here to hide it",
    "dxDataGrid-groupContinuesMessage": "Continues on the next page",
    "dxDataGrid-groupContinuedMessage": "Continued from the previous page",
    "dxDataGrid-groupHeaderText": "Group by This Column",
    "dxDataGrid-ungroupHeaderText": "Ungroup",
    "dxDataGrid-ungroupAllText": "Ungroup All",
    "dxDataGrid-editingEditRow": "Edit",
    "dxDataGrid-editingSaveRowChanges": "Save",
    "dxDataGrid-editingCancelRowChanges": "Cancel",
    "dxDataGrid-editingDeleteRow": "Delete",
    "dxDataGrid-editingUndeleteRow": "Undelete",
    "dxDataGrid-editingConfirmDeleteMessage": "Are you sure you want to delete this record?",
    "dxDataGrid-validationCancelChanges": "Cancel changes",
    "dxDataGrid-groupPanelEmptyText": "Drag a column header here to group by that column",
    "dxDataGrid-noDataText": "No data",
    "dxDataGrid-searchPanelPlaceholder": "Search...",
    "dxDataGrid-filterRowShowAllText": "(All)",
    "dxDataGrid-filterRowResetOperationText": "Reset",
    "dxDataGrid-filterRowOperationEquals": "Equals",
    "dxDataGrid-filterRowOperationNotEquals": "Does not equal",
    "dxDataGrid-filterRowOperationLess": "Less than",
    "dxDataGrid-filterRowOperationLessOrEquals": "Less than or equal to",
    "dxDataGrid-filterRowOperationGreater": "Greater than",
    "dxDataGrid-filterRowOperationGreaterOrEquals": "Greater than or equal to",
    "dxDataGrid-filterRowOperationStartsWith": "Starts with",
    "dxDataGrid-filterRowOperationContains": "Contains",
    "dxDataGrid-filterRowOperationNotContains": "Does not contain",
    "dxDataGrid-filterRowOperationEndsWith": "Ends with",
    "dxDataGrid-filterRowOperationBetween": "Between",
    "dxDataGrid-filterRowOperationBetweenStartText": "Start",
    "dxDataGrid-filterRowOperationBetweenEndText": "End",
    "dxDataGrid-applyFilterText": "Apply filter",
    "dxDataGrid-trueText": "true",
    "dxDataGrid-falseText": "false",
    "dxDataGrid-sortingAscendingText": "Sort Ascending",
    "dxDataGrid-sortingDescendingText": "Sort Descending",
    "dxDataGrid-sortingClearText": "Clear Sorting",
    "dxDataGrid-editingSaveAllChanges": "Save changes",
    "dxDataGrid-editingCancelAllChanges": "Discard changes",
    "dxDataGrid-editingAddRow": "Add a row",
    "dxDataGrid-summaryMin": "Min: {0}",
    "dxDataGrid-summaryMinOtherColumn": "Min of {1} is {0}",
    "dxDataGrid-summaryMax": "Max: {0}",
    "dxDataGrid-summaryMaxOtherColumn": "Max of {1} is {0}",
    "dxDataGrid-summaryAvg": "Avg: {0}",
    "dxDataGrid-summaryAvgOtherColumn": "Avg of {1} is {0}",
    "dxDataGrid-summarySum": "Sum: {0}",
    "dxDataGrid-summarySumOtherColumn": "Sum of {1} is {0}",
    "dxDataGrid-summaryCount": "Count: {0}",
    "dxDataGrid-columnFixingFix": "Fix",
    "dxDataGrid-columnFixingUnfix": "Unfix",
    "dxDataGrid-columnFixingLeftPosition": "To the left",
    "dxDataGrid-columnFixingRightPosition": "To the right",
    "dxDataGrid-exportTo": "Export",
    "dxDataGrid-exportToExcel": "Export to Excel file",
    "dxDataGrid-exporting": "Exporting...",
    "dxDataGrid-excelFormat": "Excel file",
    "dxDataGrid-selectedRows": "Selected rows",
    "dxDataGrid-exportSelectedRows": "Export selected rows",
    "dxDataGrid-exportAll": "Export all data",
    "dxDataGrid-headerFilterEmptyValue": "(Blanks)",
    "dxDataGrid-headerFilterOK": "OK",
    "dxDataGrid-headerFilterCancel": "Cancel",
    "dxDataGrid-ariaAdaptiveCollapse": "Hide additional data",
    "dxDataGrid-ariaAdaptiveExpand": "Display additional data",
    "dxDataGrid-ariaColumn": "Column",
    "dxDataGrid-ariaValue": "Value",
    "dxDataGrid-ariaFilterCell": "Filter cell",
    "dxDataGrid-ariaCollapse": "Collapse",
    "dxDataGrid-ariaExpand": "Expand",
    "dxDataGrid-ariaDataGrid": "Data grid",
    "dxDataGrid-ariaSearchInGrid": "Search in the data grid",
    "dxDataGrid-ariaSelectAll": "Select all",
    "dxDataGrid-ariaSelectRow": "Select row",
    "dxDataGrid-ariaToolbar": "Data grid toolbar",
    "dxDataGrid-filterBuilderPopupTitle": "Filter Builder",
    "dxDataGrid-filterPanelCreateFilter": "Create Filter",
    "dxDataGrid-filterPanelClearFilter": "Clear",
    "dxDataGrid-filterPanelFilterEnabledHint": "Enable the filter",
    "dxTreeList-ariaTreeList": "Tree list",
    "dxTreeList-ariaSearchInGrid": "Search in the tree list",
    "dxTreeList-ariaToolbar": "Tree list toolbar",
    "dxTreeList-editingAddRowToNode": "Add",
    "dxPager-infoText": "Page {0} of {1} ({2} items)",
    "dxPager-pagesCountText": "of",
    "dxPager-pageSizesAllText": "All",
    "dxPivotGrid-grandTotal": "Grand Total",
    "dxPivotGrid-total": "{0} Total",
    "dxPivotGrid-fieldChooserTitle": "Field Chooser",
    "dxPivotGrid-showFieldChooser": "Show Field Chooser",
    "dxPivotGrid-expandAll": "Expand All",
    "dxPivotGrid-collapseAll": "Collapse All",
    "dxPivotGrid-sortColumnBySummary": "Sort \"{0}\" by This Column",
    "dxPivotGrid-sortRowBySummary": "Sort \"{0}\" by This Row",
    "dxPivotGrid-removeAllSorting": "Remove All Sorting",
    "dxPivotGrid-dataNotAvailable": "N/A",
    "dxPivotGrid-rowFields": "Row Fields",
    "dxPivotGrid-columnFields": "Column Fields",
    "dxPivotGrid-dataFields": "Data Fields",
    "dxPivotGrid-filterFields": "Filter Fields",
    "dxPivotGrid-allFields": "All Fields",
    "dxPivotGrid-columnFieldArea": "Drop Column Fields Here",
    "dxPivotGrid-dataFieldArea": "Drop Data Fields Here",
    "dxPivotGrid-rowFieldArea": "Drop Row Fields Here",
    "dxPivotGrid-filterFieldArea": "Drop Filter Fields Here",
    "dxScheduler-editorLabelTitle": "Subject",
    "dxScheduler-editorLabelStartDate": "Start Date",
    "dxScheduler-editorLabelEndDate": "End Date",
    "dxScheduler-editorLabelDescription": "Description",
    "dxScheduler-editorLabelRecurrence": "Repeat",
    "dxScheduler-openAppointment": "Open appointment",
    "dxScheduler-recurrenceNever": "Never",
    "dxScheduler-recurrenceMinutely": "Every minute",
    "dxScheduler-recurrenceHourly": "Hourly",
    "dxScheduler-recurrenceDaily": "Daily",
    "dxScheduler-recurrenceWeekly": "Weekly",
    "dxScheduler-recurrenceMonthly": "Monthly",
    "dxScheduler-recurrenceYearly": "Yearly",
    "dxScheduler-recurrenceRepeatEvery": "Repeat Every",
    "dxScheduler-recurrenceRepeatOn": "Repeat On",
    "dxScheduler-recurrenceEnd": "End repeat",
    "dxScheduler-recurrenceAfter": "After",
    "dxScheduler-recurrenceOn": "On",
    "dxScheduler-recurrenceRepeatMinutely": "minute(s)",
    "dxScheduler-recurrenceRepeatHourly": "hour(s)",
    "dxScheduler-recurrenceRepeatDaily": "day(s)",
    "dxScheduler-recurrenceRepeatWeekly": "week(s)",
    "dxScheduler-recurrenceRepeatMonthly": "month(s)",
    "dxScheduler-recurrenceRepeatYearly": "year(s)",
    "dxScheduler-switcherDay": "Day",
    "dxScheduler-switcherWeek": "Week",
    "dxScheduler-switcherWorkWeek": "Work Week",
    "dxScheduler-switcherMonth": "Month",
    "dxScheduler-switcherAgenda": "Agenda",
    "dxScheduler-switcherTimelineDay": "Timeline Day",
    "dxScheduler-switcherTimelineWeek": "Timeline Week",
    "dxScheduler-switcherTimelineWorkWeek": "Timeline Work Week",
    "dxScheduler-switcherTimelineMonth": "Timeline Month",
    "dxScheduler-recurrenceRepeatOnDate": "on date",
    "dxScheduler-recurrenceRepeatCount": "occurrence(s)",
    "dxScheduler-allDay": "All day",
    "dxScheduler-confirmRecurrenceEditMessage": "Do you want to edit only this appointment or the whole series?",
    "dxScheduler-confirmRecurrenceDeleteMessage": "Do you want to delete only this appointment or the whole series?",
    "dxScheduler-confirmRecurrenceEditSeries": "Edit series",
    "dxScheduler-confirmRecurrenceDeleteSeries": "Delete series",
    "dxScheduler-confirmRecurrenceEditOccurrence": "Edit appointment",
    "dxScheduler-confirmRecurrenceDeleteOccurrence": "Delete appointment",
    "dxScheduler-noTimezoneTitle": "No timezone",
    "dxScheduler-moreAppointments": "{0} more",
    "dxCalendar-todayButtonText": "Today",
    "dxCalendar-ariaWidgetName": "Calendar",
    "dxColorView-ariaRed": "Red",
    "dxColorView-ariaGreen": "Green",
    "dxColorView-ariaBlue": "Blue",
    "dxColorView-ariaAlpha": "Transparency",
    "dxColorView-ariaHex": "Color code",
    "dxTagBox-selected": "{0} selected",
    "dxTagBox-allSelected": "All selected ({0})",
    "dxTagBox-moreSelected": "{0} more",
    "vizExport-printingButtonText": "Print",
    "vizExport-titleMenuText": "Exporting/Printing",
    "vizExport-exportButtonText": "{0} file",
    "dxFilterBuilder-and": "And",
    "dxFilterBuilder-or": "Or",
    "dxFilterBuilder-notAnd": "Not And",
    "dxFilterBuilder-notOr": "Not Or",
    "dxFilterBuilder-addCondition": "Add Condition",
    "dxFilterBuilder-addGroup": "Add Group",
    "dxFilterBuilder-enterValueText": "<enter a value>",
    "dxFilterBuilder-filterOperationEquals": "Equals",
    "dxFilterBuilder-filterOperationNotEquals": "Does not equal",
    "dxFilterBuilder-filterOperationLess": "Is less than",
    "dxFilterBuilder-filterOperationLessOrEquals": "Is less than or equal to",
    "dxFilterBuilder-filterOperationGreater": "Is greater than",
    "dxFilterBuilder-filterOperationGreaterOrEquals": "Is greater than or equal to",
    "dxFilterBuilder-filterOperationStartsWith": "Starts with",
    "dxFilterBuilder-filterOperationContains": "Contains",
    "dxFilterBuilder-filterOperationNotContains": "Does not contain",
    "dxFilterBuilder-filterOperationEndsWith": "Ends with",
    "dxFilterBuilder-filterOperationIsBlank": "Is blank",
    "dxFilterBuilder-filterOperationIsNotBlank": "Is not blank",
    "dxFilterBuilder-filterOperationBetween": "Is between",
    "dxFilterBuilder-filterOperationAnyOf": "Is any of",
    "dxFilterBuilder-filterOperationNoneOf": "Is none of",
    "dxHtmlEditor-dialogColorCaption": "Change Font Color",
    "dxHtmlEditor-dialogBackgroundCaption": "Change Background Color",
    "dxHtmlEditor-dialogLinkCaption": "Add Link",
    "dxHtmlEditor-dialogLinkUrlField": "URL",
    "dxHtmlEditor-dialogLinkTextField": "Text",
    "dxHtmlEditor-dialogLinkTargetField": "Open link in new window",
    "dxHtmlEditor-dialogImageCaption": "Add Image",
    "dxHtmlEditor-dialogImageUrlField": "URL",
    "dxHtmlEditor-dialogImageAltField": "Alternate text",
    "dxHtmlEditor-dialogImageWidthField": "Width (px)",
    "dxHtmlEditor-dialogImageHeightField": "Height (px)",
    "dxHtmlEditor-dialogInsertTableRowsField": "Rows",
    "dxHtmlEditor-dialogInsertTableColumnsField": "Columns",
    "dxHtmlEditor-dialogInsertTableCaption": "Insert Table",
    "dxHtmlEditor-heading": "Heading",
    "dxHtmlEditor-normalText": "Normal text",
    "dxHtmlEditor-background": "Background Color",
    "dxHtmlEditor-bold": "Bold",
    "dxHtmlEditor-color": "Font Color",
    "dxHtmlEditor-font": "Font",
    "dxHtmlEditor-italic": "Italic",
    "dxHtmlEditor-link": "Add Link",
    "dxHtmlEditor-image": "Add Image",
    "dxHtmlEditor-size": "Size",
    "dxHtmlEditor-strike": "Strikethrough",
    "dxHtmlEditor-subscript": "Subscript",
    "dxHtmlEditor-superscript": "Superscript",
    "dxHtmlEditor-underline": "Underline",
    "dxHtmlEditor-blockquote": "Blockquote",
    "dxHtmlEditor-header": "Header",
    "dxHtmlEditor-increaseIndent": "Increase Indent",
    "dxHtmlEditor-decreaseIndent": "Decrease Indent",
    "dxHtmlEditor-orderedList": "Ordered List",
    "dxHtmlEditor-bulletList": "Bullet List",
    "dxHtmlEditor-alignLeft": "Align Left",
    "dxHtmlEditor-alignCenter": "Align Center",
    "dxHtmlEditor-alignRight": "Align Right",
    "dxHtmlEditor-alignJustify": "Align Justify",
    "dxHtmlEditor-codeBlock": "Code Block",
    "dxHtmlEditor-variable": "Add Variable",
    "dxHtmlEditor-undo": "Undo",
    "dxHtmlEditor-redo": "Redo",
    "dxHtmlEditor-clear": "Clear Formatting",
    "dxHtmlEditor-insertTable": "Insert Table",
    "dxHtmlEditor-insertRowAbove": "Insert Row Above",
    "dxHtmlEditor-insertRowBelow": "Insert Row Below",
    "dxHtmlEditor-insertColumnLeft": "Insert Column Left",
    "dxHtmlEditor-insertColumnRight": "Insert Column Right",
    "dxHtmlEditor-deleteColumn": "Delete Column",
    "dxHtmlEditor-deleteRow": "Delete Row",
    "dxHtmlEditor-deleteTable": "Delete Table",
    "dxHtmlEditor-list": "List",
    "dxHtmlEditor-ordered": "Ordered",
    "dxHtmlEditor-bullet": "Bullet",
    "dxHtmlEditor-align": "Align",
    "dxHtmlEditor-center": "Center",
    "dxHtmlEditor-left": "Left",
    "dxHtmlEditor-right": "Right",
    "dxHtmlEditor-indent": "Indent",
    "dxHtmlEditor-justify": "Justify",
    "dxFileManager-newDirectoryName": "Untitled directory",
    "dxFileManager-rootDirectoryName": "Files",
    "dxFileManager-errorNoAccess": "Access Denied. Operation could not be completed.",
    "dxFileManager-errorDirectoryExistsFormat": "Directory '{0}' already exists.",
    "dxFileManager-errorFileExistsFormat": "File '{0}' already exists.",
    "dxFileManager-errorFileNotFoundFormat": "File '{0}' not found.",
    "dxFileManager-errorDirectoryNotFoundFormat": "Directory '{0}' not found.",
    "dxFileManager-errorWrongFileExtension": "File extension is not allowed.",
    "dxFileManager-errorMaxFileSizeExceeded": "File size exceeds the maximum allowed size.",
    "dxFileManager-errorInvalidSymbols": "This name contains invalid characters.",
    "dxFileManager-errorDefault": "Unspecified error.",
    "dxFileManager-errorDirectoryOpenFailed": "The directory cannot be opened",
    "dxFileManager-commandCreate": "New directory",
    "dxFileManager-commandRename": "Rename",
    "dxFileManager-commandMove": "Move to",
    "dxFileManager-commandCopy": "Copy to",
    "dxFileManager-commandDelete": "Delete",
    "dxFileManager-commandDownload": "Download",
    "dxFileManager-commandUpload": "Upload files",
    "dxFileManager-commandRefresh": "Refresh",
    "dxFileManager-commandThumbnails": "Thumbnails View",
    "dxFileManager-commandDetails": "Details View",
    "dxFileManager-commandClearSelection": "Clear selection",
    "dxFileManager-commandShowNavPane": "Toggle navigation pane",
    "dxFileManager-dialogDirectoryChooserMoveTitle": "Move to",
    "dxFileManager-dialogDirectoryChooserMoveButtonText": "Move",
    "dxFileManager-dialogDirectoryChooserCopyTitle": "Copy to",
    "dxFileManager-dialogDirectoryChooserCopyButtonText": "Copy",
    "dxFileManager-dialogRenameItemTitle": "Rename",
    "dxFileManager-dialogRenameItemButtonText": "Save",
    "dxFileManager-dialogCreateDirectoryTitle": "New directory",
    "dxFileManager-dialogCreateDirectoryButtonText": "Create",
    "dxFileManager-dialogDeleteItemTitle": "Delete",
    "dxFileManager-dialogDeleteItemButtonText": "Delete",
    "dxFileManager-dialogDeleteItemSingleItemConfirmation": "Are you sure you want to delete {0}?",
    "dxFileManager-dialogDeleteItemMultipleItemsConfirmation": "Are you sure you want to delete {0} items?",
    "dxFileManager-dialogButtonCancel": "Cancel",
    "dxFileManager-editingCreateSingleItemProcessingMessage": "Creating a directory inside {0}",
    "dxFileManager-editingCreateSingleItemSuccessMessage": "Created a directory inside {0}",
    "dxFileManager-editingCreateSingleItemErrorMessage": "Directory was not created",
    "dxFileManager-editingCreateCommonErrorMessage": "Directory was not created",
    "dxFileManager-editingRenameSingleItemProcessingMessage": "Renaming an item inside {0}",
    "dxFileManager-editingRenameSingleItemSuccessMessage": "Renamed an item inside {0}",
    "dxFileManager-editingRenameSingleItemErrorMessage": "Item was not renamed",
    "dxFileManager-editingRenameCommonErrorMessage": "Item was not renamed",
    "dxFileManager-editingDeleteSingleItemProcessingMessage": "Deleting an item from {0}",
    "dxFileManager-editingDeleteMultipleItemsProcessingMessage": "Deleting {0} items from {1}",
    "dxFileManager-editingDeleteSingleItemSuccessMessage": "Deleted an item from {0}",
    "dxFileManager-editingDeleteMultipleItemsSuccessMessage": "Deleted {0} items from {1}",
    "dxFileManager-editingDeleteSingleItemErrorMessage": "Item was not deleted",
    "dxFileManager-editingDeleteMultipleItemsErrorMessage": "{0} items were not deleted",
    "dxFileManager-editingDeleteCommonErrorMessage": "Some items were not deleted",
    "dxFileManager-editingMoveSingleItemProcessingMessage": "Moving an item to {0}",
    "dxFileManager-editingMoveMultipleItemsProcessingMessage": "Moving {0} items to {1}",
    "dxFileManager-editingMoveSingleItemSuccessMessage": "Moved an item to {0}",
    "dxFileManager-editingMoveMultipleItemsSuccessMessage": "Moved {0} items to {1}",
    "dxFileManager-editingMoveSingleItemErrorMessage": "Item was not moved",
    "dxFileManager-editingMoveMultipleItemsErrorMessage": "{0} items were not moved",
    "dxFileManager-editingMoveCommonErrorMessage": "Some items were not moved",
    "dxFileManager-editingCopySingleItemProcessingMessage": "Copying an item to {0}",
    "dxFileManager-editingCopyMultipleItemsProcessingMessage": "Copying {0} items to {1}",
    "dxFileManager-editingCopySingleItemSuccessMessage": "Copied an item to {0}",
    "dxFileManager-editingCopyMultipleItemsSuccessMessage": "Copied {0} items to {1}",
    "dxFileManager-editingCopySingleItemErrorMessage": "Item was not copied",
    "dxFileManager-editingCopyMultipleItemsErrorMessage": "{0} items were not copied",
    "dxFileManager-editingCopyCommonErrorMessage": "Some items were not copied",
    "dxFileManager-editingUploadSingleItemProcessingMessage": "Uploading an item to {0}",
    "dxFileManager-editingUploadMultipleItemsProcessingMessage": "Uploading {0} items to {1}",
    "dxFileManager-editingUploadSingleItemSuccessMessage": "Uploaded an item to {0}",
    "dxFileManager-editingUploadMultipleItemsSuccessMessage": "Uploaded {0} items to {1}",
    "dxFileManager-editingUploadSingleItemErrorMessage": "Item was not uploaded",
    "dxFileManager-editingUploadMultipleItemsErrorMessage": "{0} items were not uploaded",
    "dxFileManager-editingUploadCanceledMessage": "Canceled",
    "dxFileManager-listDetailsColumnCaptionName": "Name",
    "dxFileManager-listDetailsColumnCaptionDateModified": "Date Modified",
    "dxFileManager-listDetailsColumnCaptionFileSize": "File Size",
    "dxFileManager-listThumbnailsTooltipTextSize": "Size",
    "dxFileManager-listThumbnailsTooltipTextDateModified": "Date Modified",
    "dxFileManager-notificationProgressPanelTitle": "Progress",
    "dxFileManager-notificationProgressPanelEmptyListText": "No operations",
    "dxFileManager-notificationProgressPanelOperationCanceled": "Canceled",
    "dxDiagram-categoryGeneral": "General",
    "dxDiagram-categoryFlowchart": "Flowchart",
    "dxDiagram-categoryOrgChart": "Org Chart",
    "dxDiagram-categoryContainers": "Containers",
    "dxDiagram-categoryCustom": "Custom",
    "dxDiagram-commandExportToSvg": "Export to SVG",
    "dxDiagram-commandExportToPng": "Export to PNG",
    "dxDiagram-commandExportToJpg": "Export to JPEG",
    "dxDiagram-commandUndo": "Undo",
    "dxDiagram-commandRedo": "Redo",
    "dxDiagram-commandFontName": "Font Name",
    "dxDiagram-commandFontSize": "Font Size",
    "dxDiagram-commandBold": "Bold",
    "dxDiagram-commandItalic": "Italic",
    "dxDiagram-commandUnderline": "Underline",
    "dxDiagram-commandTextColor": "Font Color",
    "dxDiagram-commandLineColor": "Line Color",
    "dxDiagram-commandLineWidth": "Line Width",
    "dxDiagram-commandLineStyle": "Line Style",
    "dxDiagram-commandLineStyleSolid": "Solid",
    "dxDiagram-commandLineStyleDotted": "Dotted",
    "dxDiagram-commandLineStyleDashed": "Dashed",
    "dxDiagram-commandFillColor": "Fill Color",
    "dxDiagram-commandAlignLeft": "Align Left",
    "dxDiagram-commandAlignCenter": "Align Center",
    "dxDiagram-commandAlignRight": "Align Right",
    "dxDiagram-commandConnectorLineType": "Connector Line Type",
    "dxDiagram-commandConnectorLineStraight": "Straight",
    "dxDiagram-commandConnectorLineOrthogonal": "Orthogonal",
    "dxDiagram-commandConnectorLineStart": "Connector Line Start",
    "dxDiagram-commandConnectorLineEnd": "Connector Line End",
    "dxDiagram-commandConnectorLineNone": "None",
    "dxDiagram-commandConnectorLineArrow": "Arrow",
    "dxDiagram-commandFullscreen": "Full Screen",
    "dxDiagram-commandUnits": "Units",
    "dxDiagram-commandPageSize": "Page Size",
    "dxDiagram-commandPageOrientation": "Page Orientation",
    "dxDiagram-commandPageOrientationLandscape": "Landscape",
    "dxDiagram-commandPageOrientationPortrait": "Portrait",
    "dxDiagram-commandPageColor": "Page Color",
    "dxDiagram-commandShowGrid": "Show Grid",
    "dxDiagram-commandSnapToGrid": "Snap to Grid",
    "dxDiagram-commandGridSize": "Grid Size",
    "dxDiagram-commandZoomLevel": "Zoom Level",
    "dxDiagram-commandAutoZoom": "Auto Zoom",
    "dxDiagram-commandFitToContent": "Fit to Content",
    "dxDiagram-commandFitToWidth": "Fit to Width",
    "dxDiagram-commandAutoZoomByContent": "Auto Zoom by Content",
    "dxDiagram-commandAutoZoomByWidth": "Auto Zoom by Width",
    "dxDiagram-commandSimpleView": "Simple View",
    "dxDiagram-commandCut": "Cut",
    "dxDiagram-commandCopy": "Copy",
    "dxDiagram-commandPaste": "Paste",
    "dxDiagram-commandSelectAll": "Select All",
    "dxDiagram-commandDelete": "Delete",
    "dxDiagram-commandBringToFront": "Bring to Front",
    "dxDiagram-commandSendToBack": "Send to Back",
    "dxDiagram-commandLock": "Lock",
    "dxDiagram-commandUnlock": "Unlock",
    "dxDiagram-commandInsertShapeImage": "Insert Image...",
    "dxDiagram-commandEditShapeImage": "Change Image...",
    "dxDiagram-commandDeleteShapeImage": "Delete Image",
    "dxDiagram-commandLayoutLeftToRight": "Left-to-right",
    "dxDiagram-commandLayoutRightToLeft": "Right-to-left",
    "dxDiagram-commandLayoutTopToBottom": "Top-to-bottom",
    "dxDiagram-commandLayoutBottomToTop": "Bottom-to-top",
    "dxDiagram-unitIn": "in",
    "dxDiagram-unitCm": "cm",
    "dxDiagram-unitPx": "px",
    "dxDiagram-dialogButtonOK": "OK",
    "dxDiagram-dialogButtonCancel": "Cancel",
    "dxDiagram-dialogInsertShapeImageTitle": "Insert Image",
    "dxDiagram-dialogEditShapeImageTitle": "Change Image",
    "dxDiagram-dialogEditShapeImageSelectButton": "Select image",
    "dxDiagram-dialogEditShapeImageLabelText": "or drop file here",
    "dxDiagram-uiExport": "Export",
    "dxDiagram-uiProperties": "Properties",
    "dxDiagram-uiSettings": "Settings",
    "dxDiagram-uiShowToolbox": "Show Toolbox",
    "dxDiagram-uiSearch": "Search",
    "dxDiagram-uiStyle": "Style",
    "dxDiagram-uiLayout": "Layout",
    "dxDiagram-uiLayoutTree": "Tree",
    "dxDiagram-uiLayoutLayered": "Layered",
    "dxDiagram-uiDiagram": "Diagram",
    "dxDiagram-uiText": "Text",
    "dxDiagram-uiObject": "Object",
    "dxDiagram-uiConnector": "Connector",
    "dxDiagram-uiPage": "Page",
    "dxDiagram-shapeText": "Text",
    "dxDiagram-shapeRectangle": "Rectangle",
    "dxDiagram-shapeEllipse": "Ellipse",
    "dxDiagram-shapeCross": "Cross",
    "dxDiagram-shapeTriangle": "Triangle",
    "dxDiagram-shapeDiamond": "Diamond",
    "dxDiagram-shapeHeart": "Heart",
    "dxDiagram-shapePentagon": "Pentagon",
    "dxDiagram-shapeHexagon": "Hexagon",
    "dxDiagram-shapeOctagon": "Octagon",
    "dxDiagram-shapeStar": "Star",
    "dxDiagram-shapeArrowLeft": "Left Arrow",
    "dxDiagram-shapeArrowUp": "Up Arrow",
    "dxDiagram-shapeArrowRight": "Right Arrow",
    "dxDiagram-shapeArrowDown": "Down Arrow",
    "dxDiagram-shapeArrowUpDown": "Up Down Arrow",
    "dxDiagram-shapeArrowLeftRight": "Left Right Arrow",
    "dxDiagram-shapeProcess": "Process",
    "dxDiagram-shapeDecision": "Decision",
    "dxDiagram-shapeTerminator": "Terminator",
    "dxDiagram-shapePredefinedProcess": "Predefined Process",
    "dxDiagram-shapeDocument": "Document",
    "dxDiagram-shapeMultipleDocuments": "Multiple Documents",
    "dxDiagram-shapeManualInput": "Manual Input",
    "dxDiagram-shapePreparation": "Preparation",
    "dxDiagram-shapeData": "Data",
    "dxDiagram-shapeDatabase": "Database",
    "dxDiagram-shapeHardDisk": "Hard Disk",
    "dxDiagram-shapeInternalStorage": "Internal Storage",
    "dxDiagram-shapePaperTape": "Paper Tape",
    "dxDiagram-shapeManualOperation": "Manual Operation",
    "dxDiagram-shapeDelay": "Delay",
    "dxDiagram-shapeStoredData": "Stored Data",
    "dxDiagram-shapeDisplay": "Display",
    "dxDiagram-shapeMerge": "Merge",
    "dxDiagram-shapeConnector": "Connector",
    "dxDiagram-shapeOr": "Or",
    "dxDiagram-shapeSummingJunction": "Summing Junction",
    "dxDiagram-shapeContainerDefaultText": "Container",
    "dxDiagram-shapeVerticalContainer": "Vertical Container",
    "dxDiagram-shapeHorizontalContainer": "Horizontal Container",
    "dxDiagram-shapeCardDefaultText": "Person's Name",
    "dxDiagram-shapeCardWithImageOnLeft": "Card with Image on the Left",
    "dxDiagram-shapeCardWithImageOnTop": "Card with Image on the Top",
    "dxDiagram-shapeCardWithImageOnRight": "Card with Image on the Right",
    "dxGantt-dialogTitle": "Title",
    "dxGantt-dialogStartTitle": "Start",
    "dxGantt-dialogEndTitle": "End",
    "dxGantt-dialogProgressTitle": "Progress",
    "dxGantt-dialogResourcesTitle": "Resources",
    "dxGantt-dialogResourceManagerTitle": "Resource Manager",
    "dxGantt-dialogTaskDetailsTitle": "Task Details",
    "dxGantt-dialogEditResourceListHint": "Edit Resource List",
    "dxGantt-dialogEditNoResources": "No resources",
    "dxGantt-dialogButtonAdd": "Add",
    "dxGantt-contextMenuNewTask": "New Task",
    "dxGantt-contextMenuNewSubtask": "New Subtask",
    "dxGantt-contextMenuDeleteTask": "Delete Task",
    "dxGantt-contextMenuDeleteDependency": "Delete Dependency",
    "dxGantt-dialogTaskDeleteConfirmation": "Deleting a task also deletes all its dependencies and subtasks. Are you sure you want to delete this task?",
    "dxGantt-dialogDependencyDeleteConfirmation": "Are you sure you want to delete the dependency from the task?",
    "dxGantt-dialogResourcesDeleteConfirmation": "Deleting a resource also deletes it from tasks to which this resource is assigned. Are you sure you want to delete these resources? Resources: {0}",
    "dxGantt-dialogConstraintCriticalViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. This change would conflict with dependency rules. How would you like to proceed?",
    "dxGantt-dialogConstraintViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. How would you like to proceed?",
    "dxGantt-dialogCancelOperationMessage": "Cancel the operation",
    "dxGantt-dialogDeleteDependencyMessage": "Delete the dependency",
    "dxGantt-dialogMoveTaskAndKeepDependencyMessage": "Move the task and keep the dependency",
    "dxGantt-undo": "Undo",
    "dxGantt-redo": "Redo",
    "dxGantt-expandAll": "Expand All",
    "dxGantt-collapseAll": "Collapse All",
    "dxGantt-addNewTask": "Add New Task",
    "dxGantt-deleteSelectedTask": "Delete Selected Task",
    "dxGantt-zoomIn": "Zoom In",
    "dxGantt-zoomOut": "Zoom Out",
    "dxGantt-fullScreen": "Full Screen",
    "dxGantt-quarter": "Q{0}"
  }
};
exports.defaultMessages = defaultMessages;

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.ExportFormat = void 0;

var _string = __webpack_require__(40);

var _number = _interopRequireDefault(__webpack_require__(46));

var _date = _interopRequireDefault(__webpack_require__(33));

var _type = __webpack_require__(1);

var _date2 = __webpack_require__(170);

var _language_codes = __webpack_require__(212);

var _extend = __webpack_require__(0);

__webpack_require__(112);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ARABIC_ZERO_CODE = 1632;
var DEFINED_NUMBER_FORMTATS = {
  thousands: '#,##0{0},&quot;K&quot;',
  millions: '#,##0{0},,&quot;M&quot;',
  billions: '#,##0{0},,,&quot;B&quot;',
  trillions: '#,##0{0},,,,&quot;T&quot;',
  percent: '0{0}%',
  decimal: '#{0}',
  'fixedpoint': '#,##0{0}',
  exponential: '0{0}E+00',
  currency: ' '
};
var PERIOD_REGEXP = /a+/g;
var DAY_REGEXP = /E/g;
var DO_REGEXP = /dE+/g;
var STANDALONE_MONTH_REGEXP = /L/g;
var HOUR_REGEXP = /h/g;
var ANY_REGEXP = /./g;

function _applyPrecision(format, precision) {
  var result;
  var i;

  if (precision > 0) {
    result = format !== 'decimal' ? '.' : '';

    for (i = 0; i < precision; i++) {
      result = result + '0';
    }

    return result;
  }

  return '';
}

function _hasArabicDigits(text) {
  var code;

  for (var i = 0; i < text.length; i++) {
    code = text.charCodeAt(i);

    if (code >= ARABIC_ZERO_CODE && code < ARABIC_ZERO_CODE + 10) {
      return true;
    }
  }

  return false;
}

function _convertDateFormat(format) {
  var formattedValue = (_date.default.format(new Date(2009, 8, 8, 6, 5, 4), format) || '').toString();
  var result = (0, _date2.getFormat)(function (value) {
    return _date.default.format(value, format);
  });

  if (result) {
    result = _convertDateFormatToOpenXml(result);
    result = _getLanguageInfo(formattedValue) + result;
  }

  return result;
}

function _getLanguageInfo(defaultPattern) {
  var languageID = (0, _language_codes.getLanguageId)();
  var languageIDStr = languageID ? languageID.toString(16) : '';
  var languageInfo = '';

  if (_hasArabicDigits(defaultPattern)) {
    while (languageIDStr.length < 3) {
      languageIDStr = '0' + languageIDStr;
    }

    languageInfo = '[$-2010' + languageIDStr + ']';
  } else if (languageIDStr) {
    languageInfo = '[$-' + languageIDStr + ']';
  }

  return languageInfo;
}

function _convertDateFormatToOpenXml(format) {
  return format.split('/').join('\\/').split('\'').map(function (datePart, index) {
    if (index % 2 === 0) {
      return datePart.replace(PERIOD_REGEXP, 'AM/PM').replace(DO_REGEXP, 'd').replace(DAY_REGEXP, 'd').replace(STANDALONE_MONTH_REGEXP, 'M').replace(HOUR_REGEXP, 'H').split('[').join('\\[').split(']').join('\\]');
    }

    if (datePart) {
      return datePart.replace(ANY_REGEXP, '\\$&');
    }

    return '\'';
  }).join('');
}

function _convertNumberFormat(format, precision, currency) {
  var result;
  var excelFormat;

  if (format === 'currency') {
    excelFormat = _number.default.getOpenXmlCurrencyFormat(currency);
  } else {
    excelFormat = DEFINED_NUMBER_FORMTATS[format.toLowerCase()];
  }

  if (excelFormat) {
    result = (0, _string.format)(excelFormat, _applyPrecision(format, precision));
  }

  return result;
}

var ExportFormat = {
  formatObjectConverter: function formatObjectConverter(format, dataType) {
    var result = {
      format: format,
      precision: format && format.precision,
      dataType: dataType
    };

    if ((0, _type.isObject)(format)) {
      return (0, _extend.extend)(result, format, {
        format: format.formatter || format.type,
        currency: format.currency
      });
    }

    return result;
  },
  convertFormat: function convertFormat(format, precision, type, currency) {
    if ((0, _type.isDefined)(format)) {
      if (type === 'date') {
        return _convertDateFormat(format);
      } else {
        if ((0, _type.isString)(format) && DEFINED_NUMBER_FORMTATS[format.toLowerCase()]) {
          return _convertNumberFormat(format, precision, currency);
        }
      }
    }
  }
};
exports.ExportFormat = ExportFormat;

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.MergedRangesManager = void 0;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var MergedRangesManager = /*#__PURE__*/function () {
  function MergedRangesManager(dataProvider, helpers, mergeRowFieldValues, mergeColumnFieldValues) {
    this.mergedCells = [];
    this.mergedRanges = [];
    this.dataProvider = dataProvider;
    this.helpers = helpers;
    this.mergeRowFieldValues = mergeRowFieldValues;
    this.mergeColumnFieldValues = mergeColumnFieldValues;
  }

  var _proto = MergedRangesManager.prototype;

  _proto.updateMergedRanges = function updateMergedRanges(excelCell, rowIndex, cellIndex) {
    if (this.helpers._isHeaderCell(this.dataProvider, rowIndex, cellIndex)) {
      if (!this.isCellInMergedRanges(rowIndex, cellIndex)) {
        var _this$dataProvider$ge = this.dataProvider.getCellMerging(rowIndex, cellIndex),
            rowspan = _this$dataProvider$ge.rowspan,
            colspan = _this$dataProvider$ge.colspan;

        var isMasterCellOfMergedRange = colspan || rowspan;

        if (isMasterCellOfMergedRange) {
          var allowToMergeRange = this.helpers._allowToMergeRange(this.dataProvider, rowIndex, cellIndex, rowspan, colspan, this.mergeRowFieldValues, this.mergeColumnFieldValues);

          this.updateMergedCells(excelCell, rowIndex, cellIndex, rowspan, colspan, allowToMergeRange);

          if (allowToMergeRange) {
            this.mergedRanges.push(_extends({
              masterCell: excelCell
            }, {
              rowspan: rowspan,
              colspan: colspan
            }));
          }
        }
      }
    }
  };

  _proto.isCellInMergedRanges = function isCellInMergedRanges(rowIndex, cellIndex) {
    return this.mergedCells[rowIndex] && this.mergedCells[rowIndex][cellIndex];
  };

  _proto.findMergedCellInfo = function findMergedCellInfo(rowIndex, cellIndex) {
    if (this.helpers._isHeaderCell(this.dataProvider, rowIndex, cellIndex)) {
      if (this.isCellInMergedRanges(rowIndex, cellIndex)) {
        return this.mergedCells[rowIndex][cellIndex];
      }
    }
  };

  _proto.updateMergedCells = function updateMergedCells(excelCell, rowIndex, cellIndex, rowspan, colspan, allowToMergeRange) {
    for (var i = rowIndex; i <= rowIndex + rowspan; i++) {
      for (var j = cellIndex; j <= cellIndex + colspan; j++) {
        if (!this.mergedCells[i]) {
          this.mergedCells[i] = [];
        }

        this.mergedCells[i][j] = {
          masterCell: excelCell,
          unmerged: !allowToMergeRange
        };
      }
    }
  };

  _proto.applyMergedRages = function applyMergedRages(worksheet) {
    this.mergedRanges.forEach(function (range) {
      var startRowIndex = range.masterCell.fullAddress.row;
      var startColumnIndex = range.masterCell.fullAddress.col;
      var endRowIndex = startRowIndex + range.rowspan;
      var endColumnIndex = startColumnIndex + range.colspan;
      worksheet.mergeCells(startRowIndex, startColumnIndex, endRowIndex, endColumnIndex);
    });
  };

  return MergedRangesManager;
}();

exports.MergedRangesManager = MergedRangesManager;

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.exportPivotGrid = exportPivotGrid;

var _type = __webpack_require__(1);

var _export = __webpack_require__(259);

var _common = __webpack_require__(4);

var helpers = {
  _getWorksheetFrozenState: function _getWorksheetFrozenState(dataProvider, cellRange) {
    return {
      state: 'frozen',
      xSplit: cellRange.from.column + dataProvider.getFrozenArea().x - 1,
      ySplit: cellRange.from.row + dataProvider.getFrozenArea().y - 1
    };
  },
  _getCustomizeCellOptions: function _getCustomizeCellOptions(excelCell, pivotCell) {
    return {
      excelCell: excelCell,
      pivotCell: pivotCell
    };
  },
  _isFrozenZone: function _isFrozenZone() {
    return true;
  },
  _isHeaderCell: function _isHeaderCell(dataProvider, rowIndex, cellIndex) {
    return rowIndex < dataProvider.getColumnAreaRowCount() || cellIndex < dataProvider.getRowAreaColCount();
  },
  _allowToMergeRange: function _allowToMergeRange(dataProvider, rowIndex, cellIndex, rowspan, colspan, mergeRowFieldValues, mergeColumnFieldValues) {
    return !(dataProvider.isColumnAreaCell(rowIndex, cellIndex) && !mergeColumnFieldValues && !!colspan || dataProvider.isRowAreaCell(rowIndex, cellIndex) && !mergeRowFieldValues && !!rowspan);
  },
  _renderLoadPanel: function _renderLoadPanel(component) {
    component._renderLoadPanel(component._dataArea.groupElement(), component.$element());
  },
  _trySetAutoFilter: _common.noop,
  _trySetFont: _common.noop,
  _trySetOutlineLevel: _common.noop
};

function exportPivotGrid(options) {
  return _export.Export.export(_getFullOptions(options), helpers);
}

function _getFullOptions(options) {
  if (!((0, _type.isDefined)(options) && (0, _type.isObject)(options))) {
    throw Error('The "exportPivotGrid" method requires a configuration object.');
  }

  if (!((0, _type.isDefined)(options.component) && (0, _type.isObject)(options.component) && options.component.NAME === 'dxPivotGrid')) {
    throw Error('The "component" field must contain a PivotGrid instance.');
  }

  if (!(0, _type.isDefined)(options.mergeRowFieldValues)) {
    options.mergeRowFieldValues = true;
  }

  if (!(0, _type.isDefined)(options.mergeColumnFieldValues)) {
    options.mergeColumnFieldValues = true;
  }

  return _export.Export.getFullOptions(options);
}

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "exportDataGrid", {
  enumerable: true,
  get: function get() {
    return _export_data_grid.exportDataGrid;
  }
});

var _export_data_grid = __webpack_require__(378);

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.exportDataGrid = exportDataGrid;

var _type = __webpack_require__(1);

var _export = __webpack_require__(379);

function _getFullOptions(options) {
  if (!((0, _type.isDefined)(options) && (0, _type.isObject)(options))) {
    throw Error('The "exportDataGrid" method requires a configuration object.');
  }

  if (!((0, _type.isDefined)(options.component) && (0, _type.isObject)(options.component) && options.component.NAME === 'dxDataGrid')) {
    throw Error('The "component" field must contain a DataGrid instance.');
  }

  if (!(0, _type.isDefined)(options.selectedRowsOnly)) {
    options.selectedRowsOnly = false;
  }

  return _export.Export.getFullOptions(options);
}

function exportDataGrid(options) {
  return _export.Export.export(_getFullOptions(options));
}

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Export = void 0;

var _type = __webpack_require__(1);

var _extend = __webpack_require__(0);

var _date = _interopRequireDefault(__webpack_require__(33));

var _number = _interopRequireDefault(__webpack_require__(46));

var _message = _interopRequireDefault(__webpack_require__(10));

var _window = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Export = {
  getFullOptions: function getFullOptions(options) {
    var fullOptions = (0, _extend.extend)({}, options);

    if (!((0, _type.isDefined)(fullOptions.jsPDFDocument) && (0, _type.isObject)(fullOptions.jsPDFDocument))) {
      throw Error('The "jsPDFDocument" field must contain a jsPDF instance.');
    }

    if (!((0, _type.isDefined)(fullOptions.jsPDFDocument.autoTable) && (0, _type.isFunction)(fullOptions.jsPDFDocument.autoTable))) {
      throw Error('The "exportDataGrid" method requires a autoTable plugin for jsPDF object.');
    }

    if (!(0, _type.isDefined)(fullOptions.keepColumnWidths)) {
      fullOptions.keepColumnWidths = true;
    }

    if (!(0, _type.isDefined)(fullOptions.autoTableOptions)) {
      fullOptions.autoTableOptions = this._getDefaultAutoTableOptions();
    } else {
      if (!(0, _type.isObject)(fullOptions.autoTableOptions)) {
        throw Error('The "autoTableOptions" option must be of object type.');
      }

      fullOptions.autoTableOptions = (0, _extend.extend)(true, {}, this._getDefaultAutoTableOptions(), fullOptions.autoTableOptions);
    }

    if (!(0, _type.isDefined)(fullOptions.loadPanel)) {
      fullOptions.loadPanel = {};
    }

    if (!(0, _type.isDefined)(fullOptions.loadPanel.enabled)) {
      fullOptions.loadPanel.enabled = true;
    }

    if (!(0, _type.isDefined)(fullOptions.loadPanel.text)) {
      fullOptions.loadPanel.text = _message.default.format('dxDataGrid-exporting');
    }

    return fullOptions;
  },
  _getDefaultAutoTableOptions: function _getDefaultAutoTableOptions() {
    return {
      theme: 'plain',
      tableLineColor: 149,
      tableLineWidth: 0.1,
      styles: {
        textColor: 51,
        lineColor: 149,
        lineWidth: 0
      },
      columnStyles: {},
      headStyles: {
        fontStyle: 'normal',
        textColor: 149,
        lineWidth: 0.1
      },
      bodyStyles: {
        lineWidth: 0.1
      },
      head: [],
      body: []
    };
  },
  _setLoadPanelOptions: function _setLoadPanelOptions(component, options) {
    if (!(0, _window.hasWindow)()) {
      return;
    }

    component._setOptionWithoutOptionChange('loadPanel', options);

    this._renderLoadPanel(component);
  },
  _renderLoadPanel: function _renderLoadPanel(component) {
    var rowsView = component.getView('rowsView');

    rowsView._renderLoadPanel(rowsView.element(), rowsView.element().parent());
  },
  export: function _export(options) {
    var _component$_getIntern,
        _this = this;

    var jsPDFDocument = options.jsPDFDocument,
        autoTableOptions = options.autoTableOptions,
        component = options.component,
        customizeCell = options.customizeCell,
        keepColumnWidths = options.keepColumnWidths,
        selectedRowsOnly = options.selectedRowsOnly,
        loadPanel = options.loadPanel;
    var internalComponent = ((_component$_getIntern = component._getInternalInstance) === null || _component$_getIntern === void 0 ? void 0 : _component$_getIntern.call(component)) || component;
    var initialLoadPanelOptions = (0, _extend.extend)({}, internalComponent.option('loadPanel'));

    if ('animation' in internalComponent.option('loadPanel')) {
      loadPanel.animation = null;
    }

    this._setLoadPanelOptions(internalComponent, loadPanel);

    var dataProvider = component.getDataProvider(selectedRowsOnly);
    var wrapText = !!component.option('wordWrapEnabled');
    return new Promise(function (resolve) {
      dataProvider.ready().done(function () {
        var columns = dataProvider.getColumns();
        var styles = dataProvider.getStyles();
        var dataRowsCount = dataProvider.getRowsCount();
        var headerRowCount = dataProvider.getHeaderRowCount();
        var mergedCells = [];

        if (keepColumnWidths) {
          var pdfColumnWidths = _this._tryGetPdfColumnWidths(autoTableOptions.tableWidth, dataProvider.getColumnsWidths());

          if ((0, _type.isDefined)(pdfColumnWidths) && (0, _type.isDefined)(autoTableOptions.columnStyles)) {
            _this._setColumnWidths(autoTableOptions.columnStyles, pdfColumnWidths);
          }
        }

        for (var rowIndex = 0; rowIndex < dataRowsCount; rowIndex++) {
          var row = [];

          for (var cellIndex = 0; cellIndex < columns.length; cellIndex++) {
            var _dataProvider$getCell = dataProvider.getCellData(rowIndex, cellIndex, true),
                value = _dataProvider$getCell.value,
                gridCell = _dataProvider$getCell.cellSourceData;

            var cellStyle = styles[dataProvider.getStyleId(rowIndex, cellIndex)];
            var pdfCell = {
              content: _this._getFormattedValue(value, cellStyle.format),
              styles: _this._getPDFCellStyles(gridCell.rowType, columns[cellIndex].alignment, cellStyle, wrapText)
            };

            if (gridCell.rowType === 'header') {
              var mergedRange = _this._tryGetMergeRange(rowIndex, cellIndex, mergedCells, dataProvider);

              if (mergedRange && mergedRange.rowSpan > 0) {
                pdfCell.rowSpan = mergedRange.rowSpan + 1;
              }

              if (mergedRange && mergedRange.colSpan > 0) {
                pdfCell.colSpan = mergedRange.colSpan + 1;
              }

              var isMergedCell = mergedCells[rowIndex] && mergedCells[rowIndex][cellIndex];

              if (!isMergedCell || pdfCell.rowSpan > 1 || pdfCell.colSpan > 1) {
                if ((0, _type.isFunction)(customizeCell)) {
                  customizeCell({
                    gridCell: gridCell,
                    pdfCell: pdfCell
                  });
                }

                row.push(pdfCell);
              }
            } else if (gridCell.rowType === 'group' && !(0, _type.isDefined)(pdfCell.content) && row.length === 1) {
              var _row$0$colSpan;

              row[0].colSpan = (_row$0$colSpan = row[0].colSpan) !== null && _row$0$colSpan !== void 0 ? _row$0$colSpan : 1;
              row[0].colSpan++;
            } else {
              var _pdfCell$content;

              pdfCell.content = (_pdfCell$content = pdfCell.content) !== null && _pdfCell$content !== void 0 ? _pdfCell$content : '';

              if ((0, _type.isFunction)(customizeCell)) {
                customizeCell({
                  gridCell: gridCell,
                  pdfCell: pdfCell
                });
              }

              row.push(pdfCell);
            }
          }

          if (rowIndex < headerRowCount) {
            autoTableOptions.head.push(row);
          } else {
            autoTableOptions.body.push(row);
          }
        }

        jsPDFDocument.autoTable(autoTableOptions);
        resolve();
      }).always(function () {
        _this._setLoadPanelOptions(internalComponent, initialLoadPanelOptions);
      });
    });
  },
  _getFormattedValue: function _getFormattedValue(value, format) {
    if ((0, _type.isDefined)(format)) {
      if ((0, _type.isDate)(value)) {
        return _date.default.format(value, format);
      }

      if ((0, _type.isNumeric)(value)) {
        return _number.default.format(value, format);
      }
    }

    return value;
  },
  _getPDFCellStyles: function _getPDFCellStyles(rowType, columnAlignment, cellStyle, wrapText) {
    var cellAlignment = cellStyle.alignment,
        bold = cellStyle.bold;
    var align = rowType === 'header' ? columnAlignment : cellAlignment;
    var pdfCellStyle = {};

    if (align) {
      pdfCellStyle['halign'] = align;
    }

    if (bold && rowType !== 'header') {
      pdfCellStyle.fontStyle = 'bold';
    }

    if (wrapText) {
      pdfCellStyle.cellWidth = 'wrap';
    }

    return pdfCellStyle;
  },
  _tryGetMergeRange: function _tryGetMergeRange(rowIndex, cellIndex, mergedCells, dataProvider) {
    if (!mergedCells[rowIndex] || !mergedCells[rowIndex][cellIndex]) {
      var _dataProvider$getCell2 = dataProvider.getCellMerging(rowIndex, cellIndex),
          colspan = _dataProvider$getCell2.colspan,
          rowspan = _dataProvider$getCell2.rowspan;

      if (colspan || rowspan) {
        for (var i = rowIndex; i <= rowIndex + rowspan || 0; i++) {
          for (var j = cellIndex; j <= cellIndex + colspan || 0; j++) {
            if (!mergedCells[i]) {
              mergedCells[i] = [];
            }

            mergedCells[i][j] = true;
          }
        }

        return {
          rowSpan: rowspan,
          colSpan: colspan
        };
      }
    }
  },
  _tryGetPdfColumnWidths: function _tryGetPdfColumnWidths(autoTableWidth, columnWidths) {
    if ((0, _type.isNumeric)(autoTableWidth) && (0, _type.isDefined)(columnWidths)) {
      var tableWidth = columnWidths.reduce(function (a, b) {
        return a + b;
      }, 0);
      return columnWidths.map(function (columnWidth) {
        return autoTableWidth * columnWidth / tableWidth;
      });
    }
  },
  _setColumnWidths: function _setColumnWidths(autoTableColumnStyles, pdfColumnWidths) {
    pdfColumnWidths.forEach(function (width, index) {
      autoTableColumnStyles[index] = autoTableColumnStyles[index] || {};
      autoTableColumnStyles[index].cellWidth = width;
    });
  }
};
exports.Export = Export;

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.OptionManager = void 0;

var _data = __webpack_require__(21);

var _common = __webpack_require__(4);

var _comparator = __webpack_require__(260);

var _extend = __webpack_require__(0);

var _type = __webpack_require__(1);

var _utils = __webpack_require__(126);

var cachedGetters = {};
var cachedSetters = {};

var OptionManager = /*#__PURE__*/function () {
  function OptionManager(options, optionsByReference) {
    this._options = options;
    this._optionsByReference = optionsByReference;
    this._changingCallback;
    this._changedCallback;
    this._namePreparedCallbacks;
  }

  var _proto = OptionManager.prototype;

  _proto._setByReference = function _setByReference(options, rulesOptions) {
    (0, _extend.extend)(true, options, rulesOptions);

    for (var fieldName in this._optionsByReference) {
      if (Object.prototype.hasOwnProperty.call(rulesOptions, fieldName)) {
        options[fieldName] = rulesOptions[fieldName];
      }
    }
  };

  _proto._setPreparedValue = function _setPreparedValue(name, value, merge, silent) {
    var previousValue = this.get(this._options, name, false);

    if (!(0, _comparator.equals)(previousValue, value)) {
      var path = (0, _data.getPathParts)(name);
      !silent && this._changingCallback(name, previousValue, value);
      cachedSetters[name] = cachedSetters[name] || (0, _data.compileSetter)(name);
      cachedSetters[name](this._options, value, {
        functionsAsIs: true,
        merge: (0, _type.isDefined)(merge) ? merge : !this._optionsByReference[name],
        unwrapObservables: path.length > 1 && !!this._optionsByReference[path[0]]
      });
      !silent && this._changedCallback(name, value, previousValue);
    }
  };

  _proto._prepareRelevantNames = function _prepareRelevantNames(options, name, value, silent) {
    if ((0, _type.isPlainObject)(value)) {
      for (var valueName in value) {
        this._prepareRelevantNames(options, "".concat(name, ".").concat(valueName), value[valueName]);
      }
    }

    this._namePreparedCallbacks(options, name, value, silent);
  };

  _proto.get = function get() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._options;
    var name = arguments.length > 1 ? arguments[1] : undefined;
    var unwrapObservables = arguments.length > 2 ? arguments[2] : undefined;
    cachedGetters[name] = cachedGetters[name] || (0, _data.compileGetter)(name);
    return cachedGetters[name](options, {
      functionsAsIs: true,
      unwrapObservables: unwrapObservables
    });
  };

  _proto.set = function set(options, value, merge, silent) {
    options = (0, _utils.normalizeOptions)(options, value);

    for (var name in options) {
      this._prepareRelevantNames(options, name, options[name], silent);
    }

    for (var _name in options) {
      this._setPreparedValue(_name, options[_name], merge, silent);
    }
  };

  _proto.onRelevantNamesPrepared = function onRelevantNamesPrepared(callBack) {
    this._namePreparedCallbacks = callBack;
  };

  _proto.onChanging = function onChanging(callBack) {
    this._changingCallback = callBack;
  };

  _proto.onChanged = function onChanged(callBack) {
    this._changedCallback = callBack;
  };

  _proto.dispose = function dispose() {
    this._changingCallback = _common.noop;
    this._changedCallback = _common.noop;
  };

  return OptionManager;
}();

exports.OptionManager = OptionManager;

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.PostponedOperations = void 0;

var _deferred = __webpack_require__(6);

var _type = __webpack_require__(1);

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var PostponedOperations = /*#__PURE__*/function () {
  function PostponedOperations() {
    this._postponedOperations = {};
  }

  var _proto = PostponedOperations.prototype;

  _proto.add = function add(key, fn, postponedPromise) {
    if (key in this._postponedOperations) {
      postponedPromise && this._postponedOperations[key].promises.push(postponedPromise);
    } else {
      var completePromise = new _deferred.Deferred();
      this._postponedOperations[key] = {
        fn: fn,
        completePromise: completePromise,
        promises: postponedPromise ? [postponedPromise] : []
      };
    }

    return this._postponedOperations[key].completePromise.promise();
  };

  _proto.callPostponedOperations = function callPostponedOperations() {
    for (var key in this._postponedOperations) {
      var operation = this._postponedOperations[key];

      if ((0, _type.isDefined)(operation)) {
        if (operation.promises && operation.promises.length) {
          _deferred.when.apply(void 0, _toConsumableArray(operation.promises)).done(operation.fn).then(operation.completePromise.resolve);
        } else {
          operation.fn().done(operation.completePromise.resolve);
        }
      }
    }

    this._postponedOperations = {};
  };

  return PostponedOperations;
}();

exports.PostponedOperations = PostponedOperations;

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.TemplateManager = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _type = __webpack_require__(1);

var _common = __webpack_require__(4);

var _extend = __webpack_require__(0);

var _function_template = __webpack_require__(148);

var _empty_template = __webpack_require__(93);

var _template_manager = __webpack_require__(261);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var TEXT_NODE = 3;
var ANONYMOUS_TEMPLATE_NAME = 'template';
var TEMPLATE_OPTIONS_NAME = 'dxTemplate';
var TEMPLATE_WRAPPER_CLASS = 'dx-template-wrapper';
var DX_POLYMORPH_WIDGET_TEMPLATE = new _function_template.FunctionTemplate(function (_ref) {
  var model = _ref.model,
      parent = _ref.parent;
  var widgetName = model.widget;
  if (!widgetName) return (0, _renderer.default)();
  var widgetElement = (0, _renderer.default)('<div>');
  var widgetOptions = model.options || {};

  if (parent) {
    parent._createComponent(widgetElement, widgetName, widgetOptions);
  } else {
    widgetElement[widgetName](widgetOptions);
  }

  return widgetElement;
});

var TemplateManager = /*#__PURE__*/function () {
  function TemplateManager(createElement, anonymousTemplateName) {
    this._tempTemplates = [];
    this._defaultTemplates = {};
    this._anonymousTemplateName = anonymousTemplateName || ANONYMOUS_TEMPLATE_NAME;
    this._createElement = createElement || _template_manager.defaultCreateElement;
    this._createTemplateIfNeeded = this._createTemplateIfNeeded.bind(this);
  }

  TemplateManager.createDefaultOptions = function createDefaultOptions() {
    return {
      integrationOptions: {
        watchMethod: function watchMethod(fn, callback) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          if (!options.skipImmediate) {
            callback(fn());
          }

          return _common.noop;
        },
        templates: {
          'dx-polymorph-widget': DX_POLYMORPH_WIDGET_TEMPLATE
        },
        useDeferUpdateForTemplates: true
      }
    };
  };

  var _proto = TemplateManager.prototype;

  _proto.addDefaultTemplates = function addDefaultTemplates(templates) {
    this._defaultTemplates = (0, _extend.extend)({}, this._defaultTemplates, templates);
  };

  _proto.dispose = function dispose() {
    this._tempTemplates.forEach(function (tempTemplate) {
      tempTemplate.template.dispose && tempTemplate.template.dispose();
    });

    this._tempTemplates = [];
  };

  _proto.extractTemplates = function extractTemplates($el) {
    var templates = this._extractTemplates($el);

    var anonymousTemplateMeta = this._extractAnonymousTemplate($el);

    return {
      templates: templates,
      anonymousTemplateMeta: anonymousTemplateMeta
    };
  };

  _proto._extractTemplates = function _extractTemplates($el) {
    var _this = this;

    var templates = (0, _template_manager.findTemplates)($el, TEMPLATE_OPTIONS_NAME);
    var suitableTemplates = (0, _template_manager.suitableTemplatesByName)(templates);
    templates.forEach(function (_ref2) {
      var element = _ref2.element,
          name = _ref2.options.name;

      if (element === suitableTemplates[name]) {
        (0, _renderer.default)(element).addClass(TEMPLATE_WRAPPER_CLASS).detach();
      } else {
        (0, _renderer.default)(element).remove();
      }
    });
    return Object.keys(suitableTemplates).map(function (name) {
      return {
        name: name,
        template: _this._createTemplate(suitableTemplates[name])
      };
    });
  };

  _proto._extractAnonymousTemplate = function _extractAnonymousTemplate($el) {
    var $anonymousTemplate = $el.contents().detach();
    var $notJunkTemplateContent = $anonymousTemplate.filter(function (_, element) {
      var isTextNode = element.nodeType === TEXT_NODE;
      var isEmptyText = (0, _renderer.default)(element).text().trim().length < 1;
      return !(isTextNode && isEmptyText);
    });
    return $notJunkTemplateContent.length > 0 ? {
      template: this._createTemplate($anonymousTemplate),
      name: this._anonymousTemplateName
    } : {};
  };

  _proto._createTemplateIfNeeded = function _createTemplateIfNeeded(templateSource) {
    var cachedTemplate = this._tempTemplates.filter(function (tempTemplate) {
      return tempTemplate.source === (0, _template_manager.templateKey)(templateSource);
    })[0];

    if (cachedTemplate) return cachedTemplate.template;

    var template = this._createTemplate(templateSource);

    this._tempTemplates.push({
      template: template,
      source: (0, _template_manager.templateKey)(templateSource)
    });

    return template;
  };

  _proto._createTemplate = function _createTemplate(templateSource) {
    return this._createElement((0, _template_manager.validateTemplateSource)(templateSource));
  };

  _proto.getTemplate = function getTemplate(templateSource, templates, _ref3, context) {
    var _this2 = this;

    var isAsyncTemplate = _ref3.isAsyncTemplate,
        skipTemplates = _ref3.skipTemplates;

    if (!(0, _type.isFunction)(templateSource)) {
      return (0, _template_manager.acquireTemplate)(templateSource, this._createTemplateIfNeeded, templates, isAsyncTemplate, skipTemplates, this._defaultTemplates);
    }

    return new _function_template.FunctionTemplate(function (options) {
      var templateSourceResult = templateSource.apply(context, (0, _template_manager.getNormalizedTemplateArgs)(options));

      if (!(0, _type.isDefined)(templateSourceResult)) {
        return new _empty_template.EmptyTemplate();
      }

      var dispose = false;
      var template = (0, _template_manager.acquireTemplate)(templateSourceResult, function (templateSource) {
        if (templateSource.nodeType || (0, _type.isRenderer)(templateSource) && !(0, _renderer.default)(templateSource).is('script')) {
          return new _function_template.FunctionTemplate(function () {
            return templateSource;
          });
        }

        dispose = true;
        return _this2._createTemplate(templateSource);
      }, templates, isAsyncTemplate, skipTemplates, _this2._defaultTemplates);
      var result = template.render(options);
      dispose && template.dispose && template.dispose();
      return result;
    });
  };

  _createClass(TemplateManager, [{
    key: "anonymousTemplateName",
    get: function get() {
      return this._anonymousTemplateName;
    }
  }]);

  return TemplateManager;
}();

exports.TemplateManager = TemplateManager;

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Template = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _template_base = __webpack_require__(69);

var _dom = __webpack_require__(35);

var _template_engine_registry = __webpack_require__(171);

__webpack_require__(384);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

(0, _template_engine_registry.registerTemplateEngine)('default', {
  compile: function compile(element) {
    return (0, _dom.normalizeTemplateElement)(element);
  },
  render: function render(template, model, index) {
    return template.clone();
  }
});
(0, _template_engine_registry.setTemplateEngine)('default');

var Template = /*#__PURE__*/function (_TemplateBase) {
  _inheritsLoose(Template, _TemplateBase);

  function Template(element) {
    var _this;

    _this = _TemplateBase.call(this) || this;
    _this._element = element;
    return _this;
  }

  var _proto = Template.prototype;

  _proto._renderCore = function _renderCore(options) {
    var transclude = options.transclude;

    if (!transclude && !this._compiledTemplate) {
      this._compiledTemplate = (0, _template_engine_registry.getCurrentTemplateEngine)().compile(this._element);
    }

    return (0, _renderer.default)('<div>').append(transclude ? this._element : (0, _template_engine_registry.getCurrentTemplateEngine)().render(this._compiledTemplate, options.model, options.index)).contents();
  };

  _proto.source = function source() {
    return (0, _renderer.default)(this._element).clone();
  };

  return Template;
}(_template_base.TemplateBase);

exports.Template = Template;

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _dom = __webpack_require__(35);

var _template_engine_registry = __webpack_require__(171);

(0, _template_engine_registry.registerTemplateEngine)('jquery-tmpl', {
  compile: function compile(element) {
    return (0, _dom.extractTemplateMarkup)(element);
  },
  render: function render(template, data) {
    /* global jQuery */
    return jQuery.tmpl(template, data);
  }
});
(0, _template_engine_registry.registerTemplateEngine)('jsrender', {
  compile: function compile(element) {
    /* global jsrender */
    return (jQuery ? jQuery : jsrender).templates((0, _dom.extractTemplateMarkup)(element));
  },
  render: function render(template, data) {
    return template.render(data);
  }
});
(0, _template_engine_registry.registerTemplateEngine)('mustache', {
  compile: function compile(element) {
    /* global Mustache */
    return (0, _dom.extractTemplateMarkup)(element);
  },
  render: function render(template, data) {
    return Mustache.render(template, data);
  }
});
(0, _template_engine_registry.registerTemplateEngine)('hogan', {
  compile: function compile(element) {
    /* global Hogan */
    return Hogan.compile((0, _dom.extractTemplateMarkup)(element));
  },
  render: function render(template, data) {
    return template.render(data);
  }
});
(0, _template_engine_registry.registerTemplateEngine)('underscore', {
  compile: function compile(element) {
    /* global _ */
    return _.template((0, _dom.extractTemplateMarkup)(element));
  },
  render: function render(template, data) {
    return template(data);
  }
});
(0, _template_engine_registry.registerTemplateEngine)('handlebars', {
  compile: function compile(element) {
    /* global Handlebars */
    return Handlebars.compile((0, _dom.extractTemplateMarkup)(element));
  },
  render: function render(template, data) {
    return template(data);
  }
});
(0, _template_engine_registry.registerTemplateEngine)('doT', {
  compile: function compile(element) {
    /* global doT */
    return doT.template((0, _dom.extractTemplateMarkup)(element));
  },
  render: function render(template, data) {
    return template(data);
  }
});

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _class = _interopRequireDefault(__webpack_require__(15));

var _array = __webpack_require__(12);

var _index = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var COMPOSITION_START_EVENT = 'compositionstart';
var COMPOSITION_END_EVENT = 'compositionend';
var KEYDOWN_EVENT = 'keydown';
var NAMESPACE = 'KeyboardProcessor';

var KeyboardProcessor = _class.default.inherit({
  _keydown: (0, _index.addNamespace)(KEYDOWN_EVENT, NAMESPACE),
  _compositionStart: (0, _index.addNamespace)(COMPOSITION_START_EVENT, NAMESPACE),
  _compositionEnd: (0, _index.addNamespace)(COMPOSITION_END_EVENT, NAMESPACE),
  ctor: function ctor(options) {
    var _this = this;

    options = options || {};

    if (options.element) {
      this._element = (0, _renderer.default)(options.element);
    }

    if (options.focusTarget) {
      this._focusTarget = options.focusTarget;
    }

    this._handler = options.handler;

    if (this._element) {
      this._processFunction = function (e) {
        var isNotFocusTarget = _this._focusTarget && _this._focusTarget !== e.target && (0, _array.inArray)(e.target, (0, _renderer.default)(_this._focusTarget)) < 0;
        var shouldSkipProcessing = _this._isComposingJustFinished && e.which === 229 || _this._isComposing || isNotFocusTarget;
        _this._isComposingJustFinished = false;

        if (!shouldSkipProcessing) {
          _this.process(e);
        }
      };

      this._toggleProcessingWithContext = this.toggleProcessing.bind(this);

      _events_engine.default.on(this._element, this._keydown, this._processFunction);

      _events_engine.default.on(this._element, this._compositionStart, this._toggleProcessingWithContext);

      _events_engine.default.on(this._element, this._compositionEnd, this._toggleProcessingWithContext);
    }
  },
  dispose: function dispose() {
    if (this._element) {
      _events_engine.default.off(this._element, this._keydown, this._processFunction);

      _events_engine.default.off(this._element, this._compositionStart, this._toggleProcessingWithContext);

      _events_engine.default.off(this._element, this._compositionEnd, this._toggleProcessingWithContext);
    }

    this._element = undefined;
    this._handler = undefined;
  },
  process: function process(e) {
    this._handler({
      keyName: (0, _index.normalizeKeyName)(e),
      key: e.key,
      code: e.code,
      ctrl: e.ctrlKey,
      location: e.location,
      metaKey: e.metaKey,
      shift: e.shiftKey,
      alt: e.altKey,
      which: e.which,
      originalEvent: e
    });
  },
  toggleProcessing: function toggleProcessing(_ref) {
    var type = _ref.type;
    this._isComposing = type === COMPOSITION_START_EVENT;
    this._isComposingJustFinished = !this._isComposing;
  }
});

var _default = KeyboardProcessor;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _errors = _interopRequireDefault(__webpack_require__(24));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var addNamespace = function addNamespace(eventNames, namespace) {
  if (!namespace) {
    throw _errors.default.Error('E0017');
  }

  if (Array.isArray(eventNames)) {
    return eventNames.map(function (eventName) {
      return addNamespace(eventName, namespace);
    }).join(' ');
  }

  if (eventNames.indexOf(' ') !== -1) {
    return addNamespace(eventNames.split(/\s+/g), namespace);
  }

  return "".concat(eventNames, ".").concat(namespace);
};

var _default = addNamespace;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _base = _interopRequireDefault(__webpack_require__(165));

var _observer = _interopRequireDefault(__webpack_require__(263));

var _extend = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var eventMap = {
  'dxpointerdown': 'pointerdown',
  'dxpointermove': 'pointermove',
  'dxpointerup': 'pointerup',
  'dxpointercancel': 'pointercancel',
  'dxpointerover': 'pointerover',
  'dxpointerout': 'pointerout',
  'dxpointerenter': 'pointerenter',
  'dxpointerleave': 'pointerleave'
};
var observer;
var activated = false;

var activateStrategy = function activateStrategy() {
  if (activated) {
    return;
  }

  observer = new _observer.default(eventMap, function (a, b) {
    return a.pointerId === b.pointerId;
  }, function (e) {
    if (e.isPrimary) observer.reset();
  });
  activated = true;
};

var MsPointerStrategy = _base.default.inherit({
  ctor: function ctor() {
    this.callBase.apply(this, arguments);
    activateStrategy();
  },
  _fireEvent: function _fireEvent(args) {
    return this.callBase((0, _extend.extend)({
      pointers: observer.pointers(),
      pointerId: args.originalEvent.pointerId
    }, args));
  }
});

MsPointerStrategy.map = eventMap;

MsPointerStrategy.resetObserver = function () {
  observer.reset();
};

var _default = MsPointerStrategy;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _extend = __webpack_require__(0);

var _base = _interopRequireDefault(__webpack_require__(165));

var _mouse = _interopRequireDefault(__webpack_require__(264));

var _touch = _interopRequireDefault(__webpack_require__(262));

var _index = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var eventMap = {
  'dxpointerdown': 'touchstart mousedown',
  'dxpointermove': 'touchmove mousemove',
  'dxpointerup': 'touchend mouseup',
  'dxpointercancel': 'touchcancel',
  'dxpointerover': 'mouseover',
  'dxpointerout': 'mouseout',
  'dxpointerenter': 'mouseenter',
  'dxpointerleave': 'mouseleave'
};
var activated = false;

var activateStrategy = function activateStrategy() {
  if (activated) {
    return;
  }

  _mouse.default.activate();

  activated = true;
};

var MouseAndTouchStrategy = _base.default.inherit({
  EVENT_LOCK_TIMEOUT: 100,
  ctor: function ctor() {
    this.callBase.apply(this, arguments);
    activateStrategy();
  },
  _handler: function _handler(e) {
    var isMouse = (0, _index.isMouseEvent)(e);

    if (!isMouse) {
      this._skipNextEvents = true;
    }

    if (isMouse && this._mouseLocked) {
      return;
    }

    if (isMouse && this._skipNextEvents) {
      this._skipNextEvents = false;
      this._mouseLocked = true;
      clearTimeout(this._unlockMouseTimer);
      var that = this;
      this._unlockMouseTimer = setTimeout(function () {
        that._mouseLocked = false;
      }, this.EVENT_LOCK_TIMEOUT);
      return;
    }

    return this.callBase(e);
  },
  _fireEvent: function _fireEvent(args) {
    var normalizer = (0, _index.isMouseEvent)(args.originalEvent) ? _mouse.default.normalize : _touch.default.normalize;
    return this.callBase((0, _extend.extend)(normalizer(args.originalEvent), args));
  },
  dispose: function dispose() {
    this.callBase();
    this._skipNextEvents = false;
    this._mouseLocked = false;
    clearTimeout(this._unlockMouseTimer);
  }
});

MouseAndTouchStrategy.map = eventMap;
MouseAndTouchStrategy.resetObserver = _mouse.default.resetObserver;
var _default = MouseAndTouchStrategy;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.initMobileViewport = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _window = __webpack_require__(7);

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _extend = __webpack_require__(0);

var _resize_callbacks = _interopRequireDefault(__webpack_require__(103));

var _support = __webpack_require__(48);

var _style = __webpack_require__(92);

var _devices = _interopRequireDefault(__webpack_require__(13));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var window = (0, _window.getWindow)();

var initMobileViewport = function initMobileViewport(options) {
  options = (0, _extend.extend)({}, options);

  var realDevice = _devices.default.real();

  var allowZoom = options.allowZoom;
  var allowPan = options.allowPan;
  var allowSelection = 'allowSelection' in options ? options.allowSelection : realDevice.platform === 'generic';
  var metaSelector = 'meta[name=viewport]';

  if (!(0, _renderer.default)(metaSelector).length) {
    (0, _renderer.default)('<meta>').attr('name', 'viewport').appendTo('head');
  }

  var metaVerbs = ['width=device-width'];
  var msTouchVerbs = [];

  if (allowZoom) {
    msTouchVerbs.push('pinch-zoom');
  } else {
    metaVerbs.push('initial-scale=1.0', 'maximum-scale=1.0, user-scalable=no');
  }

  if (allowPan) {
    msTouchVerbs.push('pan-x', 'pan-y');
  }

  if (!allowPan && !allowZoom) {
    (0, _renderer.default)('html, body').css({
      'msContentZooming': 'none',
      'msUserSelect': 'none',
      'overflow': 'hidden'
    });
  } else {
    (0, _renderer.default)('html').css('msOverflowStyle', '-ms-autohiding-scrollbar');
  }

  if (!allowSelection && (0, _support.supportProp)('userSelect')) {
    (0, _renderer.default)('.dx-viewport').css((0, _style.styleProp)('userSelect'), 'none');
  }

  (0, _renderer.default)(metaSelector).attr('content', metaVerbs.join());
  (0, _renderer.default)('html').css('msTouchAction', msTouchVerbs.join(' ') || 'none');
  realDevice = _devices.default.real();

  if (_support.touch) {
    _events_engine.default.off(_dom_adapter.default.getDocument(), '.dxInitMobileViewport');

    _events_engine.default.on(_dom_adapter.default.getDocument(), 'dxpointermove.dxInitMobileViewport', function (e) {
      var count = e.pointers.length;
      var isTouchEvent = e.pointerType === 'touch';
      var zoomDisabled = !allowZoom && count > 1;
      var panDisabled = !allowPan && count === 1 && !e.isScrollingEvent;

      if (isTouchEvent && (zoomDisabled || panDisabled)) {
        e.preventDefault();
      }
    });
  }

  if (realDevice.ios) {
    var isPhoneGap = _dom_adapter.default.getLocation().protocol === 'file:';

    if (!isPhoneGap) {
      // NOTE: fix app size after device rotation in Safari when keyboard was shown
      _resize_callbacks.default.add(function () {
        var windowWidth = (0, _renderer.default)(window).width();
        (0, _renderer.default)('body').width(windowWidth);
      });
    }
  }

  if (realDevice.android) {
    _resize_callbacks.default.add(function () {
      setTimeout(function () {
        var activeElement = _dom_adapter.default.getActiveElement();

        activeElement.scrollIntoViewIfNeeded ? activeElement.scrollIntoViewIfNeeded() : activeElement.scrollIntoView(false);
      });
    });
  }
};

exports.initMobileViewport = initMobileViewport;

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getTimeZones = void 0;

var _utils = _interopRequireDefault(__webpack_require__(70));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getTimeZones = _utils.default.getTimeZones;
exports.getTimeZones = getTimeZones;

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _query_adapters = _interopRequireDefault(__webpack_require__(196));

var _errors = __webpack_require__(37);

var _iterator = __webpack_require__(3);

var _type = __webpack_require__(1);

var _deferred = __webpack_require__(6);

var _array_query = _interopRequireDefault(__webpack_require__(166));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var remoteQueryImpl = function remoteQueryImpl(url, queryOptions, tasks) {
  tasks = tasks || [];
  queryOptions = queryOptions || {};

  var createTask = function createTask(name, args) {
    return {
      name: name,
      args: args
    };
  };

  var exec = function exec(executorTask) {
    var d = new _deferred.Deferred();

    var _adapterFactory;

    var _adapter;

    var _taskQueue;

    var _currentTask;

    var _mergedSortArgs;

    var rejectWithNotify = function rejectWithNotify(error) {
      var handler = queryOptions.errorHandler;

      if (handler) {
        handler(error);
      }

      (0, _errors.handleError)(error);
      d.reject(error);
    };

    function mergeSortTask(task) {
      switch (task.name) {
        case 'sortBy':
          _mergedSortArgs = [task.args];
          return true;

        case 'thenBy':
          if (!_mergedSortArgs) {
            throw _errors.errors.Error('E4004');
          }

          _mergedSortArgs.push(task.args);

          return true;
      }

      return false;
    }

    function unmergeSortTasks() {
      var head = _taskQueue[0];
      var unmergedTasks = [];

      if (head && head.name === 'multiSort') {
        _taskQueue.shift();

        (0, _iterator.each)(head.args[0], function () {
          unmergedTasks.push(createTask(unmergedTasks.length ? 'thenBy' : 'sortBy', this));
        });
      }

      _taskQueue = unmergedTasks.concat(_taskQueue);
    }

    try {
      _adapterFactory = queryOptions.adapter;

      if (!(0, _type.isFunction)(_adapterFactory)) {
        _adapterFactory = _query_adapters.default[_adapterFactory];
      }

      _adapter = _adapterFactory(queryOptions);
      _taskQueue = [].concat(tasks).concat(executorTask);
      var optimize = _adapter.optimize;
      if (optimize) optimize(_taskQueue);

      while (_taskQueue.length) {
        _currentTask = _taskQueue[0];

        if (!mergeSortTask(_currentTask)) {
          if (_mergedSortArgs) {
            _taskQueue.unshift(createTask('multiSort', [_mergedSortArgs]));

            _mergedSortArgs = null;
            continue;
          }

          if (String(_currentTask.name) !== 'enumerate') {
            if (!_adapter[_currentTask.name] || _adapter[_currentTask.name].apply(_adapter, _currentTask.args) === false) {
              break;
            }
          }
        }

        _taskQueue.shift();
      }

      unmergeSortTasks();

      _adapter.exec(url).done(function (result, extra) {
        if (!_taskQueue.length) {
          d.resolve(result, extra);
        } else {
          var clientChain = (0, _array_query.default)(result, {
            errorHandler: queryOptions.errorHandler
          });
          (0, _iterator.each)(_taskQueue, function () {
            clientChain = clientChain[this.name].apply(clientChain, this.args);
          });
          clientChain.done(d.resolve).fail(d.reject);
        }
      }).fail(rejectWithNotify);
    } catch (x) {
      rejectWithNotify(x);
    }

    return d.promise();
  };

  var query = {};
  (0, _iterator.each)(['sortBy', 'thenBy', 'filter', 'slice', 'select', 'groupBy'], function () {
    var name = String(this);

    query[name] = function () {
      return remoteQueryImpl(url, queryOptions, tasks.concat(createTask(name, arguments)));
    };
  });
  (0, _iterator.each)(['count', 'min', 'max', 'sum', 'avg', 'aggregate', 'enumerate'], function () {
    var name = String(this);

    query[name] = function () {
      return exec.call(this, createTask(name, arguments));
    };
  });
  return query;
};

var _default = remoteQueryImpl;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;
var _default = {
  'zones': [{
    'id': 'Africa/Abidjan',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Accra',
    'untils': '-r507yk|1e3pak|681qo|cjvlc|681qo|cjvlc|681qo|cjvlc|681qo|clq9c|681qo|cjvlc|681qo|cjvlc|681qo|cjvlc|681qo|clq9c|681qo|cjvlc|681qo|cjvlc|681qo|cjvlc|681qo|clq9c|681qo|cjvlc|681qo|cjvlc|681qo|cjvlc|681qo|clq9c|681qo|cjvlc|681qo|cjvlc|681qo|cjvlc|681qo|clq9c|681qo|cjvlc|681qo|cjvlc|681qo|Infinity',
    'offsets': '0.8667|0|-20',
    'offsetIndices': '012121212121212121212121212121212121212121212121'
  }, {
    'id': 'Africa/Addis_Ababa',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Africa/Algiers',
    'untils': '-uozn3l|2qx1nl|5luo0|8y800|a4tc0|7vc00|auqo0|7idc0|b7pc0|6sg00|cyo00|7ayo0|53c00|9idxc0|3i040|51mw0|253uk0|9o2k0|92040|8l3s0|jutc0|4uy840|3rdzw0|46xc00|7x6o0|2xco40|8n180|7x9g0|9d440|kiqg0|9d440|9q2s0|9cyk0|Infinity',
    'offsets': '-9.35|0|-60|-120',
    'offsetIndices': '0121212121212121232321212122321212'
  }, {
    'id': 'Africa/Asmara',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Africa/Asmera',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Africa/Bamako',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Bangui',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Banjul',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Bissau',
    'untils': '-u9rek0|wvoyo0|Infinity',
    'offsets': '62.3333|60|0',
    'offsetIndices': '012'
  }, {
    'id': 'Africa/Blantyre',
    'untils': '-yvtfd8|Infinity',
    'offsets': '-130.3333|-120',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Brazzaville',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Bujumbura',
    'untils': '-yvtfd8|Infinity',
    'offsets': '-130.3333|-120',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Cairo',
    'untils': '-fdls80|40d80|a31g0|7x3w0|a4w40|aqyk0|80ys0|b07w0|7tk40|b07w0|8jhg0|a8fw0|60go40|7el80|awo40|7v980|awqw0|7tk40|b07w0|7tk40|ayd80|7tk40|ayd80|7tk40|ayd80|7tk40|b07w0|7tk40|ayd80|7tk40|ayd80|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|f9x80|3i040|eluk0|462s0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|b5rw0|7m5g0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|aqvs0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7k580|b5xg0|6u7w0|bvus0|6h980|c8tg0|64ak0|cyqs0|5anw0|1jms0|12t80|1w22s0|25p80|1sw40|2vmk0|Infinity',
    'offsets': '-120|-180',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Africa/Casablanca',
    'untils': '-tblt9g|di7nxg|3huk0|51k40|2znuk0|2dp9g0|776k0|8nt2s0|657w0|3ifxg0|3jp80|va040|4qak0|e1ms0|7pp80|cnms0|3afw0|2xi840|xqqk0|bp56s0|4qak0|e1ms0|45x80|d2g40|51ek0|c8tg0|64ak0|e1sc0|47uo0|1leo0|23xc0|asw00|3lmo0|1qyo0|40g00|7x6o0|4mo00|1stc0|4deo0|7x6o0|3ylc0|1stc0|51hc0|7x6o0|3lmo0|1stc0|5reo0|7k800|2vpc0|25s00|64dc0|7k800|2iqo0|1stc0|gkao0|1stc0|g7c00|25s00|g7c00|1stc0|g7c00|25s00|g7c00|1stc0|gkao0|1stc0|g7c00|25s00|g7c00|1stc0|gkao0|1stc0|g7c00|25s00|g7c00|1stc0|g7c00|25s00|g7c00|1stc0|gkao0|1stc0|g7c00|25s00|g7c00|1stc0|g7c00|25s00|g7c00|25s00|g7c00|1stc0|g7c00|25s00|Infinity',
    'offsets': '30.3333|0|-60',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'Africa/Ceuta',
    'untils': '-qyiys0|7x3w0|2vt440|8sqs0|ssyk0|8n6s0|9px80|905g0|a2yo0|902o0|k69dc0|657w0|3ifxg0|3jp80|va040|4qak0|e1ms0|7pp80|cnms0|3afw0|2xi840|129us0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '010101010101010101010121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Africa/Conakry',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Dakar',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Dar_es_Salaam',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Africa/Djibouti',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Africa/Douala',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/El_Aaiun',
    'untils': '-isdxk0|m2g0c0|vek0|4qak0|e1ms0|7pp80|cnms0|3afw0|fke5g0|4qak0|e1ms0|45x80|d2g40|51ek0|c8tg0|64ak0|e1sc0|47uo0|1leo0|23xc0|asw00|3lmo0|1qyo0|40g00|7x6o0|4mo00|1stc0|4deo0|7x6o0|3ylc0|1stc0|51hc0|7x6o0|3lmo0|1stc0|5reo0|7k800|2vpc0|25s00|64dc0|7k800|2iqo0|1stc0|gkao0|1stc0|g7c00|25s00|g7c00|1stc0|g7c00|25s00|g7c00|1stc0|gkao0|1stc0|g7c00|25s00|g7c00|1stc0|gkao0|1stc0|g7c00|25s00|g7c00|1stc0|g7c00|25s00|g7c00|1stc0|gkao0|1stc0|g7c00|25s00|g7c00|1stc0|g7c00|25s00|g7c00|25s00|g7c00|1stc0|g7c00|25s00|Infinity',
    'offsets': '52.8|60|0|-60',
    'offsetIndices': '012323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'Africa/Freetown',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Gaborone',
    'untils': '-yvtfd8|Infinity',
    'offsets': '-130.3333|-120',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Harare',
    'untils': '-yvtfd8|Infinity',
    'offsets': '-130.3333|-120',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Johannesburg',
    'untils': '-yvtdi0|kn7o60|9cyk0|9d440|9cyk0|Infinity',
    'offsets': '-90|-120|-180',
    'offsetIndices': '012121'
  }, {
    'id': 'Africa/Juba',
    'untils': '-kcrsis|kixuys|8l6k0|a4w40|8n180|a6qs0|8n180|a31g0|8ovw0|a16s0|8qqk0|9zc40|8sl80|9xhg0|8wak0|9ts40|8y580|a4w40|8n180|a31g0|8ovw0|a16s0|8sl80|9xhg0|8ufw0|9vms0|8wak0|9ts40|8y580|a4w40|8ovw0|a16s0|8qqk0|7frw40|Infinity',
    'offsets': '-126.4667|-120|-180',
    'offsetIndices': '01212121212121212121212121212121212'
  }, {
    'id': 'Africa/Kampala',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Africa/Khartoum',
    'untils': '-kcrsow|kixv4w|8l6k0|a4w40|8n180|a6qs0|8n180|a31g0|8ovw0|a16s0|8qqk0|9zc40|8sl80|9xhg0|8wak0|9ts40|8y580|a4w40|8n180|a31g0|8ovw0|a16s0|8sl80|9xhg0|8ufw0|9vms0|8wak0|9ts40|8y580|a4w40|8ovw0|a16s0|8qqk0|7frw40|9ac180|Infinity',
    'offsets': '-130.1333|-120|-180',
    'offsetIndices': '012121212121212121212121212121212121'
  }, {
    'id': 'Africa/Kigali',
    'untils': '-yvtfd8|Infinity',
    'offsets': '-130.3333|-120',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Kinshasa',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Lagos',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Libreville',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Lome',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Luanda',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Lubumbashi',
    'untils': '-yvtfd8|Infinity',
    'offsets': '-130.3333|-120',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Lusaka',
    'untils': '-yvtfd8|Infinity',
    'offsets': '-130.3333|-120',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Malabo',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Maputo',
    'untils': '-yvtfd8|Infinity',
    'offsets': '-130.3333|-120',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Maseru',
    'untils': '-yvtdi0|kn7o60|9cyk0|9d440|9cyk0|Infinity',
    'offsets': '-90|-120|-180',
    'offsetIndices': '012121'
  }, {
    'id': 'Africa/Mbabane',
    'untils': '-yvtdi0|kn7o60|9cyk0|9d440|9cyk0|Infinity',
    'offsets': '-90|-120|-180',
    'offsetIndices': '012121'
  }, {
    'id': 'Africa/Mogadishu',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Africa/Monrovia',
    'untils': '-qj6zc4|rl202a|Infinity',
    'offsets': '43.1333|44.5|0',
    'offsetIndices': '012'
  }, {
    'id': 'Africa/Nairobi',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Africa/Ndjamena',
    'untils': '-u9rk4c|zdk5cc|7iak0|Infinity',
    'offsets': '-60.2|-60|-120',
    'offsetIndices': '0121'
  }, {
    'id': 'Africa/Niamey',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Nouakchott',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Ouagadougou',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Porto-Novo',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Sao_Tome',
    'untils': '-u9rhc0|1jbm840|irxc0|Infinity',
    'offsets': '36.75|0|-60',
    'offsetIndices': '0121'
  }, {
    'id': 'Africa/Timbuktu',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Tripoli',
    'untils': '-q3gfrw|gl6ajw|422c0|xado0|4bbo0|wrpg0|4s580|1kdpg0|c05bw0|4mqs0|9et80|9d440|9et80|9eys0|9et80|9mdg0|95jw0|9io40|9cyk0|99es0|9et80|9eys0|9et80|9d440|9et80|b2840|3cf3w0|9kis0|9et80|7vqyw0|75eo0|asw00|Infinity',
    'offsets': '-52.7333|-60|-120',
    'offsetIndices': '012121212121212121212121212122122'
  }, {
    'id': 'Africa/Tunis',
    'untils': '-uozn3l|enxevl|b5uo0|53c00|u8w00|7x9g0|c8w80|7k800|z3w0|ew40|8bx80|9d440|9nx00|925o0|8l100|gi3440|7k800|b9k00|7vc00|51mw00|5ytc0|9d1c0|9d1c0|b9k00|7thc0|7m0tc0|7tk40|93us0|b5uo0|7k800|b5uo0|7x6o0|asw00|Infinity',
    'offsets': '-9.35|-60|-120',
    'offsetIndices': '0121212121212121212121212121212121'
  }, {
    'id': 'Africa/Windhoek',
    'untils': '-yvtdi0|kn7o60|9cyk0|oj2nw0|235k00|8lho0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|Infinity',
    'offsets': '-90|-120|-180|-60',
    'offsetIndices': '01211313131313131313131313131313131313131313131313131'
  }, {
    'id': 'America/Adak',
    'untils': '-ek1nw0|1tyug0|2e6s0|b7yik0|12y080|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|1l940|7rs80|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '660|600|540',
    'offsetIndices': '011001010101010101010101010101010111212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Anchorage',
    'untils': '-ek1qo0|1tyx80|2e400|b7yik0|12y080|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|1l940|7rs80|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '600|540|480',
    'offsetIndices': '011001010101010101010101010101010111212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Anguilla',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Antigua',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Araguaina',
    'untils': '-t85j2o|99k8mo|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|2yl440|64ak0|c8tg0|6u7w0|bxpg0|7iak0|biw40|6u7w0|biw40|7k580|biw40|6u7w0|c8tg0|6h980|dbpg0|5ed80|51udg0|64ak0|Infinity',
    'offsets': '192.8|180|120',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Argentina/Buenos_Aires',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvus0|6u7w0|bvus0|776k0|7qcg40|3yik0|b5xg0|7k580|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323232323232'
  }, {
    'id': 'America/Argentina/Catamarca',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvxk0|6u540|bvus0|776k0|5v42s0|z9g0|1u93w0|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323132321232'
  }, {
    'id': 'America/Argentina/ComodRivadavia',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvxk0|6u540|bvus0|776k0|5v42s0|z9g0|1u93w0|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323132321232'
  }, {
    'id': 'America/Argentina/Cordoba',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvxk0|6u540|bvus0|776k0|7qcg40|3yik0|b5xg0|7k580|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323132323232'
  }, {
    'id': 'America/Argentina/Jujuy',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|c8w80|776k0|ag040|7k2g0|bvus0|776k0|7qcg40|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '012121212121212121212121212121212121212121232323121323232'
  }, {
    'id': 'America/Argentina/La_Rioja',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6qik0|3g880|8jbw0|6u7w0|bvus0|776k0|5v42s0|z9g0|1u93w0|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '012121212121212121212121212121212121212121232323231232321232'
  }, {
    'id': 'America/Argentina/Mendoza',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bktk0|71mk0|bqas0|73h80|bvus0|773s0|5unes0|6hes0|1p7mk0|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232312121321232'
  }, {
    'id': 'America/Argentina/Rio_Gallegos',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvus0|6u7w0|bvus0|776k0|5v42s0|z9g0|1u93w0|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323232321232'
  }, {
    'id': 'America/Argentina/Salta',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvxk0|6u540|bvus0|776k0|7qcg40|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '012121212121212121212121212121212121212121232323231323232'
  }, {
    'id': 'America/Argentina/San_Juan',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6qik0|3g880|8jbw0|6u7w0|bvus0|776k0|5v2840|2txg0|1sgak0|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '012121212121212121212121212121212121212121232323231232321232'
  }, {
    'id': 'America/Argentina/San_Luis',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|7pp80|b2aw0|71mk0|4qg40|6s8ik0|2txg0|1sgak0|14nw0|2gys0|b5xg0|7k580|b5xg0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '012121212121212121212121212121212121212121232323121212321212'
  }, {
    'id': 'America/Argentina/Tucuman',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvxk0|6u540|bvus0|776k0|5v42s0|mas0|1um2k0|3yik0|b5xg0|7k580|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '0121212121212121212121212121212121212121212323232313232123232'
  }, {
    'id': 'America/Argentina/Ushuaia',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvus0|6u7w0|bvus0|776k0|5v0dg0|12ys0|1u93w0|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323232321232'
  }, {
    'id': 'America/Aruba',
    'untils': '-u7lckd|rlo7qd|Infinity',
    'offsets': '275.7833|270|240',
    'offsetIndices': '012'
  }, {
    'id': 'America/Asuncion',
    'untils': '-jy93zk|ldwofk|s4vw0|s6w40|7tek0|b0dg0|7rjw0|b0dg0|7rjw0|b0dg0|9cyk0|9eys0|9et80|9eys0|9cyk0|9eys0|9cyk0|9eys0|9cyk0|9eys0|9et80|9eys0|9cyk0|9eys0|9cyk0|9eys0|9cyk0|9eys0|9et80|9eys0|9cyk0|ahus0|8a2k0|9eys0|9cyk0|9o840|7k580|b7s40|93p80|9gtg0|7nuk0|b42s0|7lzw0|b5xg0|7tek0|b9ms0|776k0|biw40|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|9cyk0|7kas0|b5rw0|7x9g0|ast80|a31g0|7k580|b5xg0|7k580|b5xg0|7k580|biw40|776k0|biw40|776k0|biw40|8zzw0|905g0|9px80|905g0|9px80|9d440|8n180|a31g0|8n180|a31g0|8n180|a31g0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|a31g0|8n180|a31g0|8n180|a31g0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|a31g0|8n180|a31g0|8n180|a31g0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|a31g0|8n180|a31g0|8n180|a31g0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|a31g0|8n180|a31g0|8n180|a31g0|Infinity',
    'offsets': '230.6667|240|180',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'America/Atikokan',
    'untils': '-qzov40|a2vw0|bfxjw0|pmdk0|1tz8c0|2dsw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '0101111'
  }, {
    'id': 'America/Atka',
    'untils': '-ek1nw0|1tyug0|2e6s0|b7yik0|12y080|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|1l940|7rs80|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '660|600|540',
    'offsetIndices': '011001010101010101010101010101010111212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Bahia_Banderas',
    'untils': '-p1u4k0|2u7jw0|1sgdc0|8n400|7thc0|9eys0|591h80|3ie2s0|axvpg0|dpgw40|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|asqg0|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|Infinity',
    'offsets': '421|420|360|480|300',
    'offsetIndices': '0121212131212121212121212121212121212142424242424242424242424242424242424242424242424242424242'
  }, {
    'id': 'America/Bahia',
    'untils': '-t85kv8|99kaf8|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|cyqs0|64ak0|cls40|5rbw0|dbpg0|51ek0|dbpg0|6h980|c8tg0|6h980|c8tg0|64ak0|c8tg0|6u7w0|bxpg0|7iak0|biw40|6u7w0|biw40|7k580|biw40|6u7w0|c8tg0|6h980|dbpg0|5ed80|4irc40|6u7w0|Infinity',
    'offsets': '154.0667|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Barbados',
    'untils': '-o0aiaj|46b400|npv1mj|5rbw0|a31g0|8n180|a31g0|8n180|ag040|84ik0|Infinity',
    'offsets': '238.4833|240|180',
    'offsetIndices': '00121212121'
  }, {
    'id': 'America/Belem',
    'untils': '-t85j0s|99k8ks|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|Infinity',
    'offsets': '193.9333|180|120',
    'offsetIndices': '012121212121212121212121212121'
  }, {
    'id': 'America/Belize',
    'untils': '-u52ic0|3edkc0|6ham0|c8s20|6u9a0|bvte0|6u9a0|bvte0|6u9a0|c8s20|6ham0|c8s20|6ham0|c8s20|6u9a0|bvte0|6u9a0|bvte0|6u9a0|bvte0|6u9a0|c8s20|6ham0|c8s20|6ham0|c8s20|6u9a0|bvte0|6u9a0|bvte0|6u9a0|c8s20|6ham0|c8s20|6ham0|c8s20|6ham0|c8s20|6u9a0|bvte0|6u9a0|bvte0|6u9a0|c8s20|6ham0|c8s20|6ham0|c8s20|6u9a0|bvte0|6u9a0|g2t2q0|3e580|4mcys0|2vmk0|Infinity',
    'offsets': '352.8|360|330|300',
    'offsetIndices': '01212121212121212121212121212121212121212121212121213131'
  }, {
    'id': 'America/Blanc-Sablon',
    'untils': '-qzp0o0|a2vw0|c5jxg0|1tzdw0|2dnc0|Infinity',
    'offsets': '240|180',
    'offsetIndices': '010110'
  }, {
    'id': 'America/Boa_Vista',
    'untils': '-t85grk|99k93k|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|62xk40|7k580|biw40|cvw0|Infinity',
    'offsets': '242.6667|240|180',
    'offsetIndices': '0121212121212121212121212121212121'
  }, {
    'id': 'America/Bogota',
    'untils': '-srdoy8|14f1hi8|ha580|Infinity',
    'offsets': '296.2667|300|240',
    'offsetIndices': '0121'
  }, {
    'id': 'America/Boise',
    'untils': '-r0emw0|ast80|7x9g0|ast80|1um840|9s7jw0|1tz5k0|2dvo0|b9gdg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|51k40|doik0|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420|360',
    'offsetIndices': '0101012212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Buenos_Aires',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvus0|6u7w0|bvus0|776k0|7qcg40|3yik0|b5xg0|7k580|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323232323232'
  }, {
    'id': 'America/Cambridge_Bay',
    'untils': '-q3gdc0|bjeec0|1tz5k0|2dvo0|a7n3w0|9q000|7k85k0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x6o0|ast80|ct40|7kj40|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '0|420|360|300',
    'offsetIndices': '0122131212121212121212121212121212121212121212233221212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Campo_Grande',
    'untils': '-t85hvw|99ka7w|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|cyqs0|64ak0|cls40|5rbw0|dbpg0|51ek0|dbpg0|6h980|c8tg0|6h980|c8tg0|64ak0|c8tg0|6u7w0|bxpg0|7iak0|biw40|6u7w0|biw40|7k580|biw40|6u7w0|c8tg0|6h980|dbpg0|5ed80|cls40|64ak0|dfes0|5nmk0|c8tg0|6h980|dbpg0|5rbw0|bvus0|6h980|cls40|64ak0|cls40|6h980|c8tg0|6h980|c8tg0|6u7w0|c8tg0|64ak0|cls40|64ak0|cls40|6h980|c8tg0|6h980|c8tg0|6h980|c8tg0|6h980|dbpg0|5ed80|Infinity',
    'offsets': '218.4667|240|180',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Cancun',
    'untils': '-p1u7c0|vauo00|7ggw40|afuk0|8a840|afuk0|8a840|64ak0|4bms0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|51k40|Infinity',
    'offsets': '347.0667|360|300|240',
    'offsetIndices': '0123232321212121212121212121212121212121212'
  }, {
    'id': 'America/Caracas',
    'untils': '-u7lcxw|rlo83w|meoxm0|4dps00|Infinity',
    'offsets': '267.6667|270|240',
    'offsetIndices': '01212'
  }, {
    'id': 'America/Catamarca',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvxk0|6u540|bvus0|776k0|5v42s0|z9g0|1u93w0|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323132321232'
  }, {
    'id': 'America/Cayenne',
    'untils': '-uj7yb4|tcw6r4|Infinity',
    'offsets': '209.3333|240|180',
    'offsetIndices': '012'
  }, {
    'id': 'America/Cayman',
    'untils': '-w757vc|Infinity',
    'offsets': '319.6|300',
    'offsetIndices': '01'
  }, {
    'id': 'America/Chicago',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bvus0|776k0|7kas0|b5rw0|9d440|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|7x9g0|dbjw0|8a840|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|6w840|1tz8c0|2dsw0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '01010101010101010101010101010101010101010101010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Chihuahua',
    'untils': '-p1u4k0|2u7jw0|1sgdc0|8n400|7thc0|9eys0|xes2s0|afuk0|8a840|afuk0|8aaw0|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|Infinity',
    'offsets': '424.3333|420|360|300',
    'offsetIndices': '0121212323221212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Coral_Harbour',
    'untils': '-qzov40|a2vw0|bfxjw0|pmdk0|1tz8c0|2dsw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '0101111'
  }, {
    'id': 'America/Cordoba',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvxk0|6u540|bvus0|776k0|7qcg40|3yik0|b5xg0|7k580|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323132323232'
  }, {
    'id': 'America/Costa_Rica',
    'untils': '-pjw8fn|ubtl3n|51ek0|doo40|51ek0|5jso40|8drw0|acas0|2xh80|Infinity',
    'offsets': '336.2167|360|300',
    'offsetIndices': '0121212121'
  }, {
    'id': 'America/Creston',
    'untils': '-rshz80|vbus0|Infinity',
    'offsets': '420|480',
    'offsetIndices': '010'
  }, {
    'id': 'America/Cuiaba',
    'untils': '-t85hm4|99k9y4|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|cyqs0|64ak0|cls40|5rbw0|dbpg0|51ek0|dbpg0|6h980|c8tg0|6h980|c8tg0|64ak0|c8tg0|6u7w0|bxpg0|7iak0|biw40|6u7w0|biw40|7k580|biw40|6u7w0|c8tg0|6h980|dbpg0|5ed80|w5hg0|5nmk0|c8tg0|6h980|dbpg0|5rbw0|bvus0|6h980|cls40|64ak0|cls40|6h980|c8tg0|6h980|c8tg0|6u7w0|c8tg0|64ak0|cls40|64ak0|cls40|6h980|c8tg0|6h980|c8tg0|6h980|c8tg0|6h980|dbpg0|5ed80|Infinity',
    'offsets': '224.3333|240|180',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Curacao',
    'untils': '-u7lckd|rlo7qd|Infinity',
    'offsets': '275.7833|270|240',
    'offsetIndices': '012'
  }, {
    'id': 'America/Danmarkshavn',
    'untils': '-rvusjk|x8nx3k|8zrk0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|53hk0|Infinity',
    'offsets': '74.6667|180|120|0',
    'offsetIndices': '01212121212121212121212121212121213'
  }, {
    'id': 'America/Dawson_Creek',
    'untils': '-qzopk0|a2vw0|c5jxg0|1tz2s0|2dyg0|tj1g0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|69uk0|Infinity',
    'offsets': '480|420',
    'offsetIndices': '0101101010101010101010101010101010101010101010101010101011'
  }, {
    'id': 'America/Dawson',
    'untils': '-qzoms0|a2vw0|asys0|882c0|bmiwc0|1tz000|2e180|a7n3w0|9q000|465k00|3e2is0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|Infinity',
    'offsets': '540|480|420',
    'offsetIndices': '01010110201212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'America/Denver',
    'untils': '-r0epo0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|2vmk0|ataw40|1tz5k0|2dvo0|a7n9g0|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '420|360',
    'offsetIndices': '01010101011010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Detroit',
    'untils': '-xx8dyd|5eraud|dyeyk0|1tzb40|2dq40|1c9440|7x3w0|9rlbxo|71s2c|9d440|9cyk0|2cmdg0|9cyk0|3lpg0|f4d80|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '332.1833|360|300|240',
    'offsetIndices': '0123323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'America/Dominica',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Edmonton',
    'untils': '-x1yazk|629ink|a2vw0|8n6s0|29ek0|h6lg0|9px80|905g0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|9l0g40|1tz5k0|2dvo0|tj1g0|7x3w0|ctzk40|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '453.8667|420|360',
    'offsetIndices': '0121212121212122121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Eirunepe',
    'untils': '-t85f28|99ka68|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|2yy2s0|6h980|7hg2s0|2t2t80|Infinity',
    'offsets': '279.4667|300|240',
    'offsetIndices': '0121212121212121212121212121212121'
  }, {
    'id': 'America/El_Salvador',
    'untils': '-pkm4tc|ymao5c|7k580|b5xg0|7k580|Infinity',
    'offsets': '356.8|360|300',
    'offsetIndices': '012121'
  }, {
    'id': 'America/Ensenada',
    'untils': '-p1u1s0|11jrw0|1sns00|1sgdc0|71s40|9cyk0|5iidg0|1q6700|4lfk0|190g40|eluk0|2r4o80|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|84qys0|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|77c40|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '468.0667|420|480',
    'offsetIndices': '012121211212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'America/Fort_Nelson',
    'untils': '-qzopk0|a2vw0|c5jxg0|1tz2s0|2dyg0|tj1g0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|Infinity',
    'offsets': '480|420',
    'offsetIndices': '01011010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'America/Fort_Wayne',
    'untils': '-r0esg0|ast80|7x9g0|ast80|baw840|51ek0|6w840|1tz8c0|2dsw0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|19q7w0|asys0|5qonw0|9cyk0|9d440|9cyk0|ihslg0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '010101011010101010101010101010121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Fortaleza',
    'untils': '-t85kvc|99kafc|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|514g40|7k580|biw40|puk0|id6s0|6h980|Infinity',
    'offsets': '154|180|120',
    'offsetIndices': '0121212121212121212121212121212121212121'
  }, {
    'id': 'America/Glace_Bay',
    'untils': '-z94kwc|89fk8c|a2vw0|c5jxg0|1tzdw0|2dnc0|3y8g40|7x3w0|9pa5g0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '239.8|240|180',
    'offsetIndices': '012122121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Godthab',
    'untils': '-rvumf4|x8nqz4|8zrk0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '206.9333|180|120',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Goose_Bay',
    'untils': '-qzp20k|a2vw0|8kjbw0|kzjyk|7k580|b5xg0|7k580|b5xg0|7k580|biw40|776k0|biw40|7k580|b5xg0|7k580|b5xg0|1pb260|2dly0|biw40|7k580|b5xg0|7k580|b5xg0|7k580|b5xg0|7k580|biw40|7k580|ag040|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|6y2s0|22420|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a2lo|afuk0|8a840|asqg0|7xc80|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8tec|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '210.8667|150.8667|210|150|240|180|120',
    'offsetIndices': '010232323232323233232323232323232323232323232323232323232324545454545454545454545454545454545454545454546454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454'
  }, {
    'id': 'America/Grand_Turk',
    'untils': '-u85og2|z3brw2|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|18ais0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '307.1667|300|240',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121222121212121212121212121212121212121212121'
  }, {
    'id': 'America/Grenada',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Guadeloupe',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Guatemala',
    'untils': '-qqqskk|ss0akk|4ofw0|4tidg0|6djw0|3wwas0|8n180|7n5ms0|7x3w0|Infinity',
    'offsets': '362.0667|360|300',
    'offsetIndices': '0121212121'
  }, {
    'id': 'America/Guayaquil',
    'untils': '-kcr84o|wb620o|3jp80|Infinity',
    'offsets': '314|300|240',
    'offsetIndices': '0121'
  }, {
    'id': 'America/Guyana',
    'untils': '-smcak8|vj4sz8|81rf90|Infinity',
    'offsets': '232.6667|225|180|240',
    'offsetIndices': '0123'
  }, {
    'id': 'America/Halifax',
    'untils': '-z94k80|777go0|9et80|st9o0|a2vw0|ssyk0|5rbw0|cv1g0|69uk0|c6ys0|6kyk0|ci2s0|67zw0|ci2s0|6w2k0|bu040|7lzw0|bu040|66580|bu040|7lzw0|bu040|64ak0|cls40|5v180|cv1g0|6j3w0|c6ys0|79180|b42s0|7lzw0|b42s0|7yyk0|bu040|64ak0|dbpg0|66580|cls40|5ed80|bu040|7lzw0|b42s0|7lzw0|cjxg0|66580|bh1g0|7lzw0|b42s0|7lzw0|6uj00|1tzdw0|2dnc0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|tw040|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|tw040|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|1cm2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '254.4|240|180',
    'offsetIndices': '0121212121212121212121212121212121212121212121212122121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Havana',
    'untils': '-n7762o|1icfyo|69uk0|62s040|4ofw0|e1ms0|51ek0|e1ms0|4ofw0|1fhs40|4ofw0|e1ms0|4ofw0|9s9k40|67zw0|cedg0|6h980|9o840|7yyk0|b5xg0|7k580|bvus0|9cyk0|9d440|9cyk0|9d440|9px80|9d440|8a2k0|ag040|8bx80|ae5g0|8drw0|acas0|9cyk0|9d440|9px80|905g0|9px80|9q2s0|7x3w0|8a840|ast80|7x9g0|ast80|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|8a2k0|ag040|8a2k0|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|905g0|a2vw0|905g0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|8n400|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|7x6o0|1cm000|6uao0|bvs00|779c0|bitc0|6uao0|bvs00|779c0|bvs00|779c0|c8qo0|779c0|b5uo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|Infinity',
    'offsets': '329.6|300|240',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Hermosillo',
    'untils': '-p1u4k0|2u7jw0|1sgdc0|8n400|7thc0|9eys0|591h80|3ie2s0|axvpg0|dpgw40|afuk0|8a840|afuk0|8a840|afuk0|Infinity',
    'offsets': '443.8667|420|360|480',
    'offsetIndices': '0121212131212121'
  }, {
    'id': 'America/Indiana/Indianapolis',
    'untils': '-r0esg0|ast80|7x9g0|ast80|baw840|51ek0|6w840|1tz8c0|2dsw0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|19q7w0|asys0|5qonw0|9cyk0|9d440|9cyk0|ihslg0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '010101011010101010101010101010121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Indiana/Knox',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|tj1g0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|7x3w0|asys0|7x3w0|asys0|9cyk0|9d440|9px80|9d440|9cyk0|9d440|s3180|1twas0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|7j5400|asw00|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '0101011010101010101010101010101010101010101010101010101010101010101010101010101010101010111010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Indiana/Marengo',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|2wsas0|7x3w0|1c9440|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|465h80|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4g00|64dc0|clmk0|fvt9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '0101011010101010101010101212121212111212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Indiana/Petersburg',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|501ek0|7kas0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|sfzw0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|eu02o0|asw00|6udg0|c8nw0|6hc00|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '01010110101010101010101010101010101010101010101010111011212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Indiana/Tell_City',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|501ek0|7kas0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|1tw580|9d440|9cyk0|9d440|9cvs0|9d440|9cyk0|ihslg0|asw00|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '01010110101010101010101010101021211010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Indiana/Vevay',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|4gyis0|7txx80|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|hfzhg0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '010101101212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Indiana/Vincennes',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|asys0|7x3w0|3fidg0|7x3w0|asys0|7x3w0|b5rw0|7kas0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|7k580|b5xg0|9cyk0|9d440|9cyk0|9d440|2lz980|9cyk0|9d440|9cyk0|ihslg0|asw00|6udg0|c8nw0|6hc00|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '01010110101010101010101010101010121211011212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Indiana/Winamac',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|465h80|9cyk0|9d440|9cyk0|ihslg0|asw00|6udg0|c8l40|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '01010110101010101010101010101010101010121211021212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Indianapolis',
    'untils': '-r0esg0|ast80|7x9g0|ast80|baw840|51ek0|6w840|1tz8c0|2dsw0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|19q7w0|asys0|5qonw0|9cyk0|9d440|9cyk0|ihslg0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '010101011010101010101010101010121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Inuvik',
    'untils': '-8ve5c0|6fce80|9q000|71i2w0|ipzw0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '0|480|360|420',
    'offsetIndices': '0121323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'America/Iqaluit',
    'untils': '-eb6ao0|1l3h80|2dq40|a7n3w0|9q000|7k85k0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7xc80|ast80|7x6o0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '0|240|300|180|360',
    'offsetIndices': '01123212121212121212121212121212121212121212142212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'America/Jamaica',
    'untils': '-u85og2|wbl182|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|Infinity',
    'offsets': '307.1667|300|240',
    'offsetIndices': '0121212121212121212121'
  }, {
    'id': 'America/Jujuy',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|c8w80|776k0|ag040|7k2g0|bvus0|776k0|7qcg40|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '012121212121212121212121212121212121212121232323121323232'
  }, {
    'id': 'America/Juneau',
    'untils': '-ek1w80|1tz2s0|2dyg0|cawis0|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9d1c0|9d1c0|9cyk0|9d440|9px80|905g0|9px80|1leo0|7rs80|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420|540',
    'offsetIndices': '01101010101010101010101010001010122020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202'
  }, {
    'id': 'America/Kentucky/Louisville',
    'untils': '-r0esg0|ast80|7x9g0|ast80|sg5g0|6bp80|a98o40|7x3w0|6w840|1tz8c0|2dsw0|ast9o|1sw2c|21gis0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|4bh80|3j3xc0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4g00|64dc0|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '0101010101101010101010101010101010101121212121212111212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Kentucky/Monticello',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|bs6g40|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x6o0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '0101011010101010101010101010101010101010101010101010101010101010101010101121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Knox_IN',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|tj1g0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|7x3w0|asys0|7x3w0|asys0|9cyk0|9d440|9px80|9d440|9cyk0|9d440|s3180|1twas0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|7j5400|asw00|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '0101011010101010101010101010101010101010101010101010101010101010101010101010101010101010111010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Kralendijk',
    'untils': '-u7lckd|rlo7qd|Infinity',
    'offsets': '275.7833|270|240',
    'offsetIndices': '012'
  }, {
    'id': 'America/La_Paz',
    'untils': '-jxzspo|84ik0|Infinity',
    'offsets': '272.6|212.6|240',
    'offsetIndices': '012'
  }, {
    'id': 'America/Lima',
    'untils': '-w25lpo|fcxjlo|4ml80|93us0|9cyk0|9d440|9cyk0|nw16s0|4ml80|e5c40|4ml80|1fr1g0|4ml80|1yiys0|4ml80|Infinity',
    'offsets': '308.6|300|240',
    'offsetIndices': '0121212121212121'
  }, {
    'id': 'America/Los_Angeles',
    'untils': '-r0emw0|ast80|7x9g0|ast80|bmtus0|1tz2s0|2dyg0|1a3c5o|f2iic|owao0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|902o0|9q000|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Louisville',
    'untils': '-r0esg0|ast80|7x9g0|ast80|sg5g0|6bp80|a98o40|7x3w0|6w840|1tz8c0|2dsw0|ast9o|1sw2c|21gis0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|4bh80|3j3xc0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4g00|64dc0|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '0101010101101010101010101010101010101121212121212111212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Lower_Princes',
    'untils': '-u7lckd|rlo7qd|Infinity',
    'offsets': '275.7833|270|240',
    'offsetIndices': '012'
  }, {
    'id': 'America/Maceio',
    'untils': '-t85ldw|99kaxw|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|2yl440|64ak0|1wf1g0|7k580|biw40|puk0|id6s0|6h980|Infinity',
    'offsets': '142.8667|180|120',
    'offsetIndices': '012121212121212121212121212121212121212121'
  }, {
    'id': 'America/Managua',
    'untils': '-ijh6oo|ka1i0o|xqqk0|24p6s0|53980|dmtg0|53980|60itw0|dq240|53es0|235h80|4beis0|8zzw0|at4c0|7x140|Infinity',
    'offsets': '345.2|360|300',
    'offsetIndices': '0121212121212121'
  }, {
    'id': 'America/Manaus',
    'untils': '-t85gvw|99k97w|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|2yy2s0|6h980|Infinity',
    'offsets': '240.0667|240|180',
    'offsetIndices': '01212121212121212121212121212121'
  }, {
    'id': 'America/Marigot',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Martinique',
    'untils': '-umcvcs|zz5x4s|8zzw0|Infinity',
    'offsets': '244.3333|240|180',
    'offsetIndices': '0121'
  }, {
    'id': 'America/Matamoros',
    'untils': '-p1u7c0|ykt480|ast80|3vppg0|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|77c40|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '400|360|300',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Mazatlan',
    'untils': '-p1u4k0|2u7jw0|1sgdc0|8n400|7thc0|9eys0|591h80|3ie2s0|axvpg0|dpgw40|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|Infinity',
    'offsets': '425.6667|420|360|480',
    'offsetIndices': '0121212131212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Mendoza',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bktk0|71mk0|bqas0|73h80|bvus0|773s0|5unes0|6hes0|1p7mk0|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232312121321232'
  }, {
    'id': 'America/Menominee',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|asys0|7x3w0|a7n9g0|9px80|1at9g0|2396k0|9d1c0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '01010110101011010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Merida',
    'untils': '-p1u7c0|vauo00|hoyk0|6ys0c0|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|Infinity',
    'offsets': '358.4667|360|300',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Metlakatla',
    'untils': '-ek1w80|1tz2s0|2dyg0|cawis0|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|gpc840|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|3ylc0|2itg0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420|540',
    'offsetIndices': '01101010101010101010101010101010102020200202020202020202020202020202020202020202'
  }, {
    'id': 'America/Mexico_City',
    'untils': '-p1u4k0|2u7jw0|1sgdc0|8n400|7thc0|9eys0|3knek0|776k0|rf440|5t6k0|1evk40|71mk0|30p1g0|8n180|nufxo0|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|Infinity',
    'offsets': '396.6|420|360|300',
    'offsetIndices': '012121232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'America/Miquelon',
    'untils': '-ulmyxk|zzqbdk|3m59g0|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '224.6667|240|180|120',
    'offsetIndices': '012323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'America/Moncton',
    'untils': '-z94i40|89fhg0|a2vw0|7mqqo0|4ofw0|e1ms0|4ofw0|e1ms0|4ofw0|e1ms0|4ofw0|e1ms0|4ofw0|e1ms0|4ofw0|dmtg0|64ak0|cao40|6fek0|bkqs0|7iak0|6y5k0|1tzdw0|2dnc0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|s36s0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a2lo|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6uiyc|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '300|240|180',
    'offsetIndices': '012121212121212121212122121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Monterrey',
    'untils': '-p1u7c0|ykt480|ast80|3vppg0|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|Infinity',
    'offsets': '401.2667|360|300',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Montevideo',
    'untils': '-w4mll9|67elc0|1s74p9|9et80|9exe0|9czy0|9exe0|9czy0|3ydyq0|7x5a0|asxe0|7x5a0|asxe0|7x5a0|asxe0|7x5a0|b5w20|7k6m0|b5w20|7k6m0|9q1e0|9czy0|asxe0|7x5a0|6do20|ppvy0|4mmm0|8g9qq0|901a0|38pe0|2inw0|2nf9g0|8zzw0|1e3s40|9o3y0|q8he0|2kik0|yxhg0|4bh80|s36s0|2vl60|905g0|5rg20|51ek0|weqs0|3yik0|e1ms0|4ofw0|erk40|3yik0|2vs40|gk7w0|41iys0|3wnw0|erk40|4bh80|c8tg0|64ak0|c8tg0|6u7w0|c8tg0|6h980|bvus0|6u7w0|614qs0|9q2s0|a31g0|7x3w0|ag040|8a2k0|asys0|7x3w0|asys0|7x3w0|asys0|8a2k0|ag040|8a2k0|ag040|8a2k0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|Infinity',
    'offsets': '224.85|240|180|210|150|120|90',
    'offsetIndices': '001232323232323232323232324242525242525264252525252525252525252525252525252525252525252'
  }, {
    'id': 'America/Montreal',
    'untils': '-qzoxw0|a2vw0|7yx60|aqzy0|9q8c0|7jzo0|bw0c0|6bp80|cedg0|6h980|c8tg0|6h980|bvus0|776k0|biw40|776k0|biw40|776k0|biw40|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|xjeo0|1tzb40|2dq40|asys0|7x3w0|ast80|7x3w0|asys0|7x3w0|asys0|b5rw0|7xf00|ast80|7x9g0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '300|240',
    'offsetIndices': '01010101010101010101010101010101010101010101011101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Montserrat',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Nassau',
    'untils': '-u6m4c6|r7u7s6|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '309.5|300|240',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/New_York',
    'untils': '-r0ev80|ast80|7x9g0|ast80|7x9g0|b5rw0|905g0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|6w840|1tzb40|2dq40|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '300|240',
    'offsetIndices': '01010101010101010101010101010101010101010101010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Nipigon',
    'untils': '-qzoxw0|a2vw0|bfxjw0|pmdk0|1tzb40|2dq40|ewvus0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '300|240',
    'offsetIndices': '010111010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Nome',
    'untils': '-ek1nw0|1tyug0|2e6s0|b7yik0|12y080|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|1l6c0|7rs80|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '660|600|540|480',
    'offsetIndices': '011001010101010101010101010101010122323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'America/Noronha',
    'untils': '-t85lzw|99k8rw|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|514g40|7k580|biw40|cvw0|iq5g0|6h980|Infinity',
    'offsets': '129.6667|120|60',
    'offsetIndices': '0121212121212121212121212121212121212121'
  }, {
    'id': 'America/North_Dakota/Beulah',
    'untils': '-r0epo0|ast80|7x9g0|ast80|bmtus0|1tz5k0|2dvo0|b9gdg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hc00|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '420|360|300',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101011212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/North_Dakota/Center',
    'untils': '-r0epo0|ast80|7x9g0|ast80|bmtus0|1tz5k0|2dvo0|b9gdg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a5c0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '420|360|300',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101011212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/North_Dakota/New_Salem',
    'untils': '-r0epo0|ast80|7x9g0|ast80|bmtus0|1tz5k0|2dvo0|b9gdg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a5c0|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '420|360|300',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101010101010101010101010101121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Nuuk',
    'untils': '-rvumf4|x8nqz4|8zrk0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '206.9333|180|120',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Ojinaga',
    'untils': '-p1u4k0|2u7jw0|1sgdc0|8n400|7thc0|9eys0|xes2s0|afuk0|8a840|afuk0|8aaw0|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|77c40|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '417.6667|420|360|300',
    'offsetIndices': '0121212323221212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Panama',
    'untils': '-w757vc|Infinity',
    'offsets': '319.6|300',
    'offsetIndices': '01'
  }, {
    'id': 'America/Pangnirtung',
    'untils': '-pkmlc0|b0ke00|1tzdw0|2dnc0|a7n3w0|9q000|7k85k0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|asw00|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7xc80|ast80|7x6o0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '0|240|180|120|300|360',
    'offsetIndices': '012213121212121212121212121212121212114141414154414141414141414141414141414141414141414141414141414141414141414141414141414'
  }, {
    'id': 'America/Paramaribo',
    'untils': '-usj4g8|cixc0c|5lydbk|kcrm6c|Infinity',
    'offsets': '220.6667|220.8667|220.6|210|180',
    'offsetIndices': '01234'
  }, {
    'id': 'America/Phoenix',
    'untils': '-r0epo0|ast80|7x9g0|ast80|bmtus0|zjedo|4olg0|9et80|bs6lmc|9cyk0|Infinity',
    'offsets': '420|360',
    'offsetIndices': '01010101010'
  }, {
    'id': 'America/Port_of_Spain',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Port-au-Prince',
    'untils': '-rmk9ac|ylcf6c|8zzw0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8aaw0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|3vpjw0|ast80|7x9g0|ast80|2stv00|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|pkg40|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '289|300|240',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Porto_Acre',
    'untils': '-t85fg0|99kak0|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|amves0|2t2t80|Infinity',
    'offsets': '271.2|300|240',
    'offsetIndices': '01212121212121212121212121212121'
  }, {
    'id': 'America/Porto_Velho',
    'untils': '-t85g60|99k8i0|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|Infinity',
    'offsets': '255.6|240|180',
    'offsetIndices': '012121212121212121212121212121'
  }, {
    'id': 'America/Puerto_Rico',
    'untils': '-efsnk0|1ppu40|2dnc0|Infinity',
    'offsets': '240|180',
    'offsetIndices': '0110'
  }, {
    'id': 'America/Punta_Arenas',
    'untils': '-vauawq|3dlssq|157b7a|f4e0q|49hzba|aye0q|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|534ik0|351g0|2fnh80|2mg00|b73400|7k580|c8tg0|6h980|a31g0|7x3w0|asys0|7x3w0|b5xg0|7k580|ag040|8a2k0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|9cyk0|9d440|7x3w0|asys0|7x3w0|b5xg0|7k580|9q2s0|8zzw0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|a31g0|9px80|9q2s0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|asys0|8zzw0|9q2s0|ast80|5eis0|cyl80|6hes0|c8nw0|6udg0|bvp80|6udg0|vonw0|4olg0|Infinity',
    'offsets': '282.7667|300|240|180',
    'offsetIndices': '0102021212121212121232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'America/Rainy_River',
    'untils': '-qzov40|a2vw0|bfxjw0|pmdk0|1tz8c0|2dsw0|ewvus0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '010111010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Rankin_Inlet',
    'untils': '-6s8lc0|4c6oo0|9q000|7k85k0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '0|360|240|300',
    'offsetIndices': '012131313131313131313131313131313131313131313331313131313131313131313131313131313131313131313131313131313131313131313131'
  }, {
    'id': 'America/Recife',
    'untils': '-t85ljc|99kb3c|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|514g40|7k580|biw40|cvw0|iq5g0|6h980|Infinity',
    'offsets': '139.6|180|120',
    'offsetIndices': '0121212121212121212121212121212121212121'
  }, {
    'id': 'America/Regina',
    'untils': '-xkq9yc|6l1hmc|a2vw0|60enw0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|1b6840|9cyk0|9d440|8zzw0|9q2s0|9cyk0|9q2s0|9cyk0|9d440|9cyk0|66gc0|1tz5k0|2dvo0|a31g0|9cyk0|a31g0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|tj1g0|9cyk0|9d440|Infinity',
    'offsets': '418.6|420|360',
    'offsetIndices': '012121212121212121212121221212121212121212121212121212'
  }, {
    'id': 'America/Resolute',
    'untils': '-bnp9c0|97nco0|9q000|7k85k0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '0|360|240|300',
    'offsetIndices': '012131313131313131313131313131313131313131313331313131313331313131313131313131313131313131313131313131313131313131313131'
  }, {
    'id': 'America/Rio_Branco',
    'untils': '-t85fg0|99kak0|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|amves0|2t2t80|Infinity',
    'offsets': '271.2|300|240',
    'offsetIndices': '01212121212121212121212121212121'
  }, {
    'id': 'America/Rosario',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvxk0|6u540|bvus0|776k0|7qcg40|3yik0|b5xg0|7k580|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323132323232'
  }, {
    'id': 'America/Santa_Isabel',
    'untils': '-p1u1s0|11jrw0|1sns00|1sgdc0|71s40|9cyk0|5iidg0|1q6700|4lfk0|190g40|eluk0|2r4o80|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|84qys0|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|77c40|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '468.0667|420|480',
    'offsetIndices': '012121211212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'America/Santarem',
    'untils': '-t85hvc|99ka7c|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|amves0|Infinity',
    'offsets': '218.8|240|180',
    'offsetIndices': '0121212121212121212121212121212'
  }, {
    'id': 'America/Santiago',
    'untils': '-vauawq|3dlssq|157b7a|f4e0q|49hzba|aye0q|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|534ik0|351g0|229zw0|2gt80|awo40|2mg00|b73400|7k580|c8tg0|6h980|a31g0|7x3w0|asys0|7x3w0|b5xg0|7k580|ag040|8a2k0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|9cyk0|9d440|7x3w0|asys0|7x3w0|b5xg0|7k580|9q2s0|8zzw0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|a31g0|9px80|9q2s0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|asys0|8zzw0|9q2s0|ast80|5eis0|cyl80|6hes0|c8nw0|6udg0|bvp80|6udg0|vonw0|4olg0|e1h80|4olg0|e1h80|4olg0|c8nw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|Infinity',
    'offsets': '282.7667|300|240|180',
    'offsetIndices': '010202121212121212321232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'America/Santo_Domingo',
    'untils': '-j6hz1c|hiw29c|67zw0|1dy840|62ha0|cnle0|4h2m0|elyq0|47ta0|ei9e0|4bim0|eek20|4dda0|ecpe0|dkmtg0|1stc0|Infinity',
    'offsets': '280|300|240|270',
    'offsetIndices': '01213131313131212'
  }, {
    'id': 'America/Sao_Paulo',
    'untils': '-t85jd8|99k8x8|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5k02s0|6onw0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|cyqs0|64ak0|cls40|5rbw0|dbpg0|51ek0|dbpg0|6h980|c8tg0|6h980|c8tg0|64ak0|c8tg0|6u7w0|bxpg0|7iak0|biw40|6u7w0|biw40|7k580|biw40|6u7w0|c8tg0|6h980|dbpg0|5ed80|cls40|64ak0|dfes0|5nmk0|c8tg0|6h980|dbpg0|5rbw0|bvus0|6h980|cls40|64ak0|cls40|6h980|c8tg0|6h980|c8tg0|6u7w0|c8tg0|64ak0|cls40|64ak0|cls40|6h980|c8tg0|6h980|c8tg0|6h980|c8tg0|6h980|dbpg0|5ed80|Infinity',
    'offsets': '186.4667|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Scoresbysund',
    'untils': '-rvurxk|x8ntpk|902o0|9cvs0|9cyk0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '87.8667|120|60|0',
    'offsetIndices': '0121323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'America/Shiprock',
    'untils': '-r0epo0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|2vmk0|ataw40|1tz5k0|2dvo0|a7n9g0|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '420|360',
    'offsetIndices': '01010101011010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Sitka',
    'untils': '-ek1w80|1tz2s0|2dyg0|cawis0|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|1leo0|7rs80|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420|540',
    'offsetIndices': '01101010101010101010101010101010122020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202'
  }, {
    'id': 'America/St_Barthelemy',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/St_Johns',
    'untils': '-ris3ck|8bx80|ar440|a2vw0|9tjs0|53980|dkys0|9cyk0|9d440|9cyk0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|9cyk0|9d440|9cyk0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|9cyk0|9q2s0|8zzw0|9q2s0|8zzw0|7tmw0|1wfuk|8zzw0|a3480|7k580|b5xg0|7k580|b5xg0|7k580|biw40|776k0|biw40|7k580|b5xg0|7k580|b5xg0|1pb260|2dly0|biw40|7k580|b5xg0|7k580|b5xg0|7k580|b5xg0|7k580|biw40|7k580|ag040|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a2lo|afuk0|8a840|asqg0|7xc80|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8tec|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '210.8667|150.8667|210|150|90',
    'offsetIndices': '01010101010101010101010101010101010102323232323232323323232323232323232323232323232323232323232323232323232323232323232323232323232323232324232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'America/St_Kitts',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/St_Lucia',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/St_Thomas',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/St_Vincent',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Swift_Current',
    'untils': '-xkq9d4|6l1h14|a2vw0|c5jxg0|1tz5k0|2dvo0|asys0|8n180|a31g0|7x3w0|asys0|7x3w0|asys0|7x3w0|3yles0|9cyk0|s36s0|9cyk0|9d440|7x3w0|b5xg0|7k580|5j4lg0|Infinity',
    'offsets': '431.3333|420|360',
    'offsetIndices': '012122121212121212121212'
  }, {
    'id': 'America/Tegucigalpa',
    'untils': '-pfzh6k|yho0ik|7k580|b5xg0|7k580|96x1g0|4qak0|Infinity',
    'offsets': '348.8667|360|300',
    'offsetIndices': '01212121'
  }, {
    'id': 'America/Thule',
    'untils': '-rvuj9g|12yzilg|9cyk0|9d440|9cyk0|9q2s0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '275.1333|240|180',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Thunder_Bay',
    'untils': '-vbavc0|gr8qs0|1tzb40|2dq40|ctmlg0|9cyk0|9d440|9px80|9d440|9cyk0|s36s0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '0122121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Tijuana',
    'untils': '-p1u1s0|11jrw0|1sns00|1sgdc0|71s40|9cyk0|5iidg0|1q6700|4lfk0|190g40|eluk0|2r4o80|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|84qys0|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|77c40|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '468.0667|420|480',
    'offsetIndices': '012121211212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'America/Toronto',
    'untils': '-qzoxw0|a2vw0|7yx60|aqzy0|9q8c0|7jzo0|bw0c0|6bp80|cedg0|6h980|c8tg0|6h980|bvus0|776k0|biw40|776k0|biw40|776k0|biw40|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|xjeo0|1tzb40|2dq40|asys0|7x3w0|ast80|7x3w0|asys0|7x3w0|asys0|b5rw0|7xf00|ast80|7x9g0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '300|240',
    'offsetIndices': '01010101010101010101010101010101010101010101011101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Tortola',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Vancouver',
    'untils': '-qzopk0|a2vw0|c5jxg0|1tz2s0|2dyg0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420',
    'offsetIndices': '0101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Virgin',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Whitehorse',
    'untils': '-qzoms0|a2vw0|asys0|882c0|bmiwc0|1tz000|2e180|a7n3w0|9q000|tiyo0|6qp440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|Infinity',
    'offsets': '540|480|420',
    'offsetIndices': '01010110201212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'America/Winnipeg',
    'untils': '-s0s7c0|7k580|tj700|a2vw0|9ok840|6u7w0|2a5hg0|1tz8c0|2dsw0|biw40|7x3w0|a31g0|7x3w0|asys0|7x3w0|asys0|7x3w0|b7s40|7tek0|autg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9cyk0|9d440|7x3w0|1cm2s0|7k580|1cm2s0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|902o0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|902o0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|8a5c0|afxc0|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|7x6o0|asw00|7x6o0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '010101011010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Yakutat',
    'untils': '-ek1tg0|1tz000|2e180|cawis0|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|1lbw0|7rs80|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '540|480',
    'offsetIndices': '01101010101010101010101010101010100101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Yellowknife',
    'untils': '-i9m2o0|3pk3o0|1tz5k0|2dvo0|a7n3w0|9q000|7k85k0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '0|420|360|300',
    'offsetIndices': '012213121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Antarctica/Casey',
    'untils': '-irxc0|lag4o0|73bo0|uz1o0|60l80|2fnh80|pz9g0|Infinity',
    'offsets': '0|-480|-660',
    'offsetIndices': '01212121'
  }, {
    'id': 'Antarctica/Davis',
    'untils': '-6rmdc0|42jdw0|27wgs0|l8uss0|7eqs0|unmk0|60qs0|Infinity',
    'offsets': '0|-420|-300',
    'offsetIndices': '01012121'
  }, {
    'id': 'Antarctica/DumontDUrville',
    'untils': '-c05eo0|2mks80|2i72g0|Infinity',
    'offsets': '0|-600',
    'offsetIndices': '0101'
  }, {
    'id': 'Antarctica/Macquarie',
    'untils': '-rsj4w0|8zzw0|11wqk0|f4kh40|a6p8g0|9d1c0|asw00|6uao0|bvs00|6uao0|bvs00|779c0|bvs00|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|b5uo0|7k800|b5uo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|bvs00|7k800|bitc0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x6o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|7x6o0|asw00|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9d1c0|902o0|a2yo0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660|0',
    'offsetIndices': '0102010101010101010101010101010101010101010101010101010101010101010101010101010101010101011'
  }, {
    'id': 'Antarctica/Mawson',
    'untils': '-8aelc0|t22y80|Infinity',
    'offsets': '0|-360|-300',
    'offsetIndices': '012'
  }, {
    'id': 'Antarctica/McMurdo',
    'untils': '-m01p20|64ak0|biw40|7x5a0|asxe0|7x5a0|asxe0|7x5a0|asxe0|8a3y0|afyq0|8a3y0|afyq0|afvy0|7x820|asum0|7x820|asum0|7x820|asum0|7x820|asum0|7x820|b5ta0|7k9e0|b5ta0|7x820|hsl2m0|5reo0|clpc0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|b5uo0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|Infinity',
    'offsets': '-690|-750|-720|-780',
    'offsetIndices': '01020202020202020202020202023232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'Antarctica/Palmer',
    'untils': '-2lxhc0|31ho0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|46b6s0|8c2s0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|9cyk0|9d440|7x3w0|asys0|7x3w0|b5xg0|7k580|9q2s0|8zzw0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|a31g0|9px80|9q2s0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|asys0|8zzw0|9q2s0|ast80|5eis0|cyl80|6hes0|c8nw0|6udg0|bvp80|6udg0|vonw0|4olg0|Infinity',
    'offsets': '0|180|240|120',
    'offsetIndices': '0121212121213121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Antarctica/Rothera',
    'untils': '3lxs00|Infinity',
    'offsets': '0|180',
    'offsetIndices': '01'
  }, {
    'id': 'Antarctica/South_Pole',
    'untils': '-m01p20|64ak0|biw40|7x5a0|asxe0|7x5a0|asxe0|7x5a0|asxe0|8a3y0|afyq0|8a3y0|afyq0|afvy0|7x820|asum0|7x820|asum0|7x820|asum0|7x820|asum0|7x820|b5ta0|7k9e0|b5ta0|7x820|hsl2m0|5reo0|clpc0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|b5uo0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|Infinity',
    'offsets': '-690|-750|-720|-780',
    'offsetIndices': '01020202020202020202020202023232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'Antarctica/Syowa',
    'untils': '-6qsqo0|Infinity',
    'offsets': '0|-180',
    'offsetIndices': '01'
  }, {
    'id': 'Antarctica/Troll',
    'untils': 'ibruo0|27pg0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-120',
    'offsetIndices': '00101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Antarctica/Vostok',
    'untils': '-6aaao0|Infinity',
    'offsets': '0|-360',
    'offsetIndices': '01'
  }, {
    'id': 'Arctic/Longyearbyen',
    'untils': '-rzayo0|6qfs0|cgcqo0|15tsc0|7k800|9q000|9d1c0|9d1c0|9d1c0|9d1c0|70q5c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|b5uo0|7k800|7law00|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Asia/Aden',
    'untils': '-bwgbbg|Infinity',
    'offsets': '-186.8667|-180',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Almaty',
    'untils': '-nu1a90|37a0d0|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|Infinity',
    'offsets': '-307.8|-300|-360|-420',
    'offsetIndices': '012323232323232323232321232323232323232323232323232'
  }, {
    'id': 'Asia/Amman',
    'untils': '-kcrtbk|m566fk|60l80|awo40|7v980|awo40|7v980|ayis0|9gnw0|9b9g0|7v980|autg0|7v980|3e6840|9et80|9io40|9cyk0|9d440|9cyk0|9d440|9px80|ayis0|7rjw0|ag040|8a2k0|9zc40|8drw0|a31g0|8zzw0|9d440|9cyk0|9d440|8n180|ag040|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|epmo0|4deo0|9o5c0|9ew00|9b6o0|9ew00|9d1c0|9d1c0|9d1c0|asw00|7x6o0|afxc0|8n400|9d1c0|9d1c0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|wel80|51k40|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|Infinity',
    'offsets': '-143.7333|-120|-180',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Anadyr',
    'untils': '-nu1sv8|379zj8|qi27w0|9et80|is040|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|j3440|7k800|Infinity',
    'offsets': '-709.9333|-720|-780|-840|-660',
    'offsetIndices': '01232121212121212121214121212121212121212121212121212121212141'
  }, {
    'id': 'Asia/Aqtau',
    'untils': '-nu15b4|379y74|qrh3w0|iruk0|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|Infinity',
    'offsets': '-201.0667|-240|-300|-360',
    'offsetIndices': '012323232323232323232123232312121212121212121212'
  }, {
    'id': 'Asia/Aqtobe',
    'untils': '-nu16l4|379zh4|qi27w0|s6qk0|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|Infinity',
    'offsets': '-228.6667|-240|-300|-360',
    'offsetIndices': '0123232323232323232321232323232323232323232323232'
  }, {
    'id': 'Asia/Ashgabat',
    'untils': '-nu16t8|379zp8|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|Infinity',
    'offsets': '-233.5333|-240|-300|-360',
    'offsetIndices': '0123232323232323232323212'
  }, {
    'id': 'Asia/Ashkhabad',
    'untils': '-nu16t8|379zp8|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|Infinity',
    'offsets': '-233.5333|-240|-300|-360',
    'offsetIndices': '0123232323232323232323212'
  }, {
    'id': 'Asia/Atyrau',
    'untils': '-nu15m8|37a1a8|qrh140|iruk0|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|j3440|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|Infinity',
    'offsets': '-207.7333|-180|-300|-360|-240',
    'offsetIndices': '01232323232323232323242323232323232324242424242'
  }, {
    'id': 'Asia/Baghdad',
    'untils': '-r50g80|xkn3w0|7v980|9b9g0|9gnw0|9eys0|9et80|9d440|9b9g0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9f1k0|9ew00|9ew00|9ew00|9d1c0|9ew00|9d1c0|9ew00|9d1c0|9ew00|9ew00|9ew00|9d1c0|9ew00|9d1c0|9ew00|9d1c0|9ew00|9ew00|9ew00|9d1c0|9ew00|9d1c0|9ew00|9d1c0|9ew00|9ew00|9ew00|9d1c0|9ew00|9d1c0|9ew00|9d1c0|9ew00|Infinity',
    'offsets': '-177.6|-180|-240',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Bahrain',
    'untils': '-q3gmvk|rctnrk|Infinity',
    'offsets': '-206.1333|-240|-180',
    'offsetIndices': '012'
  }, {
    'id': 'Asia/Baku',
    'untils': '-nu158c|h4tkwc|ckinw0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|9d1c0|239ew0|asw00|7x3w0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-199.4|-180|-240|-300',
    'offsetIndices': '01232323232323232323232123232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Bangkok',
    'untils': '-pysda4|Infinity',
    'offsets': '-402.0667|-420',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Barnaul',
    'untils': '-q4ljic|5hu6uc|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|38fo0|64og0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|qnc40|Infinity',
    'offsets': '-335|-360|-420|-480',
    'offsetIndices': '0123232323232323232323212323232321212121212121212121212121212121212'
  }, {
    'id': 'Asia/Beirut',
    'untils': '-pyzew0|aunw0|88dg0|9et80|8yas0|a2vw0|a31g0|7k580|hjqo40|7v980|awo40|7v980|awo40|7v980|ayis0|7v980|awo40|7v980|5lhs40|56yk0|awo40|7v980|awo40|7v980|awo40|7v980|ayis0|7v980|awo40|7v980|autg0|7v980|2wxus0|8n180|a4w40|8n180|a4w40|8n180|a4w40|8n180|bs5g0|71mk0|alk40|86d80|a4w40|8n180|a4w40|8n180|a6qs0|80t80|905g0|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|Infinity',
    'offsets': '-120|-180',
    'offsetIndices': '010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Asia/Bishkek',
    'untils': '-nu19tc|379zxc|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|h8dc0|bkl80|8n180|a31g0|8n180|a31g0|8n180|a31g0|8n180|a31g0|8zzw0|9db20|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|Infinity',
    'offsets': '-298.4|-300|-360|-420',
    'offsetIndices': '012323232323232323232321212121212121212121212121212'
  }, {
    'id': 'Asia/Brunei',
    'untils': '-mvofy4|3khxs4|Infinity',
    'offsets': '-459.6667|-450|-480',
    'offsetIndices': '012'
  }, {
    'id': 'Asia/Calcutta',
    'untils': '-xehava|innm9a|bmfw0|5lxg0|1mn180|Infinity',
    'offsets': '-321.1667|-330|-390',
    'offsetIndices': '012121'
  }, {
    'id': 'Asia/Chita',
    'untils': '-q4cfog|5hkxgg|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|qnew0|Infinity',
    'offsets': '-453.8667|-480|-540|-600',
    'offsetIndices': '012323232323232323232321232323232323232323232323232323232323232312'
  }, {
    'id': 'Asia/Choibalsan',
    'untils': '-xmct7c|11sndrc|2qk2k0|9eqg0|9eys0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|1ckdo0|7x3w0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|s6qk0|3nc0c0|9ct00|9d9o0|9ct00|Infinity',
    'offsets': '-458|-420|-480|-600|-540',
    'offsetIndices': '0123434343434343434343434343434343434343434343424242'
  }, {
    'id': 'Asia/Chongqing',
    'untils': '-qh00w0|8sl80|asbpg0|6w2k0|7ves0|bxjw0|4mqs0|1vduk0|d4as0|75bw0|a31g0|aaak0|9d440|7v980|awo40|1dx80|j9xpo0|6u7w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '01010101010101010101010101010'
  }, {
    'id': 'Asia/Chungking',
    'untils': '-qh00w0|8sl80|asbpg0|6w2k0|7ves0|bxjw0|4mqs0|1vduk0|d4as0|75bw0|a31g0|aaak0|9d440|7v980|awo40|1dx80|j9xpo0|6u7w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '01010101010101010101010101010'
  }, {
    'id': 'Asia/Colombo',
    'untils': '-xehask|isle6k|cajy0|1mp2u0|qetjw0|7x5a0|4xvqq0|Infinity',
    'offsets': '-319.5333|-330|-360|-390',
    'offsetIndices': '01231321'
  }, {
    'id': 'Asia/Dacca',
    'untils': '-eqtpow|bmgyw|5lxg0|4qknw0|u4ijy0|a1400|Infinity',
    'offsets': '-353.3333|-390|-330|-360|-420',
    'offsetIndices': '0121343'
  }, {
    'id': 'Asia/Damascus',
    'untils': '-q3gk20|5k6q0|8n180|a31g0|8n180|a31g0|8n180|a31g0|8zzw0|k4hk40|7yyk0|awo40|7tek0|b0dg0|7v980|awo40|7tek0|alk40|887w0|awo40|7v980|ayis0|7v980|awo40|7v980|awo40|7v980|awo40|7v980|ayis0|7v980|awo40|7v980|awo40|7v980|awo40|7v980|ayis0|7v980|awo40|6bp80|cg840|6bp80|2eh1g0|8zzw0|9ts40|8zzw0|pvk40|c33w0|7cw40|cjrw0|6zxg0|btuk0|7rpg0|9gnw0|9d440|9cyk0|9et80|9et80|9rxg0|91uk0|92040|9et80|9o840|9et80|9d440|9et80|9eys0|9et80|9b9g0|9gnw0|99es0|9iik0|9d440|9et80|9eys0|9et80|9d440|9et80|9d440|9et80|9d440|9et80|9eys0|9et80|9d440|9et80|9d440|8y580|9q2s0|b5rw0|7x9g0|aunw0|7ig40|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|Infinity',
    'offsets': '-145.2|-120|-180',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Dhaka',
    'untils': '-eqtpow|bmgyw|5lxg0|4qknw0|u4ijy0|a1400|Infinity',
    'offsets': '-353.3333|-390|-330|-360|-420',
    'offsetIndices': '0121343'
  }, {
    'id': 'Asia/Dili',
    'untils': '-u9s4l8|fqcu98|hufs00|cpz440|Infinity',
    'offsets': '-502.3333|-480|-540',
    'offsetIndices': '01212'
  }, {
    'id': 'Asia/Dubai',
    'untils': '-q3gnko|Infinity',
    'offsets': '-221.2|-240',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Dushanbe',
    'untils': '-nu18qo|379yuo|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|hp440|Infinity',
    'offsets': '-275.2|-300|-360|-420',
    'offsetIndices': '012323232323232323232321'
  }, {
    'id': 'Asia/Famagusta',
    'untils': '-p4bqac|rvhy2c|9cyk0|b42s0|7nuk0|8yas0|8zzw0|9q2s0|9et80|9b9g0|9cyk0|9q2s0|8zzw0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|at4c0|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|8h8w0|leog0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-135.8|-120|-180',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Gaza',
    'untils': '-ffv9k0|19f3w0|7rv00|b02c0|7tk40|b07w0|8jhg0|a8lg0|8jhg0|a8ac0|5hoqs0|7el80|awo40|7v980|awqw0|7tk40|b07w0|7tk40|ayd80|7tk40|ayd80|7tk40|ayd80|7tk40|b07w0|7tk40|ayd80|7tk40|ayd80|7ves0|awik0|1sns0|3p6is0|51ek0|9q2s0|6u7w0|2khpg0|25s00|1weyo0|5reo0|bxmo0|7x3w0|cls40|5rbw0|bbhg0|7rjw0|asys0|7k580|c8tg0|6h980|ag040|7x3w0|asys0|8a2k0|asys0|8a2k0|ap9g0|80t80|ap9g0|7nuk0|b2840|80t80|66as0|4vxc0|8n400|a2yo0|8n400|a2yo0|8n400|asw00|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|8n400|a2yo0|8ulg0|97ek0|8y580|9ts40|8hms0|a4qk0|7x3w0|asys0|8a5c0|ahs1o|71mic|bzk5o|69uic|cg840|902o0|9q000|9cyk0|9d440|ast80|7z440|aqyk0|7z6w0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7vc00|auqo0|7vc00|b7pc0|7idc0|b7pc0|7idc0|b7pc0|7vc00|auqo0|7vc00|auqo0|7vc00|auqo0|7vc00|b7pc0|7idc0|b7pc0|7vc00|auqo0|7vc00|auqo0|7vc00|auqo0|7vc00|auqo0|7vc00|b7pc0|7idc0|b7pc0|7vc00|auqo0|7vc00|auqo0|7vc00|auqo0|7vc00|b7pc0|Infinity',
    'offsets': '-120|-180',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010100101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Asia/Harbin',
    'untils': '-qh00w0|8sl80|asbpg0|6w2k0|7ves0|bxjw0|4mqs0|1vduk0|d4as0|75bw0|a31g0|aaak0|9d440|7v980|awo40|1dx80|j9xpo0|6u7w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '01010101010101010101010101010'
  }, {
    'id': 'Asia/Hebron',
    'untils': '-ffv9k0|19f3w0|7rv00|b02c0|7tk40|b07w0|8jhg0|a8lg0|8jhg0|a8ac0|5hoqs0|7el80|awo40|7v980|awqw0|7tk40|b07w0|7tk40|ayd80|7tk40|ayd80|7tk40|ayd80|7tk40|b07w0|7tk40|ayd80|7tk40|ayd80|7ves0|awik0|1sns0|3p6is0|51ek0|9q2s0|6u7w0|2khpg0|25s00|1weyo0|5reo0|bxmo0|7x3w0|cls40|5rbw0|bbhg0|7rjw0|asys0|7k580|c8tg0|6h980|ag040|7x3w0|asys0|8a2k0|asys0|8a2k0|ap9g0|80t80|ap9g0|7nuk0|b2840|80t80|66as0|4vxc0|8n400|a2yo0|8n400|a2yo0|8n400|asw00|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|8n400|a2yo0|8ulg0|97ek0|8y580|9ts40|8hms0|a4qk0|82nw0|anes0|8a5c0|afxc0|73h80|bzk5o|69uic|1hs40|1lbw0|9d440|902o0|9q000|9cyk0|9d440|ast80|7z440|aqyk0|7z6w0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7vc00|auqo0|7vc00|b7pc0|7idc0|b7pc0|7idc0|b7pc0|7vc00|auqo0|7vc00|auqo0|7vc00|auqo0|7vc00|b7pc0|7idc0|b7pc0|7vc00|auqo0|7vc00|auqo0|7vc00|auqo0|7vc00|auqo0|7vc00|b7pc0|7idc0|b7pc0|7vc00|auqo0|7vc00|auqo0|7vc00|auqo0|7vc00|b7pc0|Infinity',
    'offsets': '-120|-180',
    'offsetIndices': '010101010101010101010101010101010101010101010101010101010101010010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Asia/Ho_Chi_Minh',
    'untils': '-x56934|2isioa|gj25iu|15ct80|8so00|tmtk0|4azjw0|2cmao0|8285c0|Infinity',
    'offsets': '-426.6667|-426.5|-420|-480|-540',
    'offsetIndices': '0123423232'
  }, {
    'id': 'Asia/Hong_Kong',
    'untils': '-y0i0s0|j44dk0|5k000|4d4y0|2195i0|7x3w0|bj320|6uao0|bvs00|7x6o0|9d1c0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|ast80|77c40|biqk0|77c40|bvp80|6udg0|bvp80|77c40|biqk0|77c40|biqk0|77c40|biqk0|77c40|bvp80|6udg0|bvp80|6udg0|bvp80|77c40|biqk0|77c40|biqk0|8n6s0|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|3lpg0|f4d80|9d440|9cyk0|9d440|9cyk0|1c9440|8a2k0|Infinity',
    'offsets': '-456.7|-480|-540|-510',
    'offsetIndices': '0123212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Hovd',
    'untils': '-xmcoz0|11sncb0|2qk2k0|9et80|9eys0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|1ckdo0|7x3w0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|4fio40|9ct00|9d9o0|9ct00|Infinity',
    'offsets': '-366.6|-360|-420|-480',
    'offsetIndices': '012323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Irkutsk',
    'untils': '-q28gn5|5fh175|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-417.0833|-420|-480|-540',
    'offsetIndices': '01232323232323232323232123232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Istanbul',
    'untils': '-ux9xew|2wvx6w|7v980|1tjc40|aunw0|88dg0|9et80|8yas0|a2vw0|tzpg0|79180|awo40|7v980|7p4040|4zjw0|2vs40|f4d80|9vms0|1u5ek0|c5440|69uk0|acas0|8n180|a31g0|8n180|9q2s0|8zzw0|a31g0|8zzw0|a31g0|8n180|5md9g0|o9zw0|a6qs0|75bw0|4iwyw0|7x6o0|7kas0|b5rw0|75hg0|bkl80|77c40|biqk0|7x9g0|a2vw0|8n6s0|4iqc0|2nkw80|38l80|kdes0|8qtc0|8a5c0|9ew00|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|902o0|9q000|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7kdk0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7m2o0|b4000|7k800|b5uo0|7x6o0|asw00|7z1c0|ar1c0|7x6o0|bitc0|779c0|8fe80|Infinity',
    'offsets': '-116.9333|-120|-180|-240',
    'offsetIndices': '0121212121212121212121212121212121212121212121223212121212121212121212121212121212121212121212121212121212121212122'
  }, {
    'id': 'Asia/Jakarta',
    'untils': '-o0bdpc|4lzxc0|4wdzjc|1tu960|1cx860|11jta0|74uc20|Infinity',
    'offsets': '-427.2|-440|-450|-540|-480|-420',
    'offsetIndices': '01232425'
  }, {
    'id': 'Asia/Jayapura',
    'untils': '-jebm20|66bqe0|a37vy0|Infinity',
    'offsets': '-562.8|-540|-570',
    'offsetIndices': '0121'
  }, {
    'id': 'Asia/Jerusalem',
    'untils': '-r50eig|bp54yg|19f3w0|7rv00|b02c0|7tk40|b07w0|8jhg0|a8lg0|8jhg0|a8ac0|t9s40|56vs0|35700|9b3w0|9gtg0|8jbw0|7tmw0|a6ig0|biyw0|8a5c0|9d1c0|902o0|7x6o0|e1eg0|4ofw0|dzxo0|4q500|doo40|64iw0|auqo0|7i500|8rfms0|51ek0|9q2s0|6u7w0|2khpg0|25s00|1weyo0|5reo0|bxmo0|7x3w0|cls40|5rbw0|bbhg0|7rjw0|asys0|7k580|c8tg0|6h980|ag040|7x3w0|asys0|8a2k0|asys0|8a2k0|ap9g0|80t80|ap9g0|7nuk0|b2840|80t80|9zc40|9iik0|9kis0|93p80|9mdg0|8qqk0|apf00|7x3w0|biw40|8zx40|9io40|8n180|9kis0|9vh80|8ulg0|9px80|9mdg0|8n180|9tuw0|9tmk0|8wg40|9gnw0|99es0|8qqk0|9zc40|9tmk0|8wg40|9gnw0|99es0|8qqk0|acas0|9gnw0|99es0|93p80|9mdg0|awik0|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|Infinity',
    'offsets': '-140.6667|-120|-180|-240',
    'offsetIndices': '012121212121321212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Kabul',
    'untils': '-d1pkg0|Infinity',
    'offsets': '-240|-270',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Kamchatka',
    'untils': '-olrupo|3z045o|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|j3440|7k800|Infinity',
    'offsets': '-634.6|-660|-720|-780',
    'offsetIndices': '012323232323232323232321232323232323232323232323232323232323212'
  }, {
    'id': 'Asia/Karachi',
    'untils': '-wvpb30|im3zt0|1mn180|33xpg0|a63o20|g72qo0|9cyk0|2y85g0|7v980|8hms0|aaak0|Infinity',
    'offsets': '-268.2|-330|-390|-300|-360',
    'offsetIndices': '012133434343'
  }, {
    'id': 'Asia/Kashgar',
    'untils': '-lx5pjw|Infinity',
    'offsets': '-350.3333|-360',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Kathmandu',
    'untils': '-q3gt4s|yg2lus|Infinity',
    'offsets': '-341.2667|-330|-345',
    'offsetIndices': '012'
  }, {
    'id': 'Asia/Katmandu',
    'untils': '-q3gt4s|yg2lus|Infinity',
    'offsets': '-341.2667|-330|-345',
    'offsetIndices': '012'
  }, {
    'id': 'Asia/Khandyga',
    'untils': '-q4cjrp|5hl1jp|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|3fx40|4h6s0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|8ql00|1mlho0|Infinity',
    'offsets': '-542.2167|-480|-540|-600|-660',
    'offsetIndices': '0123232323232323232323212323232323232323232323232343434343434343432'
  }, {
    'id': 'Asia/Kolkata',
    'untils': '-xehava|innm9a|bmfw0|5lxg0|1mn180|Infinity',
    'offsets': '-321.1667|-330|-390',
    'offsetIndices': '012121'
  }, {
    'id': 'Asia/Krasnoyarsk',
    'untils': '-q37l72|5gg8j2|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-371.4333|-360|-420|-480',
    'offsetIndices': '01232323232323232323232123232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Kuala_Lumpur',
    'untils': '-xphpwd|eeb94d|4it32o|8n3jc|1v2p60|iy3o60|Infinity',
    'offsets': '-415.4167|-420|-440|-450|-540|-480',
    'offsetIndices': '0123435'
  }, {
    'id': 'Asia/Kuching',
    'untils': '-mvof3k|3khwxk|1epvy0|4ohqo|e5a9c|4ohqo|e3flc|4ohqo|e3flc|4ohqo|e3flc|4ohqo|e5a9c|4ohqo|e3flc|4ohqo|3ajlc|1v2qk0|Infinity',
    'offsets': '-441.3333|-450|-480|-500|-540',
    'offsetIndices': '0123232323232323242'
  }, {
    'id': 'Asia/Kuwait',
    'untils': '-bwgbbg|Infinity',
    'offsets': '-186.8667|-180',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Macao',
    'untils': '-y0i2cy|jdvyoy|6onw0|ac580|8fs40|7v980|11luw0|awlc0|7vc00|ac800|bko00|7x6o0|9d1c0|7vc00|asw00|7x6o0|asw00|7x6o0|auqo0|88ao0|asw00|7x6o0|asw00|779c0|bitc0|779c0|bvs00|6uao0|bw1q0|77c40|biqk0|77c40|biqk0|77c40|biqk0|77c40|bvp80|6udg0|bvp80|6udg0|bvp80|77c40|biqk0|77c40|biqk0|8n6s0|9cvs0|9d6w0|9cvs0|9d6w0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|3lpg0|f4d80|9d440|9cyk0|9d440|9cyk0|1c9440|8a2k0|Infinity',
    'offsets': '-454.1667|-480|-540|-600',
    'offsetIndices': '012323212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Macau',
    'untils': '-y0i2cy|jdvyoy|6onw0|ac580|8fs40|7v980|11luw0|awlc0|7vc00|ac800|bko00|7x6o0|9d1c0|7vc00|asw00|7x6o0|asw00|7x6o0|auqo0|88ao0|asw00|7x6o0|asw00|779c0|bitc0|779c0|bvs00|6uao0|bw1q0|77c40|biqk0|77c40|biqk0|77c40|biqk0|77c40|bvp80|6udg0|bvp80|6udg0|bvp80|77c40|biqk0|77c40|biqk0|8n6s0|9cvs0|9d6w0|9cvs0|9d6w0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|3lpg0|f4d80|9d440|9cyk0|9d440|9cyk0|1c9440|8a2k0|Infinity',
    'offsets': '-454.1667|-480|-540|-600',
    'offsetIndices': '012323212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Magadan',
    'untils': '-nu1nxc|37a05c|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|s39k0|Infinity',
    'offsets': '-603.2|-600|-660|-720',
    'offsetIndices': '012323232323232323232321232323232323232323232323232323232323232312'
  }, {
    'id': 'Asia/Makassar',
    'untils': '-q3gzg0|6p5hc0|4u87w0|1w02k0|Infinity',
    'offsets': '-477.6|-480|-540',
    'offsetIndices': '00121'
  }, {
    'id': 'Asia/Manila',
    'untils': '-hb5y80|4qak0|2qidg0|1b2d80|4xf440|442k0|cdqdg0|9et80|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '010101010'
  }, {
    'id': 'Asia/Muscat',
    'untils': '-q3gnko|Infinity',
    'offsets': '-221.2|-240',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Nicosia',
    'untils': '-p4bq6g|rvhxyg|9cyk0|b42s0|7nuk0|8yas0|8zzw0|9q2s0|9et80|9b9g0|9cyk0|9q2s0|8zzw0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|at4c0|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-133.4667|-120|-180',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Novokuznetsk',
    'untils': '-nu36tc|37bu5c|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|j3440|7k800|Infinity',
    'offsets': '-348.8|-360|-420|-480',
    'offsetIndices': '012323232323232323232321232323232323232323232323232323232323212'
  }, {
    'id': 'Asia/Novosibirsk',
    'untils': '-q4do0s|5hmbcs|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|2vh00|6hn40|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|wrpg0|Infinity',
    'offsets': '-331.6667|-360|-420|-480',
    'offsetIndices': '0123232323232323232323212323212121212121212121212121212121212121212'
  }, {
    'id': 'Asia/Omsk',
    'untils': '-q5xmx6|5j6d16|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-293.5|-300|-360|-420',
    'offsetIndices': '01232323232323232323232123232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Oral',
    'untils': '-nu15ic|37a16c|qi2540|s6qk0|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|iq5g0|9d1c0|9q000|9d1c0|9d1c0|5reo0|cyo00|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|Infinity',
    'offsets': '-205.4|-180|-300|-360|-240',
    'offsetIndices': '01232323232323232424242424242424242424242424242'
  }, {
    'id': 'Asia/Phnom_Penh',
    'untils': '-pysda4|Infinity',
    'offsets': '-402.0667|-420',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Pontianak',
    'untils': '-w6piww|cse2o0|4tnu2w|1wkei0|1cx860|11jta0|74uc20|cixam0|Infinity',
    'offsets': '-437.3333|-450|-540|-480|-420',
    'offsetIndices': '001213134'
  }, {
    'id': 'Asia/Pyongyang',
    'untils': '-w895yc|1yh10c|hk5da0|10ipmo0|1f4qo0|Infinity',
    'offsets': '-503|-510|-540',
    'offsetIndices': '012212'
  }, {
    'id': 'Asia/Qatar',
    'untils': '-q3gmvk|rctnrk|Infinity',
    'offsets': '-206.1333|-240|-180',
    'offsetIndices': '012'
  }, {
    'id': 'Asia/Qostanay',
    'untils': '-nu17s4|37a0o4|qi27w0|s6qk0|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|Infinity',
    'offsets': '-254.4667|-240|-300|-360',
    'offsetIndices': '012323232323232323232123232323232323232323232323'
  }, {
    'id': 'Asia/Qyzylorda',
    'untils': '-nu184g|37a10g|qi27w0|s6qk0|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|ohhc0|cyo00|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|7osl00|Infinity',
    'offsets': '-261.8667|-240|-300|-360',
    'offsetIndices': '01232323232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Rangoon',
    'untils': '-q3gv5b|bnjp3b|1kh520|Infinity',
    'offsets': '-384.7833|-390|-540',
    'offsetIndices': '0121'
  }, {
    'id': 'Asia/Riyadh',
    'untils': '-bwgbbg|Infinity',
    'offsets': '-186.8667|-180',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Saigon',
    'untils': '-x56934|2isioa|gj25iu|15ct80|8so00|tmtk0|4azjw0|2cmao0|8285c0|Infinity',
    'offsets': '-426.6667|-426.5|-420|-480|-540',
    'offsetIndices': '0123423232'
  }, {
    'id': 'Asia/Sakhalin',
    'untils': '-xl87rc|kvnarc|ikvh40|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|iq5g0|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|qnc40|Infinity',
    'offsets': '-570.8|-540|-660|-720|-600',
    'offsetIndices': '01232323232323232323232423232323232424242424242424242424242424242'
  }, {
    'id': 'Asia/Samarkand',
    'untils': '-nu18eh|37a1ah|qi27w0|s6qk0|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|Infinity',
    'offsets': '-267.8833|-240|-300|-360',
    'offsetIndices': '01232323232323232323232'
  }, {
    'id': 'Asia/Seoul',
    'untils': '-w8966g|1yh18g|hkx5a0|1faao0|5cik0|ae5g0|8a2k0|ae5g0|8bx80|c8tg0|6h980|1bj6s0|l3aq0|6j3w0|d2g40|6u7w0|b5xg0|776k0|biw40|776k0|biw40|776k0|biw40|776k0|grs40|dfqxi0|7x6o0|asw00|7x6o0|Infinity',
    'offsets': '-507.8667|-510|-540|-600|-570',
    'offsetIndices': '012232323232141414141414123232'
  }, {
    'id': 'Asia/Shanghai',
    'untils': '-qh00w0|8sl80|asbpg0|6w2k0|7ves0|bxjw0|4mqs0|1vduk0|d4as0|75bw0|a31g0|aaak0|9d440|7v980|awo40|1dx80|j9xpo0|6u7w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '01010101010101010101010101010'
  }, {
    'id': 'Asia/Singapore',
    'untils': '-xphpwd|eeb94d|4it32o|8n3jc|1v2p60|iy3o60|Infinity',
    'offsets': '-415.4167|-420|-440|-450|-540|-480',
    'offsetIndices': '0123435'
  }, {
    'id': 'Asia/Srednekolymsk',
    'untils': '-nu1ogs|37a0os|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-614.8667|-600|-660|-720',
    'offsetIndices': '01232323232323232323232123232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Taipei',
    'untils': '-gtzfk0|45slc0|c51c0|75bw0|a31g0|aaak0|9d440|7v980|awo40|7v980|awo40|7v980|awo40|7v980|7tk40|clmk0|7rpg0|b07w0|7rpg0|b07w0|7rpg0|9et80|9eys0|9et80|9d440|9et80|9d440|9et80|9d440|9et80|cjxg0|69uk0|ci2s0|69uk0|6its40|9et80|9d440|9et80|1yf9g0|4qak0|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '01010101010101010101010101010101010101010'
  }, {
    'id': 'Asia/Tashkent',
    'untils': '-nu18tz|379yxz|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|Infinity',
    'offsets': '-277.1833|-300|-360|-420',
    'offsetIndices': '012323232323232323232321'
  }, {
    'id': 'Asia/Tbilisi',
    'untils': '-nu14an|h4tjyn|ckinw0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|9cvs0|9cyk0|9d440|9cyk0|9d440|ipzw0|9cyk0|9q2s0|tivw0|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|4ofw0|6hn40|7k800|Infinity',
    'offsets': '-179.1833|-180|-240|-300',
    'offsetIndices': '0123232323232323232323212121232323232323232323212'
  }, {
    'id': 'Asia/Tehran',
    'untils': '-s6m6uw|fnolc0|gm3h4w|777y0|b07w0|3pes0|42c20|9cyk0|9gtg0|9kd80|5ja5g0|7avw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|1av440|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|Infinity',
    'offsets': '-205.7333|-210|-240|-300|-270',
    'offsetIndices': '00123214141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141'
  }, {
    'id': 'Asia/Tel_Aviv',
    'untils': '-r50eig|bp54yg|19f3w0|7rv00|b02c0|7tk40|b07w0|8jhg0|a8lg0|8jhg0|a8ac0|t9s40|56vs0|35700|9b3w0|9gtg0|8jbw0|7tmw0|a6ig0|biyw0|8a5c0|9d1c0|902o0|7x6o0|e1eg0|4ofw0|dzxo0|4q500|doo40|64iw0|auqo0|7i500|8rfms0|51ek0|9q2s0|6u7w0|2khpg0|25s00|1weyo0|5reo0|bxmo0|7x3w0|cls40|5rbw0|bbhg0|7rjw0|asys0|7k580|c8tg0|6h980|ag040|7x3w0|asys0|8a2k0|asys0|8a2k0|ap9g0|80t80|ap9g0|7nuk0|b2840|80t80|9zc40|9iik0|9kis0|93p80|9mdg0|8qqk0|apf00|7x3w0|biw40|8zx40|9io40|8n180|9kis0|9vh80|8ulg0|9px80|9mdg0|8n180|9tuw0|9tmk0|8wg40|9gnw0|99es0|8qqk0|9zc40|9tmk0|8wg40|9gnw0|99es0|8qqk0|acas0|9gnw0|99es0|93p80|9mdg0|awik0|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|Infinity',
    'offsets': '-140.6667|-120|-180|-240',
    'offsetIndices': '012121212121321212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Thimbu',
    'untils': '-bojclo|kxymno|Infinity',
    'offsets': '-358.6|-330|-360',
    'offsetIndices': '012'
  }, {
    'id': 'Asia/Thimphu',
    'untils': '-bojclo|kxymno|Infinity',
    'offsets': '-358.6|-330|-360',
    'offsetIndices': '012'
  }, {
    'id': 'Asia/Tokyo',
    'untils': '-bb4900|6uao0|afxc0|8a5c0|c8qo0|6hc00|c8qo0|6hc00|Infinity',
    'offsets': '-540|-600',
    'offsetIndices': '010101010'
  }, {
    'id': 'Asia/Tomsk',
    'untils': '-q3zbqf|5h7z2f|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|1leo0|97k40|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|tw040|Infinity',
    'offsets': '-339.85|-360|-420|-480',
    'offsetIndices': '0123232323232323232323212323232323232323232323212121212121212121212'
  }, {
    'id': 'Asia/Ujung_Pandang',
    'untils': '-q3gzg0|6p5hc0|4u87w0|1w02k0|Infinity',
    'offsets': '-477.6|-480|-540',
    'offsetIndices': '00121'
  }, {
    'id': 'Asia/Ulaanbaatar',
    'untils': '-xmcrsk|11sncck|2qk2k0|9et80|9eys0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|1ckdo0|7x3w0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|4fio40|9ct00|9d9o0|9ct00|Infinity',
    'offsets': '-427.5333|-420|-480|-540',
    'offsetIndices': '012323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Ulan_Bator',
    'untils': '-xmcrsk|11sncck|2qk2k0|9et80|9eys0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|1ckdo0|7x3w0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|4fio40|9ct00|9d9o0|9ct00|Infinity',
    'offsets': '-427.5333|-420|-480|-540',
    'offsetIndices': '012323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Urumqi',
    'untils': '-lx5pjw|Infinity',
    'offsets': '-350.3333|-360',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Ust-Nera',
    'untils': '-q4cl6u|5hl2yu|qi27w0|9eno0|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|8ql00|1mlho0|Infinity',
    'offsets': '-572.9|-480|-540|-720|-660|-600',
    'offsetIndices': '012343434343434343434345434343434343434343434343434343434343434345'
  }, {
    'id': 'Asia/Vientiane',
    'untils': '-pysda4|Infinity',
    'offsets': '-402.0667|-420',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Vladivostok',
    'untils': '-oligf7|3yqvf7|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-527.5167|-540|-600|-660',
    'offsetIndices': '01232323232323232323232123232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Yakutsk',
    'untils': '-q4cioy|5hl0gy|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-518.9667|-480|-540|-600',
    'offsetIndices': '01232323232323232323232123232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Yangon',
    'untils': '-q3gv5b|bnjp3b|1kh520|Infinity',
    'offsets': '-384.7833|-390|-540',
    'offsetIndices': '0121'
  }, {
    'id': 'Asia/Yekaterinburg',
    'untils': '-rx5hw9|1kybx4|5pfyv5|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-242.55|-225.0833|-240|-300|-360',
    'offsetIndices': '012343434343434343434343234343434343434343434343434343434343434343'
  }, {
    'id': 'Asia/Yerevan',
    'untils': '-nu148o|h4tjwo|ckinw0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|11t180|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|Infinity',
    'offsets': '-178|-180|-240|-300',
    'offsetIndices': '0123232323232323232323212121212323232323232323232323232323232'
  }, {
    'id': 'Atlantic/Azores',
    'untils': '-u9rbs0|2bufw0|6zxg0|66580|bq800|73k00|bodc0|71pc0|bq800|73k00|bq800|71pc0|bq800|1b2g00|9b6o0|saio0|8n400|9q000|902o0|a2yo0|902o0|a2yo0|8n400|st1c0|8n400|9d1c0|9d1c0|sg2o0|9d1c0|902o0|9q000|a2yo0|8n400|9d1c0|9d1c0|902o0|9q000|a2yo0|b5uo0|51hc0|bitc0|9d1c0|9ew00|88ao0|25p80|5reo0|3lpg0|779c0|1sqk0|6uao0|38qs0|6uao0|25p80|6hc00|38qs0|6uao0|25p80|6hc00|38qs0|8a5c0|9d1c0|9d9o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|s3400|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|5qbjo0|9d1c0|9q000|9d1c0|9d1c0|9d440|9cyk0|9d440|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9cyk0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9cyk0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '114.5333|120|60|0',
    'offsetIndices': '01212121212121212121212121212121212121212121232123212321232121212121212121212121212121212121212121232323232323232323232323232323233323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Atlantic/Bermuda',
    'untils': '-kvj2fu|n4pr3u|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '259.3|240|180',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Atlantic/Canary',
    'untils': '-oytbtc|ctvupc|hhq7s0|905g0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '61.6|60|0|-60',
    'offsetIndices': '01232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Atlantic/Cape_Verde',
    'untils': '-u9rbs0|g06lc0|1mn180|fpqwc0|Infinity',
    'offsets': '94.0667|120|60',
    'offsetIndices': '01212'
  }, {
    'id': 'Atlantic/Faeroe',
    'untils': '-wcehew|127keuw|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '27.0667|0|-60',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Atlantic/Faroe',
    'untils': '-wcehew|127keuw|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '27.0667|0|-60',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Atlantic/Jan_Mayen',
    'untils': '-rzayo0|6qfs0|cgcqo0|15tsc0|7k800|9q000|9d1c0|9d1c0|9d1c0|9d1c0|70q5c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|b5uo0|7k800|7law00|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Atlantic/Madeira',
    'untils': '-u9rek0|2bufw0|6zxg0|66580|bq800|73k00|bodc0|71pc0|bq800|73k00|bq800|71pc0|bq800|1b2g00|9b6o0|saio0|8n400|9q000|902o0|a2yo0|902o0|a2yo0|8n400|st1c0|8n400|9d1c0|9d1c0|sg2o0|9d1c0|902o0|9q000|a2yo0|8n400|9d1c0|9d1c0|902o0|9q000|a2yo0|b5uo0|51hc0|bitc0|9d1c0|9ew00|88ao0|25p80|5reo0|3lpg0|779c0|1sqk0|6uao0|38qs0|6uao0|25p80|6hc00|38qs0|6uao0|25p80|6hc00|38qs0|8a5c0|9d1c0|9d9o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|s3400|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|5qbjo0|9d1c0|9q000|9d1c0|9d1c0|9d440|9cyk0|9d440|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9cyk0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '67.6|60|0|-60',
    'offsetIndices': '01212121212121212121212121212121212121212121232123212321232121212121212121212121212121212121212121232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Atlantic/Reykjavik',
    'untils': '-wcwx9c|4rpd9c|ci2s0|69uk0|du840|4xp80|du840|p7bw0|4w040|9bdzw0|9d6w0|64g40|cyl80|64dc0|clpc0|6hc00|bvs00|6uao0|bvs00|6uao0|bvs00|6uao0|c8qo0|6hc00|c8qo0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|7x6o0|afxc0|8a5c0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|8a5c0|Infinity',
    'offsets': '88|60|0',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'Atlantic/South_Georgia',
    'untils': 'Infinity',
    'offsets': '120',
    'offsetIndices': '0'
  }, {
    'id': 'Atlantic/St_Helena',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Atlantic/Stanley',
    'untils': '-u63pac|dbvxqc|8zzw0|9q2s0|8zzw0|a31g0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|4xp80|l1pus0|7k580|b5rw0|77c40|biqk0|id6s0|7kas0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7kas0|biqk0|77c40|biqk0|7kas0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7kas0|biqk0|7kas0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7kas0|b5xg0|77c40|bvp80|6udg0|bvp80|77c40|biqk0|77c40|biqk0|77c40|biqk0|77c40|biqk0|77c40|bvp80|77c40|biqk0|77c40|biqk0|77c40|Infinity',
    'offsets': '231.4|240|180|120',
    'offsetIndices': '012121212121212323212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'Australia/ACT',
    'untils': '-rnsx2c|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|8a5c0|asw00|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|bitc0|7k800|bitc0|779c0|bitc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|7x6o0|asw00|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/Adelaide',
    'untils': '-rnsvoc|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|bitc0|7k800|bitc0|779c0|bitc0|779c0|bitc0|6hc00|c8qo0|7k800|b5uo0|6uao0|c8qo0|779c0|bitc0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-570|-630',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/Brisbane',
    'untils': '-rnsx2c|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|97zuo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '01010101010101010'
  }, {
    'id': 'Australia/Broken_Hill',
    'untils': '-rnsvoc|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|8a5c0|asw00|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|bitc0|7k800|bitc0|779c0|bitc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-570|-630',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/Canberra',
    'untils': '-rnsx2c|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|8a5c0|asw00|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|bitc0|7k800|bitc0|779c0|bitc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|7x6o0|asw00|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/Currie',
    'untils': '-rsj4w0|8zzw0|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|b5uo0|7k800|b5uo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|bvs00|7k800|bitc0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x6o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|7x6o0|asw00|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9d1c0|902o0|a2yo0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/Darwin',
    'untils': '-rnsvoc|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|Infinity',
    'offsets': '-570|-630',
    'offsetIndices': '010101010'
  }, {
    'id': 'Australia/Eucla',
    'untils': '-rnstlc|49s2c|cxfms0|4h180|9d440|9cyk0|ghf1g0|6hc00|4ir9c0|6hc00|40r400|5eg00|7p9hc0|5reo0|b5uo0|7x6o0|asw00|7x6o0|Infinity',
    'offsets': '-525|-585',
    'offsetIndices': '0101010101010101010'
  }, {
    'id': 'Australia/Hobart',
    'untils': '-rsj4w0|8zzw0|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|c9tms0|9d1c0|asw00|6uao0|bvs00|6uao0|bvs00|779c0|bvs00|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|b5uo0|7k800|b5uo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|bvs00|7k800|bitc0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x6o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|7x6o0|asw00|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9d1c0|902o0|a2yo0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/LHI',
    'untils': '5tp880|c8uu0|6u7w0|c8tg0|6h980|c8tg0|6h980|c8tg0|6h980|c8tg0|777y0|b5w20|7k6m0|biuq0|7k6m0|biuq0|777y0|biuq0|6ham0|c8s20|6ham0|c8s20|6ham0|c8s20|6u9a0|c8s20|6ham0|c8s20|6ham0|c8s20|7x5a0|asxe0|7x5a0|asxe0|7x5a0|asxe0|7x5a0|b5w20|7k6m0|7x820|asum0|b5w20|7x5a0|asxe0|7x5a0|asxe0|7x5a0|b5w20|7k6m0|b5w20|7x5a0|asxe0|7k6m0|b5w20|8a3y0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9q1e0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9q1e0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9pym0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9q1e0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9q1e0|9czy0|9d2q0|9czy0|9d2q0|Infinity',
    'offsets': '-600|-630|-690|-660',
    'offsetIndices': '0121212121313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313'
  }, {
    'id': 'Australia/Lindeman',
    'untils': '-rnsx2c|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|97zuo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '010101010101010101010'
  }, {
    'id': 'Australia/Lord_Howe',
    'untils': '5tp880|c8uu0|6u7w0|c8tg0|6h980|c8tg0|6h980|c8tg0|6h980|c8tg0|777y0|b5w20|7k6m0|biuq0|7k6m0|biuq0|777y0|biuq0|6ham0|c8s20|6ham0|c8s20|6ham0|c8s20|6u9a0|c8s20|6ham0|c8s20|6ham0|c8s20|7x5a0|asxe0|7x5a0|asxe0|7x5a0|asxe0|7x5a0|b5w20|7k6m0|7x820|asum0|b5w20|7x5a0|asxe0|7x5a0|asxe0|7x5a0|b5w20|7k6m0|b5w20|7x5a0|asxe0|7k6m0|b5w20|8a3y0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9q1e0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9q1e0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9pym0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9q1e0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9q1e0|9czy0|9d2q0|9czy0|9d2q0|Infinity',
    'offsets': '-600|-630|-690|-660',
    'offsetIndices': '0121212121313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313'
  }, {
    'id': 'Australia/Melbourne',
    'untils': '-rnsx2c|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|b5uo0|7x6o0|bitc0|779c0|bitc0|779c0|bitc0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|7x6o0|asw00|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/North',
    'untils': '-rnsvoc|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|Infinity',
    'offsets': '-570|-630',
    'offsetIndices': '010101010'
  }, {
    'id': 'Australia/NSW',
    'untils': '-rnsx2c|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|8a5c0|asw00|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|bitc0|7k800|bitc0|779c0|bitc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|7x6o0|asw00|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/Perth',
    'untils': '-rnsric|49s2c|cxfms0|4h180|9d440|9cyk0|ghf1g0|6hc00|4ir9c0|6hc00|40r400|5eg00|7p9hc0|5reo0|b5uo0|7x6o0|asw00|7x6o0|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '0101010101010101010'
  }, {
    'id': 'Australia/Queensland',
    'untils': '-rnsx2c|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|97zuo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '01010101010101010'
  }, {
    'id': 'Australia/South',
    'untils': '-rnsvoc|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|bitc0|7k800|bitc0|779c0|bitc0|779c0|bitc0|6hc00|c8qo0|7k800|b5uo0|6uao0|c8qo0|779c0|bitc0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-570|-630',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/Sydney',
    'untils': '-rnsx2c|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|8a5c0|asw00|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|bitc0|7k800|bitc0|779c0|bitc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|7x6o0|asw00|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/Tasmania',
    'untils': '-rsj4w0|8zzw0|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|c9tms0|9d1c0|asw00|6uao0|bvs00|6uao0|bvs00|779c0|bvs00|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|b5uo0|7k800|b5uo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|bvs00|7k800|bitc0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x6o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|7x6o0|asw00|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9d1c0|902o0|a2yo0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/Victoria',
    'untils': '-rnsx2c|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|b5uo0|7x6o0|bitc0|779c0|bitc0|779c0|bitc0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|7x6o0|asw00|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/West',
    'untils': '-rnsric|49s2c|cxfms0|4h180|9d440|9cyk0|ghf1g0|6hc00|4ir9c0|6hc00|40r400|5eg00|7p9hc0|5reo0|b5uo0|7x6o0|asw00|7x6o0|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '0101010101010101010'
  }, {
    'id': 'Australia/Yancowinna',
    'untils': '-rnsvoc|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|8a5c0|asw00|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|bitc0|7k800|bitc0|779c0|bitc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-570|-630',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Brazil/Acre',
    'untils': '-t85fg0|99kak0|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|amves0|2t2t80|Infinity',
    'offsets': '271.2|300|240',
    'offsetIndices': '01212121212121212121212121212121'
  }, {
    'id': 'Brazil/DeNoronha',
    'untils': '-t85lzw|99k8rw|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|514g40|7k580|biw40|cvw0|iq5g0|6h980|Infinity',
    'offsets': '129.6667|120|60',
    'offsetIndices': '0121212121212121212121212121212121212121'
  }, {
    'id': 'Brazil/East',
    'untils': '-t85jd8|99k8x8|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5k02s0|6onw0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|cyqs0|64ak0|cls40|5rbw0|dbpg0|51ek0|dbpg0|6h980|c8tg0|6h980|c8tg0|64ak0|c8tg0|6u7w0|bxpg0|7iak0|biw40|6u7w0|biw40|7k580|biw40|6u7w0|c8tg0|6h980|dbpg0|5ed80|cls40|64ak0|dfes0|5nmk0|c8tg0|6h980|dbpg0|5rbw0|bvus0|6h980|cls40|64ak0|cls40|6h980|c8tg0|6h980|c8tg0|6u7w0|c8tg0|64ak0|cls40|64ak0|cls40|6h980|c8tg0|6h980|c8tg0|6h980|c8tg0|6h980|dbpg0|5ed80|Infinity',
    'offsets': '186.4667|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Brazil/West',
    'untils': '-t85gvw|99k97w|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|2yy2s0|6h980|Infinity',
    'offsets': '240.0667|240|180',
    'offsetIndices': '01212121212121212121212121212121'
  }, {
    'id': 'Canada/Atlantic',
    'untils': '-z94k80|777go0|9et80|st9o0|a2vw0|ssyk0|5rbw0|cv1g0|69uk0|c6ys0|6kyk0|ci2s0|67zw0|ci2s0|6w2k0|bu040|7lzw0|bu040|66580|bu040|7lzw0|bu040|64ak0|cls40|5v180|cv1g0|6j3w0|c6ys0|79180|b42s0|7lzw0|b42s0|7yyk0|bu040|64ak0|dbpg0|66580|cls40|5ed80|bu040|7lzw0|b42s0|7lzw0|cjxg0|66580|bh1g0|7lzw0|b42s0|7lzw0|6uj00|1tzdw0|2dnc0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|tw040|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|tw040|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|1cm2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '254.4|240|180',
    'offsetIndices': '0121212121212121212121212121212121212121212121212122121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Canada/Central',
    'untils': '-s0s7c0|7k580|tj700|a2vw0|9ok840|6u7w0|2a5hg0|1tz8c0|2dsw0|biw40|7x3w0|a31g0|7x3w0|asys0|7x3w0|asys0|7x3w0|b7s40|7tek0|autg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9cyk0|9d440|7x3w0|1cm2s0|7k580|1cm2s0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|902o0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|902o0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|8a5c0|afxc0|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|7x6o0|asw00|7x6o0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '010101011010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Canada/Eastern',
    'untils': '-qzoxw0|a2vw0|7yx60|aqzy0|9q8c0|7jzo0|bw0c0|6bp80|cedg0|6h980|c8tg0|6h980|bvus0|776k0|biw40|776k0|biw40|776k0|biw40|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|xjeo0|1tzb40|2dq40|asys0|7x3w0|ast80|7x3w0|asys0|7x3w0|asys0|b5rw0|7xf00|ast80|7x9g0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '300|240',
    'offsetIndices': '01010101010101010101010101010101010101010101011101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Canada/Mountain',
    'untils': '-x1yazk|629ink|a2vw0|8n6s0|29ek0|h6lg0|9px80|905g0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|9l0g40|1tz5k0|2dvo0|tj1g0|7x3w0|ctzk40|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '453.8667|420|360',
    'offsetIndices': '0121212121212122121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Canada/Newfoundland',
    'untils': '-ris3ck|8bx80|ar440|a2vw0|9tjs0|53980|dkys0|9cyk0|9d440|9cyk0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|9cyk0|9d440|9cyk0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|9cyk0|9q2s0|8zzw0|9q2s0|8zzw0|7tmw0|1wfuk|8zzw0|a3480|7k580|b5xg0|7k580|b5xg0|7k580|biw40|776k0|biw40|7k580|b5xg0|7k580|b5xg0|1pb260|2dly0|biw40|7k580|b5xg0|7k580|b5xg0|7k580|b5xg0|7k580|biw40|7k580|ag040|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a2lo|afuk0|8a840|asqg0|7xc80|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8tec|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '210.8667|150.8667|210|150|90',
    'offsetIndices': '01010101010101010101010101010101010102323232323232323323232323232323232323232323232323232323232323232323232323232323232323232323232323232324232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Canada/Pacific',
    'untils': '-qzopk0|a2vw0|c5jxg0|1tz2s0|2dyg0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420',
    'offsetIndices': '0101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Canada/Saskatchewan',
    'untils': '-xkq9yc|6l1hmc|a2vw0|60enw0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|1b6840|9cyk0|9d440|8zzw0|9q2s0|9cyk0|9q2s0|9cyk0|9d440|9cyk0|66gc0|1tz5k0|2dvo0|a31g0|9cyk0|a31g0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|tj1g0|9cyk0|9d440|Infinity',
    'offsets': '418.6|420|360',
    'offsetIndices': '012121212121212121212121221212121212121212121212121212'
  }, {
    'id': 'Canada/Yukon',
    'untils': '-qzoms0|a2vw0|asys0|882c0|bmiwc0|1tz000|2e180|a7n3w0|9q000|tiyo0|6qp440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|Infinity',
    'offsets': '540|480|420',
    'offsetIndices': '01010110201212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'CET',
    'untils': '-s0e080|7ves0|a4yw0|7x6o0|asw00|7x6o0|b8qdc0|1cm000|7k800|9q000|9d1c0|9d1c0|9d1c0|8l9c0|ggp1c0|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Chile/Continental',
    'untils': '-vauawq|3dlssq|157b7a|f4e0q|49hzba|aye0q|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|534ik0|351g0|229zw0|2gt80|awo40|2mg00|b73400|7k580|c8tg0|6h980|a31g0|7x3w0|asys0|7x3w0|b5xg0|7k580|ag040|8a2k0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|9cyk0|9d440|7x3w0|asys0|7x3w0|b5xg0|7k580|9q2s0|8zzw0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|a31g0|9px80|9q2s0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|asys0|8zzw0|9q2s0|ast80|5eis0|cyl80|6hes0|c8nw0|6udg0|bvp80|6udg0|vonw0|4olg0|e1h80|4olg0|e1h80|4olg0|c8nw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|Infinity',
    'offsets': '282.7667|300|240|180',
    'offsetIndices': '010202121212121212321232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'Chile/EasterIsland',
    'untils': '-jhfaew|ivmeuw|7k580|c8tg0|6h980|a31g0|7x3w0|asys0|7x3w0|b5xg0|7k580|ag040|8a2k0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|iq2o0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|9cyk0|9d440|7x3w0|asys0|7x3w0|b5xg0|7k580|9q2s0|8zzw0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|a31g0|9px80|9q2s0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|asys0|8zzw0|9q2s0|ast80|5eis0|cyl80|6hes0|c8nw0|6udg0|bvp80|6udg0|vonw0|4olg0|e1h80|4olg0|e1h80|4olg0|c8nw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|Infinity',
    'offsets': '437.4667|420|360|300',
    'offsetIndices': '012121212121212121212121212123232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'CST6CDT',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|b9gdg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Cuba',
    'untils': '-n7762o|1icfyo|69uk0|62s040|4ofw0|e1ms0|51ek0|e1ms0|4ofw0|1fhs40|4ofw0|e1ms0|4ofw0|9s9k40|67zw0|cedg0|6h980|9o840|7yyk0|b5xg0|7k580|bvus0|9cyk0|9d440|9cyk0|9d440|9px80|9d440|8a2k0|ag040|8bx80|ae5g0|8drw0|acas0|9cyk0|9d440|9px80|905g0|9px80|9q2s0|7x3w0|8a840|ast80|7x9g0|ast80|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|8a2k0|ag040|8a2k0|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|905g0|a2vw0|905g0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|8n400|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|7x6o0|1cm000|6uao0|bvs00|779c0|bitc0|6uao0|bvs00|779c0|bvs00|779c0|c8qo0|779c0|b5uo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|Infinity',
    'offsets': '329.6|300|240',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'EET',
    'untils': '3s9ms0|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-120|-180',
    'offsetIndices': '010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Egypt',
    'untils': '-fdls80|40d80|a31g0|7x3w0|a4w40|aqyk0|80ys0|b07w0|7tk40|b07w0|8jhg0|a8fw0|60go40|7el80|awo40|7v980|awqw0|7tk40|b07w0|7tk40|ayd80|7tk40|ayd80|7tk40|ayd80|7tk40|b07w0|7tk40|ayd80|7tk40|ayd80|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|f9x80|3i040|eluk0|462s0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|b5rw0|7m5g0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|aqvs0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7k580|b5xg0|6u7w0|bvus0|6h980|c8tg0|64ak0|cyqs0|5anw0|1jms0|12t80|1w22s0|25p80|1sw40|2vmk0|Infinity',
    'offsets': '-120|-180',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Eire',
    'untils': '-rzcmlr|6uao0|9pytr|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|3g8800|8a5c0|bvs00|8n400|a2yo0|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|902o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|5reo0|1xhuo0|779c0|bitc0|779c0|bitc0|779c0|bitc0|779c0|bitc0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x3w0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '25.35|-34.65|0|-60',
    'offsetIndices': '01232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'EST',
    'untils': 'Infinity',
    'offsets': '300',
    'offsetIndices': '0'
  }, {
    'id': 'EST5EDT',
    'untils': '-r0ev80|ast80|7x9g0|ast80|bmtus0|1tzb40|2dq40|b9gdg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '300|240',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Etc/GMT-0',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-1',
    'untils': 'Infinity',
    'offsets': '-60',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-10',
    'untils': 'Infinity',
    'offsets': '-600',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-11',
    'untils': 'Infinity',
    'offsets': '-660',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-12',
    'untils': 'Infinity',
    'offsets': '-720',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-13',
    'untils': 'Infinity',
    'offsets': '-780',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-14',
    'untils': 'Infinity',
    'offsets': '-840',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-2',
    'untils': 'Infinity',
    'offsets': '-120',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-3',
    'untils': 'Infinity',
    'offsets': '-180',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-4',
    'untils': 'Infinity',
    'offsets': '-240',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-5',
    'untils': 'Infinity',
    'offsets': '-300',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-6',
    'untils': 'Infinity',
    'offsets': '-360',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-7',
    'untils': 'Infinity',
    'offsets': '-420',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-8',
    'untils': 'Infinity',
    'offsets': '-480',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-9',
    'untils': 'Infinity',
    'offsets': '-540',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+0',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+1',
    'untils': 'Infinity',
    'offsets': '60',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+10',
    'untils': 'Infinity',
    'offsets': '600',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+11',
    'untils': 'Infinity',
    'offsets': '660',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+12',
    'untils': 'Infinity',
    'offsets': '720',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+2',
    'untils': 'Infinity',
    'offsets': '120',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+3',
    'untils': 'Infinity',
    'offsets': '180',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+4',
    'untils': 'Infinity',
    'offsets': '240',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+5',
    'untils': 'Infinity',
    'offsets': '300',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+6',
    'untils': 'Infinity',
    'offsets': '360',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+7',
    'untils': 'Infinity',
    'offsets': '420',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+8',
    'untils': 'Infinity',
    'offsets': '480',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+9',
    'untils': 'Infinity',
    'offsets': '540',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT0',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/Greenwich',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/UCT',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/Universal',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/UTC',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/Zulu',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Europe/Amsterdam',
    'untils': '-s0dvkk|7v980|a51o0|7x6o0|a2yo0|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9b6o0|a2yo0|c51c0|6l1c0|902o0|9q000|ci000|682o0|bgyo0|79400|bitc0|779c0|bmio0|7gio0|bbeo0|7eo00|bd9c0|7ctc0|bf400|7ayo0|bvs00|6uao0|bko00|7idc0|b9k00|7gio0|bbeo0|7eo00|bf400|7ayo0|btxc0|21uc0|4uaz8|bitc0|779c0|bko00|7idc0|bd3s0|1aarpc|7k800|9q000|9d1c0|9d1c0|9d1c0|8l9c0|ggp1c0|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-19.5333|-79.5333|-80|-20|-120|-60',
    'offsetIndices': '010101010101010101010101010101010101010101012323234545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545'
  }, {
    'id': 'Europe/Andorra',
    'untils': '-c4xmo0|k3ctg0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Astrakhan',
    'untils': '-nu2zkc|37bv8c|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|iq5g0|9d1c0|9q000|9d1c0|s3400|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|qnc40|Infinity',
    'offsets': '-192.2|-180|-240|-300',
    'offsetIndices': '012323232323232323212121212121212121212121212121212121212121212'
  }, {
    'id': 'Europe/Athens',
    'untils': '-rvv0cg|8bjasg|2vmk0|4hiw40|16ik0|scog0|7lx40|9o2k0|9eys0|4atzw0|6djw0|bplus0|bq800|71uw0|9d1c0|902o0|91xc0|9o5c0|905g0|9qgo0|9akg0|9iik0|99980|9dcg0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-94.8667|-120|-180|-60',
    'offsetIndices': '012121313121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Belfast',
    'untils': '-rzcns0|6uao0|9q000|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|mbmk0|51hc0|c8qo0|6hc00|c8qo0|6uao0|bvs00|8n400|a4tc0|5clc0|4bms0|9q000|902o0|8a5c0|1frw0|64dc0|4bms0|6uao0|bvs00|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|902o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|5reo0|1xhuo0|779c0|bitc0|779c0|bitc0|779c0|bitc0|779c0|bitc0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x3w0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010121212121210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Belgrade',
    'untils': '-ezayw0|swz00|7k800|9q000|9d1c0|9d1c0|b7pc0|6qlc0|jl1hc0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Berlin',
    'untils': '-s0e080|7ves0|a4yw0|7x6o0|asw00|7x6o0|b8qdc0|1cm000|7k800|9q000|9d1c0|9d1c0|9d1c0|2o7w0|6bs00|2txg0|7k800|91xc0|9b9g0|1sqk0|2inw0|51k40|a2yo0|8n400|9q000|902o0|fx91c0|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120|-180',
    'offsetIndices': '01010101010101210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Bratislava',
    'untils': '-s0e080|7ves0|a4yw0|7x6o0|asw00|7x6o0|b8qdc0|1cm000|7k800|9q000|9d1c0|9d1c0|9d1c0|9d1c0|b5uo0|7vc00|2vs40|4bk00|2vmk0|8n400|a2yo0|8n400|9o5c0|91xc0|fe6000|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120|0',
    'offsetIndices': '01010101010101010201010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Brussels',
    'untils': '-ss5uo0|rrx80|7vc00|a4yw0|7x6o0|asw00|7x6o0|2wh40|5omo0|b5uo0|6uao0|cyo00|7ayo0|bko00|7rmo0|a2yo0|a2yo0|8n400|902o0|9q000|9d1c0|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|90b00|a2yo0|8n400|9q000|902o0|a2yo0|8n400|9d1c0|9d1c0|902o0|a2yo0|9d1c0|9d1c0|902o0|9q000|a2yo0|8n400|9d1c0|9d1c0|902o0|9q000|a2yo0|b5uo0|51hc0|4deo0|1a36k0|7k800|9q000|9d1c0|8l9c0|a4tc0|8l9c0|clpc0|79400|fwu800|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '0121212101010101010101010101010101010101010101010101212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Bucharest',
    'untils': '-k29zi0|fj8m0|6w5c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|kp0dc0|6h980|9q000|905g0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9cvs0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9cyk0|9d440|9cyk0|9q2s0|ast80|7xhs0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-104.4|-120|-180',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Budapest',
    'untils': '-s0e080|7ves0|a4yw0|7x6o0|a31g0|8n180|autg0|bgvw0|b5jeg0|th9k0|7k800|9q000|9d1c0|9d1c0|awd00|9ew00|7q0c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9q000|902o0|a4tc0|9q000|1va2g0|6u7w0|bxpg0|6u7w0|cjxg0|64ak0|cluw0|64g40|br3ek0|905g0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Busingen',
    'untils': '-eyh6o0|7x6o0|asw00|7x6o0|k2zus0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Chisinau',
    'untils': '-r2p1bo|70f1to|fj8m0|6w5c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|geqo0|ha580|oc8g0|7k800|9q000|9d1c0|7cl00|j3pbw0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|25p80|7kdk0|9d1c0|9d1c0|9cvs0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|ast80|7xf00|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-115|-104.4|-120|-180|-60|-240',
    'offsetIndices': '012323232323232323232424235353535353535353535323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Europe/Copenhagen',
    'untils': '-rzo2w0|75bw0|cbs2w0|1aco80|7k800|9q000|9d1c0|9d1c0|9d1c0|6y000|dbmo0|6bs00|clpc0|51hc0|e1k00|4oio0|giutc0|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Dublin',
    'untils': '-rzcmlr|6uao0|9pytr|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|3g8800|8a5c0|bvs00|8n400|a2yo0|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|902o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|5reo0|1xhuo0|779c0|bitc0|779c0|bitc0|779c0|bitc0|779c0|bitc0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x3w0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '25.35|-34.65|0|-60',
    'offsetIndices': '01232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Europe/Gibraltar',
    'untils': '-rzcns0|6uao0|9q000|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|mbmk0|51hc0|c8qo0|6hc00|c8qo0|6uao0|bvs00|8n400|a4tc0|5clc0|4bms0|9q000|902o0|8a5c0|1frw0|64dc0|4bms0|6uao0|bvs00|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|d0tp80|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '010101010101010101010101010101010101010101010101012121212121010121010101010101010101012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Guernsey',
    'untils': '-rzcns0|6uao0|9q000|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|mbmk0|51hc0|c8qo0|6hc00|c8qo0|6uao0|bvs00|8n400|a4tc0|5clc0|4bms0|9q000|902o0|8a5c0|1frw0|64dc0|4bms0|6uao0|bvs00|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|902o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|5reo0|1xhuo0|779c0|bitc0|779c0|bitc0|779c0|bitc0|779c0|bitc0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x3w0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010121212121210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Helsinki',
    'untils': '-peghyd|ax3tqd|9gqo0|k31s80|9d1c0|9d1c0|9d1c0|9d440|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-99.8167|-120|-180',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Isle_of_Man',
    'untils': '-rzcns0|6uao0|9q000|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|mbmk0|51hc0|c8qo0|6hc00|c8qo0|6uao0|bvs00|8n400|a4tc0|5clc0|4bms0|9q000|902o0|8a5c0|1frw0|64dc0|4bms0|6uao0|bvs00|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|902o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|5reo0|1xhuo0|779c0|bitc0|779c0|bitc0|779c0|bitc0|779c0|bitc0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x3w0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010121212121210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Istanbul',
    'untils': '-ux9xew|2wvx6w|7v980|1tjc40|aunw0|88dg0|9et80|8yas0|a2vw0|tzpg0|79180|awo40|7v980|7p4040|4zjw0|2vs40|f4d80|9vms0|1u5ek0|c5440|69uk0|acas0|8n180|a31g0|8n180|9q2s0|8zzw0|a31g0|8zzw0|a31g0|8n180|5md9g0|o9zw0|a6qs0|75bw0|4iwyw0|7x6o0|7kas0|b5rw0|75hg0|bkl80|77c40|biqk0|7x9g0|a2vw0|8n6s0|4iqc0|2nkw80|38l80|kdes0|8qtc0|8a5c0|9ew00|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|902o0|9q000|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7kdk0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7m2o0|b4000|7k800|b5uo0|7x6o0|asw00|7z1c0|ar1c0|7x6o0|bitc0|779c0|8fe80|Infinity',
    'offsets': '-116.9333|-120|-180|-240',
    'offsetIndices': '0121212121212121212121212121212121212121212121223212121212121212121212121212121212121212121212121212121212121212122'
  }, {
    'id': 'Europe/Jersey',
    'untils': '-rzcns0|6uao0|9q000|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|mbmk0|51hc0|c8qo0|6hc00|c8qo0|6uao0|bvs00|8n400|a4tc0|5clc0|4bms0|9q000|902o0|8a5c0|1frw0|64dc0|4bms0|6uao0|bvs00|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|902o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|5reo0|1xhuo0|779c0|bitc0|779c0|bitc0|779c0|bitc0|779c0|bitc0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x3w0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010121212121210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Kaliningrad',
    'untils': '-s0e080|7ves0|a4yw0|7x6o0|asw00|7x6o0|b8qdc0|1cm000|7k800|9q000|9d1c0|9d1c0|9d1c0|el00|z6o0|9kd80|82tg0|i9avw0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-60|-120|-180|-240',
    'offsetIndices': '01010101010101121232323232323232322121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Kiev',
    'untils': '-nu11ng|37a03g|5vd6k0|kzv40|7k800|9q000|1oyg0|jipzs0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|51ek0|neqw0|9cvs0|9cyk0|9d440|9cyk0|9d440|9cyk0|9dcg0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-122.0667|-120|-180|-60|-240',
    'offsetIndices': '0121313242424242424242424242121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Kirov',
    'untils': '-qcx400|5q5zo0|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|iq5g0|9d1c0|9q000|9d1c0|s3400|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-198.8|-180|-240|-300',
    'offsetIndices': '01232323232323232321212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Lisbon',
    'untils': '-u9rhc0|2bufw0|6zxg0|66580|bq800|73k00|bodc0|71pc0|bq800|73k00|bq800|71pc0|bq800|1b2g00|9b6o0|saio0|8n400|9q000|902o0|a2yo0|902o0|a2yo0|8n400|st1c0|8n400|9d1c0|9d1c0|sg2o0|9d1c0|902o0|9q000|a2yo0|8n400|9d1c0|9d1c0|902o0|9q000|a2yo0|b5uo0|51hc0|bitc0|9d1c0|9ew00|88ao0|25p80|5reo0|3lpg0|779c0|1sqk0|6uao0|38qs0|6uao0|25p80|6hc00|38qs0|6uao0|25p80|6hc00|38qs0|8a5c0|9d1c0|9d9o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|s3400|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|5gyl40|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d440|9cyk0|9d440|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9cyk0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '36.75|0|-60|-120',
    'offsetIndices': '012121212121212121212121212121212121212121212321232123212321212121212121212121212121212121212121212121212121212121212121212121212122323232212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Ljubljana',
    'untils': '-ezayw0|swz00|7k800|9q000|9d1c0|9d1c0|b7pc0|6qlc0|jl1hc0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/London',
    'untils': '-rzcns0|6uao0|9q000|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|mbmk0|51hc0|c8qo0|6hc00|c8qo0|6uao0|bvs00|8n400|a4tc0|5clc0|4bms0|9q000|902o0|8a5c0|1frw0|64dc0|4bms0|6uao0|bvs00|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|902o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|5reo0|1xhuo0|779c0|bitc0|779c0|bitc0|779c0|bitc0|779c0|bitc0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x3w0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010121212121210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Luxembourg',
    'untils': '-y89550|68l290|75hg0|ast80|796s0|at1k0|7x6o0|3lh40|4zmo0|b6300|6u2c0|cytk0|7at40|bktk0|7rh40|a31g0|a2vw0|8n9k0|8zx40|9q2s0|9et80|9b9g0|a2vw0|8n6s0|9px80|905g0|a2vw0|905g0|a2vw0|8ncc0|9q000|902o0|a2yo0|8n400|9d1c0|9d1c0|902o0|a2yo0|9d1c0|9d1c0|902o0|9q000|a2yo0|8n400|9d1c0|9d1c0|902o0|9q000|a2yo0|b5uo0|51hc0|42ao0|1aeak0|7k800|9q000|9d1c0|8n400|a2yo0|8l9c0|clpc0|79400|fwu800|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-24.6|-60|-120|0',
    'offsetIndices': '0121212131313131313131313131313131313131313131313131212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Madrid',
    'untils': '-qzlus0|8yas0|9cyk0|9eys0|2d2vw0|8sqs0|ssyk0|8n6s0|9px80|905g0|a2yo0|902o0|a2vw0|8n6s0|40lh80|5k2s0|9cyk0|1frw0|7z1c0|j1c80|8a2k0|13yt80|685g0|brzw0|8n6s0|a2vw0|8n6s0|a2vw0|8n6s0|a2vw0|8n6s0|1clx80|7x9g0|cswik0|905g0|9px80|905g0|8zzw0|9d440|9px80|905g0|9q5k0|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '010101010101010101210121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Malta',
    'untils': '-rymys0|64ak0|9d440|9et80|88dg0|aunw0|7ig40|b5rw0|8n6s0|9cyk0|aau2s0|18r9k0|7k800|9q000|9b6o0|8n400|a4tc0|8j940|9f1k0|afxc0|89zs0|afxc0|7kdk0|b5uo0|979rs0|6h980|cls40|64dc0|clpc0|64dc0|cyo00|64dc0|clpc0|64dc0|c8qo0|6hc00|clpc0|6hc00|9b6o0|9d1c0|ahs00|7m2o0|b45k0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|a4w40|8y580|9q2s0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Mariehamn',
    'untils': '-peghyd|ax3tqd|9gqo0|k31s80|9d1c0|9d1c0|9d1c0|9d440|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-99.8167|-120|-180',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Minsk',
    'untils': '-nu113c|379zjc|5r1mk0|pbf40|7k800|9q000|9d1c0|4oac0|j6dmk0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|sg2o0|9d440|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|Infinity',
    'offsets': '-110|-120|-180|-60|-240',
    'offsetIndices': '01213131242424242424242424221212121212121212121212121212121212121212'
  }, {
    'id': 'Europe/Monaco',
    'untils': '-uozn3l|2qx1nl|5luo0|8y800|a4tc0|7vc00|auqo0|7idc0|b7pc0|6sg00|cyo00|7ayo0|bko00|7rmo0|a2yo0|bvs00|6uao0|902o0|9q000|9d1c0|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|902o0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|9d1c0|9d1c0|902o0|a2yo0|9d1c0|9d1c0|902o0|9q000|a2yo0|8n400|9d1c0|9d1c0|902o0|9q000|a2yo0|b5uo0|51po0|mdbo0|7x3w0|7x9g0|c8w80|7k800|9q000|9d1c0|9nzs0|922w0|8l9c0|fxlx80|9cyk0|9q5k0|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-9.35|0|-60|-120',
    'offsetIndices': '01212121212121212121212121212121212121212121212121232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Europe/Moscow',
    'untils': '-rx5dmh|ipzua|97hc0|7yyk0|5i840|d9p80|1jwk7|2cvk0|s8o00|1qvw0|8fpc0|1jms0|is040|412as0|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d440|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-150.2833|-151.3167|-211.3167|-271.3167|-240|-180|-300|-120',
    'offsetIndices': '012132345464575454545454545454545455754545454545454545454545454545454545454545'
  }, {
    'id': 'Europe/Nicosia',
    'untils': '-p4bq6g|rvhxyg|9cyk0|b42s0|7nuk0|8yas0|8zzw0|9q2s0|9et80|9b9g0|9cyk0|9q2s0|8zzw0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|at4c0|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-133.4667|-120|-180',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Oslo',
    'untils': '-rzayo0|6qfs0|cgcqo0|15tsc0|7k800|9q000|9d1c0|9d1c0|9d1c0|9d1c0|70q5c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|b5uo0|7k800|7law00|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Paris',
    'untils': '-uozn1x|2qx1lx|5luo0|8y800|a4tc0|7vc00|auqo0|7idc0|b7pc0|6sg00|cyo00|7ayo0|bko00|7rmo0|a2yo0|bvs00|6uao0|902o0|9q000|9d1c0|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|902o0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|9d1c0|9d1c0|902o0|a2yo0|9d1c0|9d1c0|902o0|9q000|a2yo0|8n400|9d1c0|9d1c0|902o0|9q000|a2yo0|b5uo0|51po0|5p8w0|18rcc0|7k800|9q000|9d1c0|7efo0|29k40|922w0|8l9c0|fxlx80|9cyk0|9q5k0|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-9.35|0|-60|-120',
    'offsetIndices': '0121212121212121212121212121212121212121212121212123232332323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Europe/Podgorica',
    'untils': '-ezayw0|swz00|7k800|9q000|9d1c0|9d1c0|b7pc0|6qlc0|jl1hc0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Prague',
    'untils': '-s0e080|7ves0|a4yw0|7x6o0|asw00|7x6o0|b8qdc0|1cm000|7k800|9q000|9d1c0|9d1c0|9d1c0|9d1c0|b5uo0|7vc00|2vs40|4bk00|2vmk0|8n400|a2yo0|8n400|9o5c0|91xc0|fe6000|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120|0',
    'offsetIndices': '01010101010101010201010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Riga',
    'untils': '-qznlky|7x6o0|a4tc0|2mg00|3myns0|7fhlky|gz180|p5v40|7k800|9q000|9d1c0|9d1c0|k7s0|j14ns0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d440|asw00|7x6o0|asw00|7x6o0|b5uo0|qaao0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-96.5667|-156.5667|-120|-180|-60|-240',
    'offsetIndices': '010102324242435353535353535353323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Europe/Rome',
    'untils': '-rymys0|64ak0|9d440|9et80|88dg0|aunw0|7ig40|b5rw0|8n6s0|9cyk0|aau2s0|18r9k0|7k800|9q000|9d1c0|8l9c0|a4tc0|8j940|9f1k0|afxc0|89zs0|afxc0|7kdk0|b5uo0|979rs0|6h980|cls40|64dc0|clpc0|64dc0|cyo00|64dc0|clpc0|64dc0|c8qo0|6hc00|clpc0|6hc00|clpc0|64dc0|c8qo0|6hc00|clpc0|64dc0|clpc0|64dc0|c8qo0|6hc00|clpc0|6hc00|c8qo0|6hc00|9q5k0|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Samara',
    'untils': '-qcx400|5q5zo0|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|iq5g0|9d1c0|9q000|jt1g0|89zs0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|j3440|7k800|Infinity',
    'offsets': '-200.3333|-180|-240|-300',
    'offsetIndices': '0123232323232323232121232323232323232323232323232323232323212'
  }, {
    'id': 'Europe/San_Marino',
    'untils': '-rymys0|64ak0|9d440|9et80|88dg0|aunw0|7ig40|b5rw0|8n6s0|9cyk0|aau2s0|18r9k0|7k800|9q000|9d1c0|8l9c0|a4tc0|8j940|9f1k0|afxc0|89zs0|afxc0|7kdk0|b5uo0|979rs0|6h980|cls40|64dc0|clpc0|64dc0|cyo00|64dc0|clpc0|64dc0|c8qo0|6hc00|clpc0|6hc00|clpc0|64dc0|c8qo0|6hc00|clpc0|64dc0|clpc0|64dc0|c8qo0|6hc00|clpc0|6hc00|c8qo0|6hc00|9q5k0|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Sarajevo',
    'untils': '-ezayw0|swz00|7k800|9q000|9d1c0|9d1c0|b7pc0|6qlc0|jl1hc0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Saratov',
    'untils': '-qcx400|5q5zo0|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|iq5g0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|s3400|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|13m040|Infinity',
    'offsets': '-184.3|-180|-240|-300',
    'offsetIndices': '012323232323232321212121212121212121212121212121212121212121212'
  }, {
    'id': 'Europe/Simferopol',
    'untils': '-nu12ao|37a0qo|5xiyk0|iu340|7k800|9q000|9d1c0|iac0|jajmk0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|eeio0|wrjw0|9cyk0|9d440|9cyk0|9d440|1sqk0|7k580|9d440|9cyk0|9q2s0|at4c0|7x9g0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x3w0|asqg0|Infinity',
    'offsets': '-136|-120|-180|-60|-240',
    'offsetIndices': '012131312424242424242424242121212424242212121212121212121212121212121212142'
  }, {
    'id': 'Europe/Skopje',
    'untils': '-ezayw0|swz00|7k800|9q000|9d1c0|9d1c0|b7pc0|6qlc0|jl1hc0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Sofia',
    'untils': '-e6dzw0|7k800|9q000|9d1c0|9d1c0|9d440|hqq240|9eys0|9o2k0|92040|9o2k0|90880|9pug0|90b00|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9cvs0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|ast80|7xhs0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-120|-60|-180',
    'offsetIndices': '01010102020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020'
  }, {
    'id': 'Europe/Stockholm',
    'untils': '-rzo2w0|75hg0|x5bew0|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Tallinn',
    'untils': '-r3exx0|3re10|7x6o0|et6g0|ygov0|a1zgd0|ktx80|l94g0|7k800|9q000|9d1c0|8uac0|j27mk0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asys0|7x6o0|b5uo0|19dc00|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-99|-60|-120|-180|-240',
    'offsetIndices': '012102321212343434343434343433232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Europe/Tirane',
    'untils': '-t85vo8|dt2gw8|18pew0|7k800|m800|g7ot40|7rjw0|autg0|7x3w0|ayis0|7x3w0|b5xg0|7k580|b42s0|7lzw0|b42s0|7lzw0|b42s0|7x3w0|ahus0|7x3w0|b5xg0|7x3w0|a4w40|8jbw0|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-79.3333|-60|-120',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Tiraspol',
    'untils': '-r2p1bo|70f1to|fj8m0|6w5c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|geqo0|ha580|oc8g0|7k800|9q000|9d1c0|7cl00|j3pbw0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|25p80|7kdk0|9d1c0|9d1c0|9cvs0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|ast80|7xf00|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-115|-104.4|-120|-180|-60|-240',
    'offsetIndices': '012323232323232323232424235353535353535353535323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Europe/Ulyanovsk',
    'untils': '-qcx400|5q5zo0|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|iq5g0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|qnc40|Infinity',
    'offsets': '-193.6|-180|-240|-300|-120',
    'offsetIndices': '01232323232323232321214121212121212121212121212121212121212121212'
  }, {
    'id': 'Europe/Uzhgorod',
    'untils': '-fizzw0|1cm000|7k800|9q000|9d1c0|al900|cnms0|int140|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|eeio0|e1sc0|iprk0|9cyk0|9d440|9cyk0|9d440|9cyk0|9dcg0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120|-180|-240',
    'offsetIndices': '010101023232323232323232320121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Vaduz',
    'untils': '-eyh6o0|7x6o0|asw00|7x6o0|k2zus0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Vatican',
    'untils': '-rymys0|64ak0|9d440|9et80|88dg0|aunw0|7ig40|b5rw0|8n6s0|9cyk0|aau2s0|18r9k0|7k800|9q000|9d1c0|8l9c0|a4tc0|8j940|9f1k0|afxc0|89zs0|afxc0|7kdk0|b5uo0|979rs0|6h980|cls40|64dc0|clpc0|64dc0|cyo00|64dc0|clpc0|64dc0|c8qo0|6hc00|clpc0|6hc00|clpc0|64dc0|c8qo0|6hc00|clpc0|64dc0|clpc0|64dc0|c8qo0|6hc00|clpc0|6hc00|c8qo0|6hc00|9q5k0|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Vienna',
    'untils': '-s0e080|7ves0|a4yw0|7x6o0|asw00|7x6o0|t6000|8a5c0|a7a800|1cm000|7k800|9q000|9d1c0|9d1c0|9d1c0|iio0|ivmo0|91xc0|9b6o0|9d1c0|a2yo0|8n400|gfyyg0|8zzw0|9d9o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Vilnius',
    'untils': '-rns980|1g224o|e75nc|4kqk0|acbs40|gpp40|pits0|7k800|9q000|9d1c0|65zo0|j4vx80|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x9g0|asw00|7x6o0|b5uo0|1s3eo0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-84|-95.6|-60|-120|-180|-240',
    'offsetIndices': '012324323234545454545454545443434343434343434332334343434343434343434343434343434343434343434343434343434343434343434343'
  }, {
    'id': 'Europe/Volgograd',
    'untils': '-q3cw84|5glrw4|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|iq5g0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|s3400|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|239c40|Infinity',
    'offsets': '-177.6667|-180|-240|-300',
    'offsetIndices': '012323232323232321212121212121212121212121212121212121212121212'
  }, {
    'id': 'Europe/Warsaw',
    'untils': '-se9yk0|dvyc0|7ves0|a4yw0|7x6o0|asw00|7x6o0|aunw0|7x6o0|1evbs0|9fcwc0|18cao0|7k800|9q000|9d1c0|9gnw0|an980|9kd80|8fs40|922w0|ar1c0|7x6o0|a2yo0|8n400|9q000|902o0|4013w0|64dc0|9d1c0|9d1c0|clpc0|6hc00|9d1c0|9d1c0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|clpc0|64dc0|6j4tc0|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-84|-60|-120|-180',
    'offsetIndices': '012121223212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Zagreb',
    'untils': '-ezayw0|swz00|7k800|9q000|9d1c0|9d1c0|b7pc0|6qlc0|jl1hc0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Zaporozhye',
    'untils': '-nu12hc|37a0xc|5u1180|mc0g0|7k800|9q000|12qg0|jjc7s0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9cvs0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9dcg0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-140|-120|-180|-60|-240',
    'offsetIndices': '01213132424242424242424242422121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Zurich',
    'untils': '-eyh6o0|7x6o0|asw00|7x6o0|k2zus0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'GB-Eire',
    'untils': '-rzcns0|6uao0|9q000|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|mbmk0|51hc0|c8qo0|6hc00|c8qo0|6uao0|bvs00|8n400|a4tc0|5clc0|4bms0|9q000|902o0|8a5c0|1frw0|64dc0|4bms0|6uao0|bvs00|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|902o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|5reo0|1xhuo0|779c0|bitc0|779c0|bitc0|779c0|bitc0|779c0|bitc0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x3w0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010121212121210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'GB',
    'untils': '-rzcns0|6uao0|9q000|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|mbmk0|51hc0|c8qo0|6hc00|c8qo0|6uao0|bvs00|8n400|a4tc0|5clc0|4bms0|9q000|902o0|8a5c0|1frw0|64dc0|4bms0|6uao0|bvs00|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|902o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|5reo0|1xhuo0|779c0|bitc0|779c0|bitc0|779c0|bitc0|779c0|bitc0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x3w0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010121212121210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'GMT-0',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'GMT',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'GMT+0',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'GMT0',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Greenwich',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Hongkong',
    'untils': '-y0i0s0|j44dk0|5k000|4d4y0|2195i0|7x3w0|bj320|6uao0|bvs00|7x6o0|9d1c0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|ast80|77c40|biqk0|77c40|bvp80|6udg0|bvp80|77c40|biqk0|77c40|biqk0|77c40|biqk0|77c40|bvp80|6udg0|bvp80|6udg0|bvp80|77c40|biqk0|77c40|biqk0|8n6s0|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|3lpg0|f4d80|9d440|9cyk0|9d440|9cyk0|1c9440|8a2k0|Infinity',
    'offsets': '-456.7|-480|-540|-510',
    'offsetIndices': '0123212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'HST',
    'untils': 'Infinity',
    'offsets': '600',
    'offsetIndices': '0'
  }, {
    'id': 'Iceland',
    'untils': '-wcwx9c|4rpd9c|ci2s0|69uk0|du840|4xp80|du840|p7bw0|4w040|9bdzw0|9d6w0|64g40|cyl80|64dc0|clpc0|6hc00|bvs00|6uao0|bvs00|6uao0|bvs00|6uao0|c8qo0|6hc00|c8qo0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|7x6o0|afxc0|8a5c0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|8a5c0|Infinity',
    'offsets': '88|60|0',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'Indian/Antananarivo',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Indian/Chagos',
    'untils': '-wvpc2s|1ag64us|Infinity',
    'offsets': '-289.6667|-300|-360',
    'offsetIndices': '012'
  }, {
    'id': 'Indian/Christmas',
    'untils': 'Infinity',
    'offsets': '-420',
    'offsetIndices': '0'
  }, {
    'id': 'Indian/Cocos',
    'untils': 'Infinity',
    'offsets': '-390',
    'offsetIndices': '0'
  }, {
    'id': 'Indian/Comoro',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Indian/Kerguelen',
    'untils': '-afrs00|Infinity',
    'offsets': '0|-300',
    'offsetIndices': '01'
  }, {
    'id': 'Indian/Mahe',
    'untils': '-x6pjlo|Infinity',
    'offsets': '-221.8|-240',
    'offsetIndices': '01'
  }, {
    'id': 'Indian/Maldives',
    'untils': '-57x6y0|Infinity',
    'offsets': '-294|-300',
    'offsetIndices': '01'
  }, {
    'id': 'Indian/Mauritius',
    'untils': '-wvp9bc|13jnu7c|8bx80|dd0wc0|7x3w0|Infinity',
    'offsets': '-230|-240|-300',
    'offsetIndices': '012121'
  }, {
    'id': 'Indian/Mayotte',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Indian/Reunion',
    'untils': '-uks29s|Infinity',
    'offsets': '-221.8667|-240',
    'offsetIndices': '01'
  }, {
    'id': 'Iran',
    'untils': '-s6m6uw|fnolc0|gm3h4w|777y0|b07w0|3pes0|42c20|9cyk0|9gtg0|9kd80|5ja5g0|7avw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|1av440|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|Infinity',
    'offsets': '-205.7333|-210|-240|-300|-270',
    'offsetIndices': '00123214141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141'
  }, {
    'id': 'Israel',
    'untils': '-r50eig|bp54yg|19f3w0|7rv00|b02c0|7tk40|b07w0|8jhg0|a8lg0|8jhg0|a8ac0|t9s40|56vs0|35700|9b3w0|9gtg0|8jbw0|7tmw0|a6ig0|biyw0|8a5c0|9d1c0|902o0|7x6o0|e1eg0|4ofw0|dzxo0|4q500|doo40|64iw0|auqo0|7i500|8rfms0|51ek0|9q2s0|6u7w0|2khpg0|25s00|1weyo0|5reo0|bxmo0|7x3w0|cls40|5rbw0|bbhg0|7rjw0|asys0|7k580|c8tg0|6h980|ag040|7x3w0|asys0|8a2k0|asys0|8a2k0|ap9g0|80t80|ap9g0|7nuk0|b2840|80t80|9zc40|9iik0|9kis0|93p80|9mdg0|8qqk0|apf00|7x3w0|biw40|8zx40|9io40|8n180|9kis0|9vh80|8ulg0|9px80|9mdg0|8n180|9tuw0|9tmk0|8wg40|9gnw0|99es0|8qqk0|9zc40|9tmk0|8wg40|9gnw0|99es0|8qqk0|acas0|9gnw0|99es0|93p80|9mdg0|awik0|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|Infinity',
    'offsets': '-140.6667|-120|-180|-240',
    'offsetIndices': '012121212121321212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Jamaica',
    'untils': '-u85og2|wbl182|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|Infinity',
    'offsets': '307.1667|300|240',
    'offsetIndices': '0121212121212121212121'
  }, {
    'id': 'Japan',
    'untils': '-bb4900|6uao0|afxc0|8a5c0|c8qo0|6hc00|c8qo0|6hc00|Infinity',
    'offsets': '-540|-600',
    'offsetIndices': '010101010'
  }, {
    'id': 'Kwajalein',
    'untils': '-h817w0|27sas0|1hjus0|ddxug0|cgv6k0|Infinity',
    'offsets': '-660|-600|-540|720|-720',
    'offsetIndices': '012034'
  }, {
    'id': 'Libya',
    'untils': '-q3gfrw|gl6ajw|422c0|xado0|4bbo0|wrpg0|4s580|1kdpg0|c05bw0|4mqs0|9et80|9d440|9et80|9eys0|9et80|9mdg0|95jw0|9io40|9cyk0|99es0|9et80|9eys0|9et80|9d440|9et80|b2840|3cf3w0|9kis0|9et80|7vqyw0|75eo0|asw00|Infinity',
    'offsets': '-52.7333|-60|-120',
    'offsetIndices': '012121212121212121212121212122122'
  }, {
    'id': 'MET',
    'untils': '-s0e080|7ves0|a4yw0|7x6o0|asw00|7x6o0|b8qdc0|1cm000|7k800|9q000|9d1c0|9d1c0|9d1c0|8l9c0|ggp1c0|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Mexico/BajaNorte',
    'untils': '-p1u1s0|11jrw0|1sns00|1sgdc0|71s40|9cyk0|5iidg0|1q6700|4lfk0|190g40|eluk0|2r4o80|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|84qys0|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|77c40|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '468.0667|420|480',
    'offsetIndices': '012121211212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'Mexico/BajaSur',
    'untils': '-p1u4k0|2u7jw0|1sgdc0|8n400|7thc0|9eys0|591h80|3ie2s0|axvpg0|dpgw40|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|Infinity',
    'offsets': '425.6667|420|360|480',
    'offsetIndices': '0121212131212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Mexico/General',
    'untils': '-p1u4k0|2u7jw0|1sgdc0|8n400|7thc0|9eys0|3knek0|776k0|rf440|5t6k0|1evk40|71mk0|30p1g0|8n180|nufxo0|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|Infinity',
    'offsets': '396.6|420|360|300',
    'offsetIndices': '012121232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'MST',
    'untils': 'Infinity',
    'offsets': '420',
    'offsetIndices': '0'
  }, {
    'id': 'MST7MDT',
    'untils': '-r0epo0|ast80|7x9g0|ast80|bmtus0|1tz5k0|2dvo0|b9gdg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '420|360',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Navajo',
    'untils': '-r0epo0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|2vmk0|ataw40|1tz5k0|2dvo0|a7n9g0|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '420|360',
    'offsetIndices': '01010101011010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'NZ-CHAT',
    'untils': '-ciya10|f1tq90|5reo0|clpc0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|b5uo0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|Infinity',
    'offsets': '-735|-765|-825',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'NZ',
    'untils': '-m01p20|64ak0|biw40|7x5a0|asxe0|7x5a0|asxe0|7x5a0|asxe0|8a3y0|afyq0|8a3y0|afyq0|afvy0|7x820|asum0|7x820|asum0|7x820|asum0|7x820|asum0|7x820|b5ta0|7k9e0|b5ta0|7x820|hsl2m0|5reo0|clpc0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|b5uo0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|Infinity',
    'offsets': '-690|-750|-720|-780',
    'offsetIndices': '01020202020202020202020202023232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'Pacific/Apia',
    'untils': '-usiiv4|kcrmt4|vp3la0|9odo0|902o0|4zbk0|4qog0|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|Infinity',
    'offsets': '686.9333|690|660|600|-840|-780',
    'offsetIndices': '01232345454545454545454545454545454545454545454545454545454'
  }, {
    'id': 'Pacific/Auckland',
    'untils': '-m01p20|64ak0|biw40|7x5a0|asxe0|7x5a0|asxe0|7x5a0|asxe0|8a3y0|afyq0|8a3y0|afyq0|afvy0|7x820|asum0|7x820|asum0|7x820|asum0|7x820|asum0|7x820|b5ta0|7k9e0|b5ta0|7x820|hsl2m0|5reo0|clpc0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|b5uo0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|Infinity',
    'offsets': '-690|-750|-720|-780',
    'offsetIndices': '01020202020202020202020202023232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'Pacific/Bougainville',
    'untils': '-ecsh40|1n05g0|1071c40|Infinity',
    'offsets': '-600|-540|-660',
    'offsetIndices': '0102'
  }, {
    'id': 'Pacific/Chatham',
    'untils': '-ciya10|f1tq90|5reo0|clpc0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|b5uo0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|Infinity',
    'offsets': '-735|-765|-825',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'Pacific/Chuuk',
    'untils': '-su4zs0|29hes0|bkenw0|29fk40|Infinity',
    'offsets': '-600|-540',
    'offsetIndices': '01010'
  }, {
    'id': 'Pacific/Easter',
    'untils': '-jhfaew|ivmeuw|7k580|c8tg0|6h980|a31g0|7x3w0|asys0|7x3w0|b5xg0|7k580|ag040|8a2k0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|iq2o0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|9cyk0|9d440|7x3w0|asys0|7x3w0|b5xg0|7k580|9q2s0|8zzw0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|a31g0|9px80|9q2s0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|asys0|8zzw0|9q2s0|ast80|5eis0|cyl80|6hes0|c8nw0|6udg0|bvp80|6udg0|vonw0|4olg0|e1h80|4olg0|e1h80|4olg0|c8nw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|Infinity',
    'offsets': '437.4667|420|360|300',
    'offsetIndices': '012121212121212121212121212123232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'Pacific/Efate',
    'untils': '-u964i4|11f4ba4|9cyk0|awo40|7tek0|9q2s0|8zzw0|9q2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|64ak0|e1ms0|4ofw0|Infinity',
    'offsets': '-673.2667|-660|-720',
    'offsetIndices': '0121212121212121212121'
  }, {
    'id': 'Pacific/Enderbury',
    'untils': '535io0|7yiqk0|Infinity',
    'offsets': '720|660|-780',
    'offsetIndices': '012'
  }, {
    'id': 'Pacific/Fakaofo',
    'untils': 'lx0jw0|Infinity',
    'offsets': '660|-780',
    'offsetIndices': '01'
  }, {
    'id': 'Pacific/Fiji',
    'untils': '-sa2x4w|17bs00w|64dc0|cyo00|5reo0|53a5c0|64dc0|asw00|6uao0|bvs00|4oio0|e1k00|4oio0|eeio0|4bh80|erk40|3ylc0|erhc0|3ylc0|f4g00|3lmo0|f4g00|3lmo0|f4g00|3lmo0|fheo0|38o00|fheo0|3lmo0|fheo0|38o00|fheo0|38o00|fheo0|38o00|fheo0|38o00|fheo0|3lmo0|f4g00|3lmo0|fheo0|38o00|fheo0|38o00|fheo0|38o00|fheo0|38o00|fheo0|3lmo0|fheo0|38o00|fheo0|38o00|fheo0|38o00|fheo0|38o00|fheo0|3lmo0|f4g00|3lmo0|Infinity',
    'offsets': '-715.7333|-720|-780',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Pacific/Funafuti',
    'untils': 'Infinity',
    'offsets': '-720',
    'offsetIndices': '0'
  }, {
    'id': 'Pacific/Galapagos',
    'untils': '-kcr62o|spdryo|3lsas0|3jp80|Infinity',
    'offsets': '358.4|300|360',
    'offsetIndices': '01212'
  }, {
    'id': 'Pacific/Gambier',
    'untils': '-tvndoc|Infinity',
    'offsets': '539.8|540',
    'offsetIndices': '01'
  }, {
    'id': 'Pacific/Guadalcanal',
    'untils': '-tvowac|Infinity',
    'offsets': '-639.8|-660',
    'offsetIndices': '01'
  }, {
    'id': 'Pacific/Guam',
    'untils': '-en8eg0|1dl9g0|7s1k40|txp80|3frms0|qdrpo|7kgac|3ljw0|c8tg0|6u7w0|bvus0|6u7w0|16uo40|3ljw0|16aas0|4ivxo|cls2c|6h980|c65zw0|Infinity',
    'offsets': '-600|-540|-660',
    'offsetIndices': '01020202020202020200'
  }, {
    'id': 'Pacific/Honolulu',
    'untils': '-j50la0|13l00|4jvb00|1tyvu0|2e5e0|votg0|Infinity',
    'offsets': '630|570|600',
    'offsetIndices': '0101102'
  }, {
    'id': 'Pacific/Johnston',
    'untils': '-j50la0|13l00|4jvb00|1tyvu0|2e5e0|votg0|Infinity',
    'offsets': '630|570|600',
    'offsetIndices': '0101102'
  }, {
    'id': 'Pacific/Kiritimati',
    'untils': '535eyo|7yirhc|Infinity',
    'offsets': '640|600|-840',
    'offsetIndices': '012'
  }, {
    'id': 'Pacific/Kosrae',
    'untils': '-su52k0|29hhk0|9cmd40|27sas0|29fk40|cm2540|f9l3w0|Infinity',
    'offsets': '-660|-540|-600|-720',
    'offsetIndices': '01021030'
  }, {
    'id': 'Pacific/Kwajalein',
    'untils': '-h817w0|27sas0|1hjus0|ddxug0|cgv6k0|Infinity',
    'offsets': '-660|-600|-540|720|-720',
    'offsetIndices': '012034'
  }, {
    'id': 'Pacific/Majuro',
    'untils': '-su52k0|29hhk0|9cmd40|27sas0|1h6w40|deat40|Infinity',
    'offsets': '-660|-540|-600|-720',
    'offsetIndices': '0102103'
  }, {
    'id': 'Pacific/Marquesas',
    'untils': '-tvncu0|Infinity',
    'offsets': '558|570',
    'offsetIndices': '01'
  }, {
    'id': 'Pacific/Midway',
    'untils': '-usij20|Infinity',
    'offsets': '682.8|660',
    'offsetIndices': '01'
  }, {
    'id': 'Pacific/Nauru',
    'untils': '-pjxiws|ba66ys|1kwca0|hfzda0|Infinity',
    'offsets': '-667.6667|-690|-540|-720',
    'offsetIndices': '01213'
  }, {
    'id': 'Pacific/Niue',
    'untils': '-9wyz6o|ehcj4o|Infinity',
    'offsets': '680|690|660',
    'offsetIndices': '012'
  }, {
    'id': 'Pacific/Norfolk',
    'untils': '-9x0ps0|cfj8q0|6hc00|l6nk00|239aq0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-672|-690|-750|-660|-720',
    'offsetIndices': '012134343434343434343434343434343434343434'
  }, {
    'id': 'Pacific/Noumea',
    'untils': '-u9645o|ye0ixo|4dbw0|ecqs0|4f6k0|99p700|4oio0|Infinity',
    'offsets': '-665.8|-660|-720',
    'offsetIndices': '01212121'
  }, {
    'id': 'Pacific/Pago_Pago',
    'untils': '-usij20|Infinity',
    'offsets': '682.8|660',
    'offsetIndices': '01'
  }, {
    'id': 'Pacific/Palau',
    'untils': 'Infinity',
    'offsets': '-540',
    'offsetIndices': '0'
  }, {
    'id': 'Pacific/Pitcairn',
    'untils': 'es2cy0|Infinity',
    'offsets': '510|480',
    'offsetIndices': '01'
  }, {
    'id': 'Pacific/Pohnpei',
    'untils': '-su52k0|29hhk0|9cmd40|27sas0|29fk40|Infinity',
    'offsets': '-660|-540|-600',
    'offsetIndices': '010210'
  }, {
    'id': 'Pacific/Ponape',
    'untils': '-su52k0|29hhk0|9cmd40|27sas0|29fk40|Infinity',
    'offsets': '-660|-540|-600',
    'offsetIndices': '010210'
  }, {
    'id': 'Pacific/Port_Moresby',
    'untils': 'Infinity',
    'offsets': '-600',
    'offsetIndices': '0'
  }, {
    'id': 'Pacific/Rarotonga',
    'untils': '4mj960|5rbw0|c8s20|6ham0|c8s20|6ham0|c8s20|6u9a0|c8s20|6ham0|c8s20|6ham0|c8s20|6ham0|c8s20|6ham0|c8s20|6ham0|c8s20|6u9a0|c8s20|6ham0|c8s20|6ham0|c8s20|6ham0|Infinity',
    'offsets': '630|570|600',
    'offsetIndices': '012121212121212121212121212'
  }, {
    'id': 'Pacific/Saipan',
    'untils': '-en8eg0|1dl9g0|7s1k40|txp80|3frms0|qdrpo|7kgac|3ljw0|c8tg0|6u7w0|bvus0|6u7w0|16uo40|3ljw0|16aas0|4ivxo|cls2c|6h980|c65zw0|Infinity',
    'offsets': '-600|-540|-660',
    'offsetIndices': '01020202020202020200'
  }, {
    'id': 'Pacific/Samoa',
    'untils': '-usij20|Infinity',
    'offsets': '682.8|660',
    'offsetIndices': '01'
  }, {
    'id': 'Pacific/Tahiti',
    'untils': '-tvnayw|Infinity',
    'offsets': '598.2667|600',
    'offsetIndices': '01'
  }, {
    'id': 'Pacific/Tarawa',
    'untils': 'Infinity',
    'offsets': '-720',
    'offsetIndices': '0'
  }, {
    'id': 'Pacific/Tongatapu',
    'untils': '-f4vrlc|uo2edc|8fpc0|bvs00|4bh80|eelg0|4bh80|7pmis0|3lmo0|Infinity',
    'offsets': '-740|-780|-840',
    'offsetIndices': '0121212121'
  }, {
    'id': 'Pacific/Truk',
    'untils': '-su4zs0|29hes0|bkenw0|29fk40|Infinity',
    'offsets': '-600|-540',
    'offsetIndices': '01010'
  }, {
    'id': 'Pacific/Wake',
    'untils': 'Infinity',
    'offsets': '-720',
    'offsetIndices': '0'
  }, {
    'id': 'Pacific/Wallis',
    'untils': 'Infinity',
    'offsets': '-720',
    'offsetIndices': '0'
  }, {
    'id': 'Pacific/Yap',
    'untils': '-su4zs0|29hes0|bkenw0|29fk40|Infinity',
    'offsets': '-600|-540',
    'offsetIndices': '01010'
  }, {
    'id': 'Poland',
    'untils': '-se9yk0|dvyc0|7ves0|a4yw0|7x6o0|asw00|7x6o0|aunw0|7x6o0|1evbs0|9fcwc0|18cao0|7k800|9q000|9d1c0|9gnw0|an980|9kd80|8fs40|922w0|ar1c0|7x6o0|a2yo0|8n400|9q000|902o0|4013w0|64dc0|9d1c0|9d1c0|clpc0|6hc00|9d1c0|9d1c0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|clpc0|64dc0|6j4tc0|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-84|-60|-120|-180',
    'offsetIndices': '012121223212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Portugal',
    'untils': '-u9rhc0|2bufw0|6zxg0|66580|bq800|73k00|bodc0|71pc0|bq800|73k00|bq800|71pc0|bq800|1b2g00|9b6o0|saio0|8n400|9q000|902o0|a2yo0|902o0|a2yo0|8n400|st1c0|8n400|9d1c0|9d1c0|sg2o0|9d1c0|902o0|9q000|a2yo0|8n400|9d1c0|9d1c0|902o0|9q000|a2yo0|b5uo0|51hc0|bitc0|9d1c0|9ew00|88ao0|25p80|5reo0|3lpg0|779c0|1sqk0|6uao0|38qs0|6uao0|25p80|6hc00|38qs0|6uao0|25p80|6hc00|38qs0|8a5c0|9d1c0|9d9o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|s3400|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|5gyl40|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d440|9cyk0|9d440|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9cyk0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '36.75|0|-60|-120',
    'offsetIndices': '012121212121212121212121212121212121212121212321232123212321212121212121212121212121212121212121212121212121212121212121212121212122323232212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'PRC',
    'untils': '-qh00w0|8sl80|asbpg0|6w2k0|7ves0|bxjw0|4mqs0|1vduk0|d4as0|75bw0|a31g0|aaak0|9d440|7v980|awo40|1dx80|j9xpo0|6u7w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '01010101010101010101010101010'
  }, {
    'id': 'PST8PDT',
    'untils': '-r0emw0|ast80|7x9g0|ast80|bmtus0|1tz2s0|2dyg0|b9gdg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'ROC',
    'untils': '-gtzfk0|45slc0|c51c0|75bw0|a31g0|aaak0|9d440|7v980|awo40|7v980|awo40|7v980|awo40|7v980|7tk40|clmk0|7rpg0|b07w0|7rpg0|b07w0|7rpg0|9et80|9eys0|9et80|9d440|9et80|9d440|9et80|9d440|9et80|cjxg0|69uk0|ci2s0|69uk0|6its40|9et80|9d440|9et80|1yf9g0|4qak0|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '01010101010101010101010101010101010101010'
  }, {
    'id': 'ROK',
    'untils': '-w8966g|1yh18g|hkx5a0|1faao0|5cik0|ae5g0|8a2k0|ae5g0|8bx80|c8tg0|6h980|1bj6s0|l3aq0|6j3w0|d2g40|6u7w0|b5xg0|776k0|biw40|776k0|biw40|776k0|biw40|776k0|grs40|dfqxi0|7x6o0|asw00|7x6o0|Infinity',
    'offsets': '-507.8667|-510|-540|-600|-570',
    'offsetIndices': '012232323232141414141414123232'
  }, {
    'id': 'Singapore',
    'untils': '-xphpwd|eeb94d|4it32o|8n3jc|1v2p60|iy3o60|Infinity',
    'offsets': '-415.4167|-420|-440|-450|-540|-480',
    'offsetIndices': '0123435'
  }, {
    'id': 'Turkey',
    'untils': '-ux9xew|2wvx6w|7v980|1tjc40|aunw0|88dg0|9et80|8yas0|a2vw0|tzpg0|79180|awo40|7v980|7p4040|4zjw0|2vs40|f4d80|9vms0|1u5ek0|c5440|69uk0|acas0|8n180|a31g0|8n180|9q2s0|8zzw0|a31g0|8zzw0|a31g0|8n180|5md9g0|o9zw0|a6qs0|75bw0|4iwyw0|7x6o0|7kas0|b5rw0|75hg0|bkl80|77c40|biqk0|7x9g0|a2vw0|8n6s0|4iqc0|2nkw80|38l80|kdes0|8qtc0|8a5c0|9ew00|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|902o0|9q000|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7kdk0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7m2o0|b4000|7k800|b5uo0|7x6o0|asw00|7z1c0|ar1c0|7x6o0|bitc0|779c0|8fe80|Infinity',
    'offsets': '-116.9333|-120|-180|-240',
    'offsetIndices': '0121212121212121212121212121212121212121212121223212121212121212121212121212121212121212121212121212121212121212122'
  }, {
    'id': 'UCT',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Universal',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'US/Alaska',
    'untils': '-ek1qo0|1tyx80|2e400|b7yik0|12y080|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|1l940|7rs80|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '600|540|480',
    'offsetIndices': '011001010101010101010101010101010111212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'US/Aleutian',
    'untils': '-ek1nw0|1tyug0|2e6s0|b7yik0|12y080|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|1l940|7rs80|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '660|600|540',
    'offsetIndices': '011001010101010101010101010101010111212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'US/Arizona',
    'untils': '-r0epo0|ast80|7x9g0|ast80|bmtus0|zjedo|4olg0|9et80|bs6lmc|9cyk0|Infinity',
    'offsets': '420|360',
    'offsetIndices': '01010101010'
  }, {
    'id': 'US/Central',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bvus0|776k0|7kas0|b5rw0|9d440|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|7x9g0|dbjw0|8a840|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|6w840|1tz8c0|2dsw0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '01010101010101010101010101010101010101010101010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'US/East-Indiana',
    'untils': '-r0esg0|ast80|7x9g0|ast80|baw840|51ek0|6w840|1tz8c0|2dsw0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|19q7w0|asys0|5qonw0|9cyk0|9d440|9cyk0|ihslg0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '010101011010101010101010101010121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'US/Eastern',
    'untils': '-r0ev80|ast80|7x9g0|ast80|7x9g0|b5rw0|905g0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|6w840|1tzb40|2dq40|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '300|240',
    'offsetIndices': '01010101010101010101010101010101010101010101010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'US/Hawaii',
    'untils': '-j50la0|13l00|4jvb00|1tyvu0|2e5e0|votg0|Infinity',
    'offsets': '630|570|600',
    'offsetIndices': '0101102'
  }, {
    'id': 'US/Indiana-Starke',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|tj1g0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|7x3w0|asys0|7x3w0|asys0|9cyk0|9d440|9px80|9d440|9cyk0|9d440|s3180|1twas0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|7j5400|asw00|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '0101011010101010101010101010101010101010101010101010101010101010101010101010101010101010111010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'US/Michigan',
    'untils': '-xx8dyd|5eraud|dyeyk0|1tzb40|2dq40|1c9440|7x3w0|9rlbxo|71s2c|9d440|9cyk0|2cmdg0|9cyk0|3lpg0|f4d80|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '332.1833|360|300|240',
    'offsetIndices': '0123323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'US/Mountain',
    'untils': '-r0epo0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|2vmk0|ataw40|1tz5k0|2dvo0|a7n9g0|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '420|360',
    'offsetIndices': '01010101011010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'US/Pacific-New',
    'untils': '-r0emw0|ast80|7x9g0|ast80|bmtus0|1tz2s0|2dyg0|1a3c5o|f2iic|owao0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|902o0|9q000|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'US/Pacific',
    'untils': '-r0emw0|ast80|7x9g0|ast80|bmtus0|1tz2s0|2dyg0|1a3c5o|f2iic|owao0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|902o0|9q000|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'US/Samoa',
    'untils': '-usij20|Infinity',
    'offsets': '682.8|660',
    'offsetIndices': '01'
  }, {
    'id': 'UTC',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'W-SU',
    'untils': '-rx5dmh|ipzua|97hc0|7yyk0|5i840|d9p80|1jwk7|2cvk0|s8o00|1qvw0|8fpc0|1jms0|is040|412as0|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d440|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-150.2833|-151.3167|-211.3167|-271.3167|-240|-180|-300|-120',
    'offsetIndices': '012132345464575454545454545454545455754545454545454545454545454545454545454545'
  }, {
    'id': 'WET',
    'untils': '3s9ms0|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60',
    'offsetIndices': '010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Zulu',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }]
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _date = _interopRequireDefault(__webpack_require__(18));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var toMs = _date.default.dateToMilliseconds;

var DateAdapterCore = /*#__PURE__*/function () {
  function DateAdapterCore(source) {
    this._source = new Date(source.getTime ? source.getTime() : source);
  }

  var _proto = DateAdapterCore.prototype;

  _proto.result = function result() {
    return this._source;
  };

  _proto.getTimezoneOffset = function getTimezoneOffset() {
    var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

    var value = this._source.getTimezoneOffset();

    if (format === 'minute') {
      return value * toMs('minute');
    }

    return value;
  };

  _proto.getTime = function getTime() {
    return this._source.getTime();
  };

  _proto.setTime = function setTime(value) {
    this._source.setTime(value);

    return this;
  };

  _proto.addTime = function addTime(value) {
    this._source.setTime(this._source.getTime() + value);

    return this;
  };

  _proto.setMinutes = function setMinutes(value) {
    this._source.setMinutes(value);

    return this;
  };

  _proto.addMinutes = function addMinutes(value) {
    this._source.setMinutes(this._source.getMinutes() + value);

    return this;
  };

  _proto.subtractMinutes = function subtractMinutes(value) {
    this._source.setMinutes(this._source.getMinutes() - value);

    return this;
  };

  _createClass(DateAdapterCore, [{
    key: "source",
    get: function get() {
      // TODO
      return this._source;
    }
  }]);

  return DateAdapterCore;
}();

var DateAdapter = function DateAdapter(date) {
  return new DateAdapterCore(date);
};

var _default = DateAdapter;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = _default;

var _hide_callback = __webpack_require__(217);

function _default() {
  return _hide_callback.hideCallback.fire();
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.unsubscribeNodesDisposing = exports.subscribeNodesDisposing = void 0;

var _events_engine = _interopRequireDefault(__webpack_require__(5));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var REMOVE_EVENT_NAME = 'dxremove';

function nodesByEvent(event) {
  return event && [event.target, event.delegateTarget, event.relatedTarget, event.currentTarget].filter(function (node) {
    return !!node;
  });
}

var subscribeNodesDisposing = function subscribeNodesDisposing(event, callback) {
  _events_engine.default.one(nodesByEvent(event), REMOVE_EVENT_NAME, callback);
};

exports.subscribeNodesDisposing = subscribeNodesDisposing;

var unsubscribeNodesDisposing = function unsubscribeNodesDisposing(event, callback) {
  _events_engine.default.off(nodesByEvent(event), REMOVE_EVENT_NAME, callback);
};

exports.unsubscribeNodesDisposing = unsubscribeNodesDisposing;

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.disableIntl = disableIntl;
Object.defineProperty(exports, "message", {
  enumerable: true,
  get: function get() {
    return _message.default;
  }
});
Object.defineProperty(exports, "number", {
  enumerable: true,
  get: function get() {
    return _number.default;
  }
});
Object.defineProperty(exports, "date", {
  enumerable: true,
  get: function get() {
    return _date.default;
  }
});
exports.parseDate = exports.formatDate = exports.parseNumber = exports.formatNumber = exports.formatMessage = exports.loadMessages = exports.locale = void 0;

var _core = _interopRequireDefault(__webpack_require__(85));

var _message = _interopRequireDefault(__webpack_require__(10));

var _number = _interopRequireDefault(__webpack_require__(46));

var _date = _interopRequireDefault(__webpack_require__(33));

__webpack_require__(112);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @name localization
 */
var locale = _core.default.locale.bind(_core.default);

exports.locale = locale;

var loadMessages = _message.default.load.bind(_message.default);

exports.loadMessages = loadMessages;

var formatMessage = _message.default.format.bind(_message.default);

exports.formatMessage = formatMessage;

var formatNumber = _number.default.format.bind(_number.default);

exports.formatNumber = formatNumber;

var parseNumber = _number.default.parse.bind(_number.default);

exports.parseNumber = parseNumber;

var formatDate = _date.default.format.bind(_date.default);

exports.formatDate = formatDate;

var parseDate = _date.default.parse.bind(_date.default);

exports.parseDate = parseDate;

function disableIntl() {
  if (_number.default.engine() === 'intl') {
    _number.default.resetInjection();
  }

  if (_date.default.engine() === 'intl') {
    _date.default.resetInjection();
  }
}

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _jquery = _interopRequireDefault(__webpack_require__(56));

var _renderer_base = _interopRequireDefault(__webpack_require__(247));

var _use_jquery = _interopRequireDefault(__webpack_require__(87));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
var useJQuery = (0, _use_jquery.default)();

if (useJQuery) {
  _renderer_base.default.set(_jquery.default);
}

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _jquery = _interopRequireDefault(__webpack_require__(56));

var _use_jquery = _interopRequireDefault(__webpack_require__(87));

var _version = __webpack_require__(71);

var _iterator = __webpack_require__(3);

var _type = __webpack_require__(1);

var _index = __webpack_require__(8);

var _event_registrator = _interopRequireDefault(__webpack_require__(68));

var _hook_touch_props = _interopRequireDefault(__webpack_require__(248));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
var useJQuery = (0, _use_jquery.default)();

if (useJQuery) {
  if ((0, _version.compare)(_jquery.default.fn.jquery, [3]) < 0) {
    var POINTER_TYPE_MAP = {
      2: 'touch',
      3: 'pen',
      4: 'mouse'
    };
    (0, _iterator.each)(['MSPointerDown', 'MSPointerMove', 'MSPointerUp', 'MSPointerCancel', 'MSPointerOver', 'MSPointerOut', 'mouseenter', 'mouseleave', 'pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'pointerover', 'pointerout', 'pointerenter', 'pointerleave'], function () {
      _jquery.default.event.fixHooks[this] = {
        filter: function filter(event, originalEvent) {
          var pointerType = originalEvent.pointerType;

          if ((0, _type.isNumeric)(pointerType)) {
            event.pointerType = POINTER_TYPE_MAP[pointerType];
          }

          return event;
        },
        props: _jquery.default.event.mouseHooks.props.concat(['pointerId', 'pointerType', 'originalTarget', 'width', 'height', 'pressure', 'result', 'tiltX', 'charCode', 'tiltY', 'detail', 'isPrimary', 'prevValue'])
      };
    });
    (0, _iterator.each)(['touchstart', 'touchmove', 'touchend', 'touchcancel'], function () {
      _jquery.default.event.fixHooks[this] = {
        filter: function filter(event, originalEvent) {
          (0, _hook_touch_props.default)(function (name, hook) {
            event[name] = hook(originalEvent);
          });
          return event;
        },
        props: _jquery.default.event.mouseHooks.props.concat(['touches', 'changedTouches', 'targetTouches', 'detail', 'result', 'originalTarget', 'charCode', 'prevValue'])
      };
    });
    _jquery.default.event.fixHooks['wheel'] = _jquery.default.event.mouseHooks;
    var DX_EVENT_HOOKS = {
      props: _jquery.default.event.mouseHooks.props.concat(['pointerType', 'pointerId', 'pointers'])
    };

    _event_registrator.default.callbacks.add(function (name) {
      _jquery.default.event.fixHooks[name] = DX_EVENT_HOOKS;
    });

    var fix = function fix(event, originalEvent) {
      var fixHook = _jquery.default.event.fixHooks[originalEvent.type] || _jquery.default.event.mouseHooks;
      var props = fixHook.props ? _jquery.default.event.props.concat(fixHook.props) : _jquery.default.event.props;
      var propIndex = props.length;

      while (propIndex--) {
        var prop = props[propIndex];
        event[prop] = originalEvent[prop];
      }

      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    };

    (0, _index.setEventFixMethod)(fix);
  } else {
    (0, _hook_touch_props.default)(function (name, hook) {
      _jquery.default.event.addProp(name, hook);
    });
  }
}

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _jquery = _interopRequireDefault(__webpack_require__(56));

var _deferred = __webpack_require__(6);

var _version = __webpack_require__(71);

var _use_jquery = _interopRequireDefault(__webpack_require__(87));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
var useJQuery = (0, _use_jquery.default)();

if (useJQuery) {
  var Deferred = _jquery.default.Deferred;
  var strategy = {
    Deferred: Deferred
  };
  strategy.when = (0, _version.compare)(_jquery.default.fn.jquery, [3]) < 0 ? _jquery.default.when : function (singleArg) {
    if (arguments.length === 0) {
      return new Deferred().resolve();
    } else if (arguments.length === 1) {
      return singleArg && singleArg.then ? singleArg : new Deferred().resolve(singleArg);
    } else {
      return _jquery.default.when.apply(_jquery.default, arguments);
    }
  };
  (0, _deferred.setStrategy)(strategy);
}

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _jquery = _interopRequireDefault(__webpack_require__(56));

var _themes_callback = __webpack_require__(214);

var _ready_callbacks = _interopRequireDefault(__webpack_require__(51));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
if (_jquery.default && !_themes_callback.themeReadyCallback.fired()) {
  var holdReady = _jquery.default.holdReady || _jquery.default.fn.holdReady;
  holdReady(true);

  _themes_callback.themeReadyCallback.add(function () {
    _ready_callbacks.default.add(function () {
      holdReady(false);
    });
  });
}

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _jquery = _interopRequireDefault(__webpack_require__(56));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _use_jquery = _interopRequireDefault(__webpack_require__(87));

var _event_registrator_callbacks = _interopRequireDefault(__webpack_require__(124));

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
var useJQuery = (0, _use_jquery.default)();

if (useJQuery) {
  _event_registrator_callbacks.default.add(function (name, eventObject) {
    _jquery.default.event.special[name] = eventObject;
  });

  if (_events_engine.default.passiveEventHandlersSupported()) {
    _events_engine.default.forcePassiveFalseEventNames.forEach(function (eventName) {
      _jquery.default.event.special[eventName] = {
        setup: function setup(data, namespaces, handler) {
          _dom_adapter.default.listen(this, eventName, handler, {
            passive: false
          });
        }
      };
    });
  }

  _events_engine.default.set({
    on: function on(element) {
      (0, _jquery.default)(element).on.apply((0, _jquery.default)(element), Array.prototype.slice.call(arguments, 1));
    },
    one: function one(element) {
      (0, _jquery.default)(element).one.apply((0, _jquery.default)(element), Array.prototype.slice.call(arguments, 1));
    },
    off: function off(element) {
      (0, _jquery.default)(element).off.apply((0, _jquery.default)(element), Array.prototype.slice.call(arguments, 1));
    },
    trigger: function trigger(element) {
      (0, _jquery.default)(element).trigger.apply((0, _jquery.default)(element), Array.prototype.slice.call(arguments, 1));
    },
    triggerHandler: function triggerHandler(element) {
      (0, _jquery.default)(element).triggerHandler.apply((0, _jquery.default)(element), Array.prototype.slice.call(arguments, 1));
    },
    Event: _jquery.default.Event
  });
}

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _jquery = _interopRequireDefault(__webpack_require__(56));

var _easing = __webpack_require__(267);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
if (_jquery.default) {
  (0, _easing.setEasing)(_jquery.default.easing);
}

/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _jquery = _interopRequireDefault(__webpack_require__(56));

var _element_data = __webpack_require__(43);

var _use_jquery = _interopRequireDefault(__webpack_require__(87));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
var useJQuery = (0, _use_jquery.default)();

if (useJQuery) {
  (0, _element_data.setDataStrategy)(_jquery.default);
}

/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _element = __webpack_require__(22);

var _use_jquery = _interopRequireDefault(__webpack_require__(87));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var useJQuery = (0, _use_jquery.default)();

var getPublicElement = function getPublicElement($element) {
  return $element;
};

if (useJQuery) {
  (0, _element.setPublicElementWrapper)(getPublicElement);
}

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _jquery = _interopRequireDefault(__webpack_require__(56));

var _component_registrator_callbacks = _interopRequireDefault(__webpack_require__(144));

var _errors = _interopRequireDefault(__webpack_require__(24));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
if (_jquery.default) {
  var registerJQueryComponent = function registerJQueryComponent(name, componentClass) {
    _jquery.default.fn[name] = function (options) {
      var isMemberInvoke = typeof options === 'string';
      var result;

      if (isMemberInvoke) {
        var memberName = options;
        var memberArgs = [].slice.call(arguments).slice(1);
        this.each(function () {
          var instance = componentClass.getInstance(this);

          if (!instance) {
            throw _errors.default.Error('E0009', name);
          }

          var member = instance[memberName];
          var memberValue = member.apply(instance, memberArgs);

          if (result === undefined) {
            result = memberValue;
          }
        });
      } else {
        this.each(function () {
          var instance = componentClass.getInstance(this);

          if (instance) {
            instance.option(options);
          } else {
            new componentClass(this, options);
          }
        });
        result = this;
      }

      return result;
    };
  };

  _component_registrator_callbacks.default.add(registerJQueryComponent);
}

/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _jquery = _interopRequireDefault(__webpack_require__(56));

var _ajax = _interopRequireDefault(__webpack_require__(80));

var _use_jquery = _interopRequireDefault(__webpack_require__(87));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
var useJQuery = (0, _use_jquery.default)();

if (useJQuery) {
  _ajax.default.inject({
    sendRequest: function sendRequest(options) {
      if (!options.responseType && !options.upload) {
        return _jquery.default.ajax(options);
      }

      return this.callBase.apply(this, [options]);
    }
  });
}

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(268);

__webpack_require__(408);

__webpack_require__(415);

__webpack_require__(416);

__webpack_require__(417);

/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _renderer = _interopRequireDefault(__webpack_require__(2));

var _angular = _interopRequireDefault(__webpack_require__(128));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _config = _interopRequireDefault(__webpack_require__(29));

var _component_registrator_callbacks = _interopRequireDefault(__webpack_require__(144));

var _class = _interopRequireDefault(__webpack_require__(15));

var _callbacks = _interopRequireDefault(__webpack_require__(28));

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

var _array = __webpack_require__(12);

var _locker = _interopRequireDefault(__webpack_require__(269));

var _editor = _interopRequireDefault(__webpack_require__(53));

var _template = __webpack_require__(409);

var _module = _interopRequireDefault(__webpack_require__(199));

var _uiCollection_widget = _interopRequireDefault(__webpack_require__(58));

var _data = __webpack_require__(21);

var _extend = __webpack_require__(0);

var _comparator = __webpack_require__(260);

var _inflector = __webpack_require__(41);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var ITEM_ALIAS_ATTRIBUTE_NAME = 'dxItemAlias';
var SKIP_APPLY_ACTION_CATEGORIES = ['rendering'];
var NG_MODEL_OPTION = 'value';

if (_angular.default) {
  var safeApply = function safeApply(func, scope) {
    if (scope.$root.$$phase) {
      return func(scope);
    } else {
      return scope.$apply(function () {
        return func(scope);
      });
    }
  };

  var getClassMethod = function getClassMethod(initClass, methodName) {
    var hasParentProperty = Object.prototype.hasOwnProperty.bind(initClass)('parent');
    var isES6Class = !hasParentProperty && initClass.parent;

    if (isES6Class) {
      var baseClass = Object.getPrototypeOf(initClass);
      return baseClass.prototype[methodName] ? function () {
        return baseClass.prototype[methodName]();
      } : getClassMethod(baseClass, methodName);
    } else {
      var method = initClass.parent.prototype[methodName];

      if (method) {
        return function () {
          return method();
        };
      }

      if (!method || !initClass.parent.subclassOf) {
        return function () {
          return undefined;
        };
      }

      return getClassMethod(initClass.parent, methodName);
    }
  };

  var ComponentBuilder = _class.default.inherit({
    ctor: function ctor(options) {
      this._componentDisposing = (0, _callbacks.default)();
      this._optionChangedCallbacks = (0, _callbacks.default)();
      this._ngLocker = new _locker.default();
      this._scope = options.scope;
      this._$element = options.$element;
      this._$templates = options.$templates;
      this._componentClass = options.componentClass;
      this._parse = options.parse;
      this._compile = options.compile;
      this._itemAlias = options.itemAlias;
      this._transcludeFn = options.transcludeFn;
      this._digestCallbacks = options.dxDigestCallbacks;

      this._normalizeOptions(options.ngOptions);

      this._initComponentBindings();

      this._initComponent(this._scope);

      if (!options.ngOptions) {
        this._addOptionsStringWatcher(options.ngOptionsString);
      }
    },
    _addOptionsStringWatcher: function _addOptionsStringWatcher(optionsString) {
      var _this = this;

      var clearOptionsStringWatcher = this._scope.$watch(optionsString, function (newOptions) {
        if (!newOptions) {
          return;
        }

        clearOptionsStringWatcher();

        _this._normalizeOptions(newOptions);

        _this._initComponentBindings();

        _this._component.option(_this._evalOptions(_this._scope));
      });

      this._componentDisposing.add(clearOptionsStringWatcher);
    },
    _normalizeOptions: function _normalizeOptions(options) {
      var _this2 = this;

      this._ngOptions = (0, _extend.extendFromObject)({}, options);

      if (!options) {
        return;
      }

      if (!Object.prototype.hasOwnProperty.call(options, 'bindingOptions') && options.bindingOptions) {
        this._ngOptions.bindingOptions = options.bindingOptions;
      }

      if (options.bindingOptions) {
        (0, _iterator.each)(options.bindingOptions, function (key, value) {
          if ((0, _type.type)(value) === 'string') {
            _this2._ngOptions.bindingOptions[key] = {
              dataPath: value
            };
          }
        });
      }
    },
    _initComponent: function _initComponent(scope) {
      this._component = new this._componentClass(this._$element, this._evalOptions(scope));
      this._component._isHidden = true;

      this._handleDigestPhase();
    },
    _handleDigestPhase: function _handleDigestPhase() {
      var _this3 = this;

      var beginUpdate = function beginUpdate() {
        _this3._component.beginUpdate();
      };

      var endUpdate = function endUpdate() {
        _this3._component.endUpdate();
      };

      this._digestCallbacks.begin.add(beginUpdate);

      this._digestCallbacks.end.add(endUpdate);

      this._componentDisposing.add(function () {
        _this3._digestCallbacks.begin.remove(beginUpdate);

        _this3._digestCallbacks.end.remove(endUpdate);
      });
    },
    _initComponentBindings: function _initComponentBindings() {
      var _this4 = this;

      var optionDependencies = {};

      if (!this._ngOptions.bindingOptions) {
        return;
      }

      (0, _iterator.each)(this._ngOptions.bindingOptions, function (optionPath, value) {
        var separatorIndex = optionPath.search(/\[|\./);
        var optionForSubscribe = separatorIndex > -1 ? optionPath.substring(0, separatorIndex) : optionPath;
        var prevWatchMethod;
        var clearWatcher;
        var valuePath = value.dataPath;
        var deepWatch = true;
        var forcePlainWatchMethod = false;

        if (value.deep !== undefined) {
          forcePlainWatchMethod = deepWatch = !!value.deep;
        }

        if (!optionDependencies[optionForSubscribe]) {
          optionDependencies[optionForSubscribe] = {};
        }

        optionDependencies[optionForSubscribe][optionPath] = valuePath;

        var updateWatcher = function updateWatcher() {
          var watchCallback = function watchCallback(newValue, oldValue) {
            if (_this4._ngLocker.locked(optionPath)) {
              return;
            }

            _this4._ngLocker.obtain(optionPath);

            _this4._component.option(optionPath, newValue);

            updateWatcher();

            if ((0, _comparator.equals)(oldValue, newValue) && _this4._ngLocker.locked(optionPath)) {
              _this4._ngLocker.release(optionPath);
            }
          };

          var watchMethod = Array.isArray(_this4._scope.$eval(valuePath)) && !forcePlainWatchMethod ? '$watchCollection' : '$watch';

          if (prevWatchMethod !== watchMethod) {
            if (clearWatcher) {
              clearWatcher();
            }

            clearWatcher = _this4._scope[watchMethod](valuePath, watchCallback, deepWatch);
            prevWatchMethod = watchMethod;
          }
        };

        updateWatcher();

        _this4._componentDisposing.add(clearWatcher);
      });

      this._optionChangedCallbacks.add(function (args) {
        var optionName = args.name;
        var fullName = args.fullName;
        var component = args.component;

        if (_this4._ngLocker.locked(fullName)) {
          _this4._ngLocker.release(fullName);

          return;
        }

        if (!optionDependencies || !optionDependencies[optionName]) {
          return;
        }

        var isActivePhase = _this4._scope.$root.$$phase;

        var obtainOption = function obtainOption() {
          _this4._ngLocker.obtain(fullName);
        };

        if (isActivePhase) {
          _this4._digestCallbacks.begin.add(obtainOption);
        } else {
          obtainOption();
        }

        safeApply(function () {
          (0, _iterator.each)(optionDependencies[optionName], function (optionPath, valuePath) {
            if (!_this4._optionsAreLinked(fullName, optionPath)) {
              return;
            }

            var value = component.option(optionPath);

            _this4._parse(valuePath).assign(_this4._scope, value);

            var scopeValue = _this4._parse(valuePath)(_this4._scope);

            if (scopeValue !== value) {
              args.component.option(optionPath, scopeValue);
            }
          });
        }, _this4._scope);

        var releaseOption = function releaseOption() {
          if (_this4._ngLocker.locked(fullName)) {
            _this4._ngLocker.release(fullName);
          }

          _this4._digestCallbacks.begin.remove(obtainOption);

          _this4._digestCallbacks.end.remove(releaseOption);
        };

        if (isActivePhase) {
          _this4._digestCallbacks.end.addPrioritized(releaseOption);
        } else {
          releaseOption();
        }
      });
    },
    _optionsAreNested: function _optionsAreNested(optionPath1, optionPath2) {
      var parentSeparator = optionPath1[optionPath2.length];
      return optionPath1.indexOf(optionPath2) === 0 && (parentSeparator === '.' || parentSeparator === '[');
    },
    _optionsAreLinked: function _optionsAreLinked(optionPath1, optionPath2) {
      if (optionPath1 === optionPath2) return true;
      return optionPath1.length > optionPath2.length ? this._optionsAreNested(optionPath1, optionPath2) : this._optionsAreNested(optionPath2, optionPath1);
    },
    _compilerByTemplate: function _compilerByTemplate(template) {
      var _this5 = this;

      var scopeItemsPath = this._getScopeItemsPath();

      return function (options) {
        var $resultMarkup = (0, _renderer.default)(template).clone();
        var dataIsScope = options.model && options.model.constructor === _this5._scope.$root.constructor;
        var templateScope = dataIsScope ? options.model : options.noModel ? _this5._scope : _this5._createScopeWithData(options);

        if (scopeItemsPath) {
          _this5._synchronizeScopes(templateScope, scopeItemsPath, options.index);
        }

        $resultMarkup.appendTo(options.container);

        if (!options.noModel) {
          _events_engine.default.on($resultMarkup, '$destroy', function () {
            var destroyAlreadyCalled = !templateScope.$parent;

            if (destroyAlreadyCalled) {
              return;
            }

            templateScope.$destroy();
          });
        }

        var ngTemplate = _this5._compile($resultMarkup, _this5._transcludeFn);

        _this5._applyAsync(function (scope) {
          ngTemplate(scope, null, {
            parentBoundTranscludeFn: _this5._transcludeFn
          });
        }, templateScope);

        return $resultMarkup;
      };
    },
    _applyAsync: function _applyAsync(func, scope) {
      var _this6 = this;

      func(scope);

      if (!scope.$root.$$phase) {
        if (!this._renderingTimer) {
          var clearRenderingTimer = function clearRenderingTimer() {
            clearTimeout(_this6._renderingTimer);
          };

          this._renderingTimer = setTimeout(function () {
            scope.$apply();
            _this6._renderingTimer = null;

            _this6._componentDisposing.remove(clearRenderingTimer);
          });

          this._componentDisposing.add(clearRenderingTimer);
        }
      }
    },
    _getScopeItemsPath: function _getScopeItemsPath() {
      if (this._componentClass.subclassOf(_uiCollection_widget.default) && this._ngOptions.bindingOptions && this._ngOptions.bindingOptions.items) {
        return this._ngOptions.bindingOptions.items.dataPath;
      }
    },
    _createScopeWithData: function _createScopeWithData(options) {
      var newScope = this._scope.$new();

      if (this._itemAlias) {
        newScope[this._itemAlias] = options.model;
      }

      if ((0, _type.isDefined)(options.index)) {
        newScope.$index = options.index;
      }

      return newScope;
    },
    _synchronizeScopes: function _synchronizeScopes(itemScope, parentPrefix, itemIndex) {
      if (this._itemAlias && _typeof(itemScope[this._itemAlias]) !== 'object') {
        this._synchronizeScopeField({
          parentScope: this._scope,
          childScope: itemScope,
          fieldPath: this._itemAlias,
          parentPrefix: parentPrefix,
          itemIndex: itemIndex
        });
      }
    },
    _synchronizeScopeField: function _synchronizeScopeField(args) {
      var parentScope = args.parentScope;
      var childScope = args.childScope;
      var fieldPath = args.fieldPath;
      var parentPrefix = args.parentPrefix;
      var itemIndex = args.itemIndex;
      var innerPathSuffix = fieldPath === this._itemAlias ? '' : '.' + fieldPath;
      var collectionField = itemIndex !== undefined;
      var optionOuterBag = [parentPrefix];

      if (collectionField) {
        if (!(0, _type.isNumeric)(itemIndex)) return;
        optionOuterBag.push('[', itemIndex, ']');
      }

      optionOuterBag.push(innerPathSuffix);
      var optionOuterPath = optionOuterBag.join('');
      var clearParentWatcher = parentScope.$watch(optionOuterPath, function (newValue, oldValue) {
        if (newValue !== oldValue) {
          (0, _data.compileSetter)(fieldPath)(childScope, newValue);
        }
      });
      var clearItemWatcher = childScope.$watch(fieldPath, function (newValue, oldValue) {
        if (newValue !== oldValue) {
          if (collectionField && !(0, _data.compileGetter)(parentPrefix)(parentScope)[itemIndex]) {
            clearItemWatcher();
            return;
          }

          (0, _data.compileSetter)(optionOuterPath)(parentScope, newValue);
        }
      });

      this._componentDisposing.add([clearParentWatcher, clearItemWatcher]); // TODO: test

    },
    _evalOptions: function _evalOptions(scope) {
      var _this8 = this;

      var result = (0, _extend.extendFromObject)({}, this._ngOptions);
      delete result.bindingOptions;

      if (this._ngOptions.bindingOptions) {
        (0, _iterator.each)(this._ngOptions.bindingOptions, function (key, value) {
          result[key] = scope.$eval(value.dataPath);
        });
      }

      result._optionChangedCallbacks = this._optionChangedCallbacks;
      result._disposingCallbacks = this._componentDisposing;

      result.onActionCreated = function (component, action, config) {
        if (config && (0, _array.inArray)(config.category, SKIP_APPLY_ACTION_CATEGORIES) > -1) {
          return action;
        }

        var wrappedAction = function wrappedAction() {
          var _this7 = this;

          var args = arguments;

          if (!scope || !scope.$root || scope.$root.$$phase) {
            return action.apply(this, args);
          }

          return safeApply(function () {
            return action.apply(_this7, args);
          }, scope);
        };

        return wrappedAction;
      };

      result.beforeActionExecute = result.onActionCreated;

      result.nestedComponentOptions = function (component) {
        return {
          templatesRenderAsynchronously: component.option('templatesRenderAsynchronously'),
          forceApplyBindings: component.option('forceApplyBindings'),
          modelByElement: component.option('modelByElement'),
          onActionCreated: component.option('onActionCreated'),
          beforeActionExecute: component.option('beforeActionExecute'),
          nestedComponentOptions: component.option('nestedComponentOptions')
        };
      };

      result.templatesRenderAsynchronously = true;

      if ((0, _config.default)().wrapActionsBeforeExecute) {
        result.forceApplyBindings = function () {
          safeApply(function () {}, scope);
        };
      }

      result.integrationOptions = {
        createTemplate: function createTemplate(element) {
          return new _template.NgTemplate(element, _this8._compilerByTemplate.bind(_this8));
        },
        watchMethod: function watchMethod(fn, callback, options) {
          options = options || {};
          var immediateValue;
          var skipCallback = options.skipImmediate;
          var disposeWatcher = scope.$watch(function () {
            var value = fn();

            if (value instanceof Date) {
              value = value.valueOf();
            }

            return value;
          }, function (newValue) {
            var isSameValue = immediateValue === newValue;

            if (!skipCallback && (!isSameValue || isSameValue && options.deep)) {
              callback(newValue);
            }

            skipCallback = false;
          }, options.deep);

          if (!skipCallback) {
            immediateValue = fn();
            callback(immediateValue);
          }

          if ((0, _config.default)().wrapActionsBeforeExecute) {
            _this8._applyAsync(function () {}, scope);
          }

          return disposeWatcher;
        },
        templates: {
          'dx-polymorph-widget': {
            render: function render(options) {
              var widgetName = options.model.widget;

              if (!widgetName) {
                return;
              }

              var markup = (0, _renderer.default)('<div>').attr((0, _inflector.dasherize)(widgetName), 'options').get(0);

              var newScope = _this8._scope.$new();

              newScope.options = options.model.options;
              options.container.append(markup);

              _this8._compile(markup)(newScope);
            }
          }
        }
      };

      result.modelByElement = function () {
        return scope;
      };

      return result;
    }
  });

  ComponentBuilder = ComponentBuilder.inherit({
    ctor: function ctor(options) {
      this._componentName = options.componentName;
      this._ngModel = options.ngModel;
      this._ngModelController = options.ngModelController;
      this.callBase.apply(this, arguments);
    },
    _isNgModelRequired: function _isNgModelRequired() {
      return _editor.default.isEditor(this._componentClass.prototype) && this._ngModel;
    },
    _initComponentBindings: function _initComponentBindings() {
      this.callBase.apply(this, arguments);

      this._initNgModelBinding();
    },
    _initNgModelBinding: function _initNgModelBinding() {
      var _this9 = this;

      if (!this._isNgModelRequired()) {
        return;
      }

      var clearNgModelWatcher = this._scope.$watch(this._ngModel, function (newValue, oldValue) {
        if (_this9._ngLocker.locked(NG_MODEL_OPTION)) {
          return;
        }

        if (newValue === oldValue) {
          return;
        }

        _this9._component.option(NG_MODEL_OPTION, newValue);
      });

      this._optionChangedCallbacks.add(function (args) {
        _this9._ngLocker.obtain(NG_MODEL_OPTION);

        try {
          if (args.name !== NG_MODEL_OPTION) {
            return;
          }

          _this9._ngModelController.$setViewValue(args.value);
        } finally {
          if (_this9._ngLocker.locked(NG_MODEL_OPTION)) {
            _this9._ngLocker.release(NG_MODEL_OPTION);
          }
        }
      });

      this._componentDisposing.add(clearNgModelWatcher);
    },
    _evalOptions: function _evalOptions() {
      if (!this._isNgModelRequired()) {
        return this.callBase.apply(this, arguments);
      }

      var result = this.callBase.apply(this, arguments);
      result[NG_MODEL_OPTION] = this._parse(this._ngModel)(this._scope);
      return result;
    }
  });
  var registeredComponents = {};

  var registerComponentDirective = function registerComponentDirective(name) {
    var priority = name !== 'dxValidator' ? 1 : 10;

    _module.default.directive(name, ['$compile', '$parse', 'dxDigestCallbacks', function ($compile, $parse, dxDigestCallbacks) {
      return {
        restrict: 'A',
        require: '^?ngModel',
        priority: priority,
        compile: function compile($element) {
          var componentClass = registeredComponents[name];
          var useTemplates = componentClass.prototype._useTemplates ? componentClass.prototype._useTemplates() : getClassMethod(componentClass, '_useTemplates')();
          var $content = useTemplates ? $element.contents().detach() : null;
          return function (scope, $element, attrs, ngModelController, transcludeFn) {
            $element.append($content);
            safeApply(function () {
              new ComponentBuilder({
                componentClass: componentClass,
                componentName: name,
                compile: $compile,
                parse: $parse,
                $element: $element,
                scope: scope,
                ngOptionsString: attrs[name],
                ngOptions: attrs[name] ? scope.$eval(attrs[name]) : {},
                ngModel: attrs.ngModel,
                ngModelController: ngModelController,
                transcludeFn: transcludeFn,
                itemAlias: attrs[ITEM_ALIAS_ATTRIBUTE_NAME],
                dxDigestCallbacks: dxDigestCallbacks
              });
            }, scope);
          };
        }
      };
    }]);
  };

  _component_registrator_callbacks.default.add(function (name, componentClass) {
    if (!registeredComponents[name]) {
      registerComponentDirective(name);
    }

    registeredComponents[name] = componentClass;
  });
}

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.NgTemplate = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _template_base = __webpack_require__(69);

var _type = __webpack_require__(1);

var _dom = __webpack_require__(35);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var NgTemplate = /*#__PURE__*/function (_TemplateBase) {
  _inheritsLoose(NgTemplate, _TemplateBase);

  function NgTemplate(element, templateCompiler) {
    var _this;

    _this = _TemplateBase.call(this) || this;
    _this._element = element;
    _this._compiledTemplate = templateCompiler((0, _dom.normalizeTemplateElement)(_this._element));
    return _this;
  }

  var _proto = NgTemplate.prototype;

  _proto._renderCore = function _renderCore(options) {
    var compiledTemplate = this._compiledTemplate;
    return (0, _type.isFunction)(compiledTemplate) ? compiledTemplate(options) : compiledTemplate;
  };

  _proto.source = function source() {
    return (0, _renderer.default)(this._element).clone();
  };

  return NgTemplate;
}(_template_base.TemplateBase);

exports.NgTemplate = NgTemplate;

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _common = __webpack_require__(4);

var _template_manager = __webpack_require__(261);

var _element = __webpack_require__(22);

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _type = __webpack_require__(1);

var _deferred = __webpack_require__(6);

var _extend = __webpack_require__(0);

var _array = __webpack_require__(12);

var _iterator = __webpack_require__(3);

var _action = _interopRequireDefault(__webpack_require__(121));

var _guid = _interopRequireDefault(__webpack_require__(36));

var _ui = _interopRequireDefault(__webpack_require__(20));

var _index = __webpack_require__(8);

var _pointer = _interopRequireDefault(__webpack_require__(25));

var _data_helper = _interopRequireDefault(__webpack_require__(97));

var _item = _interopRequireDefault(__webpack_require__(151));

var _selectors = __webpack_require__(67);

var _message = _interopRequireDefault(__webpack_require__(10));

var _hold = _interopRequireDefault(__webpack_require__(98));

var _data = __webpack_require__(21);

var _click = __webpack_require__(23);

var _contextmenu = __webpack_require__(167);

var _bindable_template = __webpack_require__(73);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var COLLECTION_CLASS = 'dx-collection';
var ITEM_CLASS = 'dx-item';
var CONTENT_CLASS_POSTFIX = '-content';
var ITEM_CONTENT_PLACEHOLDER_CLASS = 'dx-item-content-placeholder';
var ITEM_DATA_KEY = 'dxItemData';
var ITEM_INDEX_KEY = 'dxItemIndex';
var ITEM_TEMPLATE_ID_PREFIX = 'tmpl-';
var ITEMS_OPTIONS_NAME = 'dxItem';
var SELECTED_ITEM_CLASS = 'dx-item-selected';
var ITEM_RESPONSE_WAIT_CLASS = 'dx-item-response-wait';
var EMPTY_COLLECTION = 'dx-empty-collection';
var TEMPLATE_WRAPPER_CLASS = 'dx-template-wrapper';
var ITEM_PATH_REGEX = /^([^.]+\[\d+\]\.)+([\w.]+)$/;
var ANONYMOUS_TEMPLATE_NAME = 'item';
var FOCUS_UP = 'up';
var FOCUS_DOWN = 'down';
var FOCUS_LEFT = 'left';
var FOCUS_RIGHT = 'right';
var FOCUS_PAGE_UP = 'pageup';
var FOCUS_PAGE_DOWN = 'pagedown';
var FOCUS_LAST = 'last';
var FOCUS_FIRST = 'first';

var CollectionWidget = _ui.default.inherit({
  _activeStateUnit: '.' + ITEM_CLASS,
  _supportedKeys: function _supportedKeys() {
    var enter = function enter(e) {
      var $itemElement = (0, _renderer.default)(this.option('focusedElement'));

      if (!$itemElement.length) {
        return;
      }

      this._itemClickHandler((0, _extend.extend)({}, e, {
        target: $itemElement.get(0),
        currentTarget: $itemElement.get(0)
      }));
    };

    var space = function space(e) {
      e.preventDefault();
      enter.call(this, e);
    };

    var move = function move(location, e) {
      if (!(0, _index.isCommandKeyPressed)(e)) {
        e.preventDefault();
        e.stopPropagation();

        this._moveFocus(location, e);
      }
    };

    return (0, _extend.extend)(this.callBase(), {
      space: space,
      enter: enter,
      leftArrow: move.bind(this, FOCUS_LEFT),
      rightArrow: move.bind(this, FOCUS_RIGHT),
      upArrow: move.bind(this, FOCUS_UP),
      downArrow: move.bind(this, FOCUS_DOWN),
      pageUp: move.bind(this, FOCUS_UP),
      pageDown: move.bind(this, FOCUS_DOWN),
      home: move.bind(this, FOCUS_FIRST),
      end: move.bind(this, FOCUS_LAST)
    });
  },
  _getDefaultOptions: function _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      /**
      * @name CollectionWidgetOptions.selectOnFocus
      * @type boolean
      * @hidden
      */
      selectOnFocus: false,

      /**
      * @name CollectionWidgetOptions.loopItemFocus
      * @type boolean
      * @hidden
      */
      loopItemFocus: true,
      items: [],
      itemTemplate: 'item',
      onItemRendered: null,
      onItemClick: null,
      onItemHold: null,
      itemHoldTimeout: 750,
      onItemContextMenu: null,
      onFocusedItemChanged: null,
      noDataText: _message.default.format('dxCollectionWidget-noDataText'),
      dataSource: null,
      _itemAttributes: {},
      itemTemplateProperty: 'template',
      focusOnSelectedItem: true,

      /**
      * @name CollectionWidgetOptions.focusedElement
      * @type DxElement
      * @default null
      * @hidden
      */
      focusedElement: null,
      displayExpr: undefined,
      disabledExpr: function disabledExpr(data) {
        return data ? data.disabled : undefined;
      },
      visibleExpr: function visibleExpr(data) {
        return data ? data.visible : undefined;
      }
    });
  },
  _init: function _init() {
    this._compileDisplayGetter();

    this.callBase();

    this._cleanRenderedItems();

    this._refreshDataSource();
  },
  _compileDisplayGetter: function _compileDisplayGetter() {
    var displayExpr = this.option('displayExpr');
    this._displayGetter = displayExpr ? (0, _data.compileGetter)(this.option('displayExpr')) : undefined;
  },
  _initTemplates: function _initTemplates() {
    this._initItemsFromMarkup();

    this._initDefaultItemTemplate();

    this.callBase();
  },
  _getAnonymousTemplateName: function _getAnonymousTemplateName() {
    return ANONYMOUS_TEMPLATE_NAME;
  },
  _initDefaultItemTemplate: function _initDefaultItemTemplate() {
    var fieldsMap = this._getFieldsMap();

    this._templateManager.addDefaultTemplates({
      item: new _bindable_template.BindableTemplate(function ($container, data) {
        if ((0, _type.isPlainObject)(data)) {
          this._prepareDefaultItemTemplate(data, $container);
        } else {
          if (fieldsMap && (0, _type.isFunction)(fieldsMap.text)) {
            data = fieldsMap.text(data);
          }

          $container.text(String((0, _common.ensureDefined)(data, '')));
        }
      }.bind(this), this._getBindableFields(), this.option('integrationOptions.watchMethod'), fieldsMap)
    });
  },
  _getBindableFields: function _getBindableFields() {
    return ['text', 'html'];
  },
  _getFieldsMap: function _getFieldsMap() {
    if (this._displayGetter) {
      return {
        text: this._displayGetter
      };
    }
  },
  _prepareDefaultItemTemplate: function _prepareDefaultItemTemplate(data, $container) {
    if ((0, _type.isDefined)(data.text)) {
      $container.text(data.text);
    }

    if ((0, _type.isDefined)(data.html)) {
      $container.html(data.html);
    }
  },
  _initItemsFromMarkup: function _initItemsFromMarkup() {
    var _this = this;

    var rawItems = (0, _template_manager.findTemplates)(this.$element(), ITEMS_OPTIONS_NAME);

    if (!rawItems.length || this.option('items').length) {
      return;
    }

    var items = rawItems.map(function (_ref) {
      var element = _ref.element,
          options = _ref.options;
      var isTemplateRequired = /\S/.test(element.innerHTML) && !options.template;

      if (isTemplateRequired) {
        options.template = _this._prepareItemTemplate(element);
      } else {
        (0, _renderer.default)(element).remove();
      }

      return options;
    });
    this.option('items', items);
  },
  _prepareItemTemplate: function _prepareItemTemplate(item) {
    var templateId = ITEM_TEMPLATE_ID_PREFIX + new _guid.default();
    var $template = (0, _renderer.default)(item).detach().clone().removeAttr('data-options').addClass(TEMPLATE_WRAPPER_CLASS);

    this._saveTemplate(templateId, $template);

    return templateId;
  },
  _dataSourceOptions: function _dataSourceOptions() {
    return {
      paginate: false
    };
  },
  _cleanRenderedItems: function _cleanRenderedItems() {
    this._renderedItemsCount = 0;
  },
  _focusTarget: function _focusTarget() {
    return this.$element();
  },
  _focusInHandler: function _focusInHandler(e) {
    this.callBase.apply(this, arguments);

    if ((0, _array.inArray)(e.target, this._focusTarget()) === -1) {
      return;
    }

    var $focusedElement = (0, _renderer.default)(this.option('focusedElement'));

    if ($focusedElement.length) {
      this._setFocusedItem($focusedElement);
    } else {
      var $activeItem = this._getActiveItem();

      if ($activeItem.length) {
        this.option('focusedElement', (0, _element.getPublicElement)($activeItem));
      }
    }
  },
  _focusOutHandler: function _focusOutHandler() {
    this.callBase.apply(this, arguments);
    var $target = (0, _renderer.default)(this.option('focusedElement'));

    this._updateFocusedItemState($target, false);
  },
  _getActiveItem: function _getActiveItem(last) {
    var $focusedElement = (0, _renderer.default)(this.option('focusedElement'));

    if ($focusedElement.length) {
      return $focusedElement;
    }

    var index = this.option('focusOnSelectedItem') ? this.option('selectedIndex') : 0;

    var activeElements = this._getActiveElement();

    var lastIndex = activeElements.length - 1;

    if (index < 0) {
      index = last ? lastIndex : 0;
    }

    return activeElements.eq(index);
  },
  _moveFocus: function _moveFocus(location) {
    var $items = this._getAvailableItems();

    var $newTarget;

    switch (location) {
      case FOCUS_PAGE_UP:
      case FOCUS_UP:
        $newTarget = this._prevItem($items);
        break;

      case FOCUS_PAGE_DOWN:
      case FOCUS_DOWN:
        $newTarget = this._nextItem($items);
        break;

      case FOCUS_RIGHT:
        $newTarget = this.option('rtlEnabled') ? this._prevItem($items) : this._nextItem($items);
        break;

      case FOCUS_LEFT:
        $newTarget = this.option('rtlEnabled') ? this._nextItem($items) : this._prevItem($items);
        break;

      case FOCUS_FIRST:
        $newTarget = $items.first();
        break;

      case FOCUS_LAST:
        $newTarget = $items.last();
        break;

      default:
        return false;
    }

    if ($newTarget.length !== 0) {
      this.option('focusedElement', (0, _element.getPublicElement)($newTarget));
    }
  },
  _getVisibleItems: function _getVisibleItems($itemElements) {
    $itemElements = $itemElements || this._itemElements();
    return $itemElements.filter(':visible');
  },
  _getAvailableItems: function _getAvailableItems($itemElements) {
    return this._getVisibleItems($itemElements).not('.dx-state-disabled');
  },
  _prevItem: function _prevItem($items) {
    var $target = this._getActiveItem();

    var targetIndex = $items.index($target);
    var $last = $items.last();
    var $item = (0, _renderer.default)($items[targetIndex - 1]);
    var loop = this.option('loopItemFocus');

    if ($item.length === 0 && loop) {
      $item = $last;
    }

    return $item;
  },
  _nextItem: function _nextItem($items) {
    var $target = this._getActiveItem(true);

    var targetIndex = $items.index($target);
    var $first = $items.first();
    var $item = (0, _renderer.default)($items[targetIndex + 1]);
    var loop = this.option('loopItemFocus');

    if ($item.length === 0 && loop) {
      $item = $first;
    }

    return $item;
  },
  _selectFocusedItem: function _selectFocusedItem($target) {
    this.selectItem($target);
  },
  _updateFocusedItemState: function _updateFocusedItemState(target, isFocused, needCleanItemId) {
    var $target = (0, _renderer.default)(target);

    if ($target.length) {
      this._refreshActiveDescendant();

      this._refreshItemId($target, needCleanItemId);

      this._toggleFocusClass(isFocused, $target);
    }

    this._updateParentActiveDescendant();
  },
  _refreshActiveDescendant: function _refreshActiveDescendant($target) {
    this.setAria('activedescendant', (0, _type.isDefined)(this.option('focusedElement')) ? this.getFocusedItemId() : null, $target);
  },
  _refreshItemId: function _refreshItemId($target, needCleanItemId) {
    if (!needCleanItemId && this.option('focusedElement')) {
      this.setAria('id', this.getFocusedItemId(), $target);
    } else {
      this.setAria('id', null, $target);
    }
  },
  _setFocusedItem: function _setFocusedItem($target) {
    if (!$target || !$target.length) {
      return;
    }

    this._updateFocusedItemState($target, true);

    this.onFocusedItemChanged(this.getFocusedItemId());

    if (this.option('selectOnFocus')) {
      this._selectFocusedItem($target);
    }
  },
  _findItemElementByItem: function _findItemElementByItem(item) {
    var result = (0, _renderer.default)();
    var that = this;
    this.itemElements().each(function () {
      var $item = (0, _renderer.default)(this);

      if ($item.data(that._itemDataKey()) === item) {
        result = $item;
        return false;
      }
    });
    return result;
  },
  _getIndexByItem: function _getIndexByItem(item) {
    return this.option('items').indexOf(item);
  },
  _itemOptionChanged: function _itemOptionChanged(item, property, value, oldValue) {
    var $item = this._findItemElementByItem(item);

    if (!$item.length) {
      return;
    }

    if (!this.constructor.ItemClass.getInstance($item).setDataField(property, value)) {
      this._refreshItem($item, item);
    }

    var isDisabling = property === 'disabled' && value;

    if (isDisabling) {
      this._resetItemFocus($item);
    }
  },
  _resetItemFocus: function _resetItemFocus($item) {
    if ($item.is(this.option('focusedElement'))) {
      this.option('focusedElement', null);
    }
  },
  _refreshItem: function _refreshItem($item) {
    var itemData = this._getItemData($item);

    var index = $item.data(this._itemIndexKey());

    this._renderItem(this._renderedItemsCount + index, itemData, null, $item);
  },
  _updateParentActiveDescendant: _common.noop,
  _optionChanged: function _optionChanged(args) {
    if (args.name === 'items') {
      var matches = args.fullName.match(ITEM_PATH_REGEX);

      if (matches && matches.length) {
        var property = matches[matches.length - 1];
        var itemPath = args.fullName.replace('.' + property, '');
        var item = this.option(itemPath);

        this._itemOptionChanged(item, property, args.value, args.previousValue);

        return;
      }
    }

    switch (args.name) {
      case 'items':
      case '_itemAttributes':
      case 'itemTemplateProperty':
      case 'useItemTextAsTitle':
        this._cleanRenderedItems();

        this._invalidate();

        break;

      case 'dataSource':
        this._refreshDataSource();

        this._renderEmptyMessage();

        break;

      case 'noDataText':
        this._renderEmptyMessage();

        break;

      case 'itemTemplate':
        this._invalidate();

        break;

      case 'onItemRendered':
        this._createItemRenderAction();

        break;

      case 'onItemClick':
        break;

      case 'onItemHold':
      case 'itemHoldTimeout':
        this._attachHoldEvent();

        break;

      case 'onItemContextMenu':
        this._attachContextMenuEvent();

        break;

      case 'onFocusedItemChanged':
        this.onFocusedItemChanged = this._createActionByOption('onFocusedItemChanged');
        break;

      case 'selectOnFocus':
      case 'loopItemFocus':
      case 'focusOnSelectedItem':
        break;

      case 'focusedElement':
        this._updateFocusedItemState(args.previousValue, false, true);

        this._setFocusedItem((0, _renderer.default)(args.value));

        break;

      case 'displayExpr':
        this._compileDisplayGetter();

        this._initDefaultItemTemplate();

        this._invalidate();

        break;

      case 'visibleExpr':
      case 'disabledExpr':
        this._invalidate();

        break;

      default:
        this.callBase(args);
    }
  },
  _invalidate: function _invalidate() {
    this.option('focusedElement', null);
    return this.callBase.apply(this, arguments);
  },
  _loadNextPage: function _loadNextPage() {
    var dataSource = this._dataSource;

    this._expectNextPageLoading();

    dataSource.pageIndex(1 + dataSource.pageIndex());
    return dataSource.load();
  },
  _expectNextPageLoading: function _expectNextPageLoading() {
    this._startIndexForAppendedItems = 0;
  },
  _expectLastItemLoading: function _expectLastItemLoading() {
    this._startIndexForAppendedItems = -1;
  },
  _forgetNextPageLoading: function _forgetNextPageLoading() {
    this._startIndexForAppendedItems = null;
  },
  _dataSourceChangedHandler: function _dataSourceChangedHandler(newItems) {
    var items = this.option('items');

    if (this._initialized && items && this._shouldAppendItems()) {
      this._renderedItemsCount = items.length;

      if (!this._isLastPage() || this._startIndexForAppendedItems !== -1) {
        this.option().items = items.concat(newItems.slice(this._startIndexForAppendedItems));
      }

      this._forgetNextPageLoading();

      this._refreshContent();
    } else {
      this.option('items', newItems.slice());
    }
  },
  _refreshContent: function _refreshContent() {
    this._prepareContent();

    this._renderContent();
  },
  _dataSourceLoadErrorHandler: function _dataSourceLoadErrorHandler() {
    this._forgetNextPageLoading();

    this.option('items', this.option('items'));
  },
  _shouldAppendItems: function _shouldAppendItems() {
    return this._startIndexForAppendedItems != null && this._allowDynamicItemsAppend();
  },
  _allowDynamicItemsAppend: function _allowDynamicItemsAppend() {
    return false;
  },
  _clean: function _clean() {
    this._cleanFocusState();

    this._cleanItemContainer();
  },
  _cleanItemContainer: function _cleanItemContainer() {
    (0, _renderer.default)(this._itemContainer()).empty();
  },
  _dispose: function _dispose() {
    this.callBase();
    clearTimeout(this._itemFocusTimeout);
  },
  _refresh: function _refresh() {
    this._cleanRenderedItems();

    this.callBase.apply(this, arguments);
  },
  _itemContainer: function _itemContainer() {
    return this.$element();
  },
  _itemClass: function _itemClass() {
    return ITEM_CLASS;
  },
  _itemContentClass: function _itemContentClass() {
    return this._itemClass() + CONTENT_CLASS_POSTFIX;
  },
  _selectedItemClass: function _selectedItemClass() {
    return SELECTED_ITEM_CLASS;
  },
  _itemResponseWaitClass: function _itemResponseWaitClass() {
    return ITEM_RESPONSE_WAIT_CLASS;
  },
  _itemSelector: function _itemSelector() {
    return '.' + this._itemClass();
  },
  _itemDataKey: function _itemDataKey() {
    return ITEM_DATA_KEY;
  },
  _itemIndexKey: function _itemIndexKey() {
    return ITEM_INDEX_KEY;
  },
  _itemElements: function _itemElements() {
    return this._itemContainer().find(this._itemSelector());
  },
  _initMarkup: function _initMarkup() {
    this.callBase();
    this.onFocusedItemChanged = this._createActionByOption('onFocusedItemChanged');
    this.$element().addClass(COLLECTION_CLASS);

    this._prepareContent();
  },
  _prepareContent: (0, _common.deferRenderer)(function () {
    this._renderContentImpl();
  }),
  _renderContent: function _renderContent() {
    this._fireContentReadyAction();
  },
  _render: function _render() {
    this.callBase();

    this._attachClickEvent();

    this._attachHoldEvent();

    this._attachContextMenuEvent();
  },
  _attachClickEvent: function _attachClickEvent() {
    var itemSelector = this._itemSelector();

    var clickEventNamespace = (0, _index.addNamespace)(_click.name, this.NAME);
    var pointerDownEventNamespace = (0, _index.addNamespace)(_pointer.default.down, this.NAME);
    var that = this;
    var pointerDownAction = new _action.default(function (args) {
      var event = args.event;

      that._itemPointerDownHandler(event);
    });

    _events_engine.default.off(this._itemContainer(), clickEventNamespace, itemSelector);

    _events_engine.default.off(this._itemContainer(), pointerDownEventNamespace, itemSelector);

    _events_engine.default.on(this._itemContainer(), clickEventNamespace, itemSelector, function (e) {
      this._itemClickHandler(e);
    }.bind(this));

    _events_engine.default.on(this._itemContainer(), pointerDownEventNamespace, itemSelector, function (e) {
      pointerDownAction.execute({
        element: (0, _renderer.default)(e.target),
        event: e
      });
    });
  },
  _itemClickHandler: function _itemClickHandler(e, args, config) {
    this._itemDXEventHandler(e, 'onItemClick', args, config);
  },
  _itemPointerDownHandler: function _itemPointerDownHandler(e) {
    if (!this.option('focusStateEnabled')) {
      return;
    }

    this._itemFocusHandler = function () {
      clearTimeout(this._itemFocusTimeout);
      this._itemFocusHandler = null;

      if (e.isDefaultPrevented()) {
        return;
      }

      var $target = (0, _renderer.default)(e.target);
      var $closestItem = $target.closest(this._itemElements());

      var $closestFocusable = this._closestFocusable($target);

      if ($closestItem.length && $closestFocusable && (0, _array.inArray)($closestFocusable.get(0), this._focusTarget()) !== -1) {
        this.option('focusedElement', (0, _element.getPublicElement)($closestItem));
      }
    }.bind(this);

    this._itemFocusTimeout = setTimeout(this._forcePointerDownFocus.bind(this));
  },
  _closestFocusable: function _closestFocusable($target) {
    if ($target.is(_selectors.focusable)) {
      return $target;
    } else {
      $target = $target.parent();

      while ($target.length && !_dom_adapter.default.isDocument($target.get(0))) {
        if ($target.is(_selectors.focusable)) {
          return $target;
        }

        $target = $target.parent();
      }
    }
  },
  _forcePointerDownFocus: function _forcePointerDownFocus() {
    this._itemFocusHandler && this._itemFocusHandler();
  },
  _updateFocusState: function _updateFocusState() {
    this.callBase.apply(this, arguments);

    this._forcePointerDownFocus();
  },
  _attachHoldEvent: function _attachHoldEvent() {
    var $itemContainer = this._itemContainer();

    var itemSelector = this._itemSelector();

    var eventName = (0, _index.addNamespace)(_hold.default.name, this.NAME);

    _events_engine.default.off($itemContainer, eventName, itemSelector);

    _events_engine.default.on($itemContainer, eventName, itemSelector, {
      timeout: this._getHoldTimeout()
    }, this._itemHoldHandler.bind(this));
  },
  _getHoldTimeout: function _getHoldTimeout() {
    return this.option('itemHoldTimeout');
  },
  _shouldFireHoldEvent: function _shouldFireHoldEvent() {
    return this.hasActionSubscription('onItemHold');
  },
  _itemHoldHandler: function _itemHoldHandler(e) {
    if (this._shouldFireHoldEvent()) {
      this._itemDXEventHandler(e, 'onItemHold');
    } else {
      e.cancel = true;
    }
  },
  _attachContextMenuEvent: function _attachContextMenuEvent() {
    var $itemContainer = this._itemContainer();

    var itemSelector = this._itemSelector();

    var eventName = (0, _index.addNamespace)(_contextmenu.name, this.NAME);

    _events_engine.default.off($itemContainer, eventName, itemSelector);

    _events_engine.default.on($itemContainer, eventName, itemSelector, this._itemContextMenuHandler.bind(this));
  },
  _shouldFireContextMenuEvent: function _shouldFireContextMenuEvent() {
    return this.hasActionSubscription('onItemContextMenu');
  },
  _itemContextMenuHandler: function _itemContextMenuHandler(e) {
    if (this._shouldFireContextMenuEvent()) {
      this._itemDXEventHandler(e, 'onItemContextMenu');
    } else {
      e.cancel = true;
    }
  },
  _renderContentImpl: function _renderContentImpl() {
    var items = this.option('items') || [];

    if (this._renderedItemsCount) {
      this._renderItems(items.slice(this._renderedItemsCount));
    } else {
      this._renderItems(items);
    }
  },
  _renderItems: function _renderItems(items) {
    if (items.length) {
      (0, _iterator.each)(items, function (index, itemData) {
        this._renderItem(this._renderedItemsCount + index, itemData);
      }.bind(this));
    }

    this._renderEmptyMessage();
  },
  _renderItem: function _renderItem(index, itemData, $container, $itemToReplace) {
    $container = $container || this._itemContainer();

    var $itemFrame = this._renderItemFrame(index, itemData, $container, $itemToReplace);

    this._setElementData($itemFrame, itemData, index);

    $itemFrame.attr(this.option('_itemAttributes'));

    this._attachItemClickEvent(itemData, $itemFrame);

    var $itemContent = this._getItemContent($itemFrame);

    var renderContentPromise = this._renderItemContent({
      index: index,
      itemData: itemData,
      container: (0, _element.getPublicElement)($itemContent),
      contentClass: this._itemContentClass(),
      defaultTemplateName: this.option('itemTemplate')
    });

    var that = this;
    (0, _deferred.when)(renderContentPromise).done(function ($itemContent) {
      that._postprocessRenderItem({
        itemElement: $itemFrame,
        itemContent: $itemContent,
        itemData: itemData,
        itemIndex: index
      });

      that._executeItemRenderAction(index, itemData, (0, _element.getPublicElement)($itemFrame));
    });
    return $itemFrame;
  },
  _getItemContent: function _getItemContent($itemFrame) {
    var $itemContent = $itemFrame.find('.' + ITEM_CONTENT_PLACEHOLDER_CLASS);
    $itemContent.removeClass(ITEM_CONTENT_PLACEHOLDER_CLASS);
    return $itemContent;
  },
  _attachItemClickEvent: function _attachItemClickEvent(itemData, $itemElement) {
    if (!itemData || !itemData.onClick) {
      return;
    }

    _events_engine.default.on($itemElement, _click.name, function (e) {
      this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
        event: e
      });
    }.bind(this));
  },
  _renderItemContent: function _renderItemContent(args) {
    var itemTemplateName = this._getItemTemplateName(args);

    var itemTemplate = this._getTemplate(itemTemplateName);

    this._addItemContentClasses(args);

    var $templateResult = (0, _renderer.default)(this._createItemByTemplate(itemTemplate, args));

    if (!$templateResult.hasClass(TEMPLATE_WRAPPER_CLASS)) {
      return args.container;
    }

    return this._renderItemContentByNode(args, $templateResult);
  },
  _renderItemContentByNode: function _renderItemContentByNode(args, $node) {
    (0, _renderer.default)(args.container).replaceWith($node);
    args.container = (0, _element.getPublicElement)($node);

    this._addItemContentClasses(args);

    return $node;
  },
  _addItemContentClasses: function _addItemContentClasses(args) {
    var classes = [ITEM_CLASS + CONTENT_CLASS_POSTFIX, args.contentClass];
    (0, _renderer.default)(args.container).addClass(classes.join(' '));
  },
  _appendItemToContainer: function _appendItemToContainer($container, $itemFrame, index) {
    $itemFrame.appendTo($container);
  },
  _renderItemFrame: function _renderItemFrame(index, itemData, $container, $itemToReplace) {
    var $itemFrame = (0, _renderer.default)('<div>');
    new this.constructor.ItemClass($itemFrame, this._itemOptions(), itemData || {});

    if ($itemToReplace && $itemToReplace.length) {
      $itemToReplace.replaceWith($itemFrame);
    } else {
      this._appendItemToContainer.call(this, $container, $itemFrame, index);
    }

    if (this.option('useItemTextAsTitle')) {
      var displayValue = this._displayGetter ? this._displayGetter(itemData) : itemData;
      $itemFrame.attr('title', displayValue);
    }

    return $itemFrame;
  },
  _itemOptions: function _itemOptions() {
    var that = this;
    return {
      watchMethod: function watchMethod() {
        return that.option('integrationOptions.watchMethod');
      },
      owner: that,
      fieldGetter: function fieldGetter(field) {
        var expr = that.option(field + 'Expr');
        var getter = (0, _data.compileGetter)(expr);
        return getter;
      }
    };
  },
  _postprocessRenderItem: _common.noop,
  _executeItemRenderAction: function _executeItemRenderAction(index, itemData, itemElement) {
    this._getItemRenderAction()({
      itemElement: itemElement,
      itemIndex: index,
      itemData: itemData
    });
  },
  _setElementData: function _setElementData(element, data, index) {
    element.addClass([ITEM_CLASS, this._itemClass()].join(' ')).data(this._itemDataKey(), data).data(this._itemIndexKey(), index);
  },
  _createItemRenderAction: function _createItemRenderAction() {
    return this._itemRenderAction = this._createActionByOption('onItemRendered', {
      element: this.element(),
      excludeValidators: ['disabled', 'readOnly'],
      category: 'rendering'
    });
  },
  _getItemRenderAction: function _getItemRenderAction() {
    return this._itemRenderAction || this._createItemRenderAction();
  },
  _getItemTemplateName: function _getItemTemplateName(args) {
    var data = args.itemData;
    var templateProperty = args.templateProperty || this.option('itemTemplateProperty');
    var template = data && data[templateProperty];
    return template || args.defaultTemplateName;
  },
  _createItemByTemplate: function _createItemByTemplate(itemTemplate, renderArgs) {
    return itemTemplate.render({
      model: renderArgs.itemData,
      container: renderArgs.container,
      index: renderArgs.index
    });
  },
  _emptyMessageContainer: function _emptyMessageContainer() {
    return this._itemContainer();
  },
  _renderEmptyMessage: function _renderEmptyMessage(items) {
    items = items || this.option('items');
    var noDataText = this.option('noDataText');

    var hideNoData = !noDataText || items && items.length || this._isDataSourceLoading();

    if (hideNoData && this._$noData) {
      this._$noData.remove();

      this._$noData = null;
      this.setAria('label', undefined);
    }

    if (!hideNoData) {
      this._$noData = this._$noData || (0, _renderer.default)('<div>').addClass('dx-empty-message');

      this._$noData.appendTo(this._emptyMessageContainer()).html(noDataText);

      this.setAria('label', noDataText);
    }

    this.$element().toggleClass(EMPTY_COLLECTION, !hideNoData);
  },
  _itemDXEventHandler: function _itemDXEventHandler(dxEvent, handlerOptionName, actionArgs, actionConfig) {
    this._itemEventHandler(dxEvent.target, handlerOptionName, (0, _extend.extend)(actionArgs, {
      event: dxEvent
    }), actionConfig);
  },
  _itemEventHandler: function _itemEventHandler(initiator, handlerOptionName, actionArgs, actionConfig) {
    var action = this._createActionByOption(handlerOptionName, (0, _extend.extend)({
      validatingTargetName: 'itemElement'
    }, actionConfig));

    return this._itemEventHandlerImpl(initiator, action, actionArgs);
  },
  _itemEventHandlerByHandler: function _itemEventHandlerByHandler(initiator, handler, actionArgs, actionConfig) {
    var action = this._createAction(handler, (0, _extend.extend)({
      validatingTargetName: 'itemElement'
    }, actionConfig));

    return this._itemEventHandlerImpl(initiator, action, actionArgs);
  },
  _itemEventHandlerImpl: function _itemEventHandlerImpl(initiator, action, actionArgs) {
    var $itemElement = this._closestItemElement((0, _renderer.default)(initiator));

    var args = (0, _extend.extend)({}, actionArgs);
    return action((0, _extend.extend)(actionArgs, this._extendActionArgs($itemElement), args));
  },
  _extendActionArgs: function _extendActionArgs($itemElement) {
    return {
      itemElement: (0, _element.getPublicElement)($itemElement),
      itemIndex: this._itemElements().index($itemElement),
      itemData: this._getItemData($itemElement)
    };
  },
  _closestItemElement: function _closestItemElement($element) {
    return (0, _renderer.default)($element).closest(this._itemSelector());
  },
  _getItemData: function _getItemData(itemElement) {
    return (0, _renderer.default)(itemElement).data(this._itemDataKey());
  },
  _getSummaryItemsWidth: function _getSummaryItemsWidth(items, includeMargin) {
    var result = 0;

    if (items) {
      (0, _iterator.each)(items, function (_, item) {
        result += (0, _renderer.default)(item).outerWidth(includeMargin || false);
      });
    }

    return result;
  },

  /**
  * @name CollectionWidget.getFocusedItemId
  * @publicName getFocusedItemId()
  * @return string
  * @hidden
  */
  getFocusedItemId: function getFocusedItemId() {
    if (!this._focusedItemId) {
      this._focusedItemId = 'dx-' + new _guid.default();
    }

    return this._focusedItemId;
  },

  /**
  * @name CollectionWidget.itemElements
  * @publicName itemElements()
  * @return Array<Element>
  * @hidden
  */
  itemElements: function itemElements() {
    return this._itemElements();
  },

  /**
  * @name CollectionWidget.itemsContainer
  * @publicName itemsContainer()
  * @return Element
  * @hidden
  */
  itemsContainer: function itemsContainer() {
    return this._itemContainer();
  }
}).include(_data_helper.default);

CollectionWidget.ItemClass = _item.default;
var _default = CollectionWidget;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _utils = __webpack_require__(65);

var OperationManager = /*#__PURE__*/function () {
  function OperationManager() {
    this._counter = -1;
    this._deferreds = {};
  }

  var _proto = OperationManager.prototype;

  _proto.add = function add(deferred) {
    this._counter++;
    this._deferreds[this._counter] = deferred;
    return this._counter;
  };

  _proto.remove = function remove(operationId) {
    return delete this._deferreds[operationId];
  };

  _proto.cancel = function cancel(operationId) {
    if (operationId in this._deferreds) {
      this._deferreds[operationId].reject(_utils.CANCELED_TOKEN);

      return true;
    }

    return false;
  };

  _proto.cancelAll = function cancelAll() {
    while (this._counter > -1) {
      this.cancel(this._counter);
      this._counter--;
    }
  };

  return OperationManager;
}();

exports.default = OperationManager;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _class = _interopRequireDefault(__webpack_require__(15));

var _common = __webpack_require__(4);

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _type = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var abstract = _class.default.abstract;

var EditStrategy = _class.default.inherit({
  ctor: function ctor(collectionWidget) {
    this._collectionWidget = collectionWidget;
  },
  getIndexByItemData: abstract,
  getItemDataByIndex: abstract,
  getKeysByItems: abstract,
  getItemsByKeys: abstract,
  itemsGetter: abstract,
  getKeyByIndex: function getKeyByIndex(index) {
    var resultIndex = this._denormalizeItemIndex(index);

    return this.getKeysByItems([this.getItemDataByIndex(resultIndex)])[0];
  },
  _equalKeys: function _equalKeys(key1, key2) {
    if (this._collectionWidget._isKeySpecified()) {
      return (0, _common.equalByValue)(key1, key2);
    } else {
      return key1 === key2;
    }
  },
  beginCache: function beginCache() {
    this._cache = {};
  },
  endCache: function endCache() {
    this._cache = null;
  },
  getIndexByKey: abstract,
  getNormalizedIndex: function getNormalizedIndex(value) {
    if (this._isNormalizedItemIndex(value)) {
      return value;
    }

    if (this._isItemIndex(value)) {
      return this._normalizeItemIndex(value);
    }

    if (this._isNode(value)) {
      return this._getNormalizedItemIndex(value);
    }

    return this._normalizeItemIndex(this.getIndexByItemData(value));
  },
  getIndex: function getIndex(value) {
    if (this._isNormalizedItemIndex(value)) {
      return this._denormalizeItemIndex(value);
    }

    if (this._isItemIndex(value)) {
      return value;
    }

    if (this._isNode(value)) {
      return this._denormalizeItemIndex(this._getNormalizedItemIndex(value));
    }

    return this.getIndexByItemData(value);
  },
  getItemElement: function getItemElement(value) {
    if (this._isNormalizedItemIndex(value)) {
      return this._getItemByNormalizedIndex(value);
    }

    if (this._isItemIndex(value)) {
      return this._getItemByNormalizedIndex(this._normalizeItemIndex(value));
    }

    if (this._isNode(value)) {
      return (0, _renderer.default)(value);
    }

    var normalizedItemIndex = this._normalizeItemIndex(this.getIndexByItemData(value));

    return this._getItemByNormalizedIndex(normalizedItemIndex);
  },
  _isNode: function _isNode(el) {
    return _dom_adapter.default.isNode(el && (0, _type.isRenderer)(el) ? el.get(0) : el);
  },
  deleteItemAtIndex: abstract,
  itemPlacementFunc: function itemPlacementFunc(movingIndex, destinationIndex) {
    return this._itemsFromSameParent(movingIndex, destinationIndex) && movingIndex < destinationIndex ? 'after' : 'before';
  },
  moveItemAtIndexToIndex: abstract,
  _isNormalizedItemIndex: function _isNormalizedItemIndex(index) {
    return typeof index === 'number' && Math.round(index) === index;
  },
  _isItemIndex: abstract,
  _getNormalizedItemIndex: abstract,
  _normalizeItemIndex: abstract,
  _denormalizeItemIndex: abstract,
  _getItemByNormalizedIndex: abstract,
  _itemsFromSameParent: abstract
});

var _default = EditStrategy;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _type = __webpack_require__(1);

var _selection = _interopRequireDefault(__webpack_require__(270));

var _ui = _interopRequireDefault(__webpack_require__(19));

var _query = _interopRequireDefault(__webpack_require__(49));

var _deferred = __webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = _selection.default.inherit({
  getSelectedItems: function getSelectedItems() {
    return this._loadFilteredData(this.options.selectionFilter);
  },
  getSelectedItemKeys: function getSelectedItemKeys() {
    var d = new _deferred.Deferred();
    var that = this;
    var key = this.options.key();
    var select = (0, _type.isString)(key) ? [key] : key;

    this._loadFilteredData(this.options.selectionFilter, null, select).done(function (items) {
      var keys = items.map(function (item) {
        return that.options.keyOf(item);
      });
      d.resolve(keys);
    }).fail(d.reject);

    return d.promise();
  },
  selectedItemKeys: function selectedItemKeys(keys, preserve, isDeselect, isSelectAll) {
    if (isSelectAll) {
      var filter = this.options.filter();
      var needResetSelectionFilter = !filter || JSON.stringify(filter) === JSON.stringify(this.options.selectionFilter) && isDeselect;

      if (needResetSelectionFilter) {
        this._setOption('selectionFilter', isDeselect ? [] : null);
      } else {
        this._addSelectionFilter(isDeselect, filter, isSelectAll);
      }
    } else {
      if (!preserve) {
        this._setOption('selectionFilter', []);
      }

      for (var i = 0; i < keys.length; i++) {
        if (isDeselect) {
          this.removeSelectedItem(keys[i]);
        } else {
          this.addSelectedItem(keys[i]);
        }
      }
    }

    this.onSelectionChanged();
    return new _deferred.Deferred().resolve();
  },
  setSelectedItems: function setSelectedItems(keys) {
    this._setOption('selectionFilter', null);

    for (var i = 0; i < keys.length; i++) {
      this.addSelectedItem(keys[i]);
    }
  },
  isItemDataSelected: function isItemDataSelected(itemData) {
    return this.isItemKeySelected(itemData);
  },
  isItemKeySelected: function isItemKeySelected(itemData) {
    var selectionFilter = this.options.selectionFilter;

    if (!selectionFilter) {
      return true;
    }

    return !!(0, _query.default)([itemData]).filter(selectionFilter).toArray().length;
  },
  _getKeyExpr: function _getKeyExpr() {
    var keyField = this.options.key();

    if (Array.isArray(keyField) && keyField.length === 1) {
      return keyField[0];
    }

    return keyField;
  },
  _normalizeKey: function _normalizeKey(key) {
    var keyExpr = this.options.key();

    if (Array.isArray(keyExpr) && keyExpr.length === 1) {
      return key[keyExpr[0]];
    }

    return key;
  },
  _getFilterByKey: function _getFilterByKey(key) {
    var keyField = this._getKeyExpr();

    var filter = [keyField, '=', this._normalizeKey(key)];

    if (Array.isArray(keyField)) {
      filter = [];

      for (var i = 0; i < keyField.length; i++) {
        filter.push([keyField[i], '=', key[keyField[i]]]);

        if (i !== keyField.length - 1) {
          filter.push('and');
        }
      }
    }

    return filter;
  },
  addSelectedItem: function addSelectedItem(key) {
    var filter = this._getFilterByKey(key);

    this._addSelectionFilter(false, filter);
  },
  removeSelectedItem: function removeSelectedItem(key) {
    var filter = this._getFilterByKey(key);

    this._addSelectionFilter(true, filter);
  },
  validate: function validate() {
    var key = this.options.key;

    if (key && key() === undefined) {
      throw _ui.default.Error('E1042', 'Deferred selection');
    }
  },
  _findSubFilter: function _findSubFilter(selectionFilter, filter) {
    if (!selectionFilter) return -1;
    var filterString = JSON.stringify(filter);

    for (var index = 0; index < selectionFilter.length; index++) {
      var subFilter = selectionFilter[index];

      if (subFilter && JSON.stringify(subFilter) === filterString) {
        return index;
      }
    }

    return -1;
  },
  _isLastSubFilter: function _isLastSubFilter(selectionFilter, filter) {
    if (selectionFilter && filter) {
      return this._findSubFilter(selectionFilter, filter) === selectionFilter.length - 1 || this._findSubFilter([selectionFilter], filter) === 0;
    }

    return false;
  },
  _addFilterOperator: function _addFilterOperator(selectionFilter, filterOperator) {
    if (selectionFilter.length > 1 && (0, _type.isString)(selectionFilter[1]) && selectionFilter[1] !== filterOperator) {
      selectionFilter = [selectionFilter];
    }

    if (selectionFilter.length) {
      selectionFilter.push(filterOperator);
    }

    return selectionFilter;
  },
  _denormalizeFilter: function _denormalizeFilter(filter) {
    if (filter && (0, _type.isString)(filter[0])) {
      filter = [filter];
    }

    return filter;
  },
  _addSelectionFilter: function _addSelectionFilter(isDeselect, filter, isSelectAll) {
    var that = this;
    var currentFilter = isDeselect ? ['!', filter] : filter;
    var currentOperation = isDeselect ? 'and' : 'or';
    var needAddFilter = true;
    var selectionFilter = that.options.selectionFilter || [];
    selectionFilter = that._denormalizeFilter(selectionFilter);

    if (selectionFilter && selectionFilter.length) {
      that._removeSameFilter(selectionFilter, filter, isDeselect, isSelectAll);

      var filterIndex = that._removeSameFilter(selectionFilter, filter, !isDeselect);

      var isKeyOperatorsAfterRemoved = this._isKeyFilter(filter) && this._hasKeyFiltersOnlyStartingFromIndex(selectionFilter, filterIndex);

      needAddFilter = filter.length && !isKeyOperatorsAfterRemoved;

      if (needAddFilter) {
        selectionFilter = that._addFilterOperator(selectionFilter, currentOperation);
      }
    }

    if (needAddFilter) {
      selectionFilter.push(currentFilter);
    }

    selectionFilter = that._normalizeFilter(selectionFilter);

    that._setOption('selectionFilter', !isDeselect && !selectionFilter.length ? null : selectionFilter);
  },
  _normalizeFilter: function _normalizeFilter(filter) {
    if (filter && filter.length === 1) {
      filter = filter[0];
    }

    return filter;
  },
  _removeFilterByIndex: function _removeFilterByIndex(filter, filterIndex, isSelectAll) {
    var operation = filter[1];

    if (filterIndex > 0) {
      filter.splice(filterIndex - 1, 2);
    } else {
      filter.splice(filterIndex, 2);
    }

    if (isSelectAll && operation === 'and') {
      filter.splice(0, filter.length);
    }
  },
  _isSimpleKeyFilter: function _isSimpleKeyFilter(filter, key) {
    return filter.length === 3 && filter[0] === key && filter[1] === '=';
  },
  _isKeyFilter: function _isKeyFilter(filter) {
    if (filter.length === 2 && filter[0] === '!') {
      return this._isKeyFilter(filter[1]);
    }

    var keyField = this._getKeyExpr();

    if (Array.isArray(keyField)) {
      if (filter.length !== keyField.length * 2 - 1) {
        return false;
      }

      for (var i = 0; i < keyField.length; i++) {
        if (i > 0 && filter[i * 2 - 1] !== 'and') {
          return false;
        }

        if (!this._isSimpleKeyFilter(filter[i * 2], keyField[i])) {
          return false;
        }
      }

      return true;
    }

    return this._isSimpleKeyFilter(filter, keyField);
  },
  _hasKeyFiltersOnlyStartingFromIndex: function _hasKeyFiltersOnlyStartingFromIndex(selectionFilter, filterIndex) {
    if (filterIndex >= 0) {
      for (var i = filterIndex; i < selectionFilter.length; i++) {
        if (typeof selectionFilter[i] !== 'string' && !this._isKeyFilter(selectionFilter[i])) {
          return false;
        }
      }

      return true;
    }

    return false;
  },
  _removeSameFilter: function _removeSameFilter(selectionFilter, filter, inverted, isSelectAll) {
    filter = inverted ? ['!', filter] : filter;

    if (JSON.stringify(filter) === JSON.stringify(selectionFilter)) {
      selectionFilter.splice(0, selectionFilter.length);
      return 0;
    }

    var filterIndex = this._findSubFilter(selectionFilter, filter);

    if (filterIndex >= 0) {
      this._removeFilterByIndex(selectionFilter, filterIndex, isSelectAll);

      return filterIndex;
    } else {
      for (var i = 0; i < selectionFilter.length; i++) {
        if (Array.isArray(selectionFilter[i]) && selectionFilter[i].length > 2) {
          var _filterIndex = this._removeSameFilter(selectionFilter[i], filter, false, isSelectAll);

          if (_filterIndex >= 0) {
            if (!selectionFilter[i].length) {
              this._removeFilterByIndex(selectionFilter, i, isSelectAll);
            } else if (selectionFilter[i].length === 1) {
              selectionFilter[i] = selectionFilter[i][0];
            }

            return _filterIndex;
          }
        }
      }

      return -1;
    }
  },
  getSelectAllState: function getSelectAllState() {
    var filter = this.options.filter();
    var selectionFilter = this.options.selectionFilter;
    if (!selectionFilter) return true;
    if (!selectionFilter.length) return false;
    if (!filter || !filter.length) return undefined;
    selectionFilter = this._denormalizeFilter(selectionFilter);

    if (this._isLastSubFilter(selectionFilter, filter)) {
      return true;
    }

    if (this._isLastSubFilter(selectionFilter, ['!', filter])) {
      return false;
    }

    return undefined;
  }
});

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _common = __webpack_require__(4);

var _type = __webpack_require__(1);

var _array = __webpack_require__(12);

var _array_compare = __webpack_require__(219);

var _query = _interopRequireDefault(__webpack_require__(49));

var _deferred = __webpack_require__(6);

var _selection_filter = __webpack_require__(284);

var _ui = _interopRequireDefault(__webpack_require__(19));

var _selection = _interopRequireDefault(__webpack_require__(270));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = _selection.default.inherit({
  ctor: function ctor(options) {
    this.callBase(options);

    this._initSelectedItemKeyHash();
  },
  _initSelectedItemKeyHash: function _initSelectedItemKeyHash() {
    this._setOption('keyHashIndices', this.options.equalByReference ? null : {});
  },
  getSelectedItemKeys: function getSelectedItemKeys() {
    return this.options.selectedItemKeys.slice(0);
  },
  getSelectedItems: function getSelectedItems() {
    return this.options.selectedItems.slice(0);
  },
  _preserveSelectionUpdate: function _preserveSelectionUpdate(items, isDeselect) {
    var keyOf = this.options.keyOf;
    var keyIndicesToRemoveMap;
    var keyIndex;
    var i;
    if (!keyOf) return;
    var isBatchDeselect = isDeselect && items.length > 1 && !this.options.equalByReference;

    if (isBatchDeselect) {
      keyIndicesToRemoveMap = {};
    }

    for (i = 0; i < items.length; i++) {
      var item = items[i];
      var key = keyOf(item);

      if (isDeselect) {
        keyIndex = this.removeSelectedItem(key, keyIndicesToRemoveMap);

        if (keyIndicesToRemoveMap && keyIndex >= 0) {
          keyIndicesToRemoveMap[keyIndex] = true;
        }
      } else {
        this.addSelectedItem(key, item);
      }
    }

    if (isBatchDeselect) {
      this._batchRemoveSelectedItems(keyIndicesToRemoveMap);
    }
  },
  _batchRemoveSelectedItems: function _batchRemoveSelectedItems(keyIndicesToRemoveMap) {
    var selectedItemKeys = this.options.selectedItemKeys.slice(0);
    var selectedItems = this.options.selectedItems.slice(0);
    this.options.selectedItemKeys.length = 0;
    this.options.selectedItems.length = 0;

    for (var i = 0; i < selectedItemKeys.length; i++) {
      if (!keyIndicesToRemoveMap[i]) {
        this.options.selectedItemKeys.push(selectedItemKeys[i]);
        this.options.selectedItems.push(selectedItems[i]);
      }
    }

    this._initSelectedItemKeyHash();

    this.updateSelectedItemKeyHash(this.options.selectedItemKeys);
  },
  _loadSelectedItemsCore: function _loadSelectedItemsCore(keys, isDeselect, isSelectAll) {
    var deferred = new _deferred.Deferred();
    var key = this.options.key();

    if (!keys.length && !isSelectAll) {
      deferred.resolve([]);
      return deferred;
    }

    var filter = this.options.filter();

    if (isSelectAll && isDeselect && !filter) {
      deferred.resolve(this.getSelectedItems());
      return deferred;
    }

    var selectionFilterCreator = new _selection_filter.SelectionFilterCreator(keys, isSelectAll);
    var combinedFilter = selectionFilterCreator.getCombinedFilter(key, filter);
    var deselectedItems = [];

    if (isDeselect) {
      deselectedItems = combinedFilter ? (0, _query.default)(this.options.selectedItems).filter(combinedFilter).toArray() : this.options.selectedItems.slice(0);
    }

    var filteredItems = deselectedItems.length ? deselectedItems : this.options.plainItems(true).filter(this.options.isSelectableItem).map(this.options.getItemData);
    var localFilter = selectionFilterCreator.getLocalFilter(this.options.keyOf, this.equalKeys.bind(this), this.options.equalByReference, key);
    filteredItems = filteredItems.filter(localFilter);

    if (deselectedItems.length || !isSelectAll && filteredItems.length === keys.length) {
      deferred.resolve(filteredItems);
    } else {
      deferred = this._loadFilteredData(combinedFilter, localFilter, null, isSelectAll);
    }

    return deferred;
  },
  _replaceSelectionUpdate: function _replaceSelectionUpdate(items) {
    var internalKeys = [];
    var keyOf = this.options.keyOf;
    if (!keyOf) return;

    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var key = keyOf(item);
      internalKeys.push(key);
    }

    this.setSelectedItems(internalKeys, items);
  },
  _warnOnIncorrectKeys: function _warnOnIncorrectKeys(keys) {
    var allowNullValue = this.options.allowNullValue;

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if ((!allowNullValue || key !== null) && !this.isItemKeySelected(key)) {
        _ui.default.log('W1002', key);
      }
    }
  },
  _isMultiSelectEnabled: function _isMultiSelectEnabled() {
    var mode = this.options.mode;
    return mode === 'all' || mode === 'multiple';
  },
  _requestInProgress: function _requestInProgress() {
    var _this$_lastLoadDeferr;

    return ((_this$_lastLoadDeferr = this._lastLoadDeferred) === null || _this$_lastLoadDeferr === void 0 ? void 0 : _this$_lastLoadDeferr.state()) === 'pending';
  },
  _concatRequestsItems: function _concatRequestsItems(keys, isDeselect, oldRequestItems) {
    var deselectedItems = isDeselect ? keys : [];
    return {
      addedItems: oldRequestItems.added.concat((0, _array.removeDuplicates)(keys, this.options.selectedItemKeys)),
      removedItems: oldRequestItems.removed.concat(deselectedItems),
      keys: keys
    };
  },
  _collectLastRequestData: function _collectLastRequestData(keys, isDeselect, isSelectAll) {
    var isDeselectAll = isDeselect && isSelectAll;
    var oldRequestItems = {
      added: [],
      removed: []
    };

    var multiSelectEnabled = this._isMultiSelectEnabled();

    var lastRequestData = multiSelectEnabled ? this._lastRequestData : {};

    if (multiSelectEnabled) {
      if (this._requestInProgress()) {
        if (isDeselectAll) {
          this._lastLoadDeferred.reject();

          lastRequestData = {};
        } else if (!(0, _array_compare.isKeysEqual)(keys, this.options.selectedItemKeys)) {
          oldRequestItems.added = lastRequestData.addedItems;
          oldRequestItems.removed = lastRequestData.removedItems;

          if (!isDeselect) {
            this._lastLoadDeferred.reject();
          }
        } else {
          lastRequestData = {};
        }
      }

      lastRequestData = this._concatRequestsItems(keys, isDeselect, oldRequestItems);
    }

    return lastRequestData;
  },
  _updateKeysByLastRequestData: function _updateKeysByLastRequestData(keys, isDeselect, isSelectAll) {
    var currentKeys = keys;

    if (this._isMultiSelectEnabled() && !isDeselect && !isSelectAll) {
      var _this$_lastRequestDat, _this$_lastRequestDat2;

      currentKeys = (0, _array.removeDuplicates)(keys.concat((_this$_lastRequestDat = this._lastRequestData) === null || _this$_lastRequestDat === void 0 ? void 0 : _this$_lastRequestDat.addedItems), (_this$_lastRequestDat2 = this._lastRequestData) === null || _this$_lastRequestDat2 === void 0 ? void 0 : _this$_lastRequestDat2.removedItems);
      currentKeys = (0, _array.uniqueValues)(currentKeys);
    }

    return currentKeys;
  },
  _loadSelectedItems: function _loadSelectedItems(keys, isDeselect, isSelectAll) {
    var that = this;
    var deferred = new _deferred.Deferred();
    this._lastRequestData = this._collectLastRequestData(keys, isDeselect, isSelectAll);
    (0, _deferred.when)(that._lastLoadDeferred).always(function () {
      var currentKeys = that._updateKeysByLastRequestData(keys, isDeselect, isSelectAll);

      that._loadSelectedItemsCore(currentKeys, isDeselect, isSelectAll).done(deferred.resolve).fail(deferred.reject);
    });
    that._lastLoadDeferred = deferred;
    return deferred;
  },
  selectedItemKeys: function selectedItemKeys(keys, preserve, isDeselect, isSelectAll) {
    var that = this;

    var deferred = that._loadSelectedItems(keys, isDeselect, isSelectAll);

    deferred.done(function (items) {
      if (preserve) {
        that._preserveSelectionUpdate(items, isDeselect);
      } else {
        that._replaceSelectionUpdate(items);
      }

      that.onSelectionChanged();
    });
    return deferred;
  },
  addSelectedItem: function addSelectedItem(key, itemData) {
    if ((0, _type.isDefined)(itemData) && itemData.disabled) {
      if (this.options.disabledItemKeys.indexOf(key) === -1) {
        this.options.disabledItemKeys.push(key);
      }

      return;
    }

    var keyHash = this._getKeyHash(key);

    if (this._indexOfSelectedItemKey(keyHash) === -1) {
      if (!(0, _type.isObject)(keyHash) && this.options.keyHashIndices) {
        this.options.keyHashIndices[keyHash] = [this.options.selectedItemKeys.length];
      }

      this.options.selectedItemKeys.push(key);
      this.options.addedItemKeys.push(key);
      this.options.addedItems.push(itemData);
      this.options.selectedItems.push(itemData);
    }
  },
  _getSelectedIndexByKey: function _getSelectedIndexByKey(key, ignoreIndicesMap) {
    var selectedItemKeys = this.options.selectedItemKeys;

    for (var index = 0; index < selectedItemKeys.length; index++) {
      if ((!ignoreIndicesMap || !ignoreIndicesMap[index]) && this.equalKeys(selectedItemKeys[index], key)) {
        return index;
      }
    }

    return -1;
  },
  _getSelectedIndexByHash: function _getSelectedIndexByHash(key, ignoreIndicesMap) {
    var indices = this.options.keyHashIndices[key];

    if (indices && indices.length > 1 && ignoreIndicesMap) {
      indices = indices.filter(function (index) {
        return !ignoreIndicesMap[index];
      });
    }

    return indices && indices[0] >= 0 ? indices[0] : -1;
  },
  _indexOfSelectedItemKey: function _indexOfSelectedItemKey(key, ignoreIndicesMap) {
    var selectedIndex;

    if (this.options.equalByReference) {
      selectedIndex = this.options.selectedItemKeys.indexOf(key);
    } else if ((0, _type.isObject)(key)) {
      selectedIndex = this._getSelectedIndexByKey(key, ignoreIndicesMap);
    } else {
      selectedIndex = this._getSelectedIndexByHash(key, ignoreIndicesMap);
    }

    return selectedIndex;
  },
  _shiftSelectedKeyIndices: function _shiftSelectedKeyIndices(keyIndex) {
    for (var currentKeyIndex = keyIndex; currentKeyIndex < this.options.selectedItemKeys.length; currentKeyIndex++) {
      var currentKey = this.options.selectedItemKeys[currentKeyIndex];
      var currentKeyHash = (0, _common.getKeyHash)(currentKey);
      var currentKeyIndices = this.options.keyHashIndices[currentKeyHash];
      if (!currentKeyIndices) continue;

      for (var i = 0; i < currentKeyIndices.length; i++) {
        if (currentKeyIndices[i] > keyIndex) {
          currentKeyIndices[i]--;
        }
      }
    }
  },
  removeSelectedItem: function removeSelectedItem(key, keyIndicesToRemoveMap) {
    var keyHash = this._getKeyHash(key);

    var isBatchDeselect = !!keyIndicesToRemoveMap;

    var keyIndex = this._indexOfSelectedItemKey(keyHash, keyIndicesToRemoveMap);

    if (keyIndex < 0) {
      return keyIndex;
    }

    this.options.removedItemKeys.push(key);
    this.options.removedItems.push(this.options.selectedItems[keyIndex]);

    if (isBatchDeselect) {
      return keyIndex;
    }

    this.options.selectedItemKeys.splice(keyIndex, 1);
    this.options.selectedItems.splice(keyIndex, 1);

    if ((0, _type.isObject)(keyHash) || !this.options.keyHashIndices) {
      return keyIndex;
    }

    var keyIndices = this.options.keyHashIndices[keyHash];

    if (!keyIndices) {
      return keyIndex;
    }

    keyIndices.shift();

    if (!keyIndices.length) {
      delete this.options.keyHashIndices[keyHash];
    }

    this._shiftSelectedKeyIndices(keyIndex);

    return keyIndex;
  },
  _updateAddedItemKeys: function _updateAddedItemKeys(keys, items) {
    for (var i = 0; i < keys.length; i++) {
      if (!this.isItemKeySelected(keys[i])) {
        this.options.addedItemKeys.push(keys[i]);
        this.options.addedItems.push(items[i]);
      }
    }
  },
  _updateRemovedItemKeys: function _updateRemovedItemKeys(keys, oldSelectedKeys, oldSelectedItems) {
    for (var i = 0; i < oldSelectedKeys.length; i++) {
      if (!this.isItemKeySelected(oldSelectedKeys[i])) {
        this.options.removedItemKeys.push(oldSelectedKeys[i]);
        this.options.removedItems.push(oldSelectedItems[i]);
      }
    }
  },
  _isItemSelectionInProgress: function _isItemSelectionInProgress(key, checkPending) {
    var shouldCheckPending = checkPending && this._lastRequestData && this._requestInProgress();

    if (shouldCheckPending) {
      return this._lastRequestData.addedItems && this._lastRequestData.addedItems.indexOf(key) !== -1;
    } else {
      return false;
    }
  },
  _getKeyHash: function _getKeyHash(key) {
    return this.options.equalByReference ? key : (0, _common.getKeyHash)(key);
  },
  setSelectedItems: function setSelectedItems(keys, items) {
    this._updateAddedItemKeys(keys, items);

    var oldSelectedKeys = this.options.selectedItemKeys;
    var oldSelectedItems = this.options.selectedItems;

    if (!this.options.equalByReference) {
      this._initSelectedItemKeyHash();

      this.updateSelectedItemKeyHash(keys);
    }

    this._setOption('selectedItemKeys', keys);

    this._setOption('selectedItems', items);

    this._updateRemovedItemKeys(keys, oldSelectedKeys, oldSelectedItems);
  },
  isItemDataSelected: function isItemDataSelected(itemData) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var key = this.options.keyOf(itemData);
    return this.isItemKeySelected(key, options);
  },
  isItemKeySelected: function isItemKeySelected(key) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var result = this._isItemSelectionInProgress(key, options.checkPending);

    if (!result) {
      var keyHash = this._getKeyHash(key);

      var index = this._indexOfSelectedItemKey(keyHash);

      result = index !== -1;
    }

    return result;
  },
  getSelectAllState: function getSelectAllState(visibleOnly) {
    if (visibleOnly) {
      return this._getVisibleSelectAllState();
    } else {
      return this._getFullSelectAllState();
    }
  }
});

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _event_registrator_callbacks = _interopRequireDefault(__webpack_require__(124));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _module = _interopRequireDefault(__webpack_require__(199));

var _angular = _interopRequireDefault(__webpack_require__(128));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
if (_angular.default) {
  _event_registrator_callbacks.default.add(function (name) {
    var ngEventName = name.slice(0, 2) + name.charAt(2).toUpperCase() + name.slice(3);

    _module.default.directive(ngEventName, ['$parse', function ($parse) {
      return function (scope, element, attr) {
        var attrValue = attr[ngEventName].trim();
        var handler;
        var eventOptions = {};

        if (attrValue.charAt(0) === '{') {
          eventOptions = scope.$eval(attrValue);
          handler = $parse(eventOptions.execute);
        } else {
          handler = $parse(attr[ngEventName]);
        }

        _events_engine.default.on(element, name, eventOptions, function (e) {
          scope.$apply(function () {
            handler(scope, {
              $event: e
            });
          });
        });
      };
    }]);
  });
}

/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _callbacks = _interopRequireDefault(__webpack_require__(28));

var _module = _interopRequireDefault(__webpack_require__(199));

var _angular = _interopRequireDefault(__webpack_require__(128));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
if (_angular.default) {
  _module.default.service('dxDigestCallbacks', ['$rootScope', function ($rootScope) {
    var begin = (0, _callbacks.default)();
    var prioritizedEnd = (0, _callbacks.default)();
    var end = (0, _callbacks.default)();
    var digestPhase = false;
    $rootScope.$watch(function () {
      if (digestPhase) {
        return;
      }

      digestPhase = true;
      begin.fire();
      $rootScope.$$postDigest(function () {
        digestPhase = false;
        prioritizedEnd.fire();
        end.fire();
      });
    });
    return {
      begin: {
        add: function add(callback) {
          if (digestPhase) {
            callback();
          }

          begin.add(callback);
        },
        remove: begin.remove.bind(begin)
      },
      end: {
        add: end.add.bind(end),
        addPrioritized: prioritizedEnd.add.bind(prioritizedEnd),
        remove: end.remove.bind(end)
      }
    };
  }]);
}

/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _action = _interopRequireDefault(__webpack_require__(121));

var _angular = _interopRequireDefault(__webpack_require__(128));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
if (_angular.default) {
  _action.default.registerExecutor({
    'ngExpression': {
      execute: function execute(e) {
        if (typeof e.action === 'string') {
          e.context.$eval(e.action);
        }
      }
    }
  });
}

/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _knockout = _interopRequireDefault(__webpack_require__(62));

var _errors = _interopRequireDefault(__webpack_require__(24));

var _version = __webpack_require__(71);

__webpack_require__(419);

__webpack_require__(421);

__webpack_require__(422);

__webpack_require__(423);

__webpack_require__(424);

__webpack_require__(425);

__webpack_require__(426);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
// Check availability in global environment
if (_knockout.default) {
  if ((0, _version.compare)(_knockout.default.version, [2, 3]) < 0) {
    throw _errors.default.Error('E0013');
  }
}

/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _renderer = _interopRequireDefault(__webpack_require__(2));

var _knockout = _interopRequireDefault(__webpack_require__(62));

var _callbacks = _interopRequireDefault(__webpack_require__(28));

var _type = __webpack_require__(1);

var _component_registrator_callbacks = _interopRequireDefault(__webpack_require__(144));

var _ui = _interopRequireDefault(__webpack_require__(20));

var _draggable = _interopRequireDefault(__webpack_require__(174));

var _template = __webpack_require__(420);

var _editor = _interopRequireDefault(__webpack_require__(53));

var _locker = _interopRequireDefault(__webpack_require__(269));

var _utils = __webpack_require__(271);

var _config = _interopRequireDefault(__webpack_require__(29));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
if (_knockout.default) {
  var LOCKS_DATA_KEY = 'dxKoLocks';
  var CREATED_WITH_KO_DATA_KEY = 'dxKoCreation';
  var editorsBindingHandlers = [];

  var registerComponentKoBinding = function registerComponentKoBinding(componentName, componentClass) {
    if (_editor.default.isEditor(componentClass.prototype)) {
      editorsBindingHandlers.push(componentName);
    }

    _knockout.default.bindingHandlers[componentName] = {
      init: function init(domNode, valueAccessor) {
        var $element = (0, _renderer.default)(domNode);
        var optionChangedCallbacks = (0, _callbacks.default)();
        var optionsByReference = {};
        var component;
        var knockoutConfig = (0, _config.default)().knockout;
        var isBindingPropertyPredicateName = knockoutConfig && knockoutConfig.isBindingPropertyPredicateName;
        var isBindingPropertyPredicate;
        var ctorOptions = {
          onInitializing: function onInitializing(options) {
            var _this = this;

            optionsByReference = this._getOptionsByReference();

            _knockout.default.computed(function () {
              var model = _knockout.default.unwrap(valueAccessor());

              if (component) {
                component.beginUpdate();
              }

              isBindingPropertyPredicate = isBindingPropertyPredicateName && model && model[isBindingPropertyPredicateName];
              unwrapModel(model);

              if (component) {
                component.endUpdate();
              } else {
                var _model$onInitializing;

                model === null || model === void 0 ? void 0 : (_model$onInitializing = model.onInitializing) === null || _model$onInitializing === void 0 ? void 0 : _model$onInitializing.call(_this, options);
              }
            }, null, {
              disposeWhenNodeIsRemoved: domNode
            });

            component = this;
          },
          modelByElement: function modelByElement($element) {
            if ($element.length) {
              var node = (0, _utils.getClosestNodeWithContext)($element.get(0));
              return _knockout.default.dataFor(node);
            }
          },
          nestedComponentOptions: function nestedComponentOptions(component) {
            return {
              modelByElement: component.option('modelByElement'),
              nestedComponentOptions: component.option('nestedComponentOptions')
            };
          },
          _optionChangedCallbacks: optionChangedCallbacks,
          integrationOptions: {
            watchMethod: function watchMethod(fn, callback, options) {
              options = options || {};
              var skipCallback = options.skipImmediate;

              var watcher = _knockout.default.computed(function () {
                var newValue = _knockout.default.unwrap(fn());

                if (!skipCallback) {
                  callback(newValue);
                }

                skipCallback = false;
              });

              return function () {
                watcher.dispose();
              };
            },
            templates: {
              'dx-polymorph-widget': {
                render: function render(options) {
                  var widgetName = _knockout.default.utils.unwrapObservable(options.model.widget);

                  if (!widgetName) {
                    return;
                  }

                  var markup = (0, _renderer.default)('<div>').attr('data-bind', widgetName + ': options').get(0);
                  (0, _renderer.default)(options.container).append(markup);

                  _knockout.default.applyBindings(options.model, markup);
                }
              }
            },
            createTemplate: function createTemplate(element) {
              return new _template.KoTemplate(element);
            }
          }
        };
        var optionNameToModelMap = {};

        var applyModelValueToOption = function applyModelValueToOption(optionName, modelValue, unwrap) {
          var locks = $element.data(LOCKS_DATA_KEY);
          var optionValue = unwrap ? _knockout.default.unwrap(modelValue) : modelValue;

          if (_knockout.default.isWriteableObservable(modelValue)) {
            optionNameToModelMap[optionName] = modelValue;
          }

          if (component) {
            if (locks.locked(optionName)) {
              return;
            }

            locks.obtain(optionName);

            try {
              if (_knockout.default.ignoreDependencies) {
                _knockout.default.ignoreDependencies(component.option, component, [optionName, optionValue]);
              } else {
                component.option(optionName, optionValue);
              }
            } finally {
              locks.release(optionName);
            }
          } else {
            ctorOptions[optionName] = optionValue;
          }
        };

        var handleOptionChanged = function handleOptionChanged(args) {
          var optionName = args.fullName;
          var optionValue = args.value;

          if (!(optionName in optionNameToModelMap)) {
            return;
          }

          var $element = this._$element;
          var locks = $element.data(LOCKS_DATA_KEY);

          if (locks.locked(optionName)) {
            return;
          }

          locks.obtain(optionName);

          try {
            optionNameToModelMap[optionName](optionValue);
          } finally {
            locks.release(optionName);
          }
        };

        var createComponent = function createComponent() {
          optionChangedCallbacks.add(handleOptionChanged);
          $element.data(CREATED_WITH_KO_DATA_KEY, true).data(LOCKS_DATA_KEY, new _locker.default());
          new componentClass($element, ctorOptions);
          ctorOptions = null;
        };

        var unwrapModelValue = function unwrapModelValue(currentModel, propertyName, propertyPath) {
          if (propertyPath === isBindingPropertyPredicateName) {
            return;
          }

          if (!isBindingPropertyPredicate || isBindingPropertyPredicate(propertyPath, propertyName, currentModel)) {
            var unwrappedPropertyValue;

            _knockout.default.computed(function () {
              var propertyValue = currentModel[propertyName];
              applyModelValueToOption(propertyPath, propertyValue, true);
              unwrappedPropertyValue = _knockout.default.unwrap(propertyValue);
            }, null, {
              disposeWhenNodeIsRemoved: domNode
            });

            if ((0, _type.isPlainObject)(unwrappedPropertyValue)) {
              if (!optionsByReference[propertyPath]) {
                unwrapModel(unwrappedPropertyValue, propertyPath);
              }
            }
          } else {
            applyModelValueToOption(propertyPath, currentModel[propertyName], false);
          }
        };

        function unwrapModel(model, propertyPath) {
          for (var propertyName in model) {
            if (Object.prototype.hasOwnProperty.call(model, propertyName)) {
              unwrapModelValue(model, propertyName, propertyPath ? [propertyPath, propertyName].join('.') : propertyName);
            }
          }
        }

        createComponent();
        return {
          controlsDescendantBindings: componentClass.subclassOf(_ui.default) || componentClass.subclassOf(_draggable.default)
        };
      }
    };

    if (componentName === 'dxValidator') {
      _knockout.default.bindingHandlers['dxValidator'].after = editorsBindingHandlers;
    }
  };

  _component_registrator_callbacks.default.add(function (name, componentClass) {
    registerComponentKoBinding(name, componentClass);
  });
}

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.KoTemplate = void 0;

var _renderer = _interopRequireDefault(__webpack_require__(2));

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _knockout = _interopRequireDefault(__webpack_require__(62));

var _type = __webpack_require__(1);

var _template_base = __webpack_require__(69);

var _dom = __webpack_require__(35);

var _utils = __webpack_require__(271);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var getParentContext = function getParentContext(data) {
  var parentNode = _dom_adapter.default.createElement('div');

  _knockout.default.applyBindingsToNode(parentNode, null, data);

  var parentContext = _knockout.default.contextFor(parentNode);

  _knockout.default.cleanNode(parentNode);

  return parentContext;
};

var KoTemplate = /*#__PURE__*/function (_TemplateBase) {
  _inheritsLoose(KoTemplate, _TemplateBase);

  function KoTemplate(element) {
    var _this;

    _this = _TemplateBase.call(this) || this;
    _this._element = element;
    _this._template = (0, _renderer.default)('<div>').append((0, _dom.normalizeTemplateElement)(element));

    _this._registerKoTemplate();

    return _this;
  }

  var _proto = KoTemplate.prototype;

  _proto._registerKoTemplate = function _registerKoTemplate() {
    var template = this._template.get(0);

    new _knockout.default.templateSources.anonymousTemplate(template)['nodes'](template);
  };

  _proto._prepareDataForContainer = function _prepareDataForContainer(data, container) {
    if (container && container.length) {
      var node = (0, _utils.getClosestNodeWithContext)(container.get(0));

      var containerContext = _knockout.default.contextFor(node);

      data = data !== undefined ? data : _knockout.default.dataFor(node) || {};

      if (containerContext) {
        return data === containerContext.$data ? containerContext : containerContext.createChildContext(data);
      }
    } // workaround for https://github.com/knockout/knockout/pull/651


    return getParentContext(data).createChildContext(data);
  };

  _proto._renderCore = function _renderCore(options) {
    var model = this._prepareDataForContainer(options.model, (0, _renderer.default)(options.container));

    if ((0, _type.isDefined)(options.index)) {
      model.$index = options.index;
    }

    var $placeholder = (0, _renderer.default)('<div>').appendTo(options.container);
    var $result;

    _knockout.default.renderTemplate(this._template.get(0), model, {
      afterRender: function afterRender(nodes) {
        $result = (0, _renderer.default)(nodes);
      }
    }, $placeholder.get(0), 'replaceNode');

    return $result;
  };

  _proto.source = function source() {
    return (0, _renderer.default)(this._element).clone();
  };

  _proto.dispose = function dispose() {
    this._template.remove();
  };

  return KoTemplate;
}(_template_base.TemplateBase);

exports.KoTemplate = KoTemplate;

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _renderer = _interopRequireDefault(__webpack_require__(2));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _knockout = _interopRequireDefault(__webpack_require__(62));

var _type = __webpack_require__(1);

var _event_registrator_callbacks = _interopRequireDefault(__webpack_require__(124));

var _index = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
if (_knockout.default) {
  _event_registrator_callbacks.default.add(function (name) {
    var koBindingEventName = (0, _index.addNamespace)(name, name + 'Binding');
    _knockout.default.bindingHandlers[name] = {
      update: function update(element, valueAccessor, allBindingsAccessor, viewModel) {
        var $element = (0, _renderer.default)(element);

        var unwrappedValue = _knockout.default.utils.unwrapObservable(valueAccessor());

        var eventSource = unwrappedValue.execute ? unwrappedValue.execute : unwrappedValue;

        _events_engine.default.off($element, koBindingEventName);

        _events_engine.default.on($element, koBindingEventName, (0, _type.isPlainObject)(unwrappedValue) ? unwrappedValue : {}, function (e) {
          eventSource.call(viewModel, viewModel, e);
        });
      }
    };
  });
}

/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _knockout = _interopRequireDefault(__webpack_require__(62));

var _icon = __webpack_require__(54);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
if (_knockout.default) {
  _knockout.default.bindingHandlers.dxControlsDescendantBindings = {
    init: function init(_, valueAccessor) {
      return {
        controlsDescendantBindings: _knockout.default.unwrap(valueAccessor())
      };
    }
  };
  _knockout.default.bindingHandlers.dxIcon = {
    init: function init(element, valueAccessor) {
      var options = _knockout.default.utils.unwrapObservable(valueAccessor()) || {};
      var iconElement = (0, _icon.getImageContainer)(options);

      _knockout.default.virtualElements.emptyNode(element);

      if (iconElement) {
        _knockout.default.virtualElements.prepend(element, iconElement.get(0));
      }
    },
    update: function update(element, valueAccessor) {
      var options = _knockout.default.utils.unwrapObservable(valueAccessor()) || {};
      var iconElement = (0, _icon.getImageContainer)(options);

      _knockout.default.virtualElements.emptyNode(element);

      if (iconElement) {
        _knockout.default.virtualElements.prepend(element, iconElement.get(0));
      }
    }
  };
  _knockout.default.virtualElements.allowedBindings.dxIcon = true;
}

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _iterator = __webpack_require__(3);

var _extend = __webpack_require__(0);

var _class = _interopRequireDefault(__webpack_require__(15));

var _events_strategy = __webpack_require__(96);

var _validation_engine = _interopRequireDefault(__webpack_require__(94));

var _deferred = __webpack_require__(6);

var _guid = _interopRequireDefault(__webpack_require__(36));

var _knockout = _interopRequireDefault(__webpack_require__(62));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
if (_knockout.default) {
  var VALIDATION_STATUS_VALID = 'valid';
  var VALIDATION_STATUS_PENDING = 'pending';

  var koDxValidator = _class.default.inherit({
    ctor: function ctor(target, _ref) {
      var _this = this;

      var name = _ref.name,
          validationRules = _ref.validationRules;
      this.target = target;
      this.name = name;
      this.isValid = _knockout.default.observable(true);
      this.validationError = _knockout.default.observable();
      this.validationErrors = _knockout.default.observable();
      this.validationStatus = _knockout.default.observable(VALIDATION_STATUS_VALID);
      this._eventsStrategy = new _events_strategy.EventsStrategy(this);
      this.validationRules = (0, _iterator.map)(validationRules, function (rule, index) {
        return (0, _extend.extend)({}, rule, {
          validator: _this,
          index: index
        });
      });
      this._validationInfo = {
        result: null,
        deferred: null
      };
    },
    _updateValidationResult: function _updateValidationResult(result) {
      if (!this._validationInfo.result || this._validationInfo.result.id !== result.id) {
        var complete = this._validationInfo.deferred && this._validationInfo.result.complete;
        this._validationInfo.result = (0, _extend.extend)({}, result, {
          complete: complete
        });
      } else {
        for (var prop in result) {
          if (prop !== 'id' && prop !== 'complete') {
            this._validationInfo.result[prop] = result[prop];
          }
        }
      }
    },
    validate: function validate() {
      var _this2 = this;

      var currentResult = this._validationInfo && this._validationInfo.result;
      var value = this.target();

      if (currentResult && currentResult.status === VALIDATION_STATUS_PENDING && currentResult.value === value) {
        return (0, _extend.extend)({}, currentResult);
      }

      var result = _validation_engine.default.validate(value, this.validationRules, this.name);

      result.id = new _guid.default().toString();

      this._applyValidationResult(result);

      result.complete && result.complete.then(function (res) {
        if (res.id === _this2._validationInfo.result.id) {
          _this2._applyValidationResult(res);
        }
      });
      return (0, _extend.extend)({}, this._validationInfo.result);
    },
    reset: function reset() {
      this.target(null);
      var result = {
        id: null,
        isValid: true,
        brokenRule: null,
        pendingRules: null,
        status: VALIDATION_STATUS_VALID,
        complete: null
      };

      this._applyValidationResult(result);

      return result;
    },
    _applyValidationResult: function _applyValidationResult(result) {
      result.validator = this;

      this._updateValidationResult(result);

      this.target.dxValidator.isValid(this._validationInfo.result.isValid);
      this.target.dxValidator.validationError(this._validationInfo.result.brokenRule);
      this.target.dxValidator.validationErrors(this._validationInfo.result.brokenRules);
      this.target.dxValidator.validationStatus(this._validationInfo.result.status);

      if (result.status === VALIDATION_STATUS_PENDING) {
        if (!this._validationInfo.deferred) {
          this._validationInfo.deferred = new _deferred.Deferred();
          this._validationInfo.result.complete = this._validationInfo.deferred.promise();
        }

        this._eventsStrategy.fireEvent('validating', [this._validationInfo.result]);

        return;
      }

      if (result.status !== VALIDATION_STATUS_PENDING) {
        this._eventsStrategy.fireEvent('validated', [result]);

        if (this._validationInfo.deferred) {
          this._validationInfo.deferred.resolve(result);

          this._validationInfo.deferred = null;
        }
      }
    },
    on: function on(eventName, eventHandler) {
      this._eventsStrategy.on(eventName, eventHandler);

      return this;
    },
    off: function off(eventName, eventHandler) {
      this._eventsStrategy.off(eventName, eventHandler);

      return this;
    }
  });

  _knockout.default.extenders.dxValidator = function (target, option) {
    target.dxValidator = new koDxValidator(target, option);
    target.subscribe(target.dxValidator.validate.bind(target.dxValidator));
    return target;
  }; // TODO: MODULARITY: Move this to another place?


  _validation_engine.default.registerModelForValidation = function (model) {
    (0, _iterator.each)(model, function (name, member) {
      if (_knockout.default.isObservable(member) && member.dxValidator) {
        _validation_engine.default.registerValidatorInGroup(model, member.dxValidator);
      }
    });
  };

  _validation_engine.default.unregisterModelForValidation = function (model) {
    (0, _iterator.each)(model, function (name, member) {
      if (_knockout.default.isObservable(member) && member.dxValidator) {
        _validation_engine.default.removeRegisteredValidator(model, member.dxValidator);
      }
    });
  };

  _validation_engine.default.validateModel = _validation_engine.default.validateGroup;
}

/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _knockout = _interopRequireDefault(__webpack_require__(62));

var _variable_wrapper = _interopRequireDefault(__webpack_require__(105));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
if (_knockout.default) {
  _variable_wrapper.default.inject({
    isWrapped: _knockout.default.isObservable,
    isWritableWrapped: _knockout.default.isWritableObservable,
    wrap: _knockout.default.observable,
    unwrap: function unwrap(value) {
      if (_knockout.default.isObservable(value)) {
        return _knockout.default.utils.unwrapObservable(value);
      }

      return this.callBase(value);
    },
    assign: function assign(variable, value) {
      if (_knockout.default.isObservable(variable)) {
        variable(value);
      } else {
        this.callBase(variable, value);
      }
    }
  });
}

/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _element_data = __webpack_require__(43);

var _knockout = _interopRequireDefault(__webpack_require__(62));

var _version = __webpack_require__(71);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
if (_knockout.default) {
  var originalKOCleanExternalData = _knockout.default.utils.domNodeDisposal.cleanExternalData;

  var patchCleanData = function patchCleanData() {
    (0, _element_data.afterCleanData)(function (nodes) {
      var i;

      for (i = 0; i < nodes.length; i++) {
        nodes[i].cleanedByJquery = true;
      }

      for (i = 0; i < nodes.length; i++) {
        if (!nodes[i].cleanedByKo) {
          _knockout.default.cleanNode(nodes[i]);
        }

        delete nodes[i].cleanedByKo;
      }

      for (i = 0; i < nodes.length; i++) {
        delete nodes[i].cleanedByJquery;
      }
    });

    _knockout.default.utils.domNodeDisposal.cleanExternalData = function (node) {
      node.cleanedByKo = true;

      if (!node.cleanedByJquery) {
        (0, _element_data.cleanData)([node]);
      }
    };
  };

  var restoreOriginCleanData = function restoreOriginCleanData() {
    (0, _element_data.afterCleanData)(function () {});
    _knockout.default.utils.domNodeDisposal.cleanExternalData = originalKOCleanExternalData;
  };

  patchCleanData();

  _element_data.strategyChanging.add(function (strategy) {
    var isJQuery = !!strategy.fn;

    if (isJQuery && (0, _version.compare)(strategy.fn.jquery, [2, 0]) < 0) {
      restoreOriginCleanData();
    }
  });
}

/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _knockout = _interopRequireDefault(__webpack_require__(62));

var _version = __webpack_require__(71);

var _element_data = __webpack_require__(43);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
if (_knockout.default) {
  var patchCleanData = function patchCleanData(jQuery) {
    var cleanKoData = function cleanKoData(element, andSelf) {
      var cleanNode = function cleanNode() {
        _knockout.default.cleanNode(this);
      };

      if (andSelf) {
        element.each(cleanNode);
      } else {
        element.find('*').each(cleanNode);
      }
    };

    var originalEmpty = jQuery.fn.empty;

    jQuery.fn.empty = function () {
      cleanKoData(this, false);
      return originalEmpty.apply(this, arguments);
    };

    var originalRemove = jQuery.fn.remove;

    jQuery.fn.remove = function (selector, keepData) {
      if (!keepData) {
        var subject = this;

        if (selector) {
          subject = subject.filter(selector);
        }

        cleanKoData(subject, true);
      }

      return originalRemove.call(this, selector, keepData);
    };

    var originalHtml = jQuery.fn.html;

    jQuery.fn.html = function (value) {
      if (typeof value === 'string') {
        cleanKoData(this, false);
      }

      return originalHtml.apply(this, arguments);
    };

    var originalReplaceWith = jQuery.fn.replaceWith;

    jQuery.fn.replaceWith = function () {
      var result = originalReplaceWith.apply(this, arguments);

      if (!this.parent().length) {
        cleanKoData(this, true);
      }

      return result;
    };
  };

  _element_data.strategyChanging.add(function (strategy) {
    var isJQuery = !!strategy.fn;

    if (isJQuery && (0, _version.compare)(strategy.fn.jquery, [2, 0]) < 0) {
      patchCleanData(strategy);
    }
  });
}

/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(130);

var _globalize = _interopRequireDefault(__webpack_require__(74));

var _message = _interopRequireDefault(__webpack_require__(10));

var _core2 = _interopRequireDefault(__webpack_require__(85));

__webpack_require__(74);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
// eslint-disable-next-line no-restricted-imports
if (_globalize.default && _globalize.default.formatMessage) {
  var DEFAULT_LOCALE = 'en';
  var originalLoadMessages = _globalize.default.loadMessages;

  _globalize.default.loadMessages = function (messages) {
    _message.default.load(messages);
  };

  var globalizeMessageLocalization = {
    engine: function engine() {
      return 'globalize';
    },
    ctor: function ctor() {
      this.load(this._dictionary);
    },
    load: function load(messages) {
      this.callBase(messages);
      originalLoadMessages(messages);
    },
    getMessagesByLocales: function getMessagesByLocales() {
      return _globalize.default.cldr.get('globalize-messages');
    },
    getFormatter: function getFormatter(key, locale) {
      var currentLocale = locale || _core2.default.locale();

      var formatter = this._getFormatterBase(key, locale);

      if (!formatter) {
        formatter = this._formatterByGlobalize(key, locale);
      }

      if (!formatter && currentLocale !== DEFAULT_LOCALE) {
        formatter = this.getFormatter(key, DEFAULT_LOCALE);
      }

      return formatter;
    },
    _formatterByGlobalize: function _formatterByGlobalize(key, locale) {
      var currentGlobalize = !locale || locale === _core2.default.locale() ? _globalize.default : new _globalize.default(locale);
      var result;

      if (this._messageLoaded(key, locale)) {
        result = currentGlobalize.messageFormatter(key);
      }

      return result;
    },
    _messageLoaded: function _messageLoaded(key, locale) {
      var currentCldr = locale ? new _globalize.default(locale).cldr : _globalize.default.locale();
      var value = currentCldr.get(['globalize-messages/{bundle}', key]);
      return !!value;
    },
    _loadSingle: function _loadSingle(key, value, locale) {
      var data = {};
      data[locale] = {};
      data[locale][key] = value;
      this.load(data);
    }
  };

  _message.default.inject(globalizeMessageLocalization);
}

/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

__webpack_require__(130);

__webpack_require__(200);

__webpack_require__(74);

var _globalize = _interopRequireDefault(__webpack_require__(74));

var _date2 = _interopRequireDefault(__webpack_require__(33));

var _type = __webpack_require__(1);

var _array = __webpack_require__(12);

var iteratorUtils = _interopRequireWildcard(__webpack_require__(3));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line no-restricted-imports
var timeData = {
  'supplemental': {
    'version': {
      '_cldrVersion': '28',
      '_unicodeVersion': '8.0.0',
      '_number': '$Revision: 11969 $'
    },
    'timeData': {
      '001': {
        '_allowed': 'H h',
        '_preferred': 'H'
      },
      'DE': {
        '_allowed': 'H',
        '_preferred': 'H'
      },
      'JP': {
        '_allowed': 'H K h',
        '_preferred': 'H'
      },
      'RU': {
        '_allowed': 'H',
        '_preferred': 'H'
      },
      'US': {
        '_allowed': 'H h',
        '_preferred': 'h'
      }
    }
  }
};
var enCaGregorian = {
  'main': {
    'en': {
      'identity': {
        'version': {
          '_cldrVersion': '28',
          '_number': '$Revision: 11972 $'
        },
        'language': 'en'
      },
      'dates': {
        'calendars': {
          'gregorian': {
            'months': {
              'format': {
                'abbreviated': {
                  '1': 'Jan',
                  '2': 'Feb',
                  '3': 'Mar',
                  '4': 'Apr',
                  '5': 'May',
                  '6': 'Jun',
                  '7': 'Jul',
                  '8': 'Aug',
                  '9': 'Sep',
                  '10': 'Oct',
                  '11': 'Nov',
                  '12': 'Dec'
                },
                'narrow': {
                  '1': 'J',
                  '2': 'F',
                  '3': 'M',
                  '4': 'A',
                  '5': 'M',
                  '6': 'J',
                  '7': 'J',
                  '8': 'A',
                  '9': 'S',
                  '10': 'O',
                  '11': 'N',
                  '12': 'D'
                },
                'wide': {
                  '1': 'January',
                  '2': 'February',
                  '3': 'March',
                  '4': 'April',
                  '5': 'May',
                  '6': 'June',
                  '7': 'July',
                  '8': 'August',
                  '9': 'September',
                  '10': 'October',
                  '11': 'November',
                  '12': 'December'
                }
              },
              'stand-alone': {
                'abbreviated': {
                  '1': 'Jan',
                  '2': 'Feb',
                  '3': 'Mar',
                  '4': 'Apr',
                  '5': 'May',
                  '6': 'Jun',
                  '7': 'Jul',
                  '8': 'Aug',
                  '9': 'Sep',
                  '10': 'Oct',
                  '11': 'Nov',
                  '12': 'Dec'
                },
                'narrow': {
                  '1': 'J',
                  '2': 'F',
                  '3': 'M',
                  '4': 'A',
                  '5': 'M',
                  '6': 'J',
                  '7': 'J',
                  '8': 'A',
                  '9': 'S',
                  '10': 'O',
                  '11': 'N',
                  '12': 'D'
                },
                'wide': {
                  '1': 'January',
                  '2': 'February',
                  '3': 'March',
                  '4': 'April',
                  '5': 'May',
                  '6': 'June',
                  '7': 'July',
                  '8': 'August',
                  '9': 'September',
                  '10': 'October',
                  '11': 'November',
                  '12': 'December'
                }
              }
            },
            'days': {
              'format': {
                'abbreviated': {
                  'sun': 'Sun',
                  'mon': 'Mon',
                  'tue': 'Tue',
                  'wed': 'Wed',
                  'thu': 'Thu',
                  'fri': 'Fri',
                  'sat': 'Sat'
                },
                'narrow': {
                  'sun': 'S',
                  'mon': 'M',
                  'tue': 'T',
                  'wed': 'W',
                  'thu': 'T',
                  'fri': 'F',
                  'sat': 'S'
                },
                'short': {
                  'sun': 'Su',
                  'mon': 'Mo',
                  'tue': 'Tu',
                  'wed': 'We',
                  'thu': 'Th',
                  'fri': 'Fr',
                  'sat': 'Sa'
                },
                'wide': {
                  'sun': 'Sunday',
                  'mon': 'Monday',
                  'tue': 'Tuesday',
                  'wed': 'Wednesday',
                  'thu': 'Thursday',
                  'fri': 'Friday',
                  'sat': 'Saturday'
                }
              },
              'stand-alone': {
                'abbreviated': {
                  'sun': 'Sun',
                  'mon': 'Mon',
                  'tue': 'Tue',
                  'wed': 'Wed',
                  'thu': 'Thu',
                  'fri': 'Fri',
                  'sat': 'Sat'
                },
                'narrow': {
                  'sun': 'S',
                  'mon': 'M',
                  'tue': 'T',
                  'wed': 'W',
                  'thu': 'T',
                  'fri': 'F',
                  'sat': 'S'
                },
                'short': {
                  'sun': 'Su',
                  'mon': 'Mo',
                  'tue': 'Tu',
                  'wed': 'We',
                  'thu': 'Th',
                  'fri': 'Fr',
                  'sat': 'Sa'
                },
                'wide': {
                  'sun': 'Sunday',
                  'mon': 'Monday',
                  'tue': 'Tuesday',
                  'wed': 'Wednesday',
                  'thu': 'Thursday',
                  'fri': 'Friday',
                  'sat': 'Saturday'
                }
              }
            },
            'quarters': {
              'format': {
                'abbreviated': {
                  '1': 'Q1',
                  '2': 'Q2',
                  '3': 'Q3',
                  '4': 'Q4'
                },
                'narrow': {
                  '1': '1',
                  '2': '2',
                  '3': '3',
                  '4': '4'
                },
                'wide': {
                  '1': '1st quarter',
                  '2': '2nd quarter',
                  '3': '3rd quarter',
                  '4': '4th quarter'
                }
              },
              'stand-alone': {
                'abbreviated': {
                  '1': 'Q1',
                  '2': 'Q2',
                  '3': 'Q3',
                  '4': 'Q4'
                },
                'narrow': {
                  '1': '1',
                  '2': '2',
                  '3': '3',
                  '4': '4'
                },
                'wide': {
                  '1': '1st quarter',
                  '2': '2nd quarter',
                  '3': '3rd quarter',
                  '4': '4th quarter'
                }
              }
            },
            'dayPeriods': {
              'format': {
                'abbreviated': {
                  'midnight': 'midnight',
                  'am': 'AM',
                  'am-alt-variant': 'am',
                  'noon': 'noon',
                  'pm': 'PM',
                  'pm-alt-variant': 'pm',
                  'morning1': 'in the morning',
                  'afternoon1': 'in the afternoon',
                  'evening1': 'in the evening',
                  'night1': 'at night'
                },
                'narrow': {
                  'midnight': 'mi',
                  'am': 'a',
                  'am-alt-variant': 'am',
                  'noon': 'n',
                  'pm': 'p',
                  'pm-alt-variant': 'pm',
                  'morning1': 'in the morning',
                  'afternoon1': 'in the afternoon',
                  'evening1': 'in the evening',
                  'night1': 'at night'
                },
                'wide': {
                  'midnight': 'midnight',
                  'am': 'AM',
                  'am-alt-variant': 'am',
                  'noon': 'noon',
                  'pm': 'PM',
                  'pm-alt-variant': 'pm',
                  'morning1': 'in the morning',
                  'afternoon1': 'in the afternoon',
                  'evening1': 'in the evening',
                  'night1': 'at night'
                }
              },
              'stand-alone': {
                'abbreviated': {
                  'midnight': 'midnight',
                  'am': 'AM',
                  'am-alt-variant': 'am',
                  'noon': 'noon',
                  'pm': 'PM',
                  'pm-alt-variant': 'pm',
                  'morning1': 'in the morning',
                  'afternoon1': 'in the afternoon',
                  'evening1': 'in the evening',
                  'night1': 'at night'
                },
                'narrow': {
                  'midnight': 'midnight',
                  'am': 'AM',
                  'am-alt-variant': 'am',
                  'noon': 'noon',
                  'pm': 'PM',
                  'pm-alt-variant': 'pm',
                  'morning1': 'in the morning',
                  'afternoon1': 'in the afternoon',
                  'evening1': 'in the evening',
                  'night1': 'at night'
                },
                'wide': {
                  'midnight': 'midnight',
                  'am': 'AM',
                  'am-alt-variant': 'am',
                  'noon': 'noon',
                  'pm': 'PM',
                  'pm-alt-variant': 'pm',
                  'morning1': 'morning',
                  'afternoon1': 'afternoon',
                  'evening1': 'evening',
                  'night1': 'night'
                }
              }
            },
            'eras': {
              'eraNames': {
                '0': 'Before Christ',
                '0-alt-variant': 'Before Common Era',
                '1': 'Anno Domini',
                '1-alt-variant': 'Common Era'
              },
              'eraAbbr': {
                '0': 'BC',
                '0-alt-variant': 'BCE',
                '1': 'AD',
                '1-alt-variant': 'CE'
              },
              'eraNarrow': {
                '0': 'B',
                '0-alt-variant': 'BCE',
                '1': 'A',
                '1-alt-variant': 'CE'
              }
            },
            'dateFormats': {
              'full': 'EEEE, MMMM d, y',
              'long': 'MMMM d, y',
              'medium': 'MMM d, y',
              'short': 'M/d/yy'
            },
            'timeFormats': {
              'full': 'h:mm:ss a zzzz',
              'long': 'h:mm:ss a z',
              'medium': 'h:mm:ss a',
              'short': 'h:mm a'
            },
            'dateTimeFormats': {
              'full': '{1} \'at\' {0}',
              'long': '{1} \'at\' {0}',
              'medium': '{1}, {0}',
              'short': '{1}, {0}',
              'availableFormats': {
                'd': 'd',
                'E': 'ccc',
                'Ed': 'd E',
                'Ehm': 'E h:mm a',
                'EHm': 'E HH:mm',
                'Ehms': 'E h:mm:ss a',
                'EHms': 'E HH:mm:ss',
                'Gy': 'y G',
                'GyMMM': 'MMM y G',
                'GyMMMd': 'MMM d, y G',
                'GyMMMEd': 'E, MMM d, y G',
                'h': 'h a',
                'H': 'HH',
                'hm': 'h:mm a',
                'Hm': 'HH:mm',
                'hms': 'h:mm:ss a',
                'Hms': 'HH:mm:ss',
                'hmsv': 'h:mm:ss a v',
                'Hmsv': 'HH:mm:ss v',
                'hmv': 'h:mm a v',
                'Hmv': 'HH:mm v',
                'M': 'L',
                'Md': 'M/d',
                'MEd': 'E, M/d',
                'MMM': 'LLL',
                'MMMd': 'MMM d',
                'MMMEd': 'E, MMM d',
                'MMMMd': 'MMMM d',
                'ms': 'mm:ss',
                'y': 'y',
                'yM': 'M/y',
                'yMd': 'M/d/y',
                'yMEd': 'E, M/d/y',
                'yMMM': 'MMM y',
                'yMMMd': 'MMM d, y',
                'yMMMEd': 'E, MMM d, y',
                'yMMMM': 'MMMM y',
                'yQQQ': 'QQQ y',
                'yQQQQ': 'QQQQ y'
              },
              'appendItems': {
                'Day': '{0} ({2}: {1})',
                'Day-Of-Week': '{0} {1}',
                'Era': '{0} {1}',
                'Hour': '{0} ({2}: {1})',
                'Minute': '{0} ({2}: {1})',
                'Month': '{0} ({2}: {1})',
                'Quarter': '{0} ({2}: {1})',
                'Second': '{0} ({2}: {1})',
                'Timezone': '{0} {1}',
                'Week': '{0} ({2}: {1})',
                'Year': '{0} {1}'
              },
              'intervalFormats': {
                'intervalFormatFallback': '{0}  {1}',
                'd': {
                  'd': 'd  d'
                },
                'h': {
                  'a': 'h a  h a',
                  'h': 'h  h a'
                },
                'H': {
                  'H': 'HH  HH'
                },
                'hm': {
                  'a': 'h:mm a  h:mm a',
                  'h': 'h:mm  h:mm a',
                  'm': 'h:mm  h:mm a'
                },
                'Hm': {
                  'H': 'HH:mm  HH:mm',
                  'm': 'HH:mm  HH:mm'
                },
                'hmv': {
                  'a': 'h:mm a  h:mm a v',
                  'h': 'h:mm  h:mm a v',
                  'm': 'h:mm  h:mm a v'
                },
                'Hmv': {
                  'H': 'HH:mm  HH:mm v',
                  'm': 'HH:mm  HH:mm v'
                },
                'hv': {
                  'a': 'h a  h a v',
                  'h': 'h  h a v'
                },
                'Hv': {
                  'H': 'HH  HH v'
                },
                'M': {
                  'M': 'M  M'
                },
                'Md': {
                  'd': 'M/d  M/d',
                  'M': 'M/d  M/d'
                },
                'MEd': {
                  'd': 'E, M/d  E, M/d',
                  'M': 'E, M/d  E, M/d'
                },
                'MMM': {
                  'M': 'MMM  MMM'
                },
                'MMMd': {
                  'd': 'MMM d  d',
                  'M': 'MMM d  MMM d'
                },
                'MMMEd': {
                  'd': 'E, MMM d  E, MMM d',
                  'M': 'E, MMM d  E, MMM d'
                },
                'y': {
                  'y': 'y  y'
                },
                'yM': {
                  'M': 'M/y  M/y',
                  'y': 'M/y  M/y'
                },
                'yMd': {
                  'd': 'M/d/y  M/d/y',
                  'M': 'M/d/y  M/d/y',
                  'y': 'M/d/y  M/d/y'
                },
                'yMEd': {
                  'd': 'E, M/d/y  E, M/d/y',
                  'M': 'E, M/d/y  E, M/d/y',
                  'y': 'E, M/d/y  E, M/d/y'
                },
                'yMMM': {
                  'M': 'MMM  MMM y',
                  'y': 'MMM y  MMM y'
                },
                'yMMMd': {
                  'd': 'MMM d  d, y',
                  'M': 'MMM d  MMM d, y',
                  'y': 'MMM d, y  MMM d, y'
                },
                'yMMMEd': {
                  'd': 'E, MMM d  E, MMM d, y',
                  'M': 'E, MMM d  E, MMM d, y',
                  'y': 'E, MMM d, y  E, MMM d, y'
                },
                'yMMMM': {
                  'M': 'MMMM  MMMM y',
                  'y': 'MMMM y  MMMM y'
                }
              }
            }
          }
        }
      }
    }
  }
};
var weekData = {
  'supplemental': {
    'version': {
      '_cldrVersion': '28',
      '_unicodeVersion': '8.0.0',
      '_number': '$Revision: 11969 $'
    },
    'weekData': {
      'minDays': {
        '001': '1',
        'US': '1',
        'DE': '4'
      },
      'firstDay': {
        '001': 'mon',
        'DE': 'mon',
        'RU': 'mon',
        'JP': 'sun',
        'US': 'sun'
      },
      'weekendStart': {
        '001': 'sat'
      },
      'weekendEnd': {
        '001': 'sun'
      }
    }
  }
};
var ACCEPTABLE_JSON_FORMAT_PROPERTIES = ['skeleton', 'date', 'time', 'datetime', 'raw'];
var RTL_MARKS_REGEX = /[\u200E\u200F]/g; // eslint-disable-next-line no-restricted-imports

if (_globalize.default && _globalize.default.formatDate) {
  if (_globalize.default.locale().locale === 'en') {
    _globalize.default.load(weekData, timeData, enCaGregorian);

    _globalize.default.locale('en');
  }

  var formattersCache = {};
  var FORMATS_TO_GLOBALIZE_MAP = {
    'shortdate': {
      path: 'dateTimeFormats/availableFormats/yMd'
    },
    'shorttime': {
      path: 'timeFormats/short'
    },
    'longdate': {
      path: 'dateFormats/full'
    },
    'longtime': {
      path: 'timeFormats/medium'
    },
    'monthandday': {
      path: 'dateTimeFormats/availableFormats/MMMMd'
    },
    'monthandyear': {
      path: 'dateTimeFormats/availableFormats/yMMMM'
    },
    'quarterandyear': {
      path: 'dateTimeFormats/availableFormats/yQQQ'
    },
    'day': {
      path: 'dateTimeFormats/availableFormats/d'
    },
    'year': {
      path: 'dateTimeFormats/availableFormats/y'
    },
    'shortdateshorttime': {
      path: 'dateTimeFormats/short',
      parts: ['shorttime', 'shortdate']
    },
    'longdatelongtime': {
      path: 'dateTimeFormats/medium',
      parts: ['longtime', 'longdate']
    },
    'month': {
      pattern: 'LLLL'
    },
    'shortyear': {
      pattern: 'yy'
    },
    'dayofweek': {
      pattern: 'EEEE'
    },
    'quarter': {
      pattern: 'QQQ'
    },
    'millisecond': {
      pattern: 'SSS'
    },
    'hour': {
      pattern: 'HH'
    },
    'minute': {
      pattern: 'mm'
    },
    'second': {
      pattern: 'ss'
    }
  };
  var globalizeDateLocalization = {
    engine: function engine() {
      return 'globalize';
    },
    _getPatternByFormat: function _getPatternByFormat(format) {
      var that = this;
      var lowerFormat = format.toLowerCase();
      var globalizeFormat = FORMATS_TO_GLOBALIZE_MAP[lowerFormat];

      if (lowerFormat === 'datetime-local') {
        return 'yyyy-MM-ddTHH\':\'mm\':\'ss';
      }

      if (!globalizeFormat) {
        return;
      }

      var result = globalizeFormat.path && that._getFormatStringByPath(globalizeFormat.path) || globalizeFormat.pattern;

      if (globalizeFormat.parts) {
        iteratorUtils.each(globalizeFormat.parts, function (index, part) {
          result = result.replace('{' + index + '}', that._getPatternByFormat(part));
        });
      }

      return result;
    },
    _getFormatStringByPath: function _getFormatStringByPath(path) {
      return _globalize.default.locale().main('dates/calendars/gregorian/' + path);
    },
    getPeriodNames: function getPeriodNames() {
      var json = _globalize.default.locale().main('dates/calendars/gregorian/dayPeriods/stand-alone/wide');

      return [json['am'], json['pm']];
    },
    getMonthNames: function getMonthNames(format, type) {
      var months = _globalize.default.locale().main('dates/calendars/gregorian/months/' + (type === 'format' ? type : 'stand-alone') + '/' + (format || 'wide'));

      return iteratorUtils.map(months, function (month) {
        return month;
      });
    },
    getDayNames: function getDayNames(format) {
      var days = _globalize.default.locale().main('dates/calendars/gregorian/days/stand-alone/' + (format || 'wide'));

      return iteratorUtils.map(days, function (day) {
        return day;
      });
    },
    getTimeSeparator: function getTimeSeparator() {
      return _globalize.default.locale().main('numbers/symbols-numberSystem-latn/timeSeparator');
    },
    removeRtlMarks: function removeRtlMarks(text) {
      return text.replace(RTL_MARKS_REGEX, '');
    },
    format: function format(date, _format) {
      if (!date) {
        return;
      }

      if (!_format) {
        return date;
      }

      var formatter;
      var formatCacheKey;

      if (typeof _format === 'function') {
        return _format(date);
      }

      if (_format.formatter) {
        return _format.formatter(date);
      }

      _format = _format.type || _format;

      if (typeof _format === 'string') {
        formatCacheKey = _globalize.default.locale().locale + ':' + _format;
        formatter = formattersCache[formatCacheKey];

        if (!formatter) {
          _format = {
            raw: this._getPatternByFormat(_format) || _format
          };
          formatter = formattersCache[formatCacheKey] = _globalize.default.dateFormatter(_format);
        }
      } else {
        if (!this._isAcceptableFormat(_format)) {
          return;
        }

        formatter = _globalize.default.dateFormatter(_format);
      }

      return this.removeRtlMarks(formatter(date));
    },
    parse: function parse(text, format) {
      if (!text) {
        return;
      }

      if (!format || typeof format === 'function' || (0, _type.isObject)(format) && !this._isAcceptableFormat(format)) {
        if (format) {
          var parsedValue = this.callBase(text, format);

          if (parsedValue) {
            return parsedValue;
          }
        }

        return _globalize.default.parseDate(text);
      }

      if (format.parser) {
        return format.parser(text);
      }

      if (typeof format === 'string') {
        format = {
          raw: this._getPatternByFormat(format) || format
        };
      }

      return _globalize.default.parseDate(text, format);
    },
    _isAcceptableFormat: function _isAcceptableFormat(format) {
      if (format.parser) {
        return true;
      }

      for (var i = 0; i < ACCEPTABLE_JSON_FORMAT_PROPERTIES.length; i++) {
        if (Object.prototype.hasOwnProperty.call(format, ACCEPTABLE_JSON_FORMAT_PROPERTIES[i])) {
          return true;
        }
      }
    },
    firstDayOfWeekIndex: function firstDayOfWeekIndex() {
      var firstDay = _globalize.default.locale().supplemental.weekData.firstDay();

      return (0, _array.inArray)(firstDay, this._getDayKeys());
    },
    _getDayKeys: function _getDayKeys() {
      var days = _globalize.default.locale().main('dates/calendars/gregorian/days/format/short');

      return iteratorUtils.map(days, function (day, key) {
        return key;
      });
    }
  };

  _date2.default.resetInjection();

  _date2.default.inject(globalizeDateLocalization);
}

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _open_xml_currency_format = _interopRequireDefault(__webpack_require__(252));

__webpack_require__(130);

__webpack_require__(200);

__webpack_require__(112);

__webpack_require__(74);

var _globalize = _interopRequireDefault(__webpack_require__(74));

var _config = _interopRequireDefault(__webpack_require__(29));

var _number2 = _interopRequireDefault(__webpack_require__(46));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var enCurrencyUSD = {
  'main': {
    'en': {
      'identity': {
        'version': {
          '_cldrVersion': '28',
          '_number': '$Revision: 11972 $'
        },
        'language': 'en'
      },
      'numbers': {
        'currencies': {
          'USD': {
            'displayName': 'US Dollar',
            'displayName-count-one': 'US dollar',
            'displayName-count-other': 'US dollars',
            'symbol': '$',
            'symbol-alt-narrow': '$'
          }
        }
      }
    }
  }
};
var currencyData = {
  'supplemental': {
    'version': {
      '_cldrVersion': '28',
      '_unicodeVersion': '8.0.0',
      '_number': '$Revision: 11969 $'
    },
    'currencyData': {
      'fractions': {
        'DEFAULT': {
          '_rounding': '0',
          '_digits': '2'
        }
      }
    }
  }
}; // eslint-disable-next-line no-restricted-imports

if (_globalize.default && _globalize.default.formatCurrency) {
  if (_globalize.default.locale().locale === 'en') {
    _globalize.default.load(enCurrencyUSD, currencyData);

    _globalize.default.locale('en');
  }

  var formattersCache = {};

  var getFormatter = function getFormatter(currency, format) {
    var formatter;
    var formatCacheKey;

    if (_typeof(format) === 'object') {
      formatCacheKey = _globalize.default.locale().locale + ':' + currency + ':' + JSON.stringify(format);
    } else {
      formatCacheKey = _globalize.default.locale().locale + ':' + currency + ':' + format;
    }

    formatter = formattersCache[formatCacheKey];

    if (!formatter) {
      formatter = formattersCache[formatCacheKey] = _globalize.default.currencyFormatter(currency, format);
    }

    return formatter;
  };

  var globalizeCurrencyLocalization = {
    _formatNumberCore: function _formatNumberCore(value, format, formatConfig) {
      if (format === 'currency') {
        var currency = formatConfig && formatConfig.currency || (0, _config.default)().defaultCurrency;
        return getFormatter(currency, this._normalizeFormatConfig(format, formatConfig, value))(value);
      }

      return this.callBase.apply(this, arguments);
    },
    _normalizeFormatConfig: function _normalizeFormatConfig(format, formatConfig, value) {
      var config = this.callBase(format, formatConfig, value);

      if (format === 'currency') {
        config.style = 'accounting';
      }

      return config;
    },
    format: function format(value, _format) {
      if (typeof value !== 'number') {
        return value;
      }

      _format = this._normalizeFormat(_format);

      if (_format) {
        if (_format.currency === 'default') {
          _format.currency = (0, _config.default)().defaultCurrency;
        }

        if (_format.type === 'currency') {
          return this._formatNumber(value, this._parseNumberFormatString('currency'), _format);
        } else if (!_format.type && _format.currency) {
          return getFormatter(_format.currency, _format)(value);
        }
      }

      return this.callBase.apply(this, arguments);
    },
    getCurrencySymbol: function getCurrencySymbol(currency) {
      if (!currency) {
        currency = (0, _config.default)().defaultCurrency;
      }

      return _globalize.default.cldr.main('numbers/currencies/' + currency);
    },
    getOpenXmlCurrencyFormat: function getOpenXmlCurrencyFormat(currency) {
      var currencySymbol = this.getCurrencySymbol(currency).symbol;

      var accountingFormat = _globalize.default.cldr.main('numbers/currencyFormats-numberSystem-latn').accounting;

      return (0, _open_xml_currency_format.default)(currencySymbol, accountingFormat);
    }
  };

  _number2.default.inject(globalizeCurrencyLocalization);
}

/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _window = __webpack_require__(7);

var _class = _interopRequireDefault(__webpack_require__(15));

var _errors = __webpack_require__(37);

var _array_store = _interopRequireDefault(__webpack_require__(84));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var window = (0, _window.getWindow)();
var abstract = _class.default.abstract;

var LocalStoreBackend = _class.default.inherit({
  ctor: function ctor(store, storeOptions) {
    this._store = store;
    this._dirty = !!storeOptions.data;
    this.save();
    var immediate = this._immediate = storeOptions.immediate;
    var flushInterval = Math.max(100, storeOptions.flushInterval || 10 * 1000);

    if (!immediate) {
      var saveProxy = this.save.bind(this);
      setInterval(saveProxy, flushInterval);

      _events_engine.default.on(window, 'beforeunload', saveProxy);

      if (window.cordova) {
        _dom_adapter.default.listen(_dom_adapter.default.getDocument(), 'pause', saveProxy, false);
      }
    }
  },
  notifyChanged: function notifyChanged() {
    this._dirty = true;

    if (this._immediate) {
      this.save();
    }
  },
  load: function load() {
    this._store._array = this._loadImpl();
    this._dirty = false;
  },
  save: function save() {
    if (!this._dirty) {
      return;
    }

    this._saveImpl(this._store._array);

    this._dirty = false;
  },
  _loadImpl: abstract,
  _saveImpl: abstract
});

var DomLocalStoreBackend = LocalStoreBackend.inherit({
  ctor: function ctor(store, storeOptions) {
    var name = storeOptions.name;

    if (!name) {
      throw _errors.errors.Error('E4013');
    }

    this._key = 'dx-data-localStore-' + name;
    this.callBase(store, storeOptions);
  },
  _loadImpl: function _loadImpl() {
    var raw = window.localStorage.getItem(this._key);

    if (raw) {
      return JSON.parse(raw);
    }

    return [];
  },
  _saveImpl: function _saveImpl(array) {
    if (!array.length) {
      window.localStorage.removeItem(this._key);
    } else {
      window.localStorage.setItem(this._key, JSON.stringify(array));
    }
  }
});
var localStoreBackends = {
  'dom': DomLocalStoreBackend
};

var LocalStore = _array_store.default.inherit({
  ctor: function ctor(options) {
    if (typeof options === 'string') {
      options = {
        name: options
      };
    } else {
      options = options || {};
    }

    this.callBase(options);
    this._backend = new localStoreBackends[options.backend || 'dom'](this, options);

    this._backend.load();
  },
  clear: function clear() {
    this.callBase();

    this._backend.notifyChanged();
  },
  _insertImpl: function _insertImpl(values) {
    var b = this._backend;
    return this.callBase(values).done(b.notifyChanged.bind(b));
  },
  _updateImpl: function _updateImpl(key, values) {
    var b = this._backend;
    return this.callBase(key, values).done(b.notifyChanged.bind(b));
  },
  _removeImpl: function _removeImpl(key) {
    var b = this._backend;
    return this.callBase(key).done(b.notifyChanged.bind(b));
  }
}, 'local');

var _default = LocalStore;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _array_utils = __webpack_require__(88);

var _default = _array_utils.applyChanges;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _errors = _interopRequireDefault(__webpack_require__(24));

var _window = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* global Debug*/
var window = (0, _window.getWindow)();
var IS_WINJS_ORIGIN;
var IS_LOCAL_ORIGIN;

function isLocalHostName(url) {
  return /^(localhost$|127\.)/i.test(url); // TODO more precise check for 127.x.x.x IP
}
/**
* @name EndpointSelector.ctor
* @publicName ctor(options)
* @param1 options:Object
* @hidden
*/


var EndpointSelector = function EndpointSelector(config) {
  this.config = config;
  IS_WINJS_ORIGIN = window.location.protocol === 'ms-appx:';
  IS_LOCAL_ORIGIN = isLocalHostName(window.location.hostname);
};

EndpointSelector.prototype = {
  urlFor: function urlFor(key) {
    var bag = this.config[key];

    if (!bag) {
      throw _errors.default.Error('E0006');
    }

    if (bag.production) {
      if (IS_WINJS_ORIGIN && !Debug.debuggerEnabled || !IS_WINJS_ORIGIN && !IS_LOCAL_ORIGIN) {
        return bag.production;
      }
    }

    return bag.local;
  }
};
var _default = EndpointSelector;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* global DevExpress */

/* eslint-disable import/no-commonjs */
__webpack_require__(273);

DevExpress.data.ODataStore = __webpack_require__(274);
DevExpress.data.ODataContext = __webpack_require__(434);
DevExpress.data.utils = DevExpress.data.utils || {};
DevExpress.data.utils.odata = {};
DevExpress.data.utils.odata.keyConverters = __webpack_require__(99).keyConverters;
DevExpress.data.EdmLiteral = __webpack_require__(99).EdmLiteral;

var ODataUtilsModule = __webpack_require__(99);

DevExpress.data.utils.odata.serializePropName = ODataUtilsModule.serializePropName;
DevExpress.data.utils.odata.serializeValue = ODataUtilsModule.serializeValue;
DevExpress.data.utils.odata.serializeKey = ODataUtilsModule.serializeKey;
DevExpress.data.utils.odata.sendRequest = ODataUtilsModule.sendRequest;
DevExpress.data.queryAdapters = DevExpress.data.queryAdapters || {};
DevExpress.data.queryAdapters.odata = __webpack_require__(168).odata;

/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _class = _interopRequireDefault(__webpack_require__(15));

var _extend = __webpack_require__(0);

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

var _errors = __webpack_require__(37);

var _store = _interopRequireDefault(__webpack_require__(274));

var _request_dispatcher = _interopRequireDefault(__webpack_require__(275));

var _utils = __webpack_require__(99);

var _deferred = __webpack_require__(6);

__webpack_require__(168);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ODataContext = _class.default.inherit({
  ctor: function ctor(options) {
    var _this = this;

    this._requestDispatcher = new _request_dispatcher.default(options);
    this._errorHandler = options.errorHandler;
    (0, _iterator.each)(options.entities || [], function (entityAlias, entityOptions) {
      _this[entityAlias] = new _store.default((0, _extend.extend)({}, options, {
        url: "".concat(_this._requestDispatcher.url, "/").concat(encodeURIComponent(entityOptions.name || entityAlias))
      }, entityOptions));
    });
  },
  get: function get(operationName, params) {
    return this.invoke(operationName, params, 'GET');
  },
  invoke: function invoke(operationName) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var httpMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'POST';
    httpMethod = httpMethod.toLowerCase();
    var d = new _deferred.Deferred();
    var url = "".concat(this._requestDispatcher.url, "/").concat(encodeURIComponent(operationName));
    var payload;

    if (this.version() === 4) {
      if (httpMethod === 'get') {
        url = (0, _utils.formatFunctionInvocationUrl)(url, (0, _utils.escapeServiceOperationParams)(params, this.version()));
        params = null;
      } else if (httpMethod === 'post') {
        payload = params;
        params = null;
      }
    }

    (0, _deferred.when)(this._requestDispatcher.sendRequest(url, httpMethod, (0, _utils.escapeServiceOperationParams)(params, this.version()), payload)).done(function (r) {
      if ((0, _type.isPlainObject)(r) && operationName in r) {
        r = r[operationName];
      }

      d.resolve(r);
    }).fail(this._errorHandler).fail(_errors.handleError).fail(d.reject);
    return d.promise();
  },
  objectLink: function objectLink(entityAlias, key) {
    var store = this[entityAlias];

    if (!store) {
      throw _errors.errors.Error('E4015', entityAlias);
    }

    if (!(0, _type.isDefined)(key)) {
      return null;
    }

    return {
      __metadata: {
        uri: store._byKeyUrl(key)
      }
    };
  },
  version: function version() {
    return this._requestDispatcher.version;
  }
});

var _default = ODataContext;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 435 */,
/* 436 */,
/* 437 */,
/* 438 */,
/* 439 */,
/* 440 */,
/* 441 */,
/* 442 */,
/* 443 */,
/* 444 */,
/* 445 */,
/* 446 */,
/* 447 */,
/* 448 */,
/* 449 */,
/* 450 */,
/* 451 */,
/* 452 */,
/* 453 */,
/* 454 */,
/* 455 */,
/* 456 */,
/* 457 */,
/* 458 */,
/* 459 */,
/* 460 */,
/* 461 */,
/* 462 */,
/* 463 */,
/* 464 */,
/* 465 */,
/* 466 */,
/* 467 */,
/* 468 */,
/* 469 */,
/* 470 */,
/* 471 */,
/* 472 */,
/* 473 */,
/* 474 */,
/* 475 */,
/* 476 */,
/* 477 */,
/* 478 */,
/* 479 */,
/* 480 */,
/* 481 */,
/* 482 */,
/* 483 */,
/* 484 */,
/* 485 */,
/* 486 */,
/* 487 */,
/* 488 */,
/* 489 */,
/* 490 */,
/* 491 */,
/* 492 */,
/* 493 */,
/* 494 */,
/* 495 */,
/* 496 */,
/* 497 */,
/* 498 */,
/* 499 */,
/* 500 */,
/* 501 */,
/* 502 */,
/* 503 */,
/* 504 */,
/* 505 */,
/* 506 */,
/* 507 */,
/* 508 */,
/* 509 */,
/* 510 */,
/* 511 */,
/* 512 */,
/* 513 */,
/* 514 */,
/* 515 */,
/* 516 */,
/* 517 */,
/* 518 */,
/* 519 */,
/* 520 */,
/* 521 */,
/* 522 */,
/* 523 */,
/* 524 */,
/* 525 */,
/* 526 */,
/* 527 */,
/* 528 */,
/* 529 */,
/* 530 */,
/* 531 */,
/* 532 */,
/* 533 */,
/* 534 */,
/* 535 */,
/* 536 */,
/* 537 */,
/* 538 */,
/* 539 */,
/* 540 */,
/* 541 */,
/* 542 */,
/* 543 */,
/* 544 */,
/* 545 */,
/* 546 */,
/* 547 */,
/* 548 */,
/* 549 */,
/* 550 */,
/* 551 */,
/* 552 */,
/* 553 */,
/* 554 */,
/* 555 */,
/* 556 */,
/* 557 */,
/* 558 */,
/* 559 */,
/* 560 */,
/* 561 */,
/* 562 */,
/* 563 */,
/* 564 */,
/* 565 */,
/* 566 */,
/* 567 */,
/* 568 */,
/* 569 */,
/* 570 */,
/* 571 */,
/* 572 */,
/* 573 */,
/* 574 */,
/* 575 */,
/* 576 */,
/* 577 */,
/* 578 */,
/* 579 */,
/* 580 */,
/* 581 */,
/* 582 */,
/* 583 */,
/* 584 */,
/* 585 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "refreshPaths", {
  enumerable: true,
  get: function get() {
    return _renderer.refreshPaths;
  }
});
exports.prepareSegmentRectPoints = void 0;

var _renderer = __webpack_require__(183);

var _iterator = __webpack_require__(3);

// 'var' because JSHint throws W021 error
var prepareSegmentRectPoints = function prepareSegmentRectPoints(left, top, width, height, borderOptions) {
  var maxSW = ~~((width < height ? width : height) / 2);
  var sw = borderOptions.width || 0;
  var newSW = sw < maxSW ? sw : maxSW;
  left = left + newSW / 2;
  top = top + newSW / 2;
  width = width - newSW;
  height = height - newSW;
  var right = left + width;
  var bottom = top + height;
  var points = [];
  var segments = [];
  var segmentSequence;
  var visiblyOpt = 0;
  var prevSegmentVisibility = 0;
  var allSegment = {
    top: [[left, top], [right, top]],
    right: [[right, top], [right, bottom]],
    bottom: [[right, bottom], [left, bottom]],
    left: [[left, bottom], [left, top]]
  };
  (0, _iterator.each)(allSegment, function (seg) {
    var visibility = !!borderOptions[seg];
    visiblyOpt = visiblyOpt * 2 + ~~visibility;
  });

  switch (visiblyOpt) {
    case 13:
    case 9:
      segmentSequence = ['left', 'top', 'right', 'bottom'];
      break;

    case 11:
      segmentSequence = ['bottom', 'left', 'top', 'right'];
      break;

    default:
      segmentSequence = ['top', 'right', 'bottom', 'left'];
  }

  (0, _iterator.each)(segmentSequence, function (_, seg) {
    var segmentVisibility = !!borderOptions[seg];

    if (!prevSegmentVisibility && segments.length) {
      points.push(segments);
      segments = [];
    }

    if (segmentVisibility) {
      (0, _iterator.each)(allSegment[seg].slice(prevSegmentVisibility), function (_, segment) {
        segments = segments.concat(segment);
      });
    }

    prevSegmentVisibility = ~~segmentVisibility;
  });
  segments.length && points.push(segments);
  points.length === 1 && (points = points[0]);
  return {
    points: points,
    pathType: visiblyOpt === 15 ? 'area' : 'line'
  };
};

exports.prepareSegmentRectPoints = prepareSegmentRectPoints;

/***/ }),
/* 586 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _error = _interopRequireDefault(__webpack_require__(142));

var _errors = _interopRequireDefault(__webpack_require__(24));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _error.default)(_errors.default.ERROR_MESSAGES, {
  /**
  * @name ErrorsUIWidgets.E2001
  */
  E2001: 'Invalid data source',

  /**
  * @name ErrorsUIWidgets.E2002
  */
  E2002: 'Axis type and data type are incompatible',

  /**
  * @name ErrorsUIWidgets.E2003
  */
  E2003: 'The "{0}" data source field contains data of unsupported type',

  /**
  * @name ErrorsUIWidgets.E2004
  */
  E2004: 'The "{0}" data source field is inconsistent',

  /**
  * @name ErrorsUIWidgets.E2005
  */
  E2005: 'The value field "{0}" is absent in the data source or all its values are negative',

  /**
  * @name ErrorsUIWidgets.E2006
  */
  E2006: 'A cycle is detected in provided data',

  /**
  * @name ErrorsUIWidgets.E2007
  */
  E2007: 'The value field "{0}" is absent in the data source',

  /**
  * @name ErrorsUIWidgets.E2008
  */
  E2008: 'The value field "{0}" must be a string',

  /**
  * @name ErrorsUIWidgets.E2009
  */
  E2009: 'The value field "{0}" must be a positive numeric value',

  /**
  * @name ErrorsUIWidgets.E2101
  */
  E2101: 'Unknown series type: {0}',

  /**
  * @name ErrorsUIWidgets.E2102
  */
  E2102: 'Ambiguity occurred between two value axes with the same name',

  /**
  * @name ErrorsUIWidgets.E2103
  */
  E2103: 'The "{0}" option is given an invalid value. Assign a function instead',

  /**
  * @name ErrorsUIWidgets.E2104
  */
  E2104: 'Invalid logarithm base',

  /**
  * @name ErrorsUIWidgets.E2105
  */
  E2105: 'Invalid value of a "{0}"',

  /**
  * @name ErrorsUIWidgets.E2202
  */
  E2202: 'Invalid {0} scale value',

  /**
  * @name ErrorsUIWidgets.E2203
  */
  E2203: 'The range you are trying to set is invalid',

  /**
  * @name ErrorsUIWidgets.W2002
  */
  W2002: 'The {0} series cannot be drawn because the {1} data field is missing',

  /**
  * @name ErrorsUIWidgets.W2003
  */
  W2003: 'Tick interval is too small',

  /**
  * @name ErrorsUIWidgets.W2101
  */
  W2101: 'The "{0}" pane does not exist; the last pane is used by default',

  /**
  * @name ErrorsUIWidgets.W2102
  */
  W2102: 'A value axis with the "{0}" name was created automatically',

  /**
  * @name ErrorsUIWidgets.W2103
  */
  W2103: 'The chart title was hidden due to the container size',

  /**
  * @name ErrorsUIWidgets.W2104
  */
  W2104: 'The legend was hidden due to the container size',

  /**
  * @name ErrorsUIWidgets.W2105
  */
  W2105: 'The title of the "{0}" axis was hidden due to the container size',

  /**
  * @name ErrorsUIWidgets.W2106
  */
  W2106: 'The labels of the "{0}" axis were hidden due to the container size',

  /**
  * @name ErrorsUIWidgets.W2107
  */
  W2107: 'The export menu was hidden due to the container size',

  /**
  * @name ErrorsUIWidgets.W2108
  */
  W2108: 'The browser does not support exporting images to {0} format.',

  /**
  * @name ErrorsUIWidgets.W2301
  */
  W2301: 'Invalid value range'
});

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 587 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _extend2 = __webpack_require__(0);

var _symbol_point = _interopRequireDefault(__webpack_require__(162));

var _utils = __webpack_require__(14);

var _type = __webpack_require__(1);

var _consts = _interopRequireDefault(__webpack_require__(161));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extend = _extend2.extend;
var _round = Math.round;
var _sqrt = Math.sqrt;
var _acos = Math.acos;
var DEG = 180 / Math.PI;
var _abs = Math.abs;
var RADIAL_LABEL_INDENT = _consts.default.radialLabelIndent;

var _default = _extend({}, _symbol_point.default, {
  _updateData: function _updateData(data, argumentChanged) {
    var that = this;

    _symbol_point.default._updateData.call(this, data);

    if (argumentChanged || !(0, _type.isDefined)(that._visible)) {
      that._visible = true;
    }

    that.minValue = that.initialMinValue = that.originalMinValue = (0, _type.isDefined)(data.minValue) ? data.minValue : 0;
  },
  animate: function animate(complete, duration, delay) {
    var that = this;
    that.graphic.animate({
      x: that.centerX,
      y: that.centerY,
      outerRadius: that.radiusOuter,
      innerRadius: that.radiusInner,
      startAngle: that.toAngle,
      endAngle: that.fromAngle
    }, {
      delay: delay,
      partitionDuration: duration
    }, complete);
  },
  correctPosition: function correctPosition(correction) {
    var that = this;
    that.correctRadius(correction);
    that.correctLabelRadius(correction.radiusOuter + RADIAL_LABEL_INDENT);
    that.centerX = correction.centerX;
    that.centerY = correction.centerY;
  },
  correctRadius: function correctRadius(correction) {
    this.radiusInner = correction.radiusInner;
    this.radiusOuter = correction.radiusOuter;
  },
  correctLabelRadius: function correctLabelRadius(radiusLabels) {
    this.radiusLabels = radiusLabels;
  },
  correctValue: function correctValue(correction, percent, base) {
    var that = this;
    that.value = (base || that.normalInitialValue) + correction;
    that.minValue = correction;
    that.percent = percent;

    that._label.setDataField('percent', percent);
  },
  _updateLabelData: function _updateLabelData() {
    this._label.setData(this._getLabelFormatObject());
  },
  _getShiftLabelCoords: function _getShiftLabelCoords() {
    var that = this;

    var bBox = that._label.getBoundingRect();

    var coord = that._getLabelCoords(that._label);

    var visibleArea = that._getVisibleArea();

    if (that._isLabelDrawingWithoutPoints) {
      return that._checkLabelPosition(coord, bBox, visibleArea);
    } else {
      return that._getLabelExtraCoord(coord, that._checkVerticalLabelPosition(coord, bBox, visibleArea), bBox);
    }
  },
  _getLabelPosition: function _getLabelPosition(options) {
    return options.position;
  },
  getAnnotationCoords: function getAnnotationCoords(location) {
    return this._getElementCoords(location !== 'edge' ? 'inside' : 'outside', this.radiusOuter, 0);
  },
  _getElementCoords: function _getElementCoords(position, elementRadius, radialOffset) {
    var bBox = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    var that = this;
    var angleFunctions = (0, _utils.getCosAndSin)(that.middleAngle);
    var radiusInner = that.radiusInner;
    var radiusOuter = that.radiusOuter;
    var columnsPosition = position === 'columns';
    var rad;
    var x;

    if (position === 'inside') {
      rad = radiusInner + (radiusOuter - radiusInner) / 2 + radialOffset;
      x = that.centerX + rad * angleFunctions.cos - bBox.width / 2;
    } else {
      rad = elementRadius + radialOffset;

      if (angleFunctions.cos > 0.1 || columnsPosition && angleFunctions.cos >= 0) {
        x = that.centerX + rad * angleFunctions.cos;
      } else if (angleFunctions.cos < -0.1 || columnsPosition && angleFunctions.cos < 0) {
        x = that.centerX + rad * angleFunctions.cos - bBox.width;
      } else {
        x = that.centerX + rad * angleFunctions.cos - bBox.width / 2;
      }
    }

    return {
      x: x,
      y: _round(that.centerY - rad * angleFunctions.sin - bBox.height / 2)
    };
  },
  _getLabelCoords: function _getLabelCoords(label) {
    var that = this;
    var bBox = label.getBoundingRect();
    var options = label.getLayoutOptions();

    var position = that._getLabelPosition(options);

    return that._getElementCoords(position, that.radiusLabels, options.radialOffset, bBox);
  },
  _correctLabelCoord: function _correctLabelCoord(coord, moveLabelsFromCenter) {
    var that = this;
    var label = that._label;
    var bBox = label.getBoundingRect();
    var labelWidth = bBox.width;
    var options = label.getLayoutOptions();

    var visibleArea = that._getVisibleArea();

    var rightBorderX = visibleArea.maxX - labelWidth;
    var leftBorderX = visibleArea.minX;
    var angleOfPoint = (0, _utils.normalizeAngle)(that.middleAngle);
    var centerX = that.centerX;
    var connectorOffset = options.connectorOffset;
    var x = coord.x;

    if (options.position === 'columns') {
      if (angleOfPoint <= 90 || angleOfPoint >= 270) {
        x = rightBorderX;
      } else {
        x = leftBorderX;
      }

      coord.x = x;
    } else if (options.position !== 'inside' && moveLabelsFromCenter) {
      if (angleOfPoint <= 90 || angleOfPoint >= 270) {
        if (x - connectorOffset < centerX) {
          x = centerX + connectorOffset;
        }
      } else {
        if (x + labelWidth + connectorOffset > centerX) {
          x = centerX - labelWidth - connectorOffset;
        }
      }

      coord.x = x;
    }

    return coord;
  },
  drawLabel: function drawLabel() {
    this.translate(); // this function is called for drawing labels without points for checking size of labels

    this._isLabelDrawingWithoutPoints = true;

    this._drawLabel();

    this._isLabelDrawingWithoutPoints = false;
  },
  updateLabelCoord: function updateLabelCoord(moveLabelsFromCenter) {
    var that = this;

    var bBox = that._label.getBoundingRect();

    var coord = that._correctLabelCoord(bBox, moveLabelsFromCenter);

    coord = that._checkHorizontalLabelPosition(coord, bBox, that._getVisibleArea());

    that._label.shift(_round(coord.x), _round(bBox.y));
  },
  _checkVerticalLabelPosition: function _checkVerticalLabelPosition(coord, box, visibleArea) {
    var x = coord.x;
    var y = coord.y;

    if (coord.y + box.height > visibleArea.maxY) {
      y = visibleArea.maxY - box.height;
    } else if (coord.y < visibleArea.minY) {
      y = visibleArea.minY;
    }

    return {
      x: x,
      y: y
    };
  },
  _getLabelExtraCoord: function _getLabelExtraCoord(coord, shiftCoord, box) {
    return coord.y !== shiftCoord.y ? (0, _utils.getVerticallyShiftedAngularCoords)({
      x: coord.x,
      y: coord.y,
      width: box.width,
      height: box.height
    }, shiftCoord.y - coord.y, {
      x: this.centerX,
      y: this.centerY
    }) : coord;
  },
  _checkHorizontalLabelPosition: function _checkHorizontalLabelPosition(coord, box, visibleArea) {
    var x = coord.x;
    var y = coord.y;

    if (coord.x + box.width > visibleArea.maxX) {
      x = visibleArea.maxX - box.width;
    } else if (coord.x < visibleArea.minX) {
      x = visibleArea.minX;
    }

    return {
      x: x,
      y: y
    };
  },
  applyWordWrap: function applyWordWrap(moveLabelsFromCenter) {
    var that = this;
    var label = that._label;
    var box = label.getBoundingRect();

    var visibleArea = that._getVisibleArea();

    var position = label.getLayoutOptions().position;
    var width = box.width;
    var rowCountChanged = false;

    if (position === 'columns' && that.series.index > 0) {
      width = visibleArea.maxX - that.centerX - that.radiusLabels;
    } else if (position === 'inside') {
      if (width > visibleArea.maxX - visibleArea.minX) {
        width = visibleArea.maxX - visibleArea.minX;
      }
    } else {
      if (moveLabelsFromCenter && box.x < that.centerX && box.width + box.x > that.centerX) {
        width = Math.floor((visibleArea.maxX - visibleArea.minX) / 2);
      } else if (box.x + width > visibleArea.maxX) {
        width = visibleArea.maxX - box.x;
      } else if (box.x < visibleArea.minX) {
        width = box.x + width - visibleArea.minX;
      }
    }

    if (width < box.width) {
      rowCountChanged = label.fit(width);
    }

    return rowCountChanged;
  },
  setLabelTrackerData: function setLabelTrackerData() {
    this._label.setTrackerData(this);
  },
  _checkLabelPosition: function _checkLabelPosition(coord, bBox, visibleArea) {
    coord = this._checkHorizontalLabelPosition(coord, bBox, visibleArea);
    return this._checkVerticalLabelPosition(coord, bBox, visibleArea);
  },
  _getLabelConnector: function _getLabelConnector() {
    var that = this;
    var rad = that.radiusOuter;
    var seriesStyle = that._options.styles.normal;
    var strokeWidthBy2 = seriesStyle['stroke-width'] / 2;
    var borderWidth = that.series.getOptions().containerBackgroundColor === seriesStyle.stroke ? _round(strokeWidthBy2) : _round(-strokeWidthBy2);
    var angleFunctions = (0, _utils.getCosAndSin)(_round(that.middleAngle));
    return {
      x: _round(that.centerX + (rad - borderWidth) * angleFunctions.cos),
      y: _round(that.centerY - (rad - borderWidth) * angleFunctions.sin),
      angle: that.middleAngle
    };
  },
  _drawMarker: function _drawMarker(renderer, group, animationEnabled, firstDrawing) {
    var that = this;
    var radiusOuter = that.radiusOuter;
    var radiusInner = that.radiusInner;
    var fromAngle = that.fromAngle;
    var toAngle = that.toAngle;

    if (animationEnabled) {
      radiusInner = radiusOuter = 0;

      if (!firstDrawing) {
        fromAngle = toAngle = that.shiftedAngle;
      }
    }

    that.graphic = renderer.arc(that.centerX, that.centerY, radiusInner, radiusOuter, toAngle, fromAngle).attr({
      'stroke-linejoin': 'round'
    }).smartAttr(that._getStyle()).data({
      'chart-data-point': that
    }).sharp().append(group);
  },
  getTooltipParams: function getTooltipParams() {
    var that = this;
    var angleFunctions = (0, _utils.getCosAndSin)(that.middleAngle);
    var radiusInner = that.radiusInner;
    var radiusOuter = that.radiusOuter;
    return {
      x: that.centerX + (radiusInner + (radiusOuter - radiusInner) / 2) * angleFunctions.cos,
      y: that.centerY - (radiusInner + (radiusOuter - radiusInner) / 2) * angleFunctions.sin,
      offset: 0
    };
  },
  _translate: function _translate() {
    var that = this;
    var angle = that.shiftedAngle || 0;
    var value = that.value;
    var minValue = that.minValue;

    var translator = that._getValTranslator();

    that.fromAngle = translator.translate(minValue) + angle;
    that.toAngle = translator.translate(value) + angle;
    that.middleAngle = translator.translate((value - minValue) / 2 + minValue) + angle;

    if (!that.isVisible()) {
      that.middleAngle = that.toAngle = that.fromAngle = that.fromAngle || angle;
    }
  },
  getMarkerVisibility: function getMarkerVisibility() {
    return true;
  },
  _updateMarker: function _updateMarker(animationEnabled, style, _, callback) {
    var that = this;

    if (!animationEnabled) {
      style = _extend({
        x: that.centerX,
        y: that.centerY,
        outerRadius: that.radiusOuter,
        innerRadius: that.radiusInner,
        startAngle: that.toAngle,
        endAngle: that.fromAngle
      }, style);
    }

    that.graphic.smartAttr(style).sharp();
    callback && callback();
  },
  getLegendStyles: function getLegendStyles() {
    return this._styles.legendStyles;
  },
  isInVisibleArea: function isInVisibleArea() {
    return true;
  },
  hide: function hide() {
    var that = this;

    if (that._visible) {
      that._visible = false;
      that.hideTooltip();

      that._options.visibilityChanged();
    }
  },
  show: function show() {
    var that = this;

    if (!that._visible) {
      that._visible = true;

      that._options.visibilityChanged();
    }
  },
  setInvisibility: function setInvisibility() {
    this._label.draw(false);
  },
  isVisible: function isVisible() {
    return this._visible;
  },
  _getFormatObject: function _getFormatObject(tooltip) {
    var formatObject = _symbol_point.default._getFormatObject.call(this, tooltip);

    var percent = this.percent;
    formatObject.percent = percent;
    formatObject.percentText = tooltip.formatValue(percent, 'percent');
    return formatObject;
  },
  getColor: function getColor() {
    return this._styles.normal.fill;
  },
  coordsIn: function coordsIn(x, y) {
    var that = this;
    var lx = x - that.centerX;
    var ly = y - that.centerY;

    var r = _sqrt(lx * lx + ly * ly);

    var fromAngle = that.fromAngle % 360;
    var toAngle = that.toAngle % 360;
    var angle;

    if (r < that.radiusInner || r > that.radiusOuter || r === 0) {
      return false;
    }

    angle = _acos(lx / r) * DEG * (ly > 0 ? -1 : 1);

    if (angle < 0) {
      angle += 360;
    }

    if (fromAngle === toAngle && _abs(that.toAngle - that.fromAngle) > 1E-4) {
      return true;
    } else {
      return fromAngle >= toAngle ? angle <= fromAngle && angle >= toAngle : !(angle >= fromAngle && angle <= toAngle);
    }
  }
});

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 588 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _iterator = __webpack_require__(3);

var _extend2 = __webpack_require__(0);

var _common = __webpack_require__(4);

var _label = __webpack_require__(348);

var _symbol_point = _interopRequireDefault(__webpack_require__(162));

var _type = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extend = _extend2.extend;
var _math = Math;
var _abs = _math.abs;
var _min = _math.min;
var _max = _math.max;
var _round = _math.round;
var DEFAULT_IMAGE_WIDTH = 20;
var DEFAULT_IMAGE_HEIGHT = 20;

var _default = _extend({}, _symbol_point.default, {
  deleteLabel: function deleteLabel() {
    var that = this;

    that._topLabel.dispose();

    that._topLabel = null;

    that._bottomLabel.dispose();

    that._bottomLabel = null;
  },
  hideMarker: function hideMarker(type) {
    var graphic = this.graphic;
    var marker = graphic && graphic[type + 'Marker'];
    var label = this['_' + type + 'Label'];

    if (marker && marker.attr('visibility') !== 'hidden') {
      marker.attr({
        visibility: 'hidden'
      });
    }

    label.draw(false);
  },
  setInvisibility: function setInvisibility() {
    this.hideMarker('top');
    this.hideMarker('bottom');
  },
  clearVisibility: function clearVisibility() {
    var that = this;
    var graphic = that.graphic;
    var topMarker = graphic && graphic.topMarker;
    var bottomMarker = graphic && graphic.bottomMarker;

    if (topMarker && topMarker.attr('visibility')) {
      topMarker.attr({
        visibility: null
      });
    }

    if (bottomMarker && bottomMarker.attr('visibility')) {
      bottomMarker.attr({
        visibility: null
      });
    }
  },
  clearMarker: function clearMarker() {
    var that = this;
    var graphic = that.graphic;
    var topMarker = graphic && graphic.topMarker;
    var bottomMarker = graphic && graphic.bottomMarker;
    var emptySettings = that._emptySettings;
    topMarker && topMarker.attr(emptySettings);
    bottomMarker && bottomMarker.attr(emptySettings);
  },
  _getLabelPosition: function _getLabelPosition(markerType) {
    var position;
    var labelsInside = this._options.label.position === 'inside';

    if (!this._options.rotated) {
      position = markerType === 'top' ^ labelsInside ? 'top' : 'bottom';
    } else {
      position = markerType === 'top' ^ labelsInside ? 'right' : 'left';
    }

    return position;
  },
  _getLabelMinFormatObject: function _getLabelMinFormatObject() {
    var that = this;
    return {
      index: 0,
      argument: that.initialArgument,
      value: that.initialMinValue,
      seriesName: that.series.name,
      originalValue: that.originalMinValue,
      originalArgument: that.originalArgument,
      point: that
    };
  },
  _updateLabelData: function _updateLabelData() {
    var maxFormatObject = this._getLabelFormatObject();

    maxFormatObject.index = 1;

    this._topLabel.setData(maxFormatObject);

    this._bottomLabel.setData(this._getLabelMinFormatObject());
  },
  _updateLabelOptions: function _updateLabelOptions() {
    var that = this;
    var options = this._options.label;
    (!that._topLabel || !that._bottomLabel) && that._createLabel();

    that._topLabel.setOptions(options);

    that._bottomLabel.setOptions(options);
  },
  _createLabel: function _createLabel() {
    var options = {
      renderer: this.series._renderer,
      labelsGroup: this.series._labelsGroup,
      point: this
    };
    this._topLabel = new _label.Label(options);
    this._bottomLabel = new _label.Label(options);
  },
  _getGraphicBBox: function _getGraphicBBox(location) {
    var options = this._options;

    var images = this._getImage(options.image);

    var image = location === 'top' ? this._checkImage(images.top) : this._checkImage(images.bottom);
    var bBox;

    var coord = this._getPositionFromLocation(location);

    if (options.visible) {
      bBox = image ? this._getImageBBox(coord.x, coord.y) : this._getSymbolBBox(coord.x, coord.y, options.styles.normal.r);
    } else {
      bBox = {
        x: coord.x,
        y: coord.y,
        width: 0,
        height: 0
      };
    }

    return bBox;
  },
  _getPositionFromLocation: function _getPositionFromLocation(location) {
    var x;
    var y;
    var isTop = location === 'top';

    if (!this._options.rotated) {
      x = this.x;
      y = isTop ? _min(this.y, this.minY) : _max(this.y, this.minY);
    } else {
      x = isTop ? _max(this.x, this.minX) : _min(this.x, this.minX);
      y = this.y;
    }

    return {
      x: x,
      y: y
    };
  },
  _checkOverlay: function _checkOverlay(bottomCoord, topCoord, topValue) {
    return bottomCoord < topCoord + topValue;
  },
  _getOverlayCorrections: function _getOverlayCorrections(topCoords, bottomCoords) {
    var rotated = this._options.rotated;
    var coordSelector = !rotated ? 'y' : 'x';
    var valueSelector = !rotated ? 'height' : 'width';
    var visibleArea = this.series.getValueAxis().getVisibleArea();
    var minBound = visibleArea[0];
    var maxBound = visibleArea[1];

    var delta = _round((topCoords[coordSelector] + topCoords[valueSelector] - bottomCoords[coordSelector]) / 2);

    var coord1 = topCoords[coordSelector] - delta;
    var coord2 = bottomCoords[coordSelector] + delta;

    if (coord1 < minBound) {
      delta = minBound - coord1;
      coord1 += delta;
      coord2 += delta;
    } else if (coord2 + bottomCoords[valueSelector] > maxBound) {
      delta = maxBound - coord2 - bottomCoords[valueSelector];
      coord1 += delta;
      coord2 += delta;
    }

    return {
      coord1: coord1,
      coord2: coord2
    };
  },
  _checkLabelsOverlay: function _checkLabelsOverlay(topLocation) {
    var that = this;

    var topCoords = that._topLabel.getBoundingRect();

    var bottomCoords = that._bottomLabel.getBoundingRect();

    var corrections = {};

    if (!that._options.rotated) {
      if (topLocation === 'top') {
        if (this._checkOverlay(bottomCoords.y, topCoords.y, topCoords.height)) {
          corrections = this._getOverlayCorrections(topCoords, bottomCoords);

          that._topLabel.shift(topCoords.x, corrections.coord1);

          that._bottomLabel.shift(bottomCoords.x, corrections.coord2);
        }
      } else {
        if (this._checkOverlay(topCoords.y, bottomCoords.y, bottomCoords.height)) {
          corrections = this._getOverlayCorrections(bottomCoords, topCoords);

          that._topLabel.shift(topCoords.x, corrections.coord2);

          that._bottomLabel.shift(bottomCoords.x, corrections.coord1);
        }
      }
    } else {
      if (topLocation === 'top') {
        if (this._checkOverlay(topCoords.x, bottomCoords.x, bottomCoords.width)) {
          corrections = this._getOverlayCorrections(bottomCoords, topCoords);

          that._topLabel.shift(corrections.coord2, topCoords.y);

          that._bottomLabel.shift(corrections.coord1, bottomCoords.y);
        }
      } else {
        if (this._checkOverlay(bottomCoords.x, topCoords.x, topCoords.width)) {
          corrections = this._getOverlayCorrections(topCoords, bottomCoords);

          that._topLabel.shift(corrections.coord1, topCoords.y);

          that._bottomLabel.shift(corrections.coord2, bottomCoords.y);
        }
      }
    }
  },
  _drawLabel: function _drawLabel() {
    var that = this;
    var labels = [];
    var notInverted = that._options.rotated ? that.x >= that.minX : that.y < that.minY;

    var customVisibility = that._getCustomLabelVisibility();

    var topLabel = that._topLabel;
    var bottomLabel = that._bottomLabel;
    topLabel.pointPosition = notInverted ? 'top' : 'bottom';
    bottomLabel.pointPosition = notInverted ? 'bottom' : 'top';

    if ((that.series.getLabelVisibility() || customVisibility) && that.hasValue() && customVisibility !== false) {
      that.visibleTopMarker !== false && labels.push(topLabel);
      that.visibleBottomMarker !== false && labels.push(bottomLabel);
      (0, _iterator.each)(labels, function (_, label) {
        label.draw(true);
      });

      that._checkLabelsOverlay(that._topLabel.pointPosition);
    } else {
      topLabel.draw(false);
      bottomLabel.draw(false);
    }
  },
  _getImage: function _getImage(imageOption) {
    var image = {};

    if ((0, _type.isDefined)(imageOption)) {
      if (typeof imageOption === 'string') {
        image.top = image.bottom = imageOption;
      } else {
        image.top = {
          url: typeof imageOption.url === 'string' ? imageOption.url : imageOption.url && imageOption.url.rangeMaxPoint,
          width: typeof imageOption.width === 'number' ? imageOption.width : imageOption.width && imageOption.width.rangeMaxPoint,
          height: typeof imageOption.height === 'number' ? imageOption.height : imageOption.height && imageOption.height.rangeMaxPoint
        };
        image.bottom = {
          url: typeof imageOption.url === 'string' ? imageOption.url : imageOption.url && imageOption.url.rangeMinPoint,
          width: typeof imageOption.width === 'number' ? imageOption.width : imageOption.width && imageOption.width.rangeMinPoint,
          height: typeof imageOption.height === 'number' ? imageOption.height : imageOption.height && imageOption.height.rangeMinPoint
        };
      }
    }

    return image;
  },
  _checkSymbol: function _checkSymbol(oldOptions, newOptions) {
    var that = this;
    var oldSymbol = oldOptions.symbol;
    var newSymbol = newOptions.symbol;
    var symbolChanged = oldSymbol === 'circle' && newSymbol !== 'circle' || oldSymbol !== 'circle' && newSymbol === 'circle';

    var oldImages = that._getImage(oldOptions.image);

    var newImages = that._getImage(newOptions.image);

    var topImageChanged = that._checkImage(oldImages.top) !== that._checkImage(newImages.top);

    var bottomImageChanged = that._checkImage(oldImages.bottom) !== that._checkImage(newImages.bottom);

    return symbolChanged || topImageChanged || bottomImageChanged;
  },
  _getSettingsForTwoMarkers: function _getSettingsForTwoMarkers(style) {
    var that = this;
    var options = that._options;
    var settings = {};
    var x = options.rotated ? _min(that.x, that.minX) : that.x;
    var y = options.rotated ? that.y : _min(that.y, that.minY);
    var radius = style.r;

    var points = that._populatePointShape(options.symbol, radius);

    settings.top = _extend({
      translateX: x + that.width,
      translateY: y,
      r: radius
    }, style);
    settings.bottom = _extend({
      translateX: x,
      translateY: y + that.height,
      r: radius
    }, style);

    if (points) {
      settings.top.points = settings.bottom.points = points;
    }

    return settings;
  },
  _hasGraphic: function _hasGraphic() {
    return this.graphic && this.graphic.topMarker && this.graphic.bottomMarker;
  },
  _drawOneMarker: function _drawOneMarker(renderer, markerType, imageSettings, settings) {
    var that = this;
    var graphic = that.graphic;

    if (graphic[markerType]) {
      that._updateOneMarker(markerType, settings);
    } else {
      graphic[markerType] = that._createMarker(renderer, graphic, imageSettings, settings);
    }
  },
  _drawMarker: function _drawMarker(renderer, group, animationEnabled, firstDrawing, style) {
    var that = this;

    var settings = that._getSettingsForTwoMarkers(style || that._getStyle());

    var image = that._getImage(that._options.image);

    if (that._checkImage(image.top)) {
      settings.top = that._getImageSettings(settings.top, image.top);
    }

    if (that._checkImage(image.bottom)) {
      settings.bottom = that._getImageSettings(settings.bottom, image.bottom);
    }

    that.graphic = that.graphic || renderer.g().append(group);
    that.visibleTopMarker && that._drawOneMarker(renderer, 'topMarker', image.top, settings.top);
    that.visibleBottomMarker && that._drawOneMarker(renderer, 'bottomMarker', image.bottom, settings.bottom);
  },
  _getSettingsForTracker: function _getSettingsForTracker(radius) {
    var that = this;
    var rotated = that._options.rotated;
    return {
      translateX: rotated ? _min(that.x, that.minX) - radius : that.x - radius,
      translateY: rotated ? that.y - radius : _min(that.y, that.minY) - radius,
      width: that.width + 2 * radius,
      height: that.height + 2 * radius
    };
  },
  isInVisibleArea: function isInVisibleArea() {
    var that = this;
    var rotated = that._options.rotated;
    var argument = !rotated ? that.x : that.y;
    var maxValue = !rotated ? _max(that.minY, that.y) : _max(that.minX, that.x);
    var minValue = !rotated ? _min(that.minY, that.y) : _min(that.minX, that.x);
    var tmp;
    var visibleTopMarker;
    var visibleBottomMarker;
    var visibleRangeArea = true;
    var visibleArgArea = that.series.getArgumentAxis().getVisibleArea();
    var visibleValArea = that.series.getValueAxis().getVisibleArea();
    var notVisibleByArg = visibleArgArea[1] < argument || visibleArgArea[0] > argument;
    var notVisibleByVal = visibleValArea[0] > minValue && visibleValArea[0] > maxValue || visibleValArea[1] < minValue && visibleValArea[1] < maxValue;

    if (notVisibleByArg || notVisibleByVal) {
      visibleTopMarker = visibleBottomMarker = visibleRangeArea = false;
    } else {
      visibleTopMarker = visibleValArea[0] <= minValue && visibleValArea[1] > minValue;
      visibleBottomMarker = visibleValArea[0] < maxValue && visibleValArea[1] >= maxValue;

      if (rotated) {
        tmp = visibleTopMarker;
        visibleTopMarker = visibleBottomMarker;
        visibleBottomMarker = tmp;
      }
    }

    that.visibleTopMarker = visibleTopMarker;
    that.visibleBottomMarker = visibleBottomMarker;
    return visibleRangeArea;
  },
  getTooltipParams: function getTooltipParams() {
    var that = this;
    var x;
    var y;
    var rotated = that._options.rotated;
    var minValue = !rotated ? _min(that.y, that.minY) : _min(that.x, that.minX);
    var side = !rotated ? 'height' : 'width';

    var visibleArea = that._getVisibleArea();

    var minVisible = rotated ? visibleArea.minX : visibleArea.minY;
    var maxVisible = rotated ? visibleArea.maxX : visibleArea.maxY;

    var min = _max(minVisible, minValue);

    var max = _min(maxVisible, minValue + that[side]);

    if (!rotated) {
      x = that.x;
      y = min + (max - min) / 2;
    } else {
      y = that.y;
      x = min + (max - min) / 2;
    }

    return {
      x: x,
      y: y,
      offset: 0
    };
  },
  _translate: function _translate() {
    var that = this;
    var rotated = that._options.rotated;

    _symbol_point.default._translate.call(that);

    that.height = rotated ? 0 : _abs(that.minY - that.y);
    that.width = rotated ? _abs(that.x - that.minX) : 0;
  },
  hasCoords: function hasCoords() {
    return _symbol_point.default.hasCoords.call(this) && !(this.minX === null || this.minY === null);
  },
  _updateData: function _updateData(data) {
    var that = this;

    _symbol_point.default._updateData.call(that, data);

    that.minValue = that.initialMinValue = that.originalMinValue = data.minValue;
  },
  _getImageSettings: function _getImageSettings(settings, image) {
    return {
      href: image.url || image.toString(),
      width: image.width || DEFAULT_IMAGE_WIDTH,
      height: image.height || DEFAULT_IMAGE_HEIGHT,
      translateX: settings.translateX,
      translateY: settings.translateY
    };
  },
  getCrosshairData: function getCrosshairData(x, y) {
    var that = this;
    var rotated = that._options.rotated;
    var minX = that.minX;
    var minY = that.minY;
    var vx = that.vx;
    var vy = that.vy;
    var value = that.value;
    var minValue = that.minValue;
    var argument = that.argument;
    var coords = {
      axis: that.series.axis,
      x: vx,
      y: vy,
      yValue: value,
      xValue: argument
    };

    if (rotated) {
      coords.yValue = argument;

      if (_abs(vx - x) < _abs(minX - x)) {
        coords.xValue = value;
      } else {
        coords.x = minX;
        coords.xValue = minValue;
      }
    } else {
      if (_abs(vy - y) >= _abs(minY - y)) {
        coords.y = minY;
        coords.yValue = minValue;
      }
    }

    return coords;
  },
  _updateOneMarker: function _updateOneMarker(markerType, settings) {
    this.graphic && this.graphic[markerType] && this.graphic[markerType].attr(settings);
  },
  _updateMarker: function _updateMarker(animationEnabled, style) {
    this._drawMarker(undefined, undefined, false, false, style);
  },
  _getFormatObject: function _getFormatObject(tooltip) {
    var that = this;
    var initialMinValue = that.initialMinValue;
    var initialValue = that.initialValue;
    var initialArgument = that.initialArgument;
    var minValue = tooltip.formatValue(initialMinValue);
    var value = tooltip.formatValue(initialValue);
    return {
      argument: initialArgument,
      argumentText: tooltip.formatValue(initialArgument, 'argument'),
      valueText: minValue + ' - ' + value,
      rangeValue1Text: minValue,
      rangeValue2Text: value,
      rangeValue1: initialMinValue,
      rangeValue2: initialValue,
      seriesName: that.series.name,
      point: that,
      originalMinValue: that.originalMinValue,
      originalValue: that.originalValue,
      originalArgument: that.originalArgument
    };
  },
  getLabel: function getLabel() {
    return [this._topLabel, this._bottomLabel];
  },
  getLabels: function getLabels() {
    return [this._topLabel, this._bottomLabel];
  },
  getBoundingRect: _common.noop,
  coordsIn: function coordsIn(x, y) {
    var trackerRadius = this._storeTrackerR();

    var xCond = x >= this.x - trackerRadius && x <= this.x + trackerRadius;
    var yCond = y >= this.y - trackerRadius && y <= this.y + trackerRadius;

    if (this._options.rotated) {
      return yCond && (xCond || x >= this.minX - trackerRadius && x <= this.minX + trackerRadius);
    } else {
      return xCond && (yCond || y >= this.minY - trackerRadius && y <= this.minY + trackerRadius);
    }
  },
  getMaxValue: function getMaxValue() {
    if (this.series.valueAxisType !== 'discrete') {
      return this.minValue > this.value ? this.minValue : this.value;
    }

    return this.value;
  },
  getMinValue: function getMinValue() {
    if (this.series.valueAxisType !== 'discrete') {
      return this.minValue < this.value ? this.minValue : this.value;
    }

    return this.minValue;
  }
});

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 589 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _extend2 = __webpack_require__(0);

var _symbol_point = _interopRequireDefault(__webpack_require__(162));

var _bar_point = _interopRequireDefault(__webpack_require__(240));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _math = Math;
var _abs = _math.abs;
var _min = _math.min;
var _max = _math.max;
var _round = _math.round;
var DEFAULT_FINANCIAL_TRACKER_MARGIN = 2;

var _default = (0, _extend2.extend)({}, _bar_point.default, {
  _getContinuousPoints: function _getContinuousPoints(openCoord, closeCoord) {
    var that = this;
    var x = that.x;
    var createPoint = that._options.rotated ? function (x, y) {
      return [y, x];
    } : function (x, y) {
      return [x, y];
    };
    var width = that.width;
    var highCoord = that.highY;
    var max = _abs(highCoord - openCoord) < _abs(highCoord - closeCoord) ? openCoord : closeCoord;
    var min = max === closeCoord ? openCoord : closeCoord;
    var points;

    if (min === max) {
      points = [].concat(createPoint(x, that.highY)).concat(createPoint(x, that.lowY)).concat(createPoint(x, that.closeY)).concat(createPoint(x - width / 2, that.closeY)).concat(createPoint(x + width / 2, that.closeY)).concat(createPoint(x, that.closeY));
    } else {
      points = [].concat(createPoint(x, that.highY)).concat(createPoint(x, max)).concat(createPoint(x + width / 2, max)).concat(createPoint(x + width / 2, min)).concat(createPoint(x, min)).concat(createPoint(x, that.lowY)).concat(createPoint(x, min)).concat(createPoint(x - width / 2, min)).concat(createPoint(x - width / 2, max)).concat(createPoint(x, max));
    }

    return points;
  },
  _getCrockPoints: function _getCrockPoints(y) {
    var that = this;
    var x = that.x;
    var createPoint = that._options.rotated ? function (x, y) {
      return [y, x];
    } : function (x, y) {
      return [x, y];
    };
    return [].concat(createPoint(x, that.highY)).concat(createPoint(x, that.lowY)).concat(createPoint(x, y)).concat(createPoint(x - that.width / 2, y)).concat(createPoint(x + that.width / 2, y)).concat(createPoint(x, y));
  },
  _getPoints: function _getPoints() {
    var that = this;
    var points;
    var closeCoord = that.closeY;
    var openCoord = that.openY;

    if (closeCoord !== null && openCoord !== null) {
      points = that._getContinuousPoints(openCoord, closeCoord);
    } else {
      if (openCoord === closeCoord) {
        points = [that.x, that.highY, that.x, that.lowY];
      } else {
        points = that._getCrockPoints(openCoord !== null ? openCoord : closeCoord);
      }
    }

    return points;
  },
  getColor: function getColor() {
    var that = this;
    return that._isReduction ? that._options.reduction.color : that._styles.normal.stroke || that.series.getColor();
  },
  _drawMarkerInGroup: function _drawMarkerInGroup(group, attributes, renderer) {
    var that = this;
    that.graphic = renderer.path(that._getPoints(), 'area').attr({
      'stroke-linecap': 'square'
    }).attr(attributes).data({
      'chart-data-point': that
    }).sharp().append(group);
  },
  _fillStyle: function _fillStyle() {
    var that = this;
    var styles = that._options.styles;

    if (that._isReduction && that._isPositive) {
      that._styles = styles.reductionPositive;
    } else if (that._isReduction) {
      that._styles = styles.reduction;
    } else if (that._isPositive) {
      that._styles = styles.positive;
    } else {
      that._styles = styles;
    }
  },
  _getMinTrackerWidth: function _getMinTrackerWidth() {
    return 2 + 2 * this._styles.normal['stroke-width'];
  },
  correctCoordinates: function correctCoordinates(correctOptions) {
    var minWidth = this._getMinTrackerWidth();

    var maxWidth = 10;
    var width = correctOptions.width;
    width = width < minWidth ? minWidth : width > maxWidth ? maxWidth : width;
    this.width = width + width % 2;
    this.xCorrection = correctOptions.offset;
  },
  _getMarkerGroup: function _getMarkerGroup(group) {
    var that = this;
    var markerGroup;

    if (that._isReduction && that._isPositive) {
      markerGroup = group.reductionPositiveMarkersGroup;
    } else if (that._isReduction) {
      markerGroup = group.reductionMarkersGroup;
    } else if (that._isPositive) {
      markerGroup = group.defaultPositiveMarkersGroup;
    } else {
      markerGroup = group.defaultMarkersGroup;
    }

    return markerGroup;
  },
  _drawMarker: function _drawMarker(renderer, group) {
    this._drawMarkerInGroup(this._getMarkerGroup(group), this._getStyle(), renderer);
  },
  _getSettingsForTracker: function _getSettingsForTracker() {
    var that = this;
    var highY = that.highY;
    var lowY = that.lowY;
    var rotated = that._options.rotated;
    var x;
    var y;
    var width;
    var height;

    if (highY === lowY) {
      highY = rotated ? highY + DEFAULT_FINANCIAL_TRACKER_MARGIN : highY - DEFAULT_FINANCIAL_TRACKER_MARGIN;
      lowY = rotated ? lowY - DEFAULT_FINANCIAL_TRACKER_MARGIN : lowY + DEFAULT_FINANCIAL_TRACKER_MARGIN;
    }

    if (rotated) {
      x = _min(lowY, highY);
      y = that.x - that.width / 2;
      width = _abs(lowY - highY);
      height = that.width;
    } else {
      x = that.x - that.width / 2;
      y = _min(lowY, highY);
      width = that.width;
      height = _abs(lowY - highY);
    }

    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  },
  _getGraphicBBox: function _getGraphicBBox(location) {
    var that = this;
    var rotated = that._options.rotated;
    var x = that.x;
    var width = that.width;
    var lowY = that.lowY;
    var highY = that.highY;

    if (location) {
      var valVisibleArea = that.series.getValueAxis().getVisibleArea();
      highY = that._truncateCoord(highY, valVisibleArea);
      lowY = that._truncateCoord(lowY, valVisibleArea);
    }

    var bBox = {
      x: !rotated ? x - _round(width / 2) : lowY,
      y: !rotated ? highY : x - _round(width / 2),
      width: !rotated ? width : highY - lowY,
      height: !rotated ? lowY - highY : width
    };

    if (location) {
      var isTop = location === 'top';

      if (!this._options.rotated) {
        bBox.y = isTop ? bBox.y : bBox.y + bBox.height;
        bBox.height = 0;
      } else {
        bBox.x = isTop ? bBox.x + bBox.width : bBox.x;
        bBox.width = 0;
      }
    }

    return bBox;
  },
  getTooltipParams: function getTooltipParams(location) {
    var that = this;

    if (that.graphic) {
      var minValue = _min(that.lowY, that.highY);

      var maxValue = _max(that.lowY, that.highY);

      var visibleArea = that._getVisibleArea();

      var rotated = that._options.rotated;
      var minVisible = rotated ? visibleArea.minX : visibleArea.minY;
      var maxVisible = rotated ? visibleArea.maxX : visibleArea.maxY;

      var min = _max(minVisible, minValue);

      var max = _min(maxVisible, maxValue);

      var centerCoord = that.getCenterCoord();

      if (location === 'edge') {
        centerCoord[rotated ? 'x' : 'y'] = rotated ? max : min;
      }

      centerCoord.offset = 0;
      return centerCoord;
    }
  },
  getCenterCoord: function getCenterCoord() {
    if (this.graphic) {
      var that = this;
      var x;
      var y;

      var minValue = _min(that.lowY, that.highY);

      var maxValue = _max(that.lowY, that.highY);

      var visibleArea = that._getVisibleArea();

      var rotated = that._options.rotated;
      var minVisible = rotated ? visibleArea.minX : visibleArea.minY;
      var maxVisible = rotated ? visibleArea.maxX : visibleArea.maxY;

      var min = _max(minVisible, minValue);

      var max = _min(maxVisible, maxValue);

      var center = min + (max - min) / 2;

      if (rotated) {
        y = that.x;
        x = center;
      } else {
        x = that.x;
        y = center;
      }

      return {
        x: x,
        y: y
      };
    }
  },
  hasValue: function hasValue() {
    return this.highValue !== null && this.lowValue !== null;
  },
  hasCoords: function hasCoords() {
    return this.x !== null && this.lowY !== null && this.highY !== null;
  },
  _translate: function _translate() {
    var that = this;
    var rotated = that._options.rotated;

    var valTranslator = that._getValTranslator();

    var x = that._getArgTranslator().translate(that.argument);

    that.vx = that.vy = that.x = x === null ? x : x + (that.xCorrection || 0);
    that.openY = that.openValue !== null ? valTranslator.translate(that.openValue) : null;
    that.highY = valTranslator.translate(that.highValue);
    that.lowY = valTranslator.translate(that.lowValue);
    that.closeY = that.closeValue !== null ? valTranslator.translate(that.closeValue) : null;
    var centerValue = _min(that.lowY, that.highY) + _abs(that.lowY - that.highY) / 2;

    that._calculateVisibility(!rotated ? that.x : centerValue, !rotated ? centerValue : that.x);
  },
  getCrosshairData: function getCrosshairData(x, y) {
    var that = this;
    var rotated = that._options.rotated;
    var origY = rotated ? x : y;
    var yValue;
    var argument = that.argument;
    var coords;
    var coord = 'low';

    if (_abs(that.lowY - origY) < _abs(that.closeY - origY)) {
      yValue = that.lowY;
    } else {
      yValue = that.closeY;
      coord = 'close';
    }

    if (_abs(yValue - origY) >= _abs(that.openY - origY)) {
      yValue = that.openY;
      coord = 'open';
    }

    if (_abs(yValue - origY) >= _abs(that.highY - origY)) {
      yValue = that.highY;
      coord = 'high';
    }

    if (rotated) {
      coords = {
        y: that.vy,
        x: yValue,
        xValue: that[coord + 'Value'],
        yValue: argument
      };
    } else {
      coords = {
        x: that.vx,
        y: yValue,
        xValue: argument,
        yValue: that[coord + 'Value']
      };
    }

    coords.axis = that.series.axis;
    return coords;
  },
  _updateData: function _updateData(data) {
    var that = this;
    var label = that._label;
    var reductionColor = this._options.reduction.color;
    that.value = that.initialValue = data.reductionValue;
    that.originalValue = data.value;
    that.lowValue = that.originalLowValue = data.lowValue;
    that.highValue = that.originalHighValue = data.highValue;
    that.openValue = that.originalOpenValue = data.openValue;
    that.closeValue = that.originalCloseValue = data.closeValue;
    that._isPositive = data.openValue < data.closeValue;
    that._isReduction = data.isReduction;

    if (that._isReduction) {
      label.setColor(reductionColor);
    }
  },
  _updateMarker: function _updateMarker(animationEnabled, style, group) {
    var that = this;
    var graphic = that.graphic;
    graphic.attr({
      points: that._getPoints()
    }).smartAttr(style).sharp();
    group && graphic.append(that._getMarkerGroup(group));
  },
  _getLabelFormatObject: function _getLabelFormatObject() {
    var that = this;
    return {
      openValue: that.openValue,
      highValue: that.highValue,
      lowValue: that.lowValue,
      closeValue: that.closeValue,
      reductionValue: that.initialValue,
      argument: that.initialArgument,
      value: that.initialValue,
      seriesName: that.series.name,
      originalOpenValue: that.originalOpenValue,
      originalCloseValue: that.originalCloseValue,
      originalLowValue: that.originalLowValue,
      originalHighValue: that.originalHighValue,
      originalArgument: that.originalArgument,
      point: that
    };
  },
  _getFormatObject: function _getFormatObject(tooltip) {
    var that = this;
    var highValue = tooltip.formatValue(that.highValue);
    var openValue = tooltip.formatValue(that.openValue);
    var closeValue = tooltip.formatValue(that.closeValue);
    var lowValue = tooltip.formatValue(that.lowValue);
    var symbolMethods = _symbol_point.default;

    var formatObject = symbolMethods._getFormatObject.call(that, tooltip);

    return (0, _extend2.extend)({}, formatObject, {
      valueText: 'h: ' + highValue + (openValue !== '' ? ' o: ' + openValue : '') + (closeValue !== '' ? ' c: ' + closeValue : '') + ' l: ' + lowValue,
      highValueText: highValue,
      openValueText: openValue,
      closeValueText: closeValue,
      lowValueText: lowValue
    });
  },
  getMaxValue: function getMaxValue() {
    return this.highValue;
  },
  getMinValue: function getMinValue() {
    return this.lowValue;
  }
});

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 590 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.ThemeManager = void 0;

var _common = __webpack_require__(4);

var _type = __webpack_require__(1);

var _extend = __webpack_require__(0);

var _base_theme_manager = __webpack_require__(343);

var _utils = __webpack_require__(14);

var ThemeManager = _base_theme_manager.BaseThemeManager.inherit(function () {
  var ctor = function ctor(params) {
    var that = this;
    that.callBase.apply(that, arguments);
    var options = params.options || {};
    that._userOptions = options;
    that._mergeAxisTitleOptions = [];
    that._multiPieColors = {}; // This is required because chart calls "_getOption" during "_init" stage
    // TODO: Remove it when chart stops doing that

    that._callback = _common.noop;
  };

  var dispose = function dispose() {
    var that = this;
    that.palette && that.palette.dispose();
    that.palette = that._userOptions = that._mergedSettings = that._multiPieColors = null;
    return that.callBase.apply(that, arguments);
  };

  var resetPalette = function resetPalette() {
    this.palette.reset();
    this._multiPieColors = {};
  };

  var processTitleOptions = function processTitleOptions(options) {
    return (0, _type.isString)(options) ? {
      text: options
    } : options;
  };

  var processAxisOptions = function processAxisOptions(axisOptions) {
    if (!axisOptions) {
      return {};
    }

    axisOptions = (0, _extend.extend)(true, {}, axisOptions);
    axisOptions.title = processTitleOptions(axisOptions.title);

    if (axisOptions.type === 'logarithmic' && axisOptions.logarithmBase <= 0 || axisOptions.logarithmBase && !(0, _type.isNumeric)(axisOptions.logarithmBase)) {
      axisOptions.logarithmBase = undefined;
      axisOptions.logarithmBaseError = true;
    }

    if (axisOptions.label) {
      if (axisOptions.label.alignment) {
        axisOptions.label['userAlignment'] = true;
      }
    }

    return axisOptions;
  };

  var applyParticularAxisOptions = function applyParticularAxisOptions(name, userOptions, rotated) {
    var theme = this._theme;
    var position = !(rotated ^ name === 'valueAxis') ? 'horizontalAxis' : 'verticalAxis';
    var processedUserOptions = processAxisOptions(userOptions);
    var commonAxisSettings = processAxisOptions(this._userOptions['commonAxisSettings']);
    var mergeOptions = (0, _extend.extend)(true, {}, theme.commonAxisSettings, theme[position], theme[name], commonAxisSettings, processedUserOptions);
    mergeOptions.workWeek = processedUserOptions.workWeek || theme[name].workWeek;
    mergeOptions.forceUserTickInterval |= (0, _type.isDefined)(processedUserOptions.tickInterval) && !(0, _type.isDefined)(processedUserOptions.axisDivisionFactor);
    return mergeOptions;
  };

  var mergeOptions = function mergeOptions(name, userOptions) {
    userOptions = userOptions || this._userOptions[name];
    var theme = this._theme[name];
    var result = this._mergedSettings[name];

    if (result) {
      return result;
    }

    if ((0, _type.isPlainObject)(theme) && (0, _type.isPlainObject)(userOptions)) {
      result = (0, _extend.extend)(true, {}, theme, userOptions);
    } else {
      result = (0, _type.isDefined)(userOptions) ? userOptions : theme;
    }

    this._mergedSettings[name] = result;
    return result;
  };

  var applyParticularTheme = {
    base: mergeOptions,
    argumentAxis: applyParticularAxisOptions,
    valueAxisRangeSelector: function valueAxisRangeSelector() {
      return mergeOptions.call(this, 'valueAxis');
    },
    valueAxis: applyParticularAxisOptions,
    series: function series(name, userOptions, seriesCount) {
      var that = this;
      var theme = that._theme;
      var userCommonSettings = that._userOptions.commonSeriesSettings || {};
      var themeCommonSettings = theme.commonSeriesSettings;

      var widgetType = that._themeSection.split('.').slice(-1)[0];

      var type = (0, _utils.normalizeEnum)(userOptions.type || userCommonSettings.type || themeCommonSettings.type || widgetType === 'pie' && theme.type); // userCommonSettings.type && themeCommonSettings.type deprecated in 15.2 in pie

      var palette = that.palette;
      var isBar = ~type.indexOf('bar');
      var isLine = ~type.indexOf('line');
      var isArea = ~type.indexOf('area');
      var isBubble = type === 'bubble';
      var mainSeriesColor;
      var resolveLabelsOverlapping = that.getOptions('resolveLabelsOverlapping');
      var containerBackgroundColor = that.getOptions('containerBackgroundColor');
      var seriesTemplate = applyParticularTheme.seriesTemplate.call(this);
      var seriesVisibility;

      if (isBar || isBubble) {
        userOptions = (0, _extend.extend)(true, {}, userCommonSettings, userCommonSettings[type], userOptions);
        seriesVisibility = userOptions.visible;
        userCommonSettings = {
          type: {}
        };
        (0, _extend.extend)(true, userOptions, userOptions.point);
        userOptions.visible = seriesVisibility;
      }

      var settings = (0, _extend.extend)(true, {
        aggregation: {}
      }, themeCommonSettings, themeCommonSettings[type], userCommonSettings, userCommonSettings[type], userOptions);
      settings.aggregation.enabled = widgetType === 'chart' && !!settings.aggregation.enabled;
      settings.type = type;
      settings.widgetType = widgetType;
      settings.containerBackgroundColor = containerBackgroundColor;

      if (widgetType !== 'pie') {
        mainSeriesColor = settings.color || palette.getNextColor(seriesCount);
      } else {
        mainSeriesColor = function mainSeriesColor(argument, index, count) {
          var cat = "".concat(argument, "-").concat(index);

          if (!that._multiPieColors[cat]) {
            that._multiPieColors[cat] = palette.getNextColor(count);
          }

          return that._multiPieColors[cat];
        };
      }

      settings.mainSeriesColor = mainSeriesColor;
      settings.resolveLabelsOverlapping = resolveLabelsOverlapping;

      if (settings.label && (isLine || isArea && type !== 'rangearea' || type === 'scatter')) {
        settings.label.position = 'outside';
      }

      if (seriesTemplate) {
        settings.nameField = seriesTemplate.nameField;
      }

      return settings;
    },
    animation: function animation(name) {
      var userOptions = this._userOptions[name];
      userOptions = (0, _type.isPlainObject)(userOptions) ? userOptions : (0, _type.isDefined)(userOptions) ? {
        enabled: !!userOptions
      } : {};
      return mergeOptions.call(this, name, userOptions);
    },
    seriesTemplate: function seriesTemplate() {
      var value = mergeOptions.call(this, 'seriesTemplate');

      if (value) {
        value.nameField = value.nameField || 'series';
      }

      return value;
    },
    zoomAndPan: function zoomAndPan() {
      function parseOption(option) {
        option = (0, _utils.normalizeEnum)(option);
        var pan = option === 'pan' || option === 'both';
        var zoom = option === 'zoom' || option === 'both';
        return {
          pan: pan,
          zoom: zoom,
          none: !pan && !zoom
        };
      }

      var options = mergeOptions.call(this, 'zoomAndPan');
      return {
        valueAxis: parseOption(options.valueAxis),
        argumentAxis: parseOption(options.argumentAxis),
        dragToZoom: !!options.dragToZoom,
        dragBoxStyle: {
          class: 'dxc-shutter',
          fill: options.dragBoxStyle.color,
          opacity: options.dragBoxStyle.opacity
        },
        panKey: options.panKey,
        allowMouseWheel: !!options.allowMouseWheel,
        allowTouchGestures: !!options.allowTouchGestures
      };
    }
  };
  return {
    _themeSection: 'chart',
    ctor: ctor,
    dispose: dispose,
    resetPalette: resetPalette,
    getOptions: function getOptions(name) {
      return (applyParticularTheme[name] || applyParticularTheme.base).apply(this, arguments);
    },
    refresh: function refresh() {
      this._mergedSettings = {};
      return this.callBase.apply(this, arguments);
    },
    _initializeTheme: function _initializeTheme() {
      var that = this;
      that.callBase.apply(that, arguments);
      that.updatePalette();
    },
    resetOptions: function resetOptions(name) {
      this._mergedSettings[name] = null;
    },
    update: function update(options) {
      this._userOptions = options;
    },
    updatePalette: function updatePalette() {
      var that = this;
      that.palette = that.createPalette(that.getOptions('palette'), {
        useHighlight: true,
        extensionMode: that.getOptions('paletteExtensionMode')
      });
    }
  };
}());

exports.ThemeManager = ThemeManager;

/***/ }),
/* 591 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.LayoutManager = LayoutManager;

var _type = __webpack_require__(1);

var _consts = _interopRequireDefault(__webpack_require__(161));

var _layout_element = __webpack_require__(344);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var floor = Math.floor,
    sqrt = Math.sqrt;
var _min = Math.min;
var _max = Math.max;
var DEFAULT_INNER_RADIUS = 0.5;
var RADIAL_LABEL_INDENT = _consts.default.radialLabelIndent;

function getNearestCoord(firstCoord, secondCoord, pointCenterCoord) {
  var nearestCoord;

  if (pointCenterCoord < firstCoord) {
    nearestCoord = firstCoord;
  } else if (secondCoord < pointCenterCoord) {
    nearestCoord = secondCoord;
  } else {
    nearestCoord = pointCenterCoord;
  }

  return nearestCoord;
}

function getLabelLayout(point) {
  if (point._label.isVisible() && point._label.getLayoutOptions().position !== 'inside') {
    return point._label.getBoundingRect();
  }
}

function getPieRadius(series, paneCenterX, paneCenterY, accessibleRadius, minR) {
  series.some(function (singleSeries) {
    return singleSeries.getVisiblePoints().reduce(function (radiusIsFound, point) {
      var labelBBox = getLabelLayout(point);

      if (labelBBox) {
        var xCoords = getNearestCoord(labelBBox.x, labelBBox.x + labelBBox.width, paneCenterX);
        var yCoords = getNearestCoord(labelBBox.y, labelBBox.y + labelBBox.height, paneCenterY);
        accessibleRadius = _min(_max(getLengthFromCenter(xCoords, yCoords, paneCenterX, paneCenterY) - RADIAL_LABEL_INDENT, minR), accessibleRadius);
        radiusIsFound = true;
      }

      return radiusIsFound;
    }, false);
  });
  return accessibleRadius;
}

function getSizeLabels(series) {
  return series.reduce(function (res, singleSeries) {
    var maxWidth = singleSeries.getVisiblePoints().reduce(function (width, point) {
      var labelBBox = getLabelLayout(point);

      if (labelBBox && labelBBox.width > width) {
        width = labelBBox.width;
      }

      return width;
    }, 0);
    var rWidth = maxWidth;

    if (maxWidth) {
      res.outerLabelsCount++;

      if (res.outerLabelsCount > 1) {
        maxWidth += _consts.default.pieLabelSpacing;
      }

      rWidth += _consts.default.pieLabelSpacing;
    }

    res.sizes.push(maxWidth);
    res.rSizes.push(rWidth);
    res.common += maxWidth;
    return res;
  }, {
    sizes: [],
    rSizes: [],
    common: 0,
    outerLabelsCount: 0
  });
}

function correctLabelRadius(labelSizes, radius, series, canvas, averageWidthLabels, centerX) {
  var curRadius;
  var i;
  var runningWidth = 0;
  var sizes = labelSizes.sizes;
  var rSizes = labelSizes.rSizes;

  for (i = 0; i < series.length; i++) {
    if (sizes[i] === 0) {
      curRadius && (curRadius += rSizes[i - 1]);
      continue;
    }

    curRadius = floor(curRadius ? curRadius + rSizes[i - 1] : radius);
    series[i].correctLabelRadius(curRadius);
    runningWidth += averageWidthLabels || sizes[i];
    rSizes[i] = averageWidthLabels || rSizes[i];
    series[i].setVisibleArea({
      left: floor(centerX - radius - runningWidth),
      right: floor(canvas.width - (centerX + radius + runningWidth)),
      top: canvas.top,
      bottom: canvas.bottom,
      width: canvas.width,
      height: canvas.height
    });
  }
}

function getLengthFromCenter(x, y, paneCenterX, paneCenterY) {
  return sqrt((x - paneCenterX) * (x - paneCenterX) + (y - paneCenterY) * (y - paneCenterY));
}

function getInnerRadius(_ref) {
  var type = _ref.type,
      innerRadius = _ref.innerRadius;
  return type === 'pie' ? 0 : (0, _type.isNumeric)(innerRadius) ? Number(innerRadius) : DEFAULT_INNER_RADIUS;
}

function LayoutManager() {}

function getAverageLabelWidth(centerX, radius, canvas, sizeLabels) {
  return (centerX - radius - RADIAL_LABEL_INDENT - canvas.left) / sizeLabels.outerLabelsCount;
}

function getFullRadiusWithLabels(centerX, canvas, sizeLabels) {
  return centerX - canvas.left - (sizeLabels.outerLabelsCount > 0 ? sizeLabels.common + RADIAL_LABEL_INDENT : 0);
}

function correctAvailableRadius(availableRadius, canvas, series, minR, paneCenterX, paneCenterY) {
  var sizeLabels = getSizeLabels(series);
  var averageWidthLabels;
  var fullRadiusWithLabels = getFullRadiusWithLabels(paneCenterX, canvas, sizeLabels);

  if (fullRadiusWithLabels < minR) {
    availableRadius = minR;
    averageWidthLabels = getAverageLabelWidth(paneCenterX, availableRadius, canvas, sizeLabels);
  } else {
    availableRadius = _min(getPieRadius(series, paneCenterX, paneCenterY, availableRadius, minR), fullRadiusWithLabels);
  }

  correctLabelRadius(sizeLabels, availableRadius + RADIAL_LABEL_INDENT, series, canvas, averageWidthLabels, paneCenterX);
  return availableRadius;
}

function toLayoutElementCoords(canvas) {
  return new _layout_element.WrapperLayoutElement(null, {
    x: canvas.left,
    y: canvas.top,
    width: canvas.width - canvas.left - canvas.right,
    height: canvas.height - canvas.top - canvas.bottom
  });
}

LayoutManager.prototype = {
  constructor: LayoutManager,
  setOptions: function setOptions(options) {
    this._options = options;
  },
  applyPieChartSeriesLayout: function applyPieChartSeriesLayout(canvas, series, hideLayoutLabels) {
    var paneSpaceHeight = canvas.height - canvas.top - canvas.bottom;
    var paneSpaceWidth = canvas.width - canvas.left - canvas.right;
    var paneCenterX = paneSpaceWidth / 2 + canvas.left;
    var paneCenterY = paneSpaceHeight / 2 + canvas.top;
    var piePercentage = this._options.piePercentage;
    var availableRadius;
    var minR;

    if ((0, _type.isNumeric)(piePercentage)) {
      availableRadius = minR = piePercentage * _min(canvas.height, canvas.width) / 2;
    } else {
      availableRadius = _min(paneSpaceWidth, paneSpaceHeight) / 2;
      minR = this._options.minPiePercentage * availableRadius;
    }

    if (!hideLayoutLabels) {
      availableRadius = correctAvailableRadius(availableRadius, canvas, series, minR, paneCenterX, paneCenterY);
    }

    return {
      centerX: floor(paneCenterX),
      centerY: floor(paneCenterY),
      radiusInner: floor(availableRadius * getInnerRadius(series[0])),
      radiusOuter: floor(availableRadius)
    };
  },
  applyEqualPieChartLayout: function applyEqualPieChartLayout(series, layout) {
    var radius = layout.radius;
    return {
      centerX: floor(layout.x),
      centerY: floor(layout.y),
      radiusInner: floor(radius * getInnerRadius(series[0])),
      radiusOuter: floor(radius)
    };
  },
  correctPieLabelRadius: function correctPieLabelRadius(series, layout, canvas) {
    var sizeLabels = getSizeLabels(series);
    var averageWidthLabels;
    var radius = layout.radiusOuter + RADIAL_LABEL_INDENT;
    var availableLabelWidth = layout.centerX - canvas.left - radius;

    if (sizeLabels.common + RADIAL_LABEL_INDENT > availableLabelWidth) {
      averageWidthLabels = getAverageLabelWidth(layout.centerX, layout.radiusOuter, canvas, sizeLabels);
    }

    correctLabelRadius(sizeLabels, radius, series, canvas, averageWidthLabels, layout.centerX);
  },
  needMoreSpaceForPanesCanvas: function needMoreSpaceForPanesCanvas(panes, rotated, fixedSizeCallback) {
    var options = this._options;
    var width = options.width;
    var height = options.height;
    var piePercentage = options.piePercentage;
    var percentageIsValid = (0, _type.isNumeric)(piePercentage);
    var needHorizontalSpace = 0;
    var needVerticalSpace = 0;
    panes.forEach(function (pane) {
      var paneCanvas = pane.canvas;
      var minSize = percentageIsValid ? _min(paneCanvas.width, paneCanvas.height) * piePercentage : undefined;
      var paneSized = fixedSizeCallback ? fixedSizeCallback(pane) : {
        width: false,
        height: false
      };
      var needPaneHorizontalSpace = !paneSized.width ? (percentageIsValid ? minSize : width) - (paneCanvas.width - paneCanvas.left - paneCanvas.right) : 0;
      var needPaneVerticalSpace = !paneSized.height ? (percentageIsValid ? minSize : height) - (paneCanvas.height - paneCanvas.top - paneCanvas.bottom) : 0;

      if (rotated) {
        needHorizontalSpace += needPaneHorizontalSpace > 0 ? needPaneHorizontalSpace : 0;
        needVerticalSpace = _max(needPaneVerticalSpace > 0 ? needPaneVerticalSpace : 0, needVerticalSpace);
      } else {
        needHorizontalSpace = _max(needPaneHorizontalSpace > 0 ? needPaneHorizontalSpace : 0, needHorizontalSpace);
        needVerticalSpace += needPaneVerticalSpace > 0 ? needPaneVerticalSpace : 0;
      }
    });
    return needHorizontalSpace > 0 || needVerticalSpace > 0 ? {
      width: needHorizontalSpace,
      height: needVerticalSpace
    } : false;
  },
  layoutInsideLegend: function layoutInsideLegend(legend, canvas) {
    var inverseAlign = {
      left: 'right',
      right: 'left',
      top: 'bottom',
      bottom: 'top',
      center: 'center'
    };
    var layoutOptions = legend.getLayoutOptions();

    if (!layoutOptions) {
      return;
    }

    var position = layoutOptions.position;
    var cutSide = layoutOptions.cutSide;
    var my = {
      horizontal: position.horizontal,
      vertical: position.vertical
    };
    canvas[layoutOptions.cutLayoutSide] += layoutOptions.cutSide === 'horizontal' ? layoutOptions.width : layoutOptions.height;
    my[cutSide] = inverseAlign[my[cutSide]];
    legend.position({
      of: toLayoutElementCoords(canvas),
      my: my,
      at: position
    });
  }
};

/***/ }),
/* 592 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Plaque = void 0;

var _extend = __webpack_require__(0);

var _type = __webpack_require__(1);

var _excluded = ["x", "y", "canvas", "offsetX", "offsetY", "offset"];

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var math = Math;
var round = math.round;
var max = math.max;
var min = math.min;
var sin = math.sin;
var cos = math.cos;
var asin = math.asin;
var PI = math.PI;

var buildPath = function buildPath() {
  for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {
    points[_key] = arguments[_key];
  }

  return points.join('');
};

function getArc(cornerRadius, xDirection, yDirection) {
  return "a ".concat(cornerRadius, " ").concat(cornerRadius, " 0 0 1 ").concat(xDirection * cornerRadius, " ").concat(yDirection * cornerRadius);
}

function getAbsoluteArc(cornerRadius, x, y) {
  return "A ".concat(cornerRadius, " ").concat(cornerRadius, " 0 0 1 ").concat(x, " ").concat(y);
}

function rotateX(x, y, angle, x0, y0) {
  return (x - x0) * round(cos(angle)) + (y - y0) * round(sin(angle)) + x0;
}

function rotateY(x, y, angle, x0, y0) {
  return -(x - x0) * round(sin(angle)) + (y - y0) * round(cos(angle)) + y0;
}

function rotateSize(options, angle) {
  if (angle % 90 === 0 && angle % 180 !== 0) {
    return {
      width: options.height,
      height: options.width
    };
  }

  return options;
}

function getCloudAngle(_ref, x, y, anchorX, anchorY) {
  var width = _ref.width,
      height = _ref.height;
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var xr = Math.ceil(x + halfWidth);
  var xl = Math.floor(x - halfWidth);
  var yt = Math.floor(y - halfHeight);
  var yb = Math.ceil(y + halfHeight); // 1 | 2 | 3
  // 8 | 0 | 4
  // 7 | 6 | 5

  if (anchorX < xl && anchorY < yt || // 1
  anchorX >= xl && anchorX <= xr && anchorY < yt // 2
  ) {
      return 270;
    }

  if (anchorX > xr && anchorY > yb || // 5
  anchorX >= xl && anchorX <= xr && anchorY > yb // 6
  ) {
      return 90;
    } else if (anchorX < xl && anchorY > yb || // 7
  anchorX < xl && anchorY >= yt && anchorY <= yb // 8
  ) {
      return 180;
    }

  return 0; // 0, 3, 4
}

function getCloudPoints(_ref2, x, y, anchorX, anchorY, _ref3, bounded) {
  var width = _ref2.width,
      height = _ref2.height;
  var arrowWidth = _ref3.arrowWidth,
      _ref3$cornerRadius = _ref3.cornerRadius,
      cornerRadius = _ref3$cornerRadius === void 0 ? 0 : _ref3$cornerRadius;
  var halfArrowWidth = arrowWidth / 2;
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var xr = Math.ceil(x + halfWidth);
  var xl = Math.floor(x - halfWidth);
  var yt = Math.floor(y - halfHeight);
  var yb = Math.ceil(y + halfHeight);
  var leftTopCorner = [xl, yt];
  var rightTopCorner = [xr, yt];
  var rightBottomCorner = [xr, yb];
  var leftBottomCorner = [xl, yb];
  var arrowX = anchorX <= xl ? xl : xr <= anchorX ? xr : anchorX;
  var arrowY = anchorY <= yt ? yt : yb <= anchorY ? yb : anchorY;
  var arrowBaseBottom = min(arrowY + halfArrowWidth, yb);
  var arrowBaseTop = max(arrowY - halfArrowWidth, yt);
  var arrowBaseLeft = max(arrowX - halfArrowWidth, xl);
  cornerRadius = Math.min(width / 2, height / 2, cornerRadius);
  var points;
  leftTopCorner[1] += cornerRadius;
  rightTopCorner[0] -= cornerRadius;
  rightBottomCorner[1] -= cornerRadius;
  leftBottomCorner[0] += cornerRadius; // 1 | 2 | 3
  // 8 | 0 | 4
  // 7 | 6 | 5

  if (!bounded || xl <= anchorX && anchorX <= xr && yt <= anchorY && anchorY <= yb) {
    // 0
    points = buildPath(leftTopCorner, getArc(cornerRadius, 1, -1), 'L', rightTopCorner, getArc(cornerRadius, 1, 1), 'L', rightBottomCorner, getArc(cornerRadius, -1, 1), 'L', leftBottomCorner, getArc(cornerRadius, -1, -1));
  } else if (anchorX > xr && anchorY < yt) {
    // 3
    var arrowAngle = arrowWidth / cornerRadius || 0;
    var angle = PI / 4 + arrowAngle / 2;
    var endAngle = PI / 4 - arrowAngle / 2;
    var arrowEndPointX = rightTopCorner[0] + cos(endAngle) * cornerRadius;
    var arrowEndPointY = rightTopCorner[1] + (1 - sin(endAngle)) * cornerRadius;
    var arrowArc = buildPath('L', rightTopCorner, getArc(cornerRadius, cos(angle), 1 - sin(angle)), 'L', [anchorX, anchorY, arrowEndPointX, arrowEndPointY], getAbsoluteArc(cornerRadius, rightTopCorner[0] + cornerRadius, rightTopCorner[1] + cornerRadius));

    if (Math.abs(angle) > PI / 2) {
      arrowArc = buildPath('L', [arrowBaseLeft, yt, anchorX, anchorY, xr, arrowBaseBottom]);
    }

    points = buildPath(leftTopCorner, getArc(cornerRadius, 1, -1), arrowArc, 'L', rightBottomCorner, getArc(cornerRadius, -1, 1), 'L', leftBottomCorner, getArc(cornerRadius, -1, -1));
  } else if (anchorX > xr && anchorY >= yt && anchorY <= yb) {
    // 4
    var _arrowArc;

    if (arrowBaseTop >= rightTopCorner[1] + cornerRadius && arrowBaseBottom <= rightBottomCorner[1]) {
      _arrowArc = buildPath(getArc(cornerRadius, 1, 1), 'L', [xr, arrowBaseTop, anchorX, anchorY, xr, arrowBaseBottom], 'L', rightBottomCorner, getArc(cornerRadius, -1, 1));
    } else if (arrowBaseTop < rightTopCorner[1] + cornerRadius && arrowBaseBottom >= rightTopCorner[1] + cornerRadius && arrowBaseBottom <= rightBottomCorner[1]) {
      var arrowWidthRest = rightTopCorner[1] + cornerRadius - arrowBaseTop;

      var _angle = arrowWidthRest / cornerRadius;

      var arrowBaseTopX = rightTopCorner[0] + cos(_angle) * cornerRadius;
      var arrowBaseTopY = rightTopCorner[1] + (1 - sin(_angle)) * cornerRadius;
      _arrowArc = buildPath(getArc(cornerRadius, cos(_angle), 1 - sin(_angle)), 'L', [arrowBaseTopX, arrowBaseTopY, anchorX, anchorY, xr, arrowBaseBottom], 'L', rightBottomCorner, getArc(cornerRadius, -1, 1));
    } else if (arrowBaseTop < rightTopCorner[1] + cornerRadius && arrowBaseBottom < rightTopCorner[1] + cornerRadius) {
      var _arrowWidthRest = rightTopCorner[1] + cornerRadius - arrowBaseTop;

      var _arrowAngle = _arrowWidthRest / cornerRadius;

      var _angle2 = _arrowAngle;

      var _arrowBaseTopX = rightTopCorner[0] + cos(_angle2) * cornerRadius;

      var _arrowBaseTopY = rightTopCorner[1] + (1 - sin(_angle2)) * cornerRadius;

      var bottomAngle = Math.sin((rightTopCorner[1] + cornerRadius - arrowBaseBottom) / cornerRadius);
      var arrowBaseBottomX = rightTopCorner[0] + cornerRadius * cos(bottomAngle);
      var arrowBaseBottomY = rightTopCorner[1] + cornerRadius * (1 - sin(bottomAngle));
      _arrowArc = buildPath(getArc(cornerRadius, cos(_angle2), 1 - sin(_angle2)), 'L', [_arrowBaseTopX, _arrowBaseTopY, anchorX, anchorY, arrowBaseBottomX, arrowBaseBottomY], getAbsoluteArc(cornerRadius, rightTopCorner[0] + cornerRadius, rightTopCorner[1] + cornerRadius), 'L', rightBottomCorner, getArc(cornerRadius, -1, 1));
    } else if (arrowBaseTop <= rightTopCorner[1] + cornerRadius && arrowBaseBottom >= rightBottomCorner[1]) {
      var topAngle = asin((rightTopCorner[1] + cornerRadius - arrowBaseTop) / cornerRadius);

      var _arrowBaseTopX2 = rightTopCorner[0] + cornerRadius * cos(topAngle);

      var _arrowBaseTopY2 = rightTopCorner[1] + cornerRadius * (1 - sin(topAngle));

      var _bottomAngle = asin((arrowBaseBottom - rightBottomCorner[1]) / cornerRadius);

      var _arrowBaseBottomX = rightBottomCorner[0] + cornerRadius * (cos(_bottomAngle) - 1);

      var _arrowBaseBottomY = rightBottomCorner[1] + cornerRadius * sin(_bottomAngle);

      _arrowArc = buildPath(getArc(cornerRadius, cos(topAngle), 1 - sin(topAngle)), 'L', [_arrowBaseTopX2, _arrowBaseTopY2, anchorX, anchorY, _arrowBaseBottomX, _arrowBaseBottomY], getAbsoluteArc(cornerRadius, rightBottomCorner[0] - cornerRadius, rightBottomCorner[1] + cornerRadius));
    } else if (arrowBaseTop > rightTopCorner[1] + cornerRadius && arrowBaseTop <= rightBottomCorner[1] && arrowBaseBottom > rightBottomCorner[1]) {
      var _bottomAngle2 = asin((arrowBaseBottom - rightBottomCorner[1]) / cornerRadius);

      var _arrowBaseBottomX2 = rightBottomCorner[0] + cornerRadius * (cos(_bottomAngle2) - 1);

      var _arrowBaseBottomY2 = rightBottomCorner[1] + cornerRadius * sin(_bottomAngle2);

      _arrowArc = buildPath(getArc(cornerRadius, 1, 1), 'L', [xr, arrowBaseTop, anchorX, anchorY, _arrowBaseBottomX2, _arrowBaseBottomY2], getAbsoluteArc(cornerRadius, rightBottomCorner[0] - cornerRadius, rightBottomCorner[1] + cornerRadius));
    } else if (arrowBaseTop > rightTopCorner[1] + cornerRadius && arrowBaseBottom > rightBottomCorner[1]) {
      var _bottomAngle3 = asin((arrowBaseBottom - rightBottomCorner[1]) / cornerRadius);

      var _arrowBaseBottomX3 = rightBottomCorner[0] + cornerRadius * (cos(_bottomAngle3) - 1);

      var _arrowBaseBottomY3 = rightBottomCorner[1] + cornerRadius * sin(_bottomAngle3);

      var _topAngle = asin((arrowBaseTop - rightBottomCorner[1]) / cornerRadius);

      var _arrowBaseTopX3 = rightBottomCorner[0] + cornerRadius * (cos(_topAngle) - 1);

      var _arrowBaseTopY3 = rightBottomCorner[1] + cornerRadius * sin(_topAngle);

      _arrowArc = buildPath(getArc(cornerRadius, 1, 1), 'L', rightBottomCorner, getArc(cornerRadius, cos(_topAngle) - 1, sin(_topAngle)), 'L', [_arrowBaseTopX3, _arrowBaseTopY3, anchorX, anchorY, _arrowBaseBottomX3, _arrowBaseBottomY3], getAbsoluteArc(cornerRadius, rightBottomCorner[0] - cornerRadius, rightBottomCorner[1] + cornerRadius));
    }

    points = buildPath(leftTopCorner, getArc(cornerRadius, 1, -1), 'L', rightTopCorner, _arrowArc, 'L', leftBottomCorner, getArc(cornerRadius, -1, -1));
  }

  return buildPath('M', points, 'Z');
}

var Plaque = /*#__PURE__*/function () {
  function Plaque(options, widget, root, contentTemplate) {
    var bounded = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    var measureContent = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function (_, g) {
      return g.getBBox();
    };
    var moveContentGroup = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : function (_, g, x, y) {
      return g.move(x, y);
    };
    this.widget = widget;
    this.options = options;
    this.root = root;
    this.contentTemplate = contentTemplate;
    this.bonded = bounded;
    this.measureContent = measureContent;
    this.moveContentGroup = moveContentGroup;
  }

  var _proto = Plaque.prototype;

  _proto.draw = function draw(_ref4) {
    var _this = this;

    var anchorX = _ref4.x,
        anchorY = _ref4.y,
        _ref4$canvas = _ref4.canvas,
        canvas = _ref4$canvas === void 0 ? {} : _ref4$canvas,
        offsetX = _ref4.offsetX,
        offsetY = _ref4.offsetY,
        _ref4$offset = _ref4.offset,
        offset = _ref4$offset === void 0 ? 0 : _ref4$offset,
        restProps = _objectWithoutProperties(_ref4, _excluded);

    var options = this.options;
    var x = options.x,
        y = options.y;
    var bounds = {
      xl: canvas.left,
      xr: canvas.width - canvas.right,
      width: canvas.width - canvas.right - canvas.left,
      yt: canvas.top,
      yb: canvas.height - canvas.bottom,
      height: canvas.height - canvas.bottom - canvas.top
    };

    if (!((0, _type.isDefined)(anchorX) && (0, _type.isDefined)(anchorY)) && !((0, _type.isDefined)(x) && (0, _type.isDefined)(y))) {
      return false;
    }

    if ((0, _type.isDefined)(anchorX) && (anchorX < bounds.xl || bounds.xr < anchorX || anchorY < bounds.yt || bounds.yb < anchorY)) {
      return false;
    }

    if (!this._root) {
      this._draw();
    }

    var shadowSettings = (0, _extend.extend)({
      x: '-50%',
      y: '-50%',
      width: '200%',
      height: '200%'
    }, options.shadow);
    var contentWidth = options.width > 0 ? options.width : null;
    var contentHeight = options.height > 0 ? options.height : null;

    var onRender = function onRender() {
      var _this$_root;

      var bBox = _this._contentBBox = _this.measureContent(_this.widget, _this._contentGroup);

      var size = _this._size = {
        width: max(contentWidth, bBox.width) + options.paddingLeftRight * 2,
        height: max(contentHeight, bBox.height) + options.paddingTopBottom * 2,
        offset: offset
      };
      var xOff = shadowSettings.offsetX;
      var yOff = shadowSettings.offsetY;
      var blur = shadowSettings.blur * 2 + 1;
      var lm = max(blur - xOff, 0); // left margin

      var rm = max(blur + xOff, 0); // right margin

      var tm = max(blur - yOff, 0); // top margin

      var bm = max(blur + yOff, 0); // bottom margin

      _this.margins = {
        lm: lm,
        rm: rm,
        tm: tm,
        bm: bm
      };

      if (!(0, _type.isDefined)(x)) {
        if ((0, _type.isDefined)(offsetX)) {
          x = anchorX + offsetX;
        } else {
          if (bounds.width < size.width) {
            x = round(bounds.xl + bounds.width / 2);
          } else {
            x = min(max(anchorX, Math.ceil(bounds.xl + size.width / 2 + lm)), Math.floor(bounds.xr - size.width / 2 - rm));
          }
        }
      } else {
        x += offsetX || 0;

        if (!(0, _type.isDefined)(anchorX)) {
          anchorX = x;
        }
      }

      if (!(0, _type.isDefined)(y)) {
        if ((0, _type.isDefined)(offsetY)) {
          y = anchorY + offsetY;
        } else {
          var y_top = anchorY - options.arrowLength - size.height / 2 - offset;
          var y_bottom = anchorY + options.arrowLength + size.height / 2 + offset;

          if (bounds.height < size.height + options.arrowLength) {
            y = round(bounds.yt + size.height / 2);
          } else if (y_top - size.height / 2 - tm < bounds.yt) {
            if (y_bottom + size.height / 2 + bm < bounds.yb) {
              y = y_bottom;
              anchorY += offset;
            } else {
              y = round(bounds.yt + size.height / 2);
            }
          } else {
            y = y_top;
            anchorY -= offset;
          }
        }
      } else {
        y += offsetY || 0;

        if (!(0, _type.isDefined)(anchorY)) {
          anchorY = y + size.height / 2;
        }
      }

      _this.anchorX = anchorX;
      _this.anchorY = anchorY;

      _this.move(x, y);

      (_this$_root = _this._root) === null || _this$_root === void 0 ? void 0 : _this$_root.append(_this.root);
    };

    if (this.contentTemplate.render) {
      this.contentTemplate.render({
        model: options,
        container: this._contentGroup.element,
        onRendered: onRender
      });
    } else {
      return this.contentTemplate(_extends({
        group: this._contentGroup,
        onRender: onRender
      }, restProps));
    }

    return true;
  };

  _proto._draw = function _draw() {
    var renderer = this.widget._renderer;
    var options = this.options;
    var shadowSettings = (0, _extend.extend)({
      x: '-50%',
      y: '-50%',
      width: '200%',
      height: '200%'
    }, options.shadow);
    var shadow = this._shadow = renderer.shadowFilter().attr(shadowSettings);
    var cloudSettings = {
      opacity: options.opacity,
      'stroke-width': 0,
      fill: options.color
    };
    var borderOptions = options.border || {};

    if (borderOptions.visible) {
      (0, _extend.extend)(cloudSettings, {
        'stroke-width': borderOptions.width,
        stroke: borderOptions.color,
        'stroke-opacity': borderOptions.opacity,
        dashStyle: borderOptions.dashStyle
      });
    }

    var group = this._root = renderer.g().append(this.root);

    if (options.type) {
      group.attr({
        class: "dxc-".concat(options.type, "-annotation")
      });
    }

    var cloudGroup = renderer.g().attr({
      filter: shadow.id
    }).append(group);
    this._cloud = renderer.path([], 'area').attr(cloudSettings).sharp().append(cloudGroup);
    this._contentGroup = renderer.g().append(group);
  };

  _proto.getBBox = function getBBox() {
    var size = this._size || {};
    var margins = this.margins || {};
    var rotationAngle = getCloudAngle(size, this.x, this.y, this.anchorX, this.anchorY);
    return {
      x: Math.floor(this.x - size.width / 2 - margins.lm),
      y: Math.floor(this.y - size.height / 2 - margins.tm - (rotationAngle === 270 ? this.options.arrowLength : 0)),
      width: size.width + margins.lm + margins.rm,
      height: size.height + margins.tm + margins.bm + (rotationAngle === 90 || rotationAngle === 270 ? this.options.arrowLength : 0)
    };
  };

  _proto.clear = function clear() {
    if (this._root) {
      this._root.remove();

      this._shadow.remove();

      this._root = null;
    }

    return this;
  };

  _proto.customizeCloud = function customizeCloud(attr) {
    if (this._cloud) {
      this._cloud.attr(attr);
    }
  };

  _proto.moveRoot = function moveRoot(x, y) {
    if (this._root) {
      this._root.move(x, y);
    }
  };

  _proto.move = function move(x, y) {
    x = round(x);
    y = round(y);
    this.x = x;
    this.y = y;
    var rotationAngle = getCloudAngle(this._size, x, y, this.anchorX, this.anchorY);
    var radRotationAngle = rotationAngle * PI / 180;

    this._cloud.attr({
      d: getCloudPoints(rotateSize(this._size, rotationAngle), x, y, rotateX(this.anchorX, this.anchorY, radRotationAngle, x, y), rotateY(this.anchorX, this.anchorY, radRotationAngle, x, y), this.options, this.bonded)
    }).rotate(rotationAngle, x, y);

    this.moveContentGroup(this.widget, this._contentGroup, x - this._contentBBox.x - this._contentBBox.width / 2, y - this._contentBBox.y - this._contentBBox.height / 2);
  };

  _proto.hitTest = function hitTest(x, y) {
    var _ref5 = this._size || {},
        width = _ref5.width,
        height = _ref5.height;

    return Math.abs(x - this.x) <= width / 2 && Math.abs(y - this.y) <= height / 2;
  };

  return Plaque;
}();

exports.Plaque = Plaque;

/***/ }),
/* 593 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.AdvancedChart = void 0;

var _extend2 = __webpack_require__(0);

var _array = __webpack_require__(12);

var _iterator = __webpack_require__(3);

var _range = __webpack_require__(141);

var _base_axis = __webpack_require__(349);

var _series_family = __webpack_require__(599);

var _base_chart = __webpack_require__(342);

var _crosshair = __webpack_require__(600);

var _range_data_calculator = _interopRequireDefault(__webpack_require__(241));

var _type = __webpack_require__(1);

var _common = __webpack_require__(4);

var _utils = __webpack_require__(14);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _isArray = Array.isArray;
var DEFAULT_AXIS_NAME = 'defaultAxisName';
var FONT = 'font';
var COMMON_AXIS_SETTINGS = 'commonAxisSettings';
var DEFAULT_PANE_NAME = 'default';
var VISUAL_RANGE = 'VISUAL_RANGE';

function prepareAxis(axisOptions) {
  return _isArray(axisOptions) ? axisOptions.length === 0 ? [{}] : axisOptions : [axisOptions];
}

function processBubbleMargin(opt, bubbleSize) {
  if (opt.processBubbleSize) {
    opt.size = bubbleSize;
  }

  return opt;
}

function estimateBubbleSize(size, panesCount, maxSize, rotated) {
  var width = rotated ? size.width / panesCount : size.width;
  var height = rotated ? size.height : size.height / panesCount;
  return Math.min(width, height) * maxSize;
}

function setAxisVisualRangeByOption(arg, axis, isDirectOption, index) {
  var options;
  var visualRange;

  if (isDirectOption) {
    visualRange = arg.value;
    options = {
      skipEventRising: true
    };
    var wrappedVisualRange = wrapVisualRange(arg.fullName, visualRange);

    if (wrappedVisualRange) {
      options = {
        allowPartialUpdate: true
      };
      visualRange = wrappedVisualRange;
    }
  } else {
    visualRange = ((0, _type.isDefined)(index) ? arg.value[index] : arg.value).visualRange;
  }

  axis.visualRange(visualRange, options);
}

function getAxisTypes(groupsData, axis, isArgumentAxes) {
  if (isArgumentAxes) {
    return {
      argumentAxisType: groupsData.argumentAxisType,
      argumentType: groupsData.argumentType
    };
  }

  var _groupsData$groups$fi = groupsData.groups.filter(function (g) {
    return g.valueAxis === axis;
  })[0],
      valueAxisType = _groupsData$groups$fi.valueAxisType,
      valueType = _groupsData$groups$fi.valueType;
  return {
    valueAxisType: valueAxisType,
    valueType: valueType
  };
}

function wrapVisualRange(fullName, value) {
  var pathElements = fullName.split('.');
  var destElem = pathElements[pathElements.length - 1];

  if (destElem === 'endValue' || destElem === 'startValue') {
    return _defineProperty({}, destElem, value);
  }
}

var AdvancedChart = _base_chart.BaseChart.inherit({
  _fontFields: [COMMON_AXIS_SETTINGS + '.label.' + FONT, COMMON_AXIS_SETTINGS + '.title.' + FONT],
  _partialOptionChangesMap: {
    visualRange: VISUAL_RANGE,
    _customVisualRange: VISUAL_RANGE,
    strips: 'REFRESH_AXES',
    constantLines: 'REFRESH_AXES'
  },
  _partialOptionChangesPath: {
    argumentAxis: ['strips', 'constantLines', 'visualRange', '_customVisualRange'],
    valueAxis: ['strips', 'constantLines', 'visualRange', '_customVisualRange']
  },
  _initCore: function _initCore() {
    this._panesClipRects = {};
    this.callBase();
  },
  _disposeCore: function _disposeCore() {
    var disposeObjectsInArray = this._disposeObjectsInArray;
    var panesClipRects = this._panesClipRects;
    this.callBase();
    disposeObjectsInArray.call(panesClipRects, 'fixed');
    disposeObjectsInArray.call(panesClipRects, 'base');
    disposeObjectsInArray.call(panesClipRects, 'wide');
    this._panesClipRects = null;

    this._labelsAxesGroup.linkOff();

    this._labelsAxesGroup.dispose();

    this._labelsAxesGroup = null;
  },
  _dispose: function _dispose() {
    var that = this;
    var disposeObjectsInArray = this._disposeObjectsInArray;
    that.callBase();
    that.panes = null;

    if (that._legend) {
      that._legend.dispose();

      that._legend = null;
    }

    disposeObjectsInArray.call(that, 'panesBackground');
    disposeObjectsInArray.call(that, 'seriesFamilies');

    that._disposeAxes();
  },
  _createPanes: function _createPanes() {
    this._cleanPanesClipRects('fixed');

    this._cleanPanesClipRects('base');

    this._cleanPanesClipRects('wide');
  },
  _cleanPanesClipRects: function _cleanPanesClipRects(clipArrayName) {
    var clipArray = this._panesClipRects[clipArrayName];
    (clipArray || []).forEach(function (clipRect) {
      return clipRect && clipRect.dispose();
    });
    this._panesClipRects[clipArrayName] = [];
  },
  _getElementsClipRectID: function _getElementsClipRectID(paneName) {
    var clipShape = this._panesClipRects.fixed[this._getPaneIndex(paneName)];

    return clipShape && clipShape.id;
  },
  _getPaneIndex: function _getPaneIndex(paneName) {
    var paneIndex;
    var name = paneName || DEFAULT_PANE_NAME;
    (0, _iterator.each)(this.panes, function (index, pane) {
      if (pane.name === name) {
        paneIndex = index;
        return false;
      }
    });
    return paneIndex;
  },
  _updateSize: function _updateSize() {
    this.callBase();
    (0, _utils.setCanvasValues)(this._canvas);
  },
  _reinitAxes: function _reinitAxes() {
    this.panes = this._createPanes();

    this._populateAxes();

    this._axesReinitialized = true;
  },
  _getCrosshairMargins: function _getCrosshairMargins() {
    var crosshairOptions = this._getCrosshairOptions() || {};
    var crosshairEnabled = crosshairOptions.enabled;
    var margins = (0, _crosshair.getMargins)();
    return {
      x: crosshairEnabled && crosshairOptions.horizontalLine.visible ? margins.x : 0,
      y: crosshairEnabled && crosshairOptions.verticalLine.visible ? margins.y : 0
    };
  },
  _populateAxes: function _populateAxes() {
    var that = this;
    var panes = that.panes;

    var rotated = that._isRotated();

    var argumentAxesOptions = prepareAxis(that.option('argumentAxis') || {})[0];
    var valueAxisOption = that.option('valueAxis');
    var valueAxesOptions = prepareAxis(valueAxisOption || {});
    var argumentAxesPopulatedOptions = [];
    var valueAxesPopulatedOptions = [];
    var axisNames = [];
    var valueAxesCounter = 0;
    var paneWithNonVirtualAxis;

    var crosshairMargins = that._getCrosshairMargins();

    function getNextAxisName() {
      return DEFAULT_AXIS_NAME + valueAxesCounter++;
    }

    if (rotated) {
      paneWithNonVirtualAxis = argumentAxesOptions.position === 'right' ? panes[panes.length - 1].name : panes[0].name;
    } else {
      paneWithNonVirtualAxis = argumentAxesOptions.position === 'top' ? panes[0].name : panes[panes.length - 1].name;
    }

    argumentAxesPopulatedOptions = (0, _utils.map)(panes, function (pane) {
      var virtual = pane.name !== paneWithNonVirtualAxis;
      return that._populateAxesOptions('argumentAxis', argumentAxesOptions, {
        pane: pane.name,
        name: null,
        optionPath: 'argumentAxis',
        crosshairMargin: rotated ? crosshairMargins.x : crosshairMargins.y
      }, rotated, virtual);
    });
    (0, _iterator.each)(valueAxesOptions, function (priority, axisOptions) {
      var _axisOptions$panes;

      var axisPanes = [];
      var name = axisOptions.name;

      if (name && (0, _array.inArray)(name, axisNames) !== -1) {
        that._incidentOccurred('E2102');

        return;
      }

      name && axisNames.push(name);

      if (axisOptions.pane) {
        axisPanes.push(axisOptions.pane);
      }

      if ((_axisOptions$panes = axisOptions.panes) !== null && _axisOptions$panes !== void 0 && _axisOptions$panes.length) {
        axisPanes = axisPanes.concat(axisOptions.panes.slice(0));
      }

      axisPanes = (0, _utils.unique)(axisPanes);

      if (!axisPanes.length) {
        axisPanes.push(undefined);
      }

      (0, _iterator.each)(axisPanes, function (_, pane) {
        var optionPath = _isArray(valueAxisOption) ? "valueAxis[".concat(priority, "]") : 'valueAxis';
        valueAxesPopulatedOptions.push(that._populateAxesOptions('valueAxis', axisOptions, {
          name: name || getNextAxisName(),
          pane: pane,
          priority: priority,
          optionPath: optionPath,
          crosshairMargin: rotated ? crosshairMargins.y : crosshairMargins.x
        }, rotated));
      });
    });

    that._redesignAxes(argumentAxesPopulatedOptions, true, paneWithNonVirtualAxis);

    that._redesignAxes(valueAxesPopulatedOptions, false);
  },
  _redesignAxes: function _redesignAxes(options, isArgumentAxes, paneWithNonVirtualAxis) {
    var that = this;
    var axesBasis = [];
    var axes = isArgumentAxes ? that._argumentAxes : that._valueAxes;
    (0, _iterator.each)(options, function (_, opt) {
      var curAxes = axes && axes.filter(function (a) {
        return a.name === opt.name && (!(0, _type.isDefined)(opt.pane) && that.panes.some(function (p) {
          return p.name === a.pane;
        }) || a.pane === opt.pane);
      });

      if (curAxes && curAxes.length > 0) {
        (0, _iterator.each)(curAxes, function (_, axis) {
          var axisTypes = getAxisTypes(that._groupsData, axis, isArgumentAxes); // T891599

          axis.updateOptions(opt);

          if (isArgumentAxes) {
            axis.setTypes(axisTypes.argumentAxisType, axisTypes.argumentType, 'argumentType');
          } else {
            axis.setTypes(axisTypes.valueAxisType, axisTypes.valueType, 'valueType');
          }

          axis.validate();
          axesBasis.push({
            axis: axis
          });
        });
      } else {
        axesBasis.push({
          options: opt
        });
      }
    });

    if (axes) {
      (0, _iterator.reverseEach)(axes, function (index, axis) {
        if (!axesBasis.some(function (basis) {
          return basis.axis && basis.axis === axis;
        })) {
          that._disposeAxis(index, isArgumentAxes);
        }
      });
    } else if (isArgumentAxes) {
      axes = that._argumentAxes = [];
    } else {
      axes = that._valueAxes = [];
    }

    (0, _iterator.each)(axesBasis, function (_, basis) {
      var axis = basis.axis;

      if (basis.axis && isArgumentAxes) {
        basis.axis.isVirtual = basis.axis.pane !== paneWithNonVirtualAxis;
      } else if (basis.options) {
        axis = that._createAxis(isArgumentAxes, basis.options, isArgumentAxes ? basis.options.pane !== paneWithNonVirtualAxis : undefined);
        axes.push(axis);
      }

      axis.applyVisualRangeSetter(that._getVisualRangeSetter());
    });
  },
  _disposeAxis: function _disposeAxis(index, isArgumentAxis) {
    var axes = isArgumentAxis ? this._argumentAxes : this._valueAxes;
    var axis = axes[index];
    if (!axis) return;
    axis.dispose();
    axes.splice(index, 1);
  },
  _disposeAxes: function _disposeAxes() {
    var that = this;
    var disposeObjectsInArray = that._disposeObjectsInArray;
    disposeObjectsInArray.call(that, '_argumentAxes');
    disposeObjectsInArray.call(that, '_valueAxes');
  },
  _appendAdditionalSeriesGroups: function _appendAdditionalSeriesGroups() {
    this._crosshairCursorGroup.linkAppend(); // this._legendGroup.linkAppend();


    this._scrollBar && this._scrollBarGroup.linkAppend(); // TODO: Must be appended in the same place where removed (chart)
  },
  _getLegendTargets: function _getLegendTargets() {
    var _this = this;

    return (this.series || []).map(function (s) {
      var item = _this._getLegendOptions(s);

      item.legendData.series = s;

      if (!s.getOptions().showInLegend) {
        item.legendData.visible = false;
      }

      return item;
    });
  },
  _legendItemTextField: 'name',
  _seriesPopulatedHandlerCore: function _seriesPopulatedHandlerCore() {
    this._processSeriesFamilies();

    this._processValueAxisFormat();
  },
  _renderTrackers: function _renderTrackers() {
    var that = this;
    var i;

    for (i = 0; i < that.series.length; ++i) {
      that.series[i].drawTrackers();
    } // TODO we don't need it
    // if (that._legend) {
    //    legendHasInsidePosition && that._legendGroup.append(that._renderer.root);
    // }

  },
  _specialProcessSeries: function _specialProcessSeries() {
    this._processSeriesFamilies();
  },
  _processSeriesFamilies: function _processSeriesFamilies() {
    var _that$seriesFamilies;

    var that = this;
    var types = [];
    var families = [];
    var paneSeries;
    var themeManager = that._themeManager;
    var negativesAsZeroes = themeManager.getOptions('negativesAsZeroes');
    var negativesAsZeros = themeManager.getOptions('negativesAsZeros'); // misspelling case

    var familyOptions = {
      minBubbleSize: themeManager.getOptions('minBubbleSize'),
      maxBubbleSize: themeManager.getOptions('maxBubbleSize'),
      barGroupPadding: themeManager.getOptions('barGroupPadding'),
      barGroupWidth: themeManager.getOptions('barGroupWidth'),
      negativesAsZeroes: (0, _type.isDefined)(negativesAsZeroes) ? negativesAsZeroes : negativesAsZeros
    };

    if ((_that$seriesFamilies = that.seriesFamilies) !== null && _that$seriesFamilies !== void 0 && _that$seriesFamilies.length) {
      (0, _iterator.each)(that.seriesFamilies, function (_, family) {
        family.updateOptions(familyOptions);
        family.adjustSeriesValues();
      });
      return;
    }

    (0, _iterator.each)(that.series, function (_, item) {
      if ((0, _array.inArray)(item.type, types) === -1) {
        types.push(item.type);
      }
    });
    (0, _iterator.each)(that._getLayoutTargets(), function (_, pane) {
      paneSeries = that._getSeriesForPane(pane.name);
      (0, _iterator.each)(types, function (_, type) {
        var family = new _series_family.SeriesFamily({
          type: type,
          pane: pane.name,
          minBubbleSize: familyOptions.minBubbleSize,
          maxBubbleSize: familyOptions.maxBubbleSize,
          barGroupPadding: familyOptions.barGroupPadding,
          barGroupWidth: familyOptions.barGroupWidth,
          negativesAsZeroes: familyOptions.negativesAsZeroes,
          rotated: that._isRotated()
        });
        family.add(paneSeries);
        family.adjustSeriesValues();
        families.push(family);
      });
    });
    that.seriesFamilies = families;
  },
  _updateSeriesDimensions: function _updateSeriesDimensions() {
    var that = this;
    var i;
    var seriesFamilies = that.seriesFamilies || [];

    for (i = 0; i < seriesFamilies.length; i++) {
      var family = seriesFamilies[i];
      family.updateSeriesValues();
      family.adjustSeriesDimensions();
    }
  },
  _getLegendCallBack: function _getLegendCallBack(series) {
    return this._legend && this._legend.getActionCallback(series);
  },
  _appendAxesGroups: function _appendAxesGroups() {
    var that = this;

    that._stripsGroup.linkAppend();

    that._gridGroup.linkAppend();

    that._axesGroup.linkAppend();

    that._labelsAxesGroup.linkAppend();

    that._constantLinesGroup.linkAppend();

    that._stripLabelAxesGroup.linkAppend();

    that._scaleBreaksGroup.linkAppend();
  },
  _populateMarginOptions: function _populateMarginOptions() {
    var that = this;
    var bubbleSize = estimateBubbleSize(that.getSize(), that.panes.length, that._themeManager.getOptions('maxBubbleSize'), that._isRotated());
    var argumentMarginOptions = {};

    that._valueAxes.forEach(function (valueAxis) {
      var groupSeries = that.series.filter(function (series) {
        return series.getValueAxis() === valueAxis;
      });
      var marginOptions = {};
      groupSeries.forEach(function (series) {
        if (series.isVisible()) {
          var seriesMarginOptions = processBubbleMargin(series.getMarginOptions(), bubbleSize);
          marginOptions = (0, _utils.mergeMarginOptions)(marginOptions, seriesMarginOptions);
          argumentMarginOptions = (0, _utils.mergeMarginOptions)(argumentMarginOptions, seriesMarginOptions);
        }
      });
      valueAxis.setMarginOptions(marginOptions);
    });

    that._argumentAxes.forEach(function (a) {
      return a.setMarginOptions(argumentMarginOptions);
    });
  },
  _populateBusinessRange: function _populateBusinessRange(updatedAxis, keepRange) {
    var that = this;

    var rotated = that._isRotated();

    var series = that._getVisibleSeries();

    var argRanges = {};
    var commonArgRange = new _range.Range({
      rotated: !!rotated
    });

    var getPaneName = function getPaneName(axis) {
      return axis.pane || DEFAULT_PANE_NAME;
    };

    that.panes.forEach(function (p) {
      return argRanges[p.name] = new _range.Range({
        rotated: !!rotated
      });
    });

    that._valueAxes.forEach(function (valueAxis) {
      var groupRange = new _range.Range({
        rotated: !!rotated,
        pane: valueAxis.pane,
        axis: valueAxis.name
      });
      var groupSeries = series.filter(function (series) {
        return series.getValueAxis() === valueAxis;
      });
      groupSeries.forEach(function (series) {
        var seriesRange = series.getRangeData();
        groupRange.addRange(seriesRange.val);
        argRanges[getPaneName(valueAxis)].addRange(seriesRange.arg);
      });

      if (!updatedAxis || updatedAxis && groupSeries.length && valueAxis === updatedAxis) {
        valueAxis.setGroupSeries(groupSeries);
        valueAxis.setBusinessRange(groupRange, that._axesReinitialized || keepRange, that._argumentAxes[0]._lastVisualRangeUpdateMode);
      }
    });

    if (!updatedAxis || updatedAxis && series.length) {
      Object.keys(argRanges).forEach(function (p) {
        return commonArgRange.addRange(argRanges[p]);
      });
      var commonInterval = commonArgRange.interval;

      that._argumentAxes.forEach(function (a) {
        var _argRanges$getPaneNam;

        var currentInterval = (_argRanges$getPaneNam = argRanges[getPaneName(a)].interval) !== null && _argRanges$getPaneNam !== void 0 ? _argRanges$getPaneNam : commonInterval; // T956425

        a.setBusinessRange(new _range.Range(_extends({}, commonArgRange, {
          interval: currentInterval
        })), that._axesReinitialized, undefined, that._groupsData.categories);
      });
    }

    that._populateMarginOptions();
  },
  getArgumentAxis: function getArgumentAxis() {
    return (this._argumentAxes || []).filter(function (a) {
      return !a.isVirtual;
    })[0];
  },
  getValueAxis: function getValueAxis(name) {
    var _this2 = this;

    return (this._valueAxes || []).filter((0, _type.isDefined)(name) ? function (a) {
      return a.name === name;
    } : function (a) {
      return a.pane === _this2.defaultPane;
    })[0];
  },
  _getGroupsData: function _getGroupsData() {
    var that = this;
    var groups = [];

    that._valueAxes.forEach(function (axis) {
      groups.push({
        series: that.series.filter(function (series) {
          return series.getValueAxis() === axis;
        }),
        valueAxis: axis,
        valueOptions: axis.getOptions()
      });
    });

    return {
      groups: groups,
      argumentAxes: that._argumentAxes,
      argumentOptions: that._argumentAxes[0].getOptions()
    };
  },
  _groupSeries: function _groupSeries() {
    var that = this;

    that._correctValueAxes(false);

    that._groupsData = that._getGroupsData();
  },
  _processValueAxisFormat: function _processValueAxisFormat() {
    var axesWithFullStackedFormat = [];
    this.series.forEach(function (series) {
      var axis = series.getValueAxis();

      if (series.isFullStackedSeries()) {
        axis.setPercentLabelFormat();
        axesWithFullStackedFormat.push(axis);
      }
    });

    this._valueAxes.forEach(function (axis) {
      if (axesWithFullStackedFormat.indexOf(axis) === -1) {
        axis.resetAutoLabelFormat(); // B239299
      }
    });
  },
  _populateAxesOptions: function _populateAxesOptions(typeSelector, userOptions, axisOptions, rotated, virtual) {
    var that = this;

    var preparedUserOptions = that._prepareStripsAndConstantLines(typeSelector, userOptions, rotated);

    var options = (0, _extend2.extend)(true, {}, preparedUserOptions, axisOptions, that._prepareAxisOptions(typeSelector, preparedUserOptions, rotated));

    if (virtual) {
      options.visible = options.tick.visible = options.minorTick.visible = options.label.visible = false;
      options.title = {};
    }

    return options;
  },
  _getValFilter: function _getValFilter(series) {
    return _range_data_calculator.default.getViewPortFilter(series.getValueAxis().visualRange() || {});
  },
  _createAxis: function _createAxis(isArgumentAxes, options, virtual) {
    var that = this;
    var typeSelector = isArgumentAxes ? 'argumentAxis' : 'valueAxis';
    var renderingSettings = (0, _extend2.extend)({
      renderer: that._renderer,
      incidentOccurred: that._incidentOccurred,
      eventTrigger: that._eventTrigger,
      axisClass: isArgumentAxes ? 'arg' : 'val',
      widgetClass: 'dxc',
      stripsGroup: that._stripsGroup,
      stripLabelAxesGroup: that._stripLabelAxesGroup,
      constantLinesGroup: that._constantLinesGroup,
      scaleBreaksGroup: that._scaleBreaksGroup,
      axesContainerGroup: that._axesGroup,
      labelsAxesGroup: that._labelsAxesGroup,
      gridGroup: that._gridGroup,
      isArgumentAxis: isArgumentAxes,
      getTemplate: function getTemplate(template) {
        return that._getTemplate(template);
      }
    }, that._getAxisRenderingOptions(typeSelector));
    var axis = new _base_axis.Axis(renderingSettings);
    axis.updateOptions(options);
    axis.isVirtual = virtual;
    return axis;
  },
  _applyVisualRangeByVirtualAxes: function _applyVisualRangeByVirtualAxes(axis, range) {
    return false;
  },
  _applyCustomVisualRangeOption: function _applyCustomVisualRangeOption(axis, range) {
    var that = this;

    if (axis.getOptions().optionPath) {
      that._parseVisualRangeOption("".concat(axis.getOptions().optionPath, ".visualRange"), range);
    }
  },
  _getVisualRangeSetter: function _getVisualRangeSetter() {
    var chart = this;
    return function (axis, _ref2) {
      var skipEventRising = _ref2.skipEventRising,
          range = _ref2.range;

      chart._applyCustomVisualRangeOption(axis, range);

      axis.setCustomVisualRange(range);
      axis.skipEventRising = skipEventRising;

      if (!chart._applyVisualRangeByVirtualAxes(axis, range)) {
        if (chart._applyingChanges) {
          chart._change_VISUAL_RANGE();
        } else {
          chart._requestChange([VISUAL_RANGE]);
        }
      }
    };
  },
  _getTrackerSettings: function _getTrackerSettings() {
    return (0, _extend2.extend)(this.callBase(), {
      argumentAxis: this.getArgumentAxis()
    });
  },
  _prepareStripsAndConstantLines: function _prepareStripsAndConstantLines(typeSelector, userOptions, rotated) {
    userOptions = this._themeManager.getOptions(typeSelector, userOptions, rotated);

    if (userOptions.strips) {
      (0, _iterator.each)(userOptions.strips, function (i) {
        userOptions.strips[i] = (0, _extend2.extend)(true, {}, userOptions.stripStyle, userOptions.strips[i]);
      });
    }

    if (userOptions.constantLines) {
      (0, _iterator.each)(userOptions.constantLines, function (i, line) {
        userOptions.constantLines[i] = (0, _extend2.extend)(true, {}, userOptions.constantLineStyle, line);
      });
    }

    return userOptions;
  },
  refresh: function refresh() {
    this._disposeAxes();

    this.callBase();
  },
  _layoutAxes: function _layoutAxes(drawAxes) {
    var that = this;
    drawAxes();
    var needSpace = that.checkForMoreSpaceForPanesCanvas();

    if (needSpace) {
      var rect = this._rect.slice();

      var size = this._layout.backward(rect, rect, [needSpace.width, needSpace.height]);

      needSpace.width = Math.max(0, size[0]);
      needSpace.height = Math.max(0, size[1]);
      this._canvas = this._createCanvasFromRect(rect);
      drawAxes(needSpace);
    }
  },
  checkForMoreSpaceForPanesCanvas: function checkForMoreSpaceForPanesCanvas() {
    return this.layoutManager.needMoreSpaceForPanesCanvas(this._getLayoutTargets(), this._isRotated());
  },
  _parseVisualRangeOption: function _parseVisualRangeOption(fullName, value) {
    var that = this;
    var name = fullName.split(/[.[]/)[0];
    var index = fullName.match(/\d+/g);
    index = (0, _type.isDefined)(index) ? parseInt(index[0]) : index;

    if (fullName.indexOf('visualRange') > 0) {
      if ((0, _type.type)(value) !== 'object') {
        value = wrapVisualRange(fullName, value) || value;
      }

      that._setCustomVisualRange(name, index, value);
    } else if (((0, _type.type)(value) === 'object' || _isArray(value)) && name.indexOf('Axis') > 0 && JSON.stringify(value).indexOf('visualRange') > 0) {
      if ((0, _type.isDefined)(value.visualRange)) {
        that._setCustomVisualRange(name, index, value.visualRange);
      } else if (_isArray(value)) {
        value.forEach(function (a, i) {
          return (0, _type.isDefined)(a.visualRange) && that._setCustomVisualRange(name, i, a.visualRange);
        });
      }
    }
  },
  _setCustomVisualRange: function _setCustomVisualRange(axesName, index, value) {
    var that = this;

    var options = that._options.silent(axesName);

    if (!options) {
      return;
    }

    if (!(0, _type.isDefined)(index)) {
      options._customVisualRange = value;
    } else {
      options[index]._customVisualRange = value;
    }

    that._axesReinitialized = true;
  },
  _raiseZoomEndHandlers: function _raiseZoomEndHandlers() {
    this._valueAxes.forEach(function (axis) {
      return axis.handleZoomEnd();
    });
  },
  _setOptionsByReference: function _setOptionsByReference() {
    this.callBase();
    (0, _extend2.extend)(this._optionsByReference, {
      'valueAxis.visualRange': true
    });
  },
  _notifyOptionChanged: function _notifyOptionChanged(option, value, previousValue) {
    this.callBase.apply(this, arguments);

    if (!this._optionChangedLocker) {
      this._parseVisualRangeOption(option, value);
    }
  },
  _notifyVisualRange: function _notifyVisualRange() {
    var that = this;

    that._valueAxes.forEach(function (axis) {
      var axisPath = axis.getOptions().optionPath;

      if (axisPath) {
        var path = "".concat(axisPath, ".visualRange");
        var visualRange = (0, _utils.convertVisualRangeObject)(axis.visualRange(), !_isArray(that.option(path)));

        if (!axis.skipEventRising || !(0, _utils.rangesAreEqual)(visualRange, that.option(path))) {
          if (!that.option(axisPath) && axisPath !== 'valueAxis') {
            that.option(axisPath, {
              name: axis.name,
              visualRange: visualRange
            });
          } else {
            that.option(path, visualRange);
          }
        } else {
          axis.skipEventRising = null;
        }
      }
    });
  },
  _notify: function _notify() {
    this.callBase();
    this._axesReinitialized = false;

    if (this.option('disableTwoWayBinding') !== true) {
      // for dashboards T732396
      this._notifyVisualRange();
    }
  },
  _getAxesForScaling: function _getAxesForScaling() {
    return this._valueAxes;
  },
  _getAxesByOptionPath: function _getAxesByOptionPath(arg, isDirectOption, optionName) {
    var that = this;

    var sourceAxes = that._getAxesForScaling();

    var axes = [];

    if (isDirectOption) {
      var axisPath;

      if (arg.fullName) {
        axisPath = arg.fullName.slice(0, arg.fullName.indexOf('.'));
      }

      axes = sourceAxes.filter(function (a) {
        return a.getOptions().optionPath === axisPath;
      });
    } else {
      if ((0, _type.type)(arg.value) === 'object') {
        axes = sourceAxes.filter(function (a) {
          return a.getOptions().optionPath === arg.name;
        });
      } else if (_isArray(arg.value)) {
        arg.value.forEach(function (v, index) {
          var axis = sourceAxes.filter(function (a) {
            return a.getOptions().optionPath === "".concat(arg.name, "[").concat(index, "]");
          })[0];
          (0, _type.isDefined)(v[optionName]) && (0, _type.isDefined)(axis) && (axes[index] = axis);
        });
      }
    }

    return axes;
  },
  _optionChanged: function _optionChanged(arg) {
    var that = this;

    if (!that._optionChangedLocker) {
      var optionName = 'visualRange';
      var axes;
      var isDirectOption = arg.fullName.indexOf(optionName) > 0 ? true : that.getPartialChangeOptionsName(arg).indexOf(optionName) > -1 ? false : undefined;

      if ((0, _type.isDefined)(isDirectOption)) {
        axes = that._getAxesByOptionPath(arg, isDirectOption, optionName);

        if (axes) {
          if (axes.length > 1 || _isArray(arg.value)) {
            axes.forEach(function (a, index) {
              return setAxisVisualRangeByOption(arg, a, isDirectOption, index);
            });
          } else if (axes.length === 1) {
            setAxisVisualRangeByOption(arg, axes[0], isDirectOption);
          }
        }
      }
    }

    that.callBase(arg);
  },
  _change_VISUAL_RANGE: function _change_VISUAL_RANGE() {
    var that = this;

    that._recreateSizeDependentObjects(false);

    if (!that._changes.has('FULL_RENDER')) {
      var resizePanesOnZoom = that.option('resizePanesOnZoom');

      that._doRender({
        force: true,
        drawTitle: false,
        drawLegend: false,
        adjustAxes: resizePanesOnZoom !== null && resizePanesOnZoom !== void 0 ? resizePanesOnZoom : that.option('adjustAxesOnZoom') || false,
        animate: false
      });

      that._raiseZoomEndHandlers();
    }
  },
  // API
  resetVisualRange: function resetVisualRange() {
    var that = this;

    that._valueAxes.forEach(function (axis) {
      axis.resetVisualRange(false); // T602156

      that._applyCustomVisualRangeOption(axis);
    });

    that._requestChange([VISUAL_RANGE]);
  },
  _legendDataField: 'series',
  _adjustSeriesLabels: _common.noop,
  _correctValueAxes: _common.noop
});

exports.AdvancedChart = AdvancedChart;

/***/ }),
/* 594 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.smartFormatter = smartFormatter;
exports.formatRange = formatRange;

var _format_helper = _interopRequireDefault(__webpack_require__(82));

var _type = __webpack_require__(1);

var _date = _interopRequireDefault(__webpack_require__(18));

var _math = __webpack_require__(31);

var _utils = __webpack_require__(14);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _format = _format_helper.default.format;
var abs = Math.abs,
    floor = Math.floor;
var EXPONENTIAL = 'exponential';
var formats = ['fixedPoint', 'thousands', 'millions', 'billions', 'trillions', EXPONENTIAL];
var dateUnitIntervals = ['millisecond', 'second', 'minute', 'hour', 'day', 'month', 'year'];

function getDatesDifferences(prevDate, curDate, nextDate, tickFormat) {
  var prevDifferences;
  var nextDifferences;
  var dateUnitInterval;
  var dateUnitsLength = dateUnitIntervals.length;
  var i;
  var j;

  if (tickFormat === 'week') {
    tickFormat = 'day';
  } else if (tickFormat === 'quarter') {
    tickFormat = 'month';
  } else if (tickFormat === 'shorttime') {
    tickFormat = 'hour';
  } else if (tickFormat === 'longtime') {
    tickFormat = 'second';
  }

  var tickFormatIndex = dateUnitIntervals.indexOf(tickFormat);

  if (nextDate) {
    nextDifferences = _date.default.getDatesDifferences(curDate, nextDate);
    prevDifferences = _date.default.getDatesDifferences(curDate, prevDate);

    if (nextDifferences[tickFormat]) {
      for (i = dateUnitsLength - 1; i >= tickFormatIndex; i--) {
        dateUnitInterval = dateUnitIntervals[i];

        if (i === tickFormatIndex) {
          setDateUnitInterval(nextDifferences, tickFormatIndex + (nextDifferences['millisecond'] ? 2 : 1));
        } else if (nextDifferences[dateUnitInterval]) {
          resetDateUnitInterval(nextDifferences, i);
          break;
        }
      }
    }
  } else {
    prevDifferences = _date.default.getDatesDifferences(prevDate, curDate);

    for (i = dateUnitsLength - 1; i >= tickFormatIndex; i--) {
      dateUnitInterval = dateUnitIntervals[i];

      if (prevDifferences[dateUnitInterval]) {
        if (i - tickFormatIndex > 1) {
          for (j = tickFormatIndex + 1; j >= 0; j--) {
            resetDateUnitInterval(prevDifferences, j);
          }

          break;
        } else if (isDateTimeStart(curDate, dateUnitInterval)) {
          for (j = i - 1; j > 0; j--) {
            resetDateUnitInterval(prevDifferences, j);
          }

          break;
        }
      }
    }
  }

  return nextDate ? nextDifferences : prevDifferences;
}

function isDateTimeStart(date, dateUnitInterval) {
  var unitNumbers = [date.getMilliseconds(), date.getSeconds(), date.getMinutes(), date.getHours(), date.getDate(), date.getMonth()];
  var unitIndex = dateUnitIntervals.indexOf(dateUnitInterval);
  var i;

  for (i = 0; i < unitIndex; i++) {
    if (i === 4 && unitNumbers[i] !== 1 || i !== 4 && unitNumbers[i] !== 0) {
      return false;
    }
  }

  return true;
}

function resetDateUnitInterval(differences, intervalIndex) {
  var dateUnitInterval = dateUnitIntervals[intervalIndex];

  if (differences[dateUnitInterval]) {
    differences[dateUnitInterval] = false;
    differences.count--;
  }
}

function setDateUnitInterval(differences, intervalIndex) {
  var dateUnitInterval = dateUnitIntervals[intervalIndex];

  if (differences[dateUnitInterval] === false) {
    differences[dateUnitInterval] = true;
    differences.count++;
  }
}

function getNoZeroIndex(str) {
  return str.length - parseInt(str).toString().length;
}

function getTransitionTickIndex(ticks, value) {
  var i;
  var curDiff;
  var minDiff;
  var nearestTickIndex = 0;
  minDiff = abs(value - ticks[0]);

  for (i = 1; i < ticks.length; i++) {
    curDiff = abs(value - ticks[i]);

    if (curDiff < minDiff) {
      minDiff = curDiff;
      nearestTickIndex = i;
    }
  }

  return nearestTickIndex;
}

function splitDecimalNumber(value) {
  return value.toString().split('.');
}

function createFormat(type) {
  var formatter;

  if ((0, _type.isFunction)(type)) {
    formatter = type;
    type = null;
  }

  return {
    type: type,
    formatter: formatter
  };
}

function smartFormatter(tick, options) {
  var tickInterval = options.tickInterval;
  var tickIntervalIndex;
  var tickIndex;
  var actualIndex;
  var stringTick = abs(tick).toString();
  var precision = 0;
  var typeFormat;
  var offset = 0;
  var separatedTickInterval;
  var indexOfFormat = 0;
  var indexOfTick = -1;
  var datesDifferences;
  var format = options.labelOptions.format;
  var ticks = options.ticks;
  var log10Tick;
  var prevDateIndex;
  var nextDateIndex;
  var isLogarithmic = options.type === 'logarithmic';

  if (ticks.length === 1 && ticks.indexOf(tick) === 0 && !(0, _type.isDefined)(tickInterval)) {
    tickInterval = abs(tick) >= 1 ? 1 : (0, _math.adjust)(1 - abs(tick), tick);
  }

  if (!(0, _type.isDefined)(format) && options.type !== 'discrete' && tick && (options.logarithmBase === 10 || !isLogarithmic)) {
    if (options.dataType !== 'datetime' && (0, _type.isDefined)(tickInterval)) {
      if (ticks.length && ticks.indexOf(tick) === -1) {
        indexOfTick = getTransitionTickIndex(ticks, tick);
        tickInterval = (0, _math.adjust)(abs(tick - ticks[indexOfTick]), tick);
      }

      separatedTickInterval = splitDecimalNumber(tickInterval);

      if (separatedTickInterval < 2) {
        separatedTickInterval = splitDecimalNumber(tick);
      }

      if (isLogarithmic) {
        log10Tick = (0, _utils.getAdjustedLog10)(abs(tick));

        if (log10Tick > 0) {
          typeFormat = formats[floor(log10Tick / 3)] || EXPONENTIAL;
        } else {
          if (log10Tick < -4) {
            typeFormat = EXPONENTIAL;
          } else {
            return _format((0, _math.adjust)(tick));
          }
        }
      } else {
        if (separatedTickInterval.length > 1 && !(0, _type.isExponential)(tickInterval)) {
          precision = separatedTickInterval[1].length;
          typeFormat = formats[indexOfFormat];
        } else {
          if ((0, _type.isExponential)(tickInterval) && (stringTick.indexOf('.') !== -1 || (0, _type.isExponential)(tick))) {
            typeFormat = EXPONENTIAL;

            if (!(0, _type.isExponential)(tick)) {
              precision = abs(getNoZeroIndex(stringTick.split('.')[1]) - (0, _math.getExponent)(tickInterval) + 1);
            } else {
              precision = Math.max(abs((0, _math.getExponent)(tick) - (0, _math.getExponent)(tickInterval)), abs((0, _math.getPrecision)(tick) - (0, _math.getPrecision)(tickInterval)));
            }
          } else {
            tickIntervalIndex = floor((0, _utils.getAdjustedLog10)(tickInterval));
            actualIndex = tickIndex = floor((0, _utils.getAdjustedLog10)(abs(tick)));

            if (tickIndex - tickIntervalIndex >= 2) {
              actualIndex = tickIntervalIndex;
            }

            indexOfFormat = floor(actualIndex / 3);
            offset = indexOfFormat * 3;

            if (indexOfFormat < 5) {
              if (tickIntervalIndex - offset === 2 && tickIndex >= 3) {
                indexOfFormat++;
                offset = indexOfFormat * 3;
              }

              typeFormat = formats[indexOfFormat];
            } else {
              typeFormat = formats[formats.length - 1];
            }

            if (offset > 0) {
              separatedTickInterval = splitDecimalNumber(tickInterval / Math.pow(10, offset));

              if (separatedTickInterval[1]) {
                precision = separatedTickInterval[1].length;
              }
            }
          }
        }
      }

      if (typeFormat !== undefined || precision !== undefined) {
        format = {
          type: typeFormat,
          precision: precision
        };
      }
    } else if (options.dataType === 'datetime') {
      typeFormat = _date.default.getDateFormatByTickInterval(tickInterval);

      if (options.showTransition && ticks.length) {
        indexOfTick = ticks.map(Number).indexOf(+tick);

        if (ticks.length === 1 && indexOfTick === 0) {
          typeFormat = _format_helper.default.getDateFormatByTicks(ticks);
        } else {
          if (indexOfTick === -1) {
            prevDateIndex = getTransitionTickIndex(ticks, tick);
          } else {
            prevDateIndex = indexOfTick === 0 ? ticks.length - 1 : indexOfTick - 1;
            nextDateIndex = indexOfTick === 0 ? 1 : -1;
          }

          datesDifferences = getDatesDifferences(ticks[prevDateIndex], tick, ticks[nextDateIndex], typeFormat);
          typeFormat = _format_helper.default.getDateFormatByDifferences(datesDifferences, typeFormat);
        }
      }

      format = createFormat(typeFormat);
    }
  }

  return _format(tick, format);
}

function getHighDiffFormat(diff) {
  var stop = false;

  for (var i in diff) {
    if (diff[i] === true || i === 'hour' || stop) {
      diff[i] = false;
      stop = true;
    } else if (diff[i] === false) {
      diff[i] = true;
    }
  }

  return createFormat(_format_helper.default.getDateFormatByDifferences(diff));
}

function getHighAndSelfDiffFormat(diff, interval) {
  var stop = false;

  for (var i in diff) {
    if (stop) {
      diff[i] = false;
    } else if (i === interval) {
      stop = true;
    } else {
      diff[i] = true;
    }
  }

  return createFormat(_format_helper.default.getDateFormatByDifferences(diff));
}

function formatDateRange(startValue, endValue, tickInterval) {
  var diff = getDatesDifferences(startValue, endValue);

  var typeFormat = _date.default.getDateFormatByTickInterval(tickInterval);

  var diffFormatType = _format_helper.default.getDateFormatByDifferences(diff, typeFormat);

  var diffFormat = createFormat(diffFormatType);
  var values = [];

  if (tickInterval in diff) {
    var rangeFormat = getHighAndSelfDiffFormat(getDatesDifferences(startValue, endValue), tickInterval);

    var value = _format(startValue, rangeFormat);

    if (value) {
      values.push(value);
    }
  } else {
    var _rangeFormat = getHighDiffFormat(getDatesDifferences(startValue, endValue));

    var highValue = _format(startValue, _rangeFormat);

    if (highValue) {
      values.push(highValue);
    }

    values.push("".concat(_format(startValue, diffFormat), " - ").concat(_format(endValue, diffFormat)));
  }

  return values.join(', ');
}

function processDateInterval(interval) {
  if ((0, _type.isObject)(interval)) {
    var dateUnits = Object.keys(interval);
    var sum = dateUnits.reduce(function (sum, k) {
      return interval[k] + sum;
    }, 0);

    if (sum === 1) {
      var dateUnit = dateUnits.filter(function (k) {
        return interval[k] === 1;
      })[0];
      return dateUnit.slice(0, dateUnit.length - 1);
    }
  }

  return interval;
}

function formatRange(startValue, endValue, tickInterval, _ref) {
  var dataType = _ref.dataType,
      type = _ref.type,
      logarithmBase = _ref.logarithmBase;

  if (type === 'discrete') {
    return '';
  }

  if (dataType === 'datetime') {
    return formatDateRange(startValue, endValue, processDateInterval(tickInterval));
  }

  var formatOptions = {
    ticks: [],
    type: type,
    dataType: dataType,
    tickInterval: tickInterval,
    logarithmBase: logarithmBase,
    labelOptions: {}
  };
  return "".concat(smartFormatter(startValue, formatOptions), " - ").concat(smartFormatter(endValue, formatOptions));
}

/***/ }),
/* 595 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.tickGenerator = void 0;

var _utils = __webpack_require__(14);

var _date = _interopRequireDefault(__webpack_require__(18));

var _type = __webpack_require__(1);

var _math = __webpack_require__(31);

var _extend = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var convertDateUnitToMilliseconds = _date.default.convertDateUnitToMilliseconds;
var dateToMilliseconds = _date.default.dateToMilliseconds;
var math = Math;
var mathAbs = math.abs;
var mathFloor = math.floor;
var mathCeil = math.ceil;
var mathPow = math.pow;
var NUMBER_MULTIPLIERS = [1, 2, 2.5, 5];
var LOGARITHMIC_MULTIPLIERS = [1, 2, 3, 5];
var DATETIME_MULTIPLIERS = {
  millisecond: [1, 2, 5, 10, 25, 50, 100, 250, 500],
  second: [1, 2, 3, 5, 10, 15, 20, 30],
  minute: [1, 2, 3, 5, 10, 15, 20, 30],
  hour: [1, 2, 3, 4, 6, 8, 12],
  day: [1, 2],
  week: [1, 2],
  month: [1, 2, 3, 6]
};
var DATETIME_MULTIPLIERS_WITH_BIG_WEEKEND = (0, _extend.extend)({}, DATETIME_MULTIPLIERS, {
  day: [1]
});
var DATETIME_MINOR_MULTIPLIERS = {
  millisecond: [1, 2, 5, 10, 25, 50, 100, 250, 500],
  second: [1, 2, 3, 5, 10, 15, 20, 30],
  minute: [1, 2, 3, 5, 10, 15, 20, 30],
  hour: [1, 2, 3, 4, 6, 8, 12],
  day: [1, 2, 3, 7, 14],
  month: [1, 2, 3, 6]
};
var MINOR_DELIMITERS = [2, 4, 5, 8, 10];
var VISIBILITY_DELIMITER = 3;
var MINUTE = 60 * 1000;

function dummyGenerator(options) {
  return function (data, screenDelta, tickInterval, forceTickInterval) {
    var count = mathFloor(screenDelta / options.axisDivisionFactor);
    count = count < 1 ? 1 : count;
    var interval = screenDelta / count;
    return {
      ticks: interval > 0 ? Array.apply(null, new Array(count + 1)).map(function (_, i) {
        return interval * i;
      }) : [],
      tickInterval: interval
    };
  };
}

function discreteGenerator(options) {
  return function (data, screenDelta, tickInterval, forceTickInterval) {
    var categories = (0, _utils.getCategoriesInfo)(data.categories, data.min, data.max).categories;
    return {
      ticks: categories,
      tickInterval: mathCeil(categories.length * options.axisDivisionFactor / screenDelta)
    };
  };
}

var getValue = function getValue(value) {
  return value;
};

var getLogValue = function getLogValue(base, allowNegatives, linearThreshold) {
  return function (value) {
    return (0, _utils.getLogExt)(value, base, allowNegatives, linearThreshold);
  };
};

var raiseTo = function raiseTo(base, allowNegatives, linearThreshold) {
  return function (value) {
    return (0, _utils.raiseToExt)(value, base, allowNegatives, linearThreshold);
  };
};

var mathRaiseTo = function mathRaiseTo(base) {
  return function (value) {
    return (0, _utils.raiseTo)(value, base);
  };
};

var logAbsValue = function logAbsValue(base) {
  return function (value) {
    return value === 0 ? 0 : (0, _utils.getLog)(mathAbs(value), base);
  };
};

var correctValueByInterval = function correctValueByInterval(post, round, getValue) {
  return function (value, interval) {
    return (0, _math.adjust)(post(round((0, _math.adjust)(getValue(value) / interval)) * interval));
  };
};

function correctMinValueByEndOnTick(floorFunc, ceilFunc, resolveEndOnTick, endOnTick) {
  if ((0, _type.isDefined)(endOnTick)) {
    return endOnTick ? floorFunc : ceilFunc;
  }

  return function (value, interval, businessViewInfo, forceEndOnTick) {
    var floorTickValue = floorFunc(value, interval);

    if (value - floorTickValue === 0 || !(0, _type.isDefined)(businessViewInfo) || resolveEndOnTick(value, floorTickValue, interval, businessViewInfo) || forceEndOnTick) {
      return floorTickValue;
    }

    return ceilFunc(value, interval);
  };
}

function resolveEndOnTick(curValue, tickValue, interval, businessViewInfo) {
  var prevTickDataDiff = interval - mathAbs(tickValue - curValue);
  var intervalCount = math.max(mathCeil(businessViewInfo.businessDelta / interval), 2);
  var businessRatio = businessViewInfo.screenDelta / (intervalCount * interval);
  var potentialTickScreenDiff = math.round(businessRatio * prevTickDataDiff);
  var delimiterFactor = (0, _utils.getLogExt)(businessRatio * interval / businessViewInfo.axisDivisionFactor, 2) + 1;
  var delimiterMultiplier = (businessViewInfo.isSpacedMargin ? 2 : 1) * delimiterFactor;
  var screenDelimiter = math.round(VISIBILITY_DELIMITER * delimiterMultiplier);
  return businessViewInfo.businessDelta > businessViewInfo.interval && potentialTickScreenDiff >= screenDelimiter;
}

function resolveEndOnTickLog(base) {
  return function (curValue, tickValue, interval, businessViewInfo) {
    return resolveEndOnTick((0, _utils.getLogExt)(curValue, base), (0, _utils.getLogExt)(tickValue, base), interval, businessViewInfo);
  };
}

function resolveEndOnTickDate(curValue, tickValue, interval, businessViewInfo) {
  return resolveEndOnTick(curValue.valueOf(), tickValue.valueOf(), dateToMilliseconds(interval), businessViewInfo);
}

function getBusinessDelta(data, breaks) {
  var spacing = 0;

  if (breaks) {
    spacing = breaks.reduce(function (prev, item) {
      return prev + (item.to - item.from);
    }, 0);
  }

  return mathAbs(data.max - data.min - spacing);
}

function getBusinessDeltaLog(base, allowNegatives, linearThreshold) {
  var getLog = getLogValue(base, allowNegatives, linearThreshold);
  return function (data, breaks) {
    var spacing = 0;

    if (breaks) {
      spacing = breaks.reduce(function (prev, item) {
        return prev + mathAbs(getLog(item.to / item.from));
      }, 0);
    }

    return mathCeil(mathAbs(getLog(data.max) - getLog(data.min)) - spacing);
  };
}

function getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor, addTickCount) {
  var count = screenDelta / axisDivisionFactor - (addTickCount || 0);
  count = count < 1 ? 1 : count;
  return businessDelta / count;
}

function getMultiplierFactor(interval, factorDelta) {
  return mathPow(10, mathFloor((0, _utils.getLogExt)(interval, 10)) + (factorDelta || 0));
}

function calculateTickInterval(businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, addTickCount, _, minTickInterval) {
  var interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor, addTickCount);
  var result = 1;
  var onlyIntegers = allowDecimals === false;

  if (!forceTickInterval || !tickInterval) {
    if (interval >= 1 || !onlyIntegers && interval > 0) {
      result = adjustInterval(interval, multipliers, onlyIntegers);
    }

    if (!tickInterval || !forceTickInterval && tickInterval < result) {
      tickInterval = result;
    }
  }

  if (!forceTickInterval && minTickInterval) {
    minTickInterval = adjustInterval(minTickInterval, multipliers, onlyIntegers);

    if (minTickInterval > tickInterval) {
      tickInterval = minTickInterval;
    }
  }

  return tickInterval;
}

function adjustInterval(interval, multipliers, onlyIntegers) {
  var factor = getMultiplierFactor(interval, -1);
  var result = 1;
  multipliers = multipliers || NUMBER_MULTIPLIERS;

  if (interval > 0) {
    interval /= factor;
    result = multipliers.concat(multipliers[0] * 10).map(function (m) {
      return 10 * m;
    }).reduce(function (r, m) {
      if (factor === 0.1 && onlyIntegers && m === 25) {
        return r;
      }

      return r < interval ? m : r;
    }, 0);
    result = (0, _math.adjust)(result * factor, factor);
  }

  return result;
}

function calculateMinorTickInterval(businessDelta, screenDelta, tickInterval, axisDivisionFactor) {
  var interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor);
  return tickInterval || MINOR_DELIMITERS.reduce(function (r, d) {
    var cur = businessDelta / d;
    return cur >= interval ? cur : r;
  }, 0);
}

function getCalculateTickIntervalLog(skipCalculationLimits) {
  return function (businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, _, __, minTickInterval) {
    var interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor);
    var result = 0;
    var adjustInterval = getAdjustIntervalLog(skipCalculationLimits);

    if (!forceTickInterval || !tickInterval) {
      if (interval > 0) {
        result = adjustInterval(interval, multipliers);
      }

      if (!tickInterval || !forceTickInterval && tickInterval < result) {
        tickInterval = result;
      }
    }

    if (!forceTickInterval && minTickInterval) {
      minTickInterval = adjustInterval(minTickInterval, multipliers);

      if (minTickInterval > tickInterval) {
        tickInterval = minTickInterval;
      }
    }

    return tickInterval;
  };
}

function getAdjustIntervalLog(skipCalculationLimits) {
  return function (interval, multipliers) {
    var factor = getMultiplierFactor(interval);
    multipliers = multipliers || LOGARITHMIC_MULTIPLIERS;

    if (!skipCalculationLimits && factor < 1) {
      factor = 1;
    }

    return multipliers.concat(multipliers[0] * 10).reduce(function (r, m) {
      return r < interval ? m * factor : r;
    }, 0);
  };
}

function getDataTimeMultipliers(gapSize) {
  if (gapSize && gapSize > 2) {
    return DATETIME_MULTIPLIERS_WITH_BIG_WEEKEND;
  } else {
    return DATETIME_MULTIPLIERS;
  }
}

function numbersReducer(interval, key) {
  return function (r, m) {
    if (!r && interval <= convertDateUnitToMilliseconds(key, m)) {
      r = {};
      r[key + 's'] = m;
    }

    return r;
  };
}

function yearsReducer(interval, factor) {
  return function (r, m) {
    var years = factor * m;

    if (!r && interval <= convertDateUnitToMilliseconds('year', years) && years !== 2.5) {
      r = {
        years: years
      };
    }

    return r;
  };
}

function calculateTickIntervalDateTime(businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, addTickCount, gapSize, minTickInterval) {
  if (!forceTickInterval || !tickInterval) {
    var result = adjustIntervalDateTime(getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor), multipliers, null, gapSize);

    if (!tickInterval || !forceTickInterval && dateToMilliseconds(tickInterval) <= dateToMilliseconds(result)) {
      tickInterval = result;
    }
  }

  if (!forceTickInterval && minTickInterval) {
    minTickInterval = adjustIntervalDateTime(minTickInterval, multipliers, null, gapSize);

    if (dateToMilliseconds(minTickInterval) > dateToMilliseconds(tickInterval)) {
      tickInterval = minTickInterval;
    }
  }

  return tickInterval;
}

function adjustIntervalDateTime(interval, multipliers, _, gapSize) {
  var result;
  multipliers = multipliers || getDataTimeMultipliers(gapSize);

  for (var key in multipliers) {
    result = multipliers[key].reduce(numbersReducer(interval, key), result);

    if (result) {
      break;
    }
  }

  if (!result) {
    for (var factor = 1;; factor *= 10) {
      result = NUMBER_MULTIPLIERS.reduce(yearsReducer(interval, factor), result);

      if (result) {
        break;
      }
    }
  }

  return result;
}

function calculateMinorTickIntervalDateTime(businessDelta, screenDelta, tickInterval, axisDivisionFactor) {
  return calculateTickIntervalDateTime(businessDelta, screenDelta, tickInterval, true, axisDivisionFactor, DATETIME_MINOR_MULTIPLIERS);
}

function getTickIntervalByCustomTicks(getValue, postProcess) {
  return function (ticks) {
    return ticks ? postProcess(mathAbs((0, _math.adjust)(getValue(ticks[1]) - getValue(ticks[0])))) || undefined : undefined;
  };
}

function addInterval(value, interval, isNegative) {
  return _date.default.addInterval(value, interval, isNegative);
}

function addIntervalLog(log, raise) {
  return function (value, interval, isNegative) {
    return raise(addInterval(log(value), interval, isNegative));
  };
}

function addIntervalDate(value, interval, isNegative) {
  return addInterval(value, interval, isNegative);
}

function addIntervalWithBreaks(addInterval, breaks, correctValue) {
  breaks = breaks.filter(function (b) {
    return !b.gapSize;
  });
  return function (value, interval, isNegative) {
    var breakSize;
    value = addInterval(value, interval, isNegative);

    if (!breaks.every(function (item) {
      if (value >= addInterval(item.from, interval) && addInterval(value, interval) < item.to) {
        breakSize = item.to - item.from - 2 * (addInterval(item.from, interval) - item.from);
      }

      return !breakSize;
    })) {
      value = correctValue(addInterval(value, breakSize), interval);
    }

    return value;
  };
}

function calculateTicks(addInterval, correctMinValue, adjustInterval, resolveEndOnTick) {
  return function (data, tickInterval, endOnTick, gaps, breaks, businessDelta, screenDelta, axisDivisionFactor, generateExtraTick) {
    var correctTickValue = correctTickValueOnGapSize(addInterval, gaps);
    var min = data.min;
    var max = data.max;
    var businessViewInfo = {
      screenDelta: screenDelta,
      businessDelta: businessDelta,
      axisDivisionFactor: axisDivisionFactor,
      isSpacedMargin: data.isSpacedMargin,
      interval: tickInterval
    };
    var cur = correctMinValue(min, tickInterval, businessViewInfo);
    var ticks = [];

    if (breaks !== null && breaks !== void 0 && breaks.length) {
      addInterval = addIntervalWithBreaks(addInterval, breaks, correctMinValue);
    }

    if (cur > max) {
      cur = correctMinValue(min, adjustInterval(businessDelta / 2), businessViewInfo);

      if (cur > max) {
        endOnTick = true;
        cur = correctMinValue(min, tickInterval, businessViewInfo, endOnTick);
      }
    }

    cur = correctTickValue(cur);
    var prev;

    while (cur < max && cur !== prev || generateExtraTick && cur <= max) {
      ticks.push(cur);
      prev = cur;
      cur = correctTickValue(addInterval(cur, tickInterval));
    }

    if (endOnTick || cur - max === 0 || !(0, _type.isDefined)(endOnTick) && resolveEndOnTick(max, cur, tickInterval, businessViewInfo)) {
      ticks.push(cur);
    }

    return ticks;
  };
}

function calculateMinorTicks(updateTickInterval, addInterval, correctMinValue, correctTickValue, ceil) {
  return function (min, max, majorTicks, minorTickInterval, tickInterval, breaks, maxCount) {
    var factor = tickInterval / minorTickInterval;
    var lastMajor = majorTicks[majorTicks.length - 1];
    var firstMajor = majorTicks[0];
    var tickBalance = maxCount - 1;

    if (breaks !== null && breaks !== void 0 && breaks.length) {
      addInterval = addIntervalWithBreaks(addInterval, breaks, correctMinValue);
    }

    minorTickInterval = updateTickInterval(minorTickInterval, firstMajor, firstMajor, factor);

    if (minorTickInterval === 0) {
      return [];
    } // min to first tick


    var cur = correctTickValue(correctMinValue(min, tickInterval, min), minorTickInterval);
    minorTickInterval = updateTickInterval(minorTickInterval, firstMajor, cur, factor);
    var ticks = [];

    while (cur < firstMajor && (!tickBalance || tickBalance > 0)) {
      cur >= min && ticks.push(cur);
      tickBalance--;
      cur = addInterval(cur, minorTickInterval);
    } // between ticks


    var middleTicks = majorTicks.reduce(function (r, tick) {
      tickBalance = maxCount - 1;

      if (r.prevTick === null) {
        r.prevTick = tick;
        return r;
      }

      minorTickInterval = updateTickInterval(minorTickInterval, tick, r.prevTick, factor);
      var cur = correctTickValue(r.prevTick, minorTickInterval);

      while (cur < tick && (!tickBalance || tickBalance > 0)) {
        cur !== r.prevTick && r.minors.push(cur);
        tickBalance--;
        cur = addInterval(cur, minorTickInterval);
      }

      r.prevTick = tick;
      return r;
    }, {
      prevTick: null,
      minors: []
    });
    ticks = ticks.concat(middleTicks.minors); // last tick to max

    var maxValue = ceil(max, tickInterval, min);
    minorTickInterval = updateTickInterval(minorTickInterval, maxValue, maxValue, factor);
    cur = correctTickValue(lastMajor, minorTickInterval);
    var prev;

    while (cur < max && cur !== prev) {
      ticks.push(cur);
      prev = cur;
      cur = addInterval(cur, minorTickInterval);
    }

    if (lastMajor - max !== 0 && cur - max === 0) {
      ticks.push(cur);
    }

    return ticks;
  };
}

function filterTicks(ticks, breaks) {
  if (breaks.length) {
    var result = breaks.reduce(function (result, b) {
      var tmpTicks = [];
      var i;

      for (i = result[1]; i < ticks.length; i++) {
        var tickValue = ticks[i];

        if (tickValue < b.from) {
          tmpTicks.push(tickValue);
        }

        if (tickValue >= b.to) {
          break;
        }
      }

      return [result[0].concat(tmpTicks), i];
    }, [[], 0]);
    return result[0].concat(ticks.slice(result[1]));
  }

  return ticks;
}

function correctTickValueOnGapSize(addInterval, breaks) {
  return function (value) {
    var gapSize;

    if (!breaks.every(function (item) {
      if (value >= item.from && value < item.to) {
        gapSize = item.gapSize;
      }

      return !gapSize;
    })) {
      value = addInterval(value, gapSize);
    }

    return value;
  };
}

function generator(options, getBusinessDelta, calculateTickInterval, calculateMinorTickInterval, getMajorTickIntervalByCustomTicks, getMinorTickIntervalByCustomTicks, convertTickInterval, calculateTicks, calculateMinorTicks, processScaleBreaks) {
  function processCustomTicks(customTicks) {
    return {
      tickInterval: getMajorTickIntervalByCustomTicks(customTicks.majors),
      ticks: customTicks.majors || [],
      minorTickInterval: getMinorTickIntervalByCustomTicks(customTicks.minors),
      minorTicks: customTicks.minors || []
    };
  }

  function correctUserTickInterval(tickInterval, businessDelta, limit) {
    if (tickInterval && businessDelta / convertTickInterval(tickInterval) >= limit + 1) {
      options.incidentOccurred('W2003');
      tickInterval = undefined;
    }

    return tickInterval;
  }

  function generateMajorTicks(ticks, data, businessDelta, screenDelta, tickInterval, forceTickInterval, customTicks, breaks) {
    if (customTicks.majors) {
      ticks.breaks = breaks;
      return ticks;
    }

    var gaps = breaks.filter(function (b) {
      return b.gapSize;
    });
    var majorTicks;
    tickInterval = options.skipCalculationLimits ? tickInterval : correctUserTickInterval(tickInterval, businessDelta, screenDelta);
    tickInterval = calculateTickInterval(businessDelta, screenDelta, tickInterval, forceTickInterval, options.axisDivisionFactor, options.numberMultipliers, options.allowDecimals, breaks.length, gaps[0] && gaps[0].gapSize.days, options.minTickInterval);

    if (!options.skipTickGeneration) {
      majorTicks = calculateTicks(data, tickInterval, options.endOnTick, gaps, breaks, businessDelta, screenDelta, options.axisDivisionFactor, options.generateExtraTick);
      breaks = processScaleBreaks(breaks, majorTicks, tickInterval);
      majorTicks = filterTicks(majorTicks, breaks);
      ticks.breaks = breaks;
      ticks.ticks = ticks.ticks.concat(majorTicks);
    }

    ticks.tickInterval = tickInterval;
    return ticks;
  }

  function generateMinorTicks(ticks, data, businessDelta, screenDelta, minorTickInterval, minorTickCount, customTicks) {
    if (!options.calculateMinors) {
      return ticks;
    }

    if (customTicks.minors) {
      return ticks;
    }

    var minorBusinessDelta = convertTickInterval(ticks.tickInterval);
    var minorScreenDelta = screenDelta * minorBusinessDelta / businessDelta;
    var breaks = ticks.breaks;

    if (!minorTickInterval && minorTickCount) {
      minorTickInterval = getMinorTickIntervalByCustomTicks([minorBusinessDelta / (minorTickCount + 1), minorBusinessDelta / (minorTickCount + 1) * 2]);
    } else {
      minorTickCount = undefined;
    }

    minorTickInterval = correctUserTickInterval(minorTickInterval, minorBusinessDelta, minorScreenDelta);
    minorTickInterval = calculateMinorTickInterval(minorBusinessDelta, minorScreenDelta, minorTickInterval, options.minorAxisDivisionFactor);
    ticks.minorTicks = filterTicks(ticks.minorTicks.concat(calculateMinorTicks(data.min, data.max, ticks.ticks, minorTickInterval, ticks.tickInterval, breaks, minorTickCount)), breaks);
    ticks.minorTickInterval = minorTickInterval;
    return ticks;
  }

  return function (data, screenDelta, tickInterval, forceTickInterval, customTicks, minorTickInterval, minorTickCount, breaks) {
    customTicks = customTicks || {};
    var businessDelta = getBusinessDelta(data, breaks);
    var result = processCustomTicks(customTicks);

    if (!isNaN(businessDelta)) {
      if (businessDelta === 0 && !customTicks.majors) {
        result.ticks = [data.min];
      } else {
        result = generateMajorTicks(result, data, businessDelta, screenDelta, tickInterval, forceTickInterval, customTicks, breaks || []);

        if (!options.skipTickGeneration && businessDelta > 0) {
          result = generateMinorTicks(result, data, businessDelta, screenDelta, minorTickInterval, minorTickCount, customTicks);
        }
      }
    }

    return result;
  };
}

function getBaseTick(breakValue, _ref, interval, getValue) {
  var _ref2 = _slicedToArray(_ref, 2),
      tick = _ref2[0],
      insideTick = _ref2[1];

  if (!(0, _type.isDefined)(tick) || mathAbs(getValue(breakValue) - getValue(tick)) / interval > 0.25) {
    if ((0, _type.isDefined)(insideTick)) {
      tick = insideTick;
    } else if (!(0, _type.isDefined)(tick)) {
      tick = breakValue;
    }
  }

  return tick;
}

function getScaleBreaksProcessor(convertTickInterval, getValue, addCorrection) {
  return function (breaks, ticks, tickInterval) {
    var interval = convertTickInterval(tickInterval);
    var correction = interval * 0.5;
    return breaks.reduce(function (result, b) {
      var breakTicks = ticks.filter(function (tick) {
        return tick <= b.from;
      });
      var from = addCorrection(getBaseTick(b.from, [].concat(breakTicks[breakTicks.length - 1], ticks[breakTicks.length]), interval, getValue), correction);
      breakTicks = ticks.filter(function (tick) {
        return tick >= b.to;
      });
      var to = addCorrection(getBaseTick(b.to, [].concat(breakTicks[0], ticks[ticks.length - breakTicks.length - 1]), interval, getValue), -correction);

      if (getValue(to) - getValue(from) < interval && !b.gapSize) {
        return result;
      }

      if (b.gapSize) {
        return result.concat([b]);
      }

      return result.concat([{
        from: from,
        to: to,
        cumulativeWidth: b.cumulativeWidth
      }]);
    }, []);
  };
}

function numericGenerator(options) {
  var floor = correctValueByInterval(getValue, mathFloor, getValue);
  var ceil = correctValueByInterval(getValue, mathCeil, getValue);
  var calculateTickIntervalByCustomTicks = getTickIntervalByCustomTicks(getValue, getValue);
  return generator(options, getBusinessDelta, calculateTickInterval, calculateMinorTickInterval, calculateTickIntervalByCustomTicks, calculateTickIntervalByCustomTicks, getValue, calculateTicks(addInterval, correctMinValueByEndOnTick(floor, ceil, resolveEndOnTick, options.endOnTick), adjustInterval, resolveEndOnTick), calculateMinorTicks(getValue, addInterval, floor, addInterval, getValue), getScaleBreaksProcessor(getValue, getValue, function (value, correction) {
    return value + correction;
  }));
}

var correctValueByIntervalLog = function correctValueByIntervalLog(post, getRound, getValue) {
  return function (value, interval) {
    return (0, _math.sign)(value) * (0, _math.adjust)(post(getRound(value)((0, _math.adjust)(getValue(value) / interval)) * interval));
  };
};

function logarithmicGenerator(options) {
  var base = options.logBase;
  var raise = raiseTo(base, options.allowNegatives, options.linearThreshold);
  var log = getLogValue(base, options.allowNegatives, options.linearThreshold);
  var absLog = logAbsValue(base);
  var absRaise = mathRaiseTo(base);

  var absFloor = function absFloor(value) {
    return value < 0 ? mathCeil : mathFloor;
  };

  var absCeil = function absCeil(value) {
    return value < 0 ? mathFloor : mathCeil;
  };

  var floor = correctValueByIntervalLog(absRaise, absFloor, absLog);
  var ceil = correctValueByIntervalLog(absRaise, absCeil, absLog);
  var ceilNumber = correctValueByInterval(getValue, mathCeil, getValue);
  return generator(options, getBusinessDeltaLog(base, options.allowNegatives, options.linearThreshold), getCalculateTickIntervalLog(options.skipCalculationLimits), calculateMinorTickInterval, getTickIntervalByCustomTicks(log, getValue), getTickIntervalByCustomTicks(getValue, getValue), getValue, calculateTicks(addIntervalLog(log, raise), correctMinValueByEndOnTick(floor, ceil, resolveEndOnTickLog(base), options.endOnTick), getAdjustIntervalLog(options.skipCalculationLimits), resolveEndOnTickLog(base)), calculateMinorTicks(function (_, tick, prevTick, factor) {
    return Math.max(Math.abs(tick), Math.abs(prevTick)) / factor;
  }, addInterval, floor, ceilNumber, ceil), getScaleBreaksProcessor(getValue, log, function (value, correction) {
    return raise(log(value) + correction);
  }));
}

function dateGenerator(options) {
  function floor(value, interval) {
    var floorNumber = correctValueByInterval(getValue, mathFloor, getValue);
    var intervalObject = (0, _type.isString)(interval) ? _date.default.getDateIntervalByString(interval.toLowerCase()) : interval;
    var divider = dateToMilliseconds(interval);

    if (intervalObject.days % 7 === 0 || interval.quarters) {
      intervalObject = adjustIntervalDateTime(divider);
    }

    var correctDateWithUnitBeginning = function correctDateWithUnitBeginning(v) {
      return _date.default.correctDateWithUnitBeginning(v, intervalObject, null, options.firstDayOfWeek);
    };

    var floorAtStartDate = function floorAtStartDate(v) {
      return new Date(mathFloor((v.getTime() - v.getTimezoneOffset() * MINUTE) / divider) * divider + v.getTimezoneOffset() * MINUTE);
    };

    value = correctDateWithUnitBeginning(value);

    if ('years' in intervalObject) {
      value.setFullYear(floorNumber(value.getFullYear(), intervalObject.years));
    } else if ('quarters' in intervalObject) {
      value = correctDateWithUnitBeginning(floorAtStartDate(value));
    } else if ('months' in intervalObject) {
      value.setMonth(floorNumber(value.getMonth(), intervalObject.months));
    } else if ('weeks' in intervalObject || 'days' in intervalObject) {
      value = correctDateWithUnitBeginning(floorAtStartDate(value));
    } else if ('hours' in intervalObject) {
      value.setHours(floorNumber(value.getHours(), intervalObject.hours));
    } else if ('minutes' in intervalObject) {
      value.setMinutes(floorNumber(value.getMinutes(), intervalObject.minutes));
    } else if ('seconds' in intervalObject) {
      value.setSeconds(floorNumber(value.getSeconds(), intervalObject.seconds));
    } else if ('milliseconds' in intervalObject) {
      value = floorAtStartDate(value);
    }

    return value;
  }

  function ceil(value, interval) {
    var newValue = floor(value, interval);

    while (value - newValue > 0) {
      newValue = addIntervalDate(newValue, interval);
    }

    return newValue;
  }

  var calculateTickIntervalByCustomTicks = getTickIntervalByCustomTicks(getValue, _date.default.convertMillisecondsToDateUnits);
  return generator(options, getBusinessDelta, calculateTickIntervalDateTime, calculateMinorTickIntervalDateTime, calculateTickIntervalByCustomTicks, calculateTickIntervalByCustomTicks, dateToMilliseconds, calculateTicks(addIntervalDate, correctMinValueByEndOnTick(floor, ceil, resolveEndOnTickDate, options.endOnTick), adjustIntervalDateTime, resolveEndOnTickDate), calculateMinorTicks(getValue, addIntervalDate, floor, addIntervalDate, getValue), getScaleBreaksProcessor(dateToMilliseconds, getValue, function (value, correction) {
    return new Date(value.getTime() + correction);
  }));
}

var tickGenerator = function tickGenerator(options) {
  var result;

  if (options.rangeIsEmpty) {
    result = dummyGenerator(options);
  } else if (options.axisType === 'discrete') {
    result = discreteGenerator(options);
  } else if (options.axisType === 'logarithmic') {
    result = logarithmicGenerator(options);
  } else if (options.dataType === 'datetime') {
    result = dateGenerator(options);
  } else {
    result = numericGenerator(options);
  }

  return result;
};

exports.tickGenerator = tickGenerator;

/***/ }),
/* 596 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.tick = createTick;

var _type = __webpack_require__(1);

var _extend = __webpack_require__(0);

var _deferred = __webpack_require__(6);

function getPathStyle(options) {
  return {
    stroke: options.color,
    'stroke-width': options.width,
    'stroke-opacity': options.opacity,
    opacity: 1
  };
}

function createTick(axis, renderer, tickOptions, gridOptions, skippedCategory, skipLabels, offset) {
  var tickOffset = offset || axis._tickOffset;
  var lineGroup = axis._axisLineGroup;
  var elementsGroup = axis._axisElementsGroup;
  var tickStyle = getPathStyle(tickOptions);
  var gridStyle = getPathStyle(gridOptions);
  var emptyStrRegExp = /^\s+$/;
  var axisOptions = axis.getOptions();
  var labelOptions = axisOptions.label;
  var labelStyle = axis._textOptions;

  function getLabelFontStyle(tick) {
    var fontStyle = axis._textFontStyles;
    var customizeColor = labelOptions.customizeColor;

    if (customizeColor && customizeColor.call) {
      fontStyle = (0, _extend.extend)({}, axis._textFontStyles, {
        fill: customizeColor.call(tick, tick)
      });
    }

    return fontStyle;
  }

  function createLabelHint(tick, range) {
    var labelHint = axis.formatHint(tick.value, labelOptions, range);

    if ((0, _type.isDefined)(labelHint) && labelHint !== '') {
      tick.getContentContainer().setTitle(labelHint);
    }
  }

  return function (value) {
    var tick = {
      value: value,
      updateValue: function updateValue(newValue) {
        this.value = value = newValue;
      },
      initCoords: function initCoords() {
        this.coords = axis._getTranslatedValue(value, tickOffset);
        this.labelCoords = axis._getTranslatedValue(value);
      },
      saveCoords: function saveCoords() {
        this._lastStoredCoordinates = {
          coords: this._storedCoords,
          labelCoords: this._storedLabelsCoords
        };
        this._storedCoords = this.coords;
        this._storedLabelsCoords = this.templateContainer ? this._getTemplateCoords() : this.labelCoords;
      },
      resetCoordinates: function resetCoordinates() {
        if (this._lastStoredCoordinates) {
          this._storedCoords = this._lastStoredCoordinates.coords;
          this._storedLabelsCoords = this._lastStoredCoordinates.labelCoords;
        }
      },
      drawMark: function drawMark(options) {
        if (!tickOptions.visible || skippedCategory === value) {
          return;
        }

        if (axis.areCoordsOutsideAxis(this.coords)) {
          return;
        }

        if (this.mark) {
          this.mark.append(lineGroup);
          axis.sharp(this.mark, axis.getSharpDirectionByCoords(this.coords));
          this.updateTickPosition(options);
        } else {
          this.mark = axis._createPathElement([], tickStyle, axis.getSharpDirectionByCoords(this.coords)).append(lineGroup);
          this.updateTickPosition(options);
        }
      },
      setSkippedCategory: function setSkippedCategory(category) {
        skippedCategory = category;
      },
      _updateLine: function _updateLine(lineElement, settings, storedSettings, animate, isGridLine) {
        if (!lineElement) {
          return;
        }

        if (settings.points === null || settings.r === null) {
          lineElement.remove();
          return;
        }

        if (animate && storedSettings && storedSettings.points !== null) {
          settings.opacity = 1;
          lineElement.attr(storedSettings);
          lineElement.animate(settings);
        } else {
          settings.opacity = animate ? 0 : 1;
          lineElement.attr(settings);
          animate && lineElement.animate({
            opacity: 1
          }, {
            delay: 0.5,
            partitionDuration: 0.5
          });
        }

        this.coords.angle && axis._rotateTick(lineElement, this.coords, isGridLine);
      },
      updateTickPosition: function updateTickPosition(options, animate) {
        this._updateLine(this.mark, {
          points: axis._getTickMarkPoints(tick.coords, tickOptions.length, options)
        }, this._storedCoords && {
          points: axis._getTickMarkPoints(tick._storedCoords, tickOptions.length, options)
        }, animate, false);
      },
      drawLabel: function drawLabel(range, template) {
        var _this = this;

        if (this.templateContainer && axis.isRendered()) {
          this.updateLabelPosition();
          return;
        }

        var labelIsVisible = labelOptions.visible && !skipLabels && !axis.getTranslator().getBusinessRange().isEmpty() && !axis.areCoordsOutsideAxis(this.labelCoords);

        if (!labelIsVisible) {
          if (this.label) {
            this.removeLabel();
          }

          return;
        }

        var templateOption = labelOptions.template;
        var text = axis.formatLabel(value, labelOptions, range);

        if (this.label) {
          this.label.attr({
            text: text,
            rotate: 0
          }).append(elementsGroup);
          createLabelHint(this, range);
          this.updateLabelPosition();
          return;
        }

        if (templateOption) {
          this.templateContainer = renderer.g().append(elementsGroup);
          this._templateDef && this._templateDef.reject();
          this._templateDef = new _deferred.Deferred();
          template.render({
            model: {
              valueText: text,
              value: this.value,
              labelFontStyle: getLabelFontStyle(this),
              labelStyle: labelStyle
            },
            container: this.templateContainer.element,
            onRendered: function onRendered() {
              _this.updateLabelPosition();

              _this._templateDef && _this._templateDef.resolve();
            }
          });
        } else {
          if ((0, _type.isDefined)(text) && text !== '' && !emptyStrRegExp.test(text)) {
            this.label = renderer.text(text).css(getLabelFontStyle(this)).attr(labelStyle).append(elementsGroup);
            this.updateLabelPosition();
            createLabelHint(this, range);
          }
        }

        var containerForData = this.getContentContainer();
        containerForData && containerForData.data('chart-data-argument', this.value);
        this.templateContainer && createLabelHint(this, range);
      },
      getTemplateDeferred: function getTemplateDeferred() {
        return this._templateDef;
      },
      getContentContainer: function getContentContainer() {
        return this.templateContainer || this.label;
      },
      fadeOutElements: function fadeOutElements() {
        var startSettings = {
          opacity: 1
        };
        var endSettings = {
          opacity: 0
        };
        var animationSettings = {
          partitionDuration: 0.5
        };

        if (this.getContentContainer()) {
          this._fadeOutLabel();
        }

        if (this.grid) {
          this.grid.append(axis._axisGridGroup).attr(startSettings).animate(endSettings, animationSettings);
        }

        if (this.mark) {
          this.mark.append(axis._axisLineGroup).attr(startSettings).animate(endSettings, animationSettings);
        }
      },
      _fadeInLabel: function _fadeInLabel() {
        var group = axis._renderer.g().attr({
          opacity: 0
        }).append(axis._axisElementsGroup).animate({
          opacity: 1
        }, {
          delay: 0.5,
          partitionDuration: 0.5
        });

        this.getContentContainer().append(group);
      },
      _fadeOutLabel: function _fadeOutLabel() {
        var group = axis._renderer.g().attr({
          opacity: 1
        }).animate({
          opacity: 0
        }, {
          partitionDuration: 0.5
        }).append(axis._axisElementsGroup).toBackground();

        this.getContentContainer().append(group);
      },
      _getTemplateCoords: function _getTemplateCoords() {
        return axis._getLabelAdjustedCoord(this, (axis._constantLabelOffset || 0) + (tick.labelOffset || 0));
      },
      updateLabelPosition: function updateLabelPosition(animate) {
        var templateContainer = this.templateContainer;

        if (!this.getContentContainer()) {
          return;
        }

        if (animate && this._storedLabelsCoords) {
          if (templateContainer) {
            templateContainer.attr(this._storedLabelsCoords);

            var lCoords = this._getTemplateCoords();

            templateContainer.animate(lCoords);
          } else {
            this.label.attr({
              x: this._storedLabelsCoords.x,
              y: this._storedLabelsCoords.y
            });
            this.label.animate({
              x: this.labelCoords.x,
              y: this.labelCoords.y
            });
          }
        } else {
          if (templateContainer) {
            var _lCoords = this._getTemplateCoords();

            templateContainer.attr(_lCoords);
          } else {
            this.label.attr({
              x: this.labelCoords.x,
              y: this.labelCoords.y
            });
          }

          if (animate) {
            this._fadeInLabel();
          }
        }
      },
      updateMultilineTextAlignment: function updateMultilineTextAlignment() {
        if (labelOptions.template || !this.label) {
          return;
        }

        this.label.attr({
          textsAlignment: this.labelAlignment || axis.getOptions().label.alignment
        });
      },
      drawGrid: function drawGrid(drawLine) {
        if (gridOptions.visible && skippedCategory !== this.value) {
          if (this.grid) {
            this.grid.append(axis._axisGridGroup);
            axis.sharp(this.grid, axis.getSharpDirectionByCoords(this.coords));
            this.updateGridPosition();
          } else {
            this.grid = drawLine(this, gridStyle);
            this.grid && this.grid.append(axis._axisGridGroup);
          }
        }
      },
      updateGridPosition: function updateGridPosition(animate) {
        this._updateLine(this.grid, axis._getGridPoints(tick.coords), this._storedCoords && axis._getGridPoints(this._storedCoords), animate, true);
      },
      removeLabel: function removeLabel() {
        var contentContainer = this.getContentContainer();
        contentContainer && contentContainer.remove();
        this._templateDef && this._templateDef.reject();
        this._templateDef = this.templateContainer = this.label = null;
      }
    };
    return tick;
  };
}

/***/ }),
/* 597 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _range = __webpack_require__(141);

var _format_helper = _interopRequireDefault(__webpack_require__(82));

var _date = _interopRequireDefault(__webpack_require__(18));

var _extend = __webpack_require__(0);

var _datetime_breaks = __webpack_require__(1060);

var _common = __webpack_require__(4);

var _utils = __webpack_require__(14);

var _type = __webpack_require__(1);

var _axes_constants = _interopRequireDefault(__webpack_require__(243));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getNextDateUnit = _date.default.getNextDateUnit;
var correctDateWithUnitBeginning = _date.default.correctDateWithUnitBeginning;
var _math = Math;
var _max = _math.max;
var TOP = _axes_constants.default.top;
var BOTTOM = _axes_constants.default.bottom;
var LEFT = _axes_constants.default.left;
var RIGHT = _axes_constants.default.right;
var CENTER = _axes_constants.default.center;
var SCALE_BREAK_OFFSET = 3;
var RANGE_RATIO = 0.3;
var WAVED_LINE_CENTER = 2;
var WAVED_LINE_TOP = 0;
var WAVED_LINE_BOTTOM = 4;
var WAVED_LINE_LENGTH = 24;
var TICKS_CORRECTIONS = {
  left: -1,
  top: -1,
  right: 0,
  bottom: 0,
  center: -0.5
};

function prepareDatesDifferences(datesDifferences, tickInterval) {
  var dateUnitInterval;
  var i;

  if (tickInterval === 'week') {
    tickInterval = 'day';
  }

  if (tickInterval === 'quarter') {
    tickInterval = 'month';
  }

  if (datesDifferences[tickInterval]) {
    for (i = 0; i < _date.default.dateUnitIntervals.length; i++) {
      dateUnitInterval = _date.default.dateUnitIntervals[i];

      if (datesDifferences[dateUnitInterval]) {
        datesDifferences[dateUnitInterval] = false;
        datesDifferences.count--;
      }

      if (dateUnitInterval === tickInterval) {
        break;
      }
    }
  }
}

function sortingBreaks(breaks) {
  return breaks.sort(function (a, b) {
    return a.from - b.from;
  });
}

function getMarkerDates(min, max, markerInterval) {
  var origMin = min;
  var dates;
  min = correctDateWithUnitBeginning(min, markerInterval);
  max = correctDateWithUnitBeginning(max, markerInterval);
  dates = _date.default.getSequenceByInterval(min, max, markerInterval);

  if (dates.length && origMin > dates[0]) {
    dates = dates.slice(1);
  }

  return dates;
}

function getStripHorizontalAlignmentPosition(alignment) {
  var position = 'start';

  if (alignment === 'center') {
    position = 'center';
  }

  if (alignment === 'right') {
    position = 'end';
  }

  return position;
}

function getStripVerticalAlignmentPosition(alignment) {
  var position = 'start';

  if (alignment === 'center') {
    position = 'center';
  }

  if (alignment === 'bottom') {
    position = 'end';
  }

  return position;
}

function getMarkerInterval(tickInterval) {
  var markerInterval = getNextDateUnit(tickInterval);

  if (markerInterval === 'quarter') {
    markerInterval = getNextDateUnit(markerInterval);
  }

  return markerInterval;
}

function getMarkerFormat(curDate, prevDate, tickInterval, markerInterval) {
  var format = markerInterval;

  var datesDifferences = prevDate && _date.default.getDatesDifferences(prevDate, curDate);

  if (prevDate && tickInterval !== 'year') {
    prepareDatesDifferences(datesDifferences, tickInterval);
    format = _format_helper.default.getDateFormatByDifferences(datesDifferences);
  }

  return format;
}

function getMaxSide(act, boxes) {
  return boxes.reduce(function (prevValue, box) {
    return _max(prevValue, act(box));
  }, 0);
}

function getDistanceByAngle(bBox, rotationAngle) {
  rotationAngle = _math.abs(rotationAngle);
  rotationAngle = rotationAngle % 180 >= 90 ? 90 - rotationAngle % 90 : rotationAngle % 90;
  var a = rotationAngle * (_math.PI / 180);

  if (a >= _math.atan(bBox.height / bBox.width)) {
    return bBox.height / _math.abs(_math.sin(a));
  } else {
    return bBox.width;
  }
}

function getMaxConstantLinePadding(constantLines) {
  return constantLines.reduce(function (padding, options) {
    return _max(padding, options.paddingTopBottom);
  }, 0);
}

function getConstantLineLabelMarginForVerticalAlignment(constantLines, alignment, labelHeight) {
  return constantLines.some(function (options) {
    return options.label.verticalAlignment === alignment;
  }) && labelHeight || 0;
}

function getLeftMargin(bBox) {
  return _math.abs(bBox.x) || 0;
}

function getRightMargin(bBox) {
  return _math.abs(bBox.width - _math.abs(bBox.x)) || 0;
}

function generateRangesOnPoints(points, edgePoints, getRange) {
  var i;
  var length;
  var maxRange = null;
  var ranges = [];
  var curValue;
  var prevValue;
  var curRange;

  for (i = 1, length = points.length; i < length; i++) {
    curValue = points[i];
    prevValue = points[i - 1];
    curRange = getRange(curValue, prevValue);

    if (edgePoints.indexOf(curValue) >= 0) {
      if (!maxRange || curRange > maxRange.length) {
        maxRange = {
          start: curValue,
          end: prevValue,
          length: curRange
        };
      }
    } else {
      if (maxRange && curRange < maxRange.length) {
        ranges.push(maxRange);
      } else {
        ranges.push({
          start: curValue,
          end: prevValue,
          length: curRange
        });
      }

      maxRange = null;
    }
  }

  if (maxRange) {
    ranges.push(maxRange);
  }

  return ranges;
}

function generateAutoBreaks(_ref, series, _ref2) {
  var logarithmBase = _ref.logarithmBase,
      type = _ref.type,
      maxAutoBreakCount = _ref.maxAutoBreakCount;
  var minVisible = _ref2.minVisible,
      maxVisible = _ref2.maxVisible;
  var breaks = [];
  var getRange = type === 'logarithmic' ? function (min, max) {
    return (0, _utils.getLog)(max / min, logarithmBase);
  } : function (min, max) {
    return max - min;
  };
  var visibleRange = getRange(minVisible, maxVisible);
  var points = series.reduce(function (result, s) {
    var points = s.getPointsInViewPort();
    result[0] = result[0].concat(points[0]);
    result[1] = result[1].concat(points[1]);
    return result;
  }, [[], []]);
  var sortedAllPoints = points[0].concat(points[1]).sort(function (a, b) {
    return b - a;
  });
  var edgePoints = points[1].filter(function (p) {
    return points[0].indexOf(p) < 0;
  });
  var minDiff = RANGE_RATIO * visibleRange;
  var ranges = generateRangesOnPoints(sortedAllPoints, edgePoints, getRange).sort(function (a, b) {
    return b.length - a.length;
  });
  var epsilon = _math.min.apply(null, ranges.map(function (r) {
    return r.length;
  })) / 1000;

  var _maxAutoBreakCount = (0, _type.isDefined)(maxAutoBreakCount) ? _math.min(maxAutoBreakCount, ranges.length) : ranges.length;

  for (var i = 0; i < _maxAutoBreakCount; i++) {
    if (ranges[i].length >= minDiff) {
      if (visibleRange <= ranges[i].length) {
        break;
      }

      visibleRange -= ranges[i].length;

      if (visibleRange > epsilon || visibleRange < -epsilon) {
        breaks.push({
          from: ranges[i].start,
          to: ranges[i].end
        });
        minDiff = RANGE_RATIO * visibleRange;
      }
    } else {
      break;
    }
  }

  sortingBreaks(breaks);
  return breaks;
}

var _default = {
  linear: {
    _getStep: function _getStep(boxes, rotationAngle) {
      var spacing = this._options.label.minSpacing;
      var func = this._isHorizontal ? function (box) {
        return box.width + spacing;
      } : function (box) {
        return box.height;
      };
      var maxLabelLength = getMaxSide(func, boxes);

      if (rotationAngle) {
        maxLabelLength = getDistanceByAngle({
          width: maxLabelLength,
          height: this._getMaxLabelHeight(boxes, 0)
        }, rotationAngle);
      }

      return _axes_constants.default.getTicksCountInRange(this._majorTicks, this._isHorizontal ? 'x' : 'y', maxLabelLength);
    },
    _getMaxLabelHeight: function _getMaxLabelHeight(boxes, spacing) {
      return getMaxSide(function (box) {
        return box.height;
      }, boxes) + spacing;
    },
    _validateOverlappingMode: function _validateOverlappingMode(mode, displayMode) {
      if (this._isHorizontal && (displayMode === 'rotate' || displayMode === 'stagger') || !this._isHorizontal) {
        return _axes_constants.default.validateOverlappingMode(mode);
      }

      return mode;
    },
    _validateDisplayMode: function _validateDisplayMode(mode) {
      return this._isHorizontal ? mode : 'standard';
    },
    getMarkerTrackers: function getMarkerTrackers() {
      return this._markerTrackers;
    },
    _getSharpParam: function _getSharpParam(opposite) {
      return this._isHorizontal ^ opposite ? 'h' : 'v';
    },
    _createAxisElement: function _createAxisElement() {
      return this._renderer.path([], 'line');
    },
    _updateAxisElementPosition: function _updateAxisElementPosition() {
      var axisCoord = this._axisPosition;

      var canvas = this._getCanvasStartEnd();

      this._axisElement.attr({
        points: this._isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end]
      });
    },
    _getTranslatedCoord: function _getTranslatedCoord(value, offset) {
      return this._translator.translate(value, offset);
    },
    _initAxisPositions: function _initAxisPositions() {
      var that = this;

      if (that.customPositionIsAvailable()) {
        that._customBoundaryPosition = that.getCustomBoundaryPosition();
      }

      if (!that.customPositionIsAvailable() || that.customPositionIsBoundary()) {
        that._axisPosition = that.getPredefinedPosition(that.getResolvedBoundaryPosition());
      } else {
        that._axisPosition = that.getCustomPosition();
      }
    },
    _getTickMarkPoints: function _getTickMarkPoints(coords, length, tickOptions) {
      var isHorizontal = this._isHorizontal;
      var tickOrientation = this._options.tickOrientation;
      var labelPosition = this._options.label.position;
      var tickStartCoord;

      if ((0, _type.isDefined)(tickOrientation)) {
        tickStartCoord = TICKS_CORRECTIONS[tickOrientation] * length;
      } else {
        var shift = tickOptions.shift || 0;

        if (!isHorizontal && labelPosition === LEFT || isHorizontal && labelPosition !== BOTTOM) {
          shift = -shift;
        }

        tickStartCoord = shift + this.getTickStartPositionShift(length);
      }

      return [coords.x + (isHorizontal ? 0 : tickStartCoord), coords.y + (isHorizontal ? tickStartCoord : 0), coords.x + (isHorizontal ? 0 : tickStartCoord + length), coords.y + (isHorizontal ? tickStartCoord + length : 0)];
    },
    getTickStartPositionShift: function getTickStartPositionShift(length) {
      var width = this._options.width;
      var position = this.getResolvedBoundaryPosition();
      return length % 2 === 1 ? width % 2 === 0 && (position === LEFT || position === TOP) || width % 2 === 1 && (position === RIGHT || position === BOTTOM) && !this.hasNonBoundaryPosition() ? Math.floor(-length / 2) : -Math.floor(length / 2) : -length / 2 + (width % 2 === 0 ? 0 : position === BOTTOM || position === RIGHT ? -1 : 1);
    },
    _getTitleCoords: function _getTitleCoords() {
      var that = this;
      var horizontal = that._isHorizontal;
      var x = that._axisPosition;
      var y = that._axisPosition;
      var align = that._options.title.alignment;

      var canvas = that._getCanvasStartEnd();

      var fromStartToEnd = horizontal || that._options.position === LEFT;
      var canvasStart = fromStartToEnd ? canvas.start : canvas.end;
      var canvasEnd = fromStartToEnd ? canvas.end : canvas.start;
      var coord = align === LEFT ? canvasStart : align === RIGHT ? canvasEnd : canvas.start + (canvas.end - canvas.start) / 2;

      if (horizontal) {
        x = coord;
      } else {
        y = coord;
      }

      return {
        x: x,
        y: y
      };
    },
    _drawTitleText: function _drawTitleText(group, coords) {
      var options = this._options;
      var titleOptions = options.title;
      var attrs = {
        opacity: titleOptions.opacity,
        align: titleOptions.alignment,
        'class': titleOptions.cssClass
      };

      if (!titleOptions.text || !group) {
        return;
      }

      coords = coords || this._getTitleCoords();

      if (!this._isHorizontal) {
        attrs.rotate = options.position === LEFT ? 270 : 90;
      }

      var text = this._renderer.text(titleOptions.text, coords.x, coords.y).css((0, _utils.patchFontOptions)(titleOptions.font)).attr(attrs).append(group);

      this._checkTitleOverflow(text);

      return text;
    },
    _updateTitleCoords: function _updateTitleCoords() {
      this._title && this._title.element.attr(this._getTitleCoords());
    },
    _drawTitle: function _drawTitle() {
      var title = this._drawTitleText(this._axisTitleGroup);

      if (title) {
        this._title = {
          element: title
        };
      }
    },
    _measureTitle: function _measureTitle() {
      if (this._title) {
        if (this._title.bBox && !this._title.originalSize) {
          this._title.originalSize = this._title.bBox;
        }

        this._title.bBox = this._title.element.getBBox();
      }
    },
    _drawDateMarker: function _drawDateMarker(date, options, range) {
      var that = this;
      var markerOptions = that._options.marker;

      var invert = that._translator.getBusinessRange().invert;

      var textIndent = markerOptions.width + markerOptions.textLeftIndent;
      var pathElement;
      if (options.x === null) return;

      if (!options.withoutStick) {
        pathElement = that._renderer.path([options.x, options.y, options.x, options.y + markerOptions.separatorHeight], 'line').attr({
          'stroke-width': markerOptions.width,
          stroke: markerOptions.color,
          'stroke-opacity': markerOptions.opacity,
          sharp: 'h'
        }).append(that._axisElementsGroup);
      }

      var text = String(that.formatLabel(date, options.labelOptions, range));
      return {
        date: date,
        x: options.x,
        y: options.y,
        cropped: options.withoutStick,
        label: that._renderer.text(text, options.x, options.y).css((0, _utils.patchFontOptions)(markerOptions.label.font)).append(that._axisElementsGroup),
        line: pathElement,
        getContentContainer: function getContentContainer() {
          return this.label;
        },
        getEnd: function getEnd() {
          return this.x + (invert ? -1 : 1) * (textIndent + this.labelBBox.width);
        },
        setTitle: function setTitle() {
          this.title = text;
        },
        hideLabel: function hideLabel() {
          this.label.dispose();
          this.label = null;
          this.title = text;
        },
        hide: function hide() {
          if (pathElement) {
            pathElement.dispose();
            pathElement = null;
          }

          this.label.dispose();
          this.label = null;
          this.hidden = true;
        }
      };
    },
    _drawDateMarkers: function _drawDateMarkers() {
      var that = this;
      var options = that._options;
      var translator = that._translator;

      var viewport = that._getViewportRange();

      var minBound = viewport.minVisible;
      var dateMarkers = [];
      var dateMarker;

      function draw(markerDate, format, withoutStick) {
        return that._drawDateMarker(markerDate, {
          x: translator.translate(markerDate),
          y: markersAreaTop,
          labelOptions: that._getLabelFormatOptions(format),
          withoutStick: withoutStick
        }, viewport);
      }

      if (viewport.isEmpty() || !options.marker.visible || options.argumentType !== 'datetime' || options.type === 'discrete' || that._majorTicks.length <= 1) {
        return [];
      }

      var markersAreaTop = that._axisPosition + options.marker.topIndent;

      var tickInterval = _date.default.getDateUnitInterval(this._tickInterval);

      var markerInterval = getMarkerInterval(tickInterval);
      var markerDates = getMarkerDates(minBound, viewport.maxVisible, markerInterval);

      if (markerDates.length > 1 || markerDates.length === 1 && minBound < markerDates[0]) {
        dateMarkers = markerDates.reduce(function (markers, curDate, i, dates) {
          var marker = draw(curDate, getMarkerFormat(curDate, dates[i - 1] || minBound < curDate && minBound, tickInterval, markerInterval));
          marker && markers.push(marker);
          return markers;
        }, []);

        if (minBound < markerDates[0]) {
          dateMarker = draw(minBound, getMarkerFormat(minBound, markerDates[0], tickInterval, markerInterval), true);
          dateMarker && dateMarkers.unshift(dateMarker);
        }
      }

      return dateMarkers;
    },
    _adjustDateMarkers: function _adjustDateMarkers(offset) {
      offset = offset || 0;
      var that = this;
      var markerOptions = this._options.marker;
      var textIndent = markerOptions.width + markerOptions.textLeftIndent;

      var invert = this._translator.getBusinessRange().invert;

      var canvas = that._getCanvasStartEnd();

      var dateMarkers = this._dateMarkers;

      if (!dateMarkers.length) {
        return offset;
      }

      if (dateMarkers[0].cropped) {
        if (!this._checkMarkersPosition(invert, dateMarkers[1], dateMarkers[0])) {
          dateMarkers[0].hideLabel();
        }
      }

      var prevDateMarker;
      dateMarkers.forEach(function (marker, i, markers) {
        if (marker.cropped) {
          return;
        }

        if (invert ? marker.getEnd() < canvas.end : marker.getEnd() > canvas.end) {
          marker.hideLabel();
        } else if (that._checkMarkersPosition(invert, marker, prevDateMarker)) {
          prevDateMarker = marker;
        } else {
          marker.hide();
        }
      });

      this._dateMarkers.forEach(function (marker) {
        if (marker.label) {
          var labelBBox = marker.labelBBox;
          var dy = marker.y + markerOptions.textTopIndent - labelBBox.y;
          marker.label.attr({
            translateX: invert ? marker.x - textIndent - labelBBox.x - labelBBox.width : marker.x + textIndent - labelBBox.x,
            translateY: dy + offset
          });
        }

        if (marker.line) {
          marker.line.attr({
            translateY: offset
          });
        }
      });

      that._initializeMarkersTrackers(offset);

      return offset + markerOptions.topIndent + markerOptions.separatorHeight;
    },
    _checkMarkersPosition: function _checkMarkersPosition(invert, dateMarker, prevDateMarker) {
      if (prevDateMarker === undefined) {
        return true;
      }

      return invert ? dateMarker.x < prevDateMarker.getEnd() : dateMarker.x > prevDateMarker.getEnd();
    },
    _initializeMarkersTrackers: function _initializeMarkersTrackers(offset) {
      var that = this;
      var separatorHeight = that._options.marker.separatorHeight;
      var renderer = that._renderer;

      var businessRange = this._translator.getBusinessRange();

      var canvas = that._getCanvasStartEnd();

      var group = that._axisElementsGroup;
      that._markerTrackers = this._dateMarkers.filter(function (marker) {
        return !marker.hidden;
      }).map(function (marker, i, markers) {
        var nextMarker = markers[i + 1] || {
          x: canvas.end,
          date: businessRange.max
        };
        var x = marker.x;
        var y = marker.y + offset;
        var markerTracker = renderer.path([x, y, x, y + separatorHeight, nextMarker.x, y + separatorHeight, nextMarker.x, y, x, y], 'area').attr({
          'stroke-width': 1,
          stroke: 'grey',
          fill: 'grey',
          opacity: 0.0001
        }).append(group);
        markerTracker.data('range', {
          startValue: marker.date,
          endValue: nextMarker.date
        });

        if (marker.title) {
          markerTracker.setTitle(marker.title);
        }

        return markerTracker;
      });
    },
    _getLabelFormatOptions: function _getLabelFormatOptions(formatString) {
      var that = this;
      var markerLabelOptions = that._markerLabelOptions;

      if (!markerLabelOptions) {
        that._markerLabelOptions = markerLabelOptions = (0, _extend.extend)(true, {}, that._options.marker.label);
      }

      if (!(0, _type.isDefined)(that._options.marker.label.format)) {
        markerLabelOptions.format = formatString;
      }

      return markerLabelOptions;
    },
    _adjustConstantLineLabels: function _adjustConstantLineLabels(constantLines) {
      var that = this;
      var axisPosition = that._options.position;
      var canvas = that.getCanvas();
      var canvasLeft = canvas.left;
      var canvasRight = canvas.width - canvas.right;
      var canvasTop = canvas.top;
      var canvasBottom = canvas.height - canvas.bottom;
      var verticalCenter = canvasTop + (canvasBottom - canvasTop) / 2;
      var horizontalCenter = canvasLeft + (canvasRight - canvasLeft) / 2;
      var maxLabel = 0;
      constantLines.forEach(function (item) {
        var isHorizontal = that._isHorizontal;
        var linesOptions = item.options;
        var paddingTopBottom = linesOptions.paddingTopBottom;
        var paddingLeftRight = linesOptions.paddingLeftRight;
        var labelOptions = linesOptions.label;
        var labelVerticalAlignment = labelOptions.verticalAlignment;
        var labelHorizontalAlignment = labelOptions.horizontalAlignment;
        var labelIsInside = labelOptions.position === 'inside';
        var label = item.label;
        var box = item.labelBBox;
        var translateX;
        var translateY;

        if (label === null || box.isEmpty) {
          return;
        }

        if (isHorizontal) {
          if (labelIsInside) {
            if (labelHorizontalAlignment === LEFT) {
              translateX = item.coord - paddingLeftRight - box.x - box.width;
            } else {
              translateX = item.coord + paddingLeftRight - box.x;
            }

            switch (labelVerticalAlignment) {
              case CENTER:
                translateY = verticalCenter - box.y - box.height / 2;
                break;

              case BOTTOM:
                translateY = canvasBottom - paddingTopBottom - box.y - box.height;
                break;

              default:
                translateY = canvasTop + paddingTopBottom - box.y;
                break;
            }
          } else {
            if (axisPosition === labelVerticalAlignment) {
              maxLabel = _max(maxLabel, box.height + paddingTopBottom);
            }

            translateX = item.coord - box.x - box.width / 2;

            if (labelVerticalAlignment === BOTTOM) {
              translateY = canvasBottom + paddingTopBottom - box.y;
            } else {
              translateY = canvasTop - paddingTopBottom - box.y - box.height;
            }
          }
        } else {
          if (labelIsInside) {
            if (labelVerticalAlignment === BOTTOM) {
              translateY = item.coord + paddingTopBottom - box.y;
            } else {
              translateY = item.coord - paddingTopBottom - box.y - box.height;
            }

            switch (labelHorizontalAlignment) {
              case CENTER:
                translateX = horizontalCenter - box.x - box.width / 2;
                break;

              case RIGHT:
                translateX = canvasRight - paddingLeftRight - box.x - box.width;
                break;

              default:
                translateX = canvasLeft + paddingLeftRight - box.x;
                break;
            }
          } else {
            if (axisPosition === labelHorizontalAlignment) {
              maxLabel = _max(maxLabel, box.width + paddingLeftRight);
            }

            translateY = item.coord - box.y - box.height / 2;

            if (labelHorizontalAlignment === RIGHT) {
              translateX = canvasRight + paddingLeftRight - box.x;
            } else {
              translateX = canvasLeft - paddingLeftRight - box.x - box.width;
            }
          }
        }

        label.attr({
          translateX: translateX,
          translateY: translateY
        });
      });
      return maxLabel;
    },
    _drawConstantLinesForEstimating: function _drawConstantLinesForEstimating(constantLines) {
      var that = this;
      var renderer = this._renderer;
      var group = renderer.g();
      constantLines.forEach(function (options) {
        that._drawConstantLineLabelText(options.label.text, 0, 0, options.label, group).attr({
          align: 'center'
        });
      });
      return group.append(renderer.root);
    },
    _estimateLabelHeight: function _estimateLabelHeight(bBox, labelOptions) {
      var height = bBox.height;
      var drawingType = labelOptions.drawingType;

      if (this._validateDisplayMode(drawingType) === 'stagger' || this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType) === 'stagger') {
        height = height * 2 + labelOptions.staggeringSpacing;
      }

      if (this._validateDisplayMode(drawingType) === 'rotate' || this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType) === 'rotate') {
        var sinCos = (0, _utils.getCosAndSin)(labelOptions.rotationAngle);
        height = height * sinCos.cos + bBox.width * sinCos.sin;
      }

      return height && (height + labelOptions.indentFromAxis || 0) || 0;
    },
    estimateMargins: function estimateMargins(canvas) {
      this.updateCanvas(canvas);
      var that = this;

      var range = that._getViewportRange();

      var ticksData = this._createTicksAndLabelFormat(range);

      var ticks = ticksData.ticks;
      var tickInterval = ticksData.tickInterval;
      var options = this._options;

      var constantLineOptions = that._outsideConstantLines.filter(function (l) {
        return l.labelOptions.visible;
      }).map(function (l) {
        return l.options;
      });

      var rootElement = that._renderer.root;
      var labelIsVisible = options.label.visible && !range.isEmpty() && ticks.length;
      var labelValue = labelIsVisible && that.formatLabel(ticks[ticks.length - 1], options.label, undefined, undefined, tickInterval, ticks);

      var labelElement = labelIsVisible && that._renderer.text(labelValue, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(rootElement);

      var titleElement = that._drawTitleText(rootElement, {
        x: 0,
        y: 0
      });

      var constantLinesLabelsElement = that._drawConstantLinesForEstimating(constantLineOptions);

      var labelBox = !options.label.template && labelElement && labelElement.getBBox() || {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
      var titleBox = titleElement && titleElement.getBBox() || {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
      var constantLinesBox = constantLinesLabelsElement.getBBox();
      var titleHeight = titleBox.height ? titleBox.height + options.title.margin : 0;

      var labelHeight = that._estimateLabelHeight(labelBox, options.label);

      var constantLinesHeight = constantLinesBox.height ? constantLinesBox.height + getMaxConstantLinePadding(constantLineOptions) : 0;
      var height = labelHeight + titleHeight;
      var margins = {
        left: _max(getLeftMargin(labelBox), getLeftMargin(constantLinesBox)),
        right: _max(getRightMargin(labelBox), getRightMargin(constantLinesBox)),
        top: (options.position === 'top' ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, 'top', constantLinesHeight),
        bottom: (options.position !== 'top' ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, 'bottom', constantLinesHeight)
      };
      labelElement && labelElement.remove();
      titleElement && titleElement.remove();
      constantLinesLabelsElement && constantLinesLabelsElement.remove();
      return margins;
    },
    _checkAlignmentConstantLineLabels: function _checkAlignmentConstantLineLabels(labelOptions) {
      var position = labelOptions.position;
      var verticalAlignment = (labelOptions.verticalAlignment || '').toLowerCase();
      var horizontalAlignment = (labelOptions.horizontalAlignment || '').toLowerCase();

      if (this._isHorizontal) {
        if (position === 'outside') {
          verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;
          horizontalAlignment = CENTER;
        } else {
          verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;
          horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;
        }
      } else {
        if (position === 'outside') {
          verticalAlignment = CENTER;
          horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;
        } else {
          verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;
          horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT;
        }
      }

      labelOptions.verticalAlignment = verticalAlignment;
      labelOptions.horizontalAlignment = horizontalAlignment;
    },
    _getConstantLineLabelsCoords: function _getConstantLineLabelsCoords(value, lineLabelOptions) {
      var that = this;
      var x = value;
      var y = value;

      if (that._isHorizontal) {
        y = that._orthogonalPositions[lineLabelOptions.verticalAlignment === 'top' ? 'start' : 'end'];
      } else {
        x = that._orthogonalPositions[lineLabelOptions.horizontalAlignment === 'right' ? 'end' : 'start'];
      }

      return {
        x: x,
        y: y
      };
    },
    _getAdjustedStripLabelCoords: function _getAdjustedStripLabelCoords(strip) {
      var stripOptions = strip.options;
      var paddingTopBottom = stripOptions.paddingTopBottom;
      var paddingLeftRight = stripOptions.paddingLeftRight;
      var horizontalAlignment = stripOptions.label.horizontalAlignment;
      var verticalAlignment = stripOptions.label.verticalAlignment;
      var box = strip.labelBBox;
      var labelHeight = box.height;
      var labelWidth = box.width;
      var labelCoords = strip.labelCoords;
      var y = labelCoords.y - box.y;
      var x = labelCoords.x - box.x;

      if (verticalAlignment === TOP) {
        y += paddingTopBottom;
      } else if (verticalAlignment === CENTER) {
        y -= labelHeight / 2;
      } else if (verticalAlignment === BOTTOM) {
        y -= paddingTopBottom + labelHeight;
      }

      if (horizontalAlignment === LEFT) {
        x += paddingLeftRight;
      } else if (horizontalAlignment === CENTER) {
        x -= labelWidth / 2;
      } else if (horizontalAlignment === RIGHT) {
        x -= paddingLeftRight + labelWidth;
      }

      return {
        translateX: x,
        translateY: y
      };
    },
    _adjustTitle: function _adjustTitle(offset) {
      offset = offset || 0;

      if (!this._title) {
        return;
      }

      var that = this;
      var options = that._options;
      var position = options.position;
      var margin = options.title.margin;
      var title = that._title;
      var boxTitle = title.bBox;
      var x = boxTitle.x;
      var y = boxTitle.y;
      var width = boxTitle.width;
      var height = boxTitle.height;
      var axisPosition = that._axisPosition;
      var loCoord = axisPosition - margin - offset;
      var hiCoord = axisPosition + margin + offset;
      var params = {};

      if (that._isHorizontal) {
        if (position === TOP) {
          params.translateY = loCoord - (y + height);
        } else {
          params.translateY = hiCoord - y;
        }
      } else {
        if (position === LEFT) {
          params.translateX = loCoord - (x + width);
        } else {
          params.translateX = hiCoord - x;
        }
      }

      title.element.attr(params);
    },
    _checkTitleOverflow: function _checkTitleOverflow(titleElement) {
      if (!this._title && !titleElement) {
        return;
      }

      var canvasLength = this._getScreenDelta();

      var title = titleElement ? {
        bBox: titleElement.getBBox(),
        element: titleElement
      } : this._title;
      var titleOptions = this._options.title;
      var boxTitle = title.bBox;

      if ((this._isHorizontal ? boxTitle.width : boxTitle.height) > canvasLength) {
        title.element.setMaxSize(canvasLength, undefined, {
          wordWrap: titleOptions.wordWrap || 'none',
          textOverflow: titleOptions.textOverflow || 'ellipsis'
        });
        this._wrapped = titleOptions.wordWrap && titleOptions.wordWrap !== 'none';
      } else {
        var moreThanOriginalSize = title.originalSize && canvasLength > (this._isHorizontal ? title.originalSize.width : title.originalSize.height);
        !this._wrapped && moreThanOriginalSize && title.element.restoreText();
      }
    },
    coordsIn: function coordsIn(x, y) {
      var canvas = this.getCanvas();
      var isHorizontal = this._options.isHorizontal;
      var position = this._options.position;
      var coord = isHorizontal ? y : x;

      if (isHorizontal && (x < canvas.left || x > canvas.width - canvas.right) || !isHorizontal && (y < canvas.top || y > canvas.height - canvas.bottom)) {
        return false;
      }

      if (isHorizontal && position === _axes_constants.default.top || !isHorizontal && position === _axes_constants.default.left) {
        return coord < canvas[position];
      }

      return coord > canvas[isHorizontal ? 'height' : 'width'] - canvas[position];
    },
    _boundaryTicksVisibility: {
      min: true,
      max: true
    },
    adjust: function adjust() {
      var that = this;
      var seriesData = that._seriesData;

      var viewport = that._series.filter(function (s) {
        return s.isVisible();
      }).reduce(function (range, s) {
        var seriesRange = s.getViewport();
        range.min = (0, _type.isDefined)(seriesRange.min) ? range.min < seriesRange.min ? range.min : seriesRange.min : range.min;
        range.max = (0, _type.isDefined)(seriesRange.max) ? range.max > seriesRange.max ? range.max : seriesRange.max : range.max;

        if (s.showZero) {
          range = new _range.Range(range);
          range.correctValueZeroLevel();
        }

        return range;
      }, {});

      if ((0, _type.isDefined)(viewport.min) && (0, _type.isDefined)(viewport.max)) {
        seriesData.minVisible = viewport.min;
        seriesData.maxVisible = viewport.max;
      }

      seriesData.userBreaks = that._getScaleBreaks(that._options, {
        minVisible: seriesData.minVisible,
        maxVisible: seriesData.maxVisible
      }, that._series, that.isArgumentAxis);

      that._translator.updateBusinessRange(that._getViewportRange());
    },
    hasWrap: function hasWrap() {
      return this._wrapped;
    },
    getAxisPosition: function getAxisPosition() {
      return this._axisPosition;
    },
    _getStick: function _getStick() {
      return !this._options.valueMarginsEnabled;
    },
    _getStripLabelCoords: function _getStripLabelCoords(from, to, stripLabelOptions) {
      var that = this;
      var orthogonalPositions = that._orthogonalPositions;
      var isHorizontal = that._isHorizontal;
      var horizontalAlignment = stripLabelOptions.horizontalAlignment;
      var verticalAlignment = stripLabelOptions.verticalAlignment;
      var x;
      var y;

      if (isHorizontal) {
        if (horizontalAlignment === CENTER) {
          x = from + (to - from) / 2;
        } else if (horizontalAlignment === LEFT) {
          x = from;
        } else if (horizontalAlignment === RIGHT) {
          x = to;
        }

        y = orthogonalPositions[getStripVerticalAlignmentPosition(verticalAlignment)];
      } else {
        x = orthogonalPositions[getStripHorizontalAlignmentPosition(horizontalAlignment)];

        if (verticalAlignment === TOP) {
          y = from;
        } else if (verticalAlignment === CENTER) {
          y = to + (from - to) / 2;
        } else if (verticalAlignment === BOTTOM) {
          y = to;
        }
      }

      return {
        x: x,
        y: y
      };
    },
    _getTranslatedValue: function _getTranslatedValue(value, offset) {
      var pos1 = this._translator.translate(value, offset, this._options.type === 'semidiscrete' && this._options.tickInterval);

      var pos2 = this._axisPosition;
      var isHorizontal = this._isHorizontal;
      return {
        x: isHorizontal ? pos1 : pos2,
        y: isHorizontal ? pos2 : pos1
      };
    },
    areCoordsOutsideAxis: function areCoordsOutsideAxis(coords) {
      var coord = this._isHorizontal ? coords.x : coords.y;
      var visibleArea = this.getVisibleArea();

      if (coord < visibleArea[0] || coord > visibleArea[1]) {
        return true;
      }

      return false;
    },
    _getSkippedCategory: function _getSkippedCategory(ticks) {
      var skippedCategory;

      if (this._options.type === _axes_constants.default.discrete && this._tickOffset && ticks.length !== 0) {
        skippedCategory = ticks[ticks.length - 1];
      }

      return skippedCategory;
    },
    _filterBreaks: function _filterBreaks(breaks, viewport, breakStyle) {
      var minVisible = viewport.minVisible;
      var maxVisible = viewport.maxVisible;
      var breakSize = breakStyle ? breakStyle.width : 0;
      return breaks.reduce(function (result, currentBreak) {
        var from = currentBreak.from;
        var to = currentBreak.to;
        var lastResult = result[result.length - 1];
        var newBreak;

        if (!(0, _type.isDefined)(from) || !(0, _type.isDefined)(to)) {
          return result;
        }

        if (from > to) {
          to = [from, from = to][0];
        }

        if (result.length && from < lastResult.to) {
          if (to > lastResult.to) {
            lastResult.to = to > maxVisible ? maxVisible : to;

            if (lastResult.gapSize) {
              lastResult.gapSize = undefined;
              lastResult.cumulativeWidth += breakSize;
            }
          }
        } else {
          if (from >= minVisible && from < maxVisible || to <= maxVisible && to > minVisible) {
            from = from >= minVisible ? from : minVisible;
            to = to <= maxVisible ? to : maxVisible;

            if (to - from < maxVisible - minVisible) {
              var _lastResult$cumulativ;

              newBreak = {
                from: from,
                to: to,
                cumulativeWidth: ((_lastResult$cumulativ = lastResult === null || lastResult === void 0 ? void 0 : lastResult.cumulativeWidth) !== null && _lastResult$cumulativ !== void 0 ? _lastResult$cumulativ : 0) + breakSize
              };

              if (currentBreak.gapSize) {
                var _lastResult$cumulativ2;

                newBreak.gapSize = _date.default.convertMillisecondsToDateUnits(to - from);
                newBreak.cumulativeWidth = (_lastResult$cumulativ2 = lastResult === null || lastResult === void 0 ? void 0 : lastResult.cumulativeWidth) !== null && _lastResult$cumulativ2 !== void 0 ? _lastResult$cumulativ2 : 0;
              }

              result.push(newBreak);
            }
          }
        }

        return result;
      }, []);
    },
    _getScaleBreaks: function _getScaleBreaks(axisOptions, viewport, series, isArgumentAxis) {
      var that = this;
      var breaks = (axisOptions.breaks || []).map(function (b) {
        return {
          from: that.parser(b.startValue),
          to: that.parser(b.endValue)
        };
      });

      if (axisOptions.type !== 'discrete' && axisOptions.dataType === 'datetime' && axisOptions.workdaysOnly) {
        breaks = breaks.concat((0, _datetime_breaks.generateDateBreaks)(viewport.minVisible, viewport.maxVisible, axisOptions.workWeek, axisOptions.singleWorkdays, axisOptions.holidays));
      }

      if (!isArgumentAxis && axisOptions.type !== 'discrete' && axisOptions.dataType !== 'datetime' && axisOptions.autoBreaksEnabled && axisOptions.maxAutoBreakCount !== 0) {
        breaks = breaks.concat(generateAutoBreaks(axisOptions, series, viewport));
      }

      return sortingBreaks(breaks);
    },
    _drawBreak: function _drawBreak(translatedEnd, positionFrom, positionTo, width, options, group) {
      var that = this;
      var breakStart = translatedEnd - (!that._translator.isInverted() ? width + 1 : 0);
      var attr = {
        'stroke-width': 1,
        stroke: options.borderColor,
        sharp: !options.isWaved ? options.isHorizontal ? 'h' : 'v' : undefined
      };
      var spaceAttr = {
        stroke: options.color,
        'stroke-width': width
      };
      var getPoints = that._isHorizontal ? rotateLine : function (p) {
        return p;
      };
      var drawer = getLineDrawer(that._renderer, group, getPoints, positionFrom, breakStart, positionTo, options.isWaved);
      drawer(width / 2, spaceAttr);
      drawer(0, attr);
      drawer(width, attr);
    },
    _createBreakClipRect: function _createBreakClipRect(from, to) {
      var that = this;
      var canvas = that._canvas;
      var clipWidth = to - from;
      var clipRect;

      if (that._isHorizontal) {
        clipRect = that._renderer.clipRect(canvas.left, from, canvas.width, clipWidth);
      } else {
        clipRect = that._renderer.clipRect(from, canvas.top, clipWidth, canvas.height);
      }

      that._breaksElements = that._breaksElements || [];

      that._breaksElements.push(clipRect);

      return clipRect.id;
    },
    _createBreaksGroup: function _createBreaksGroup(clipFrom, clipTo) {
      var that = this;

      var group = that._renderer.g().attr({
        'class': that._axisCssPrefix + 'breaks',
        'clip-path': that._createBreakClipRect(clipFrom, clipTo)
      }).append(that._scaleBreaksGroup);

      that._breaksElements = that._breaksElements || [];

      that._breaksElements.push(group);

      return group;
    },
    _disposeBreaksGroup: function _disposeBreaksGroup() {
      (this._breaksElements || []).forEach(function (clipRect) {
        clipRect.dispose();
      });
      this._breaksElements = null;
    },
    drawScaleBreaks: function drawScaleBreaks(customCanvas) {
      var that = this;
      var options = that._options;
      var breakStyle = options.breakStyle;
      var position = options.position;
      var positionFrom;
      var positionTo;
      var breaks = that._translator.getBusinessRange().breaks || [];
      var additionGroup;
      var additionBreakFrom;
      var additionBreakTo;

      that._disposeBreaksGroup();

      if (!(breaks && breaks.length)) {
        return;
      }

      var breakOptions = {
        color: that._options.containerColor,
        borderColor: breakStyle.color,
        isHorizontal: that._isHorizontal,
        isWaved: breakStyle.line.toLowerCase() !== 'straight'
      };

      if (customCanvas) {
        positionFrom = customCanvas.start;
        positionTo = customCanvas.end;
      } else {
        positionFrom = that._orthogonalPositions.start - (options.visible && !that._axisShift && (position === LEFT || position === TOP) ? SCALE_BREAK_OFFSET : 0);
        positionTo = that._orthogonalPositions.end + (options.visible && (position === RIGHT || position === BOTTOM) ? SCALE_BREAK_OFFSET : 0);
      }

      var mainGroup = that._createBreaksGroup(positionFrom, positionTo);

      if (that._axisShift && options.visible) {
        additionBreakFrom = that._axisPosition - that._axisShift - SCALE_BREAK_OFFSET;
        additionBreakTo = additionBreakFrom + SCALE_BREAK_OFFSET * 2;
        additionGroup = that._createBreaksGroup(additionBreakFrom, additionBreakTo);
      }

      breaks.forEach(function (br) {
        if (!br.gapSize) {
          var breakCoord = that._getTranslatedCoord(br.to);

          that._drawBreak(breakCoord, positionFrom, positionTo, breakStyle.width, breakOptions, mainGroup);

          if (that._axisShift && options.visible) {
            that._drawBreak(breakCoord, additionBreakFrom, additionBreakTo, breakStyle.width, breakOptions, additionGroup);
          }
        }
      });
    },
    _getSpiderCategoryOption: _common.noop,
    shift: function shift(margins) {
      var that = this;
      var options = that._options;
      var isHorizontal = options.isHorizontal;
      var axesSpacing = that.getMultipleAxesSpacing();
      var constantLinesGroups = that._axisConstantLineGroups;

      function shiftGroup(side, group) {
        var attr = {
          translateX: 0,
          translateY: 0
        };
        var shift = margins[side] ? margins[side] + axesSpacing : 0;
        attr[isHorizontal ? 'translateY' : 'translateX'] = (side === LEFT || side === TOP ? -1 : 1) * shift;
        (group[side] || group).attr(attr);
        return shift;
      }

      that._axisShift = shiftGroup(options.position, that._axisGroup);
      shiftGroup(options.position, that._axisElementsGroup);
      (isHorizontal ? [TOP, BOTTOM] : [LEFT, RIGHT]).forEach(function (side) {
        shiftGroup(side, constantLinesGroups.above);
        shiftGroup(side, constantLinesGroups.under);
      });
    },
    getCustomPosition: function getCustomPosition(position) {
      var that = this;
      var orthogonalAxis = that.getOrthogonalAxis();
      var resolvedPosition = position !== null && position !== void 0 ? position : that.getResolvedPositionOption();
      var offset = that.getOptions().offset;
      var orthogonalTranslator = orthogonalAxis.getTranslator();
      var orthogonalAxisType = orthogonalAxis.getOptions().type;
      var validPosition = orthogonalAxis.validateUnit(resolvedPosition);
      var currentPosition;

      if (orthogonalAxisType === 'discrete' && (!orthogonalTranslator._categories || orthogonalTranslator._categories.indexOf(validPosition) < 0)) {
        validPosition = undefined;
      }

      if (that.positionIsBoundary(resolvedPosition)) {
        currentPosition = that.getPredefinedPosition(resolvedPosition);
      } else if (!(0, _type.isDefined)(validPosition)) {
        currentPosition = that.getPredefinedPosition(that.getOptions().position);
      } else {
        currentPosition = orthogonalTranslator.to(validPosition, -1);
      }

      if (isFinite(currentPosition) && isFinite(offset)) {
        currentPosition += offset;
      }

      return currentPosition;
    },
    getCustomBoundaryPosition: function getCustomBoundaryPosition(position) {
      var that = this;

      var _that$getOptions = that.getOptions(),
          customPosition = _that$getOptions.customPosition,
          offset = _that$getOptions.offset;

      var resolvedPosition = position !== null && position !== void 0 ? position : that.getResolvedPositionOption();
      var orthogonalAxis = that.getOrthogonalAxis();
      var orthogonalTranslator = orthogonalAxis.getTranslator();
      var visibleArea = orthogonalTranslator.getCanvasVisibleArea();

      if (!(0, _type.isDefined)(orthogonalAxis._orthogonalPositions) || orthogonalTranslator.canvasLength === 0) {
        return undefined;
      }

      var currentPosition = that.getCustomPosition(resolvedPosition);

      if (!(0, _type.isDefined)(currentPosition)) {
        return that.getResolvedBoundaryPosition();
      } else if ((0, _type.isDefined)(customPosition)) {
        if (currentPosition <= visibleArea.min) {
          return that._isHorizontal ? TOP : LEFT;
        } else if (currentPosition >= visibleArea.max) {
          return that._isHorizontal ? BOTTOM : RIGHT;
        }
      } else if ((0, _type.isDefined)(offset)) {
        if (currentPosition <= that._orthogonalPositions.start) {
          return that._isHorizontal ? TOP : LEFT;
        } else if (currentPosition >= that._orthogonalPositions.end) {
          return that._isHorizontal ? BOTTOM : RIGHT;
        }
      }

      return currentPosition;
    },
    getResolvedPositionOption: function getResolvedPositionOption() {
      var _options$customPositi;

      var options = this.getOptions();
      return (_options$customPositi = options.customPosition) !== null && _options$customPositi !== void 0 ? _options$customPositi : options.position;
    },
    customPositionIsAvailable: function customPositionIsAvailable() {
      var options = this.getOptions();
      return (0, _type.isDefined)(this.getOrthogonalAxis()) && ((0, _type.isDefined)(options.customPosition) || isFinite(options.offset));
    },
    hasNonBoundaryPosition: function hasNonBoundaryPosition() {
      return this.customPositionIsAvailable() && !this.customPositionIsBoundary();
    },
    getResolvedBoundaryPosition: function getResolvedBoundaryPosition() {
      return this.customPositionIsBoundary() ? this._customBoundaryPosition : this.getOptions().position;
    },
    customPositionEqualsToPredefined: function customPositionEqualsToPredefined() {
      return this.customPositionIsBoundary() && this._customBoundaryPosition === this.getOptions().position;
    },
    customPositionIsBoundary: function customPositionIsBoundary() {
      return this.positionIsBoundary(this._customBoundaryPosition);
    },
    positionIsBoundary: function positionIsBoundary(position) {
      return [TOP, LEFT, BOTTOM, RIGHT].indexOf(position) >= 0;
    },
    getPredefinedPosition: function getPredefinedPosition(position) {
      var _this$_orthogonalPosi;

      return (_this$_orthogonalPosi = this._orthogonalPositions) === null || _this$_orthogonalPosi === void 0 ? void 0 : _this$_orthogonalPosi[position === TOP || position === LEFT ? 'start' : 'end'];
    },
    resolveOverlappingForCustomPositioning: function resolveOverlappingForCustomPositioning(oppositeAxes) {
      var that = this;

      if (!that.hasNonBoundaryPosition() && !that.customPositionIsBoundary() && !oppositeAxes.some(function (a) {
        return a.hasNonBoundaryPosition();
      })) {
        return;
      }

      var overlappingObj = {
        axes: [],
        ticks: []
      };
      oppositeAxes.filter(function (orthogonalAxis) {
        return orthogonalAxis.pane === that.pane;
      }).forEach(function (orthogonalAxis) {
        for (var i = 0; i < that._majorTicks.length; i++) {
          var tick = that._majorTicks[i];
          var label = tick.label;

          if (label) {
            if (overlappingObj.axes.indexOf(orthogonalAxis) < 0 && that._detectElementsOverlapping(label, orthogonalAxis._axisElement)) {
              overlappingObj.axes.push(orthogonalAxis);

              that._shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis);
            }

            for (var j = 0; j < orthogonalAxis._majorTicks.length; j++) {
              var oppositeTick = orthogonalAxis._majorTicks[j];
              var oppositeLabel = oppositeTick.label;

              if (oppositeLabel && that._detectElementsOverlapping(label, oppositeLabel)) {
                overlappingObj.ticks.push(tick);

                that._shiftThroughAxisOverlappedTick(tick);

                i = that._majorTicks.length;
                break;
              }
            }
          }

          if (tick.mark && overlappingObj.ticks.indexOf(tick) < 0) {
            if (that._isHorizontal && tick.mark.attr('translateY')) {
              tick.mark.attr({
                translateY: 0
              });
            } else if (!that._isHorizontal && tick.mark.attr('translateX')) {
              tick.mark.attr({
                translateX: 0
              });
            }
          }
        }
      });
    },
    _shiftThroughOrthogonalAxisOverlappedTick: function _shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis) {
      var that = this;
      var labelBBox = label.getBBox();
      var orthogonalAxisPosition = orthogonalAxis.getAxisPosition();
      var orthogonalAxisLabelOptions = orthogonalAxis.getOptions().label;
      var orthogonalAxisLabelPosition = orthogonalAxisLabelOptions.position;
      var orthogonalAxisLabelIndent = orthogonalAxisLabelOptions.indentFromAxis / 2;
      var translateCoordName = that._isHorizontal ? 'translateX' : 'translateY';
      var defaultOrthogonalAxisLabelPosition = that._isHorizontal ? LEFT : TOP;
      var translate = label.attr(translateCoordName);
      var labelCoord = (that._isHorizontal ? labelBBox.x : labelBBox.y) + translate;
      var labelSize = that._isHorizontal ? labelBBox.width : labelBBox.height;
      var outsidePart = orthogonalAxisPosition - labelCoord;
      var insidePart = labelCoord + labelSize - orthogonalAxisPosition;
      var attr = {};
      attr[translateCoordName] = translate;

      if (outsidePart > 0 && insidePart > 0) {
        if (insidePart - outsidePart > 1) {
          attr[translateCoordName] += outsidePart + orthogonalAxisLabelIndent;
        } else if (outsidePart - insidePart > 1) {
          attr[translateCoordName] -= insidePart + orthogonalAxisLabelIndent;
        } else {
          attr[translateCoordName] += orthogonalAxisLabelPosition === defaultOrthogonalAxisLabelPosition ? outsidePart + orthogonalAxisLabelIndent : -(insidePart + orthogonalAxisLabelIndent);
        }

        label.attr(attr);
      }
    },
    _shiftThroughAxisOverlappedTick: function _shiftThroughAxisOverlappedTick(tick) {
      var _tick$mark;

      var that = this;
      var label = tick.label;

      if (!label) {
        return;
      }

      var labelBBox = label.getBBox();
      var tickMarkBBox = (_tick$mark = tick.mark) === null || _tick$mark === void 0 ? void 0 : _tick$mark.getBBox();
      var axisPosition = that.getAxisPosition();
      var labelOptions = that.getOptions().label;
      var labelIndent = labelOptions.indentFromAxis;
      var labelPosition = labelOptions.position;
      var defaultLabelPosition = that._isHorizontal ? TOP : LEFT;
      var translateCoordName = that._isHorizontal ? 'translateY' : 'translateX';
      var translate = label.attr(translateCoordName);
      var labelCoord = (that._isHorizontal ? labelBBox.y : labelBBox.x) + translate;
      var labelSize = that._isHorizontal ? labelBBox.height : labelBBox.width;
      var attr = {};
      attr[translateCoordName] = translate + (labelPosition === defaultLabelPosition ? axisPosition - labelCoord + labelIndent : -(labelCoord - axisPosition + labelSize + labelIndent));
      label.attr(attr);

      if (tick.mark) {
        var markerSize = that._isHorizontal ? tickMarkBBox.height : tickMarkBBox.width;
        var dir = labelPosition === defaultLabelPosition ? 1 : -1;
        attr[translateCoordName] = dir * (markerSize - 1);
        tick.mark.attr(attr);
      }
    },
    _detectElementsOverlapping: function _detectElementsOverlapping(element1, element2) {
      if (!element1 || !element2) {
        return false;
      }

      var bBox1 = element1.getBBox();
      var x1 = bBox1.x + element1.attr('translateX');
      var y1 = bBox1.y + element1.attr('translateY');
      var bBox2 = element2.getBBox();
      var x2 = bBox2.x + element2.attr('translateX');
      var y2 = bBox2.y + element2.attr('translateY');
      return (x2 >= x1 && x2 <= x1 + bBox1.width || x1 >= x2 && x1 <= x2 + bBox2.width) && (y2 >= y1 && y2 <= y1 + bBox1.height || y1 >= y2 && y1 <= y2 + bBox2.height);
    }
  }
};
exports.default = _default;

function getLineDrawer(renderer, root, rotatePoints, positionFrom, breakStart, positionTo, isWaved) {
  var elementType = isWaved ? 'bezier' : 'line';
  var group = renderer.g().append(root);
  return function (offset, attr) {
    renderer.path(rotatePoints(getPoints(positionFrom, breakStart, positionTo, offset, isWaved)), elementType).attr(attr).append(group);
  };
}

function getPoints(positionFrom, breakStart, positionTo, offset, isWaved) {
  if (!isWaved) {
    return [positionFrom, breakStart + offset, positionTo, breakStart + offset];
  }

  breakStart += offset;
  var currentPosition;
  var topPoint = breakStart + WAVED_LINE_TOP;
  var centerPoint = breakStart + WAVED_LINE_CENTER;
  var bottomPoint = breakStart + WAVED_LINE_BOTTOM;
  var points = [[positionFrom, centerPoint]];

  for (currentPosition = positionFrom; currentPosition < positionTo + WAVED_LINE_LENGTH; currentPosition += WAVED_LINE_LENGTH) {
    points.push([currentPosition + 6, topPoint, currentPosition + 6, topPoint, currentPosition + 12, centerPoint, currentPosition + 18, bottomPoint, currentPosition + 18, bottomPoint, currentPosition + 24, centerPoint]);
  }

  return [].concat.apply([], points);
}

function rotateLine(lineCoords) {
  var points = [];
  var i;

  for (i = 0; i < lineCoords.length; i += 2) {
    points.push(lineCoords[i + 1]);
    points.push(lineCoords[i]);
  }

  return points;
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 598 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.measureLabels = exports.calculateCanvasMargins = void 0;
var _max = Math.max;

var calculateCanvasMargins = function calculateCanvasMargins(bBoxes, canvas) {
  var cLeft = canvas.left;
  var cTop = canvas.top;
  var cRight = canvas.width - canvas.right;
  var cBottom = canvas.height - canvas.bottom;
  return bBoxes.reduce(function (margins, bBox) {
    if (!bBox || bBox.isEmpty) {
      return margins;
    }

    return {
      left: _max(margins.left, cLeft - bBox.x),
      top: _max(margins.top, cTop - bBox.y),
      right: _max(margins.right, bBox.x + bBox.width - cRight),
      bottom: _max(margins.bottom, bBox.y + bBox.height - cBottom)
    };
  }, {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  });
};

exports.calculateCanvasMargins = calculateCanvasMargins;

var measureLabels = function measureLabels(items) {
  items.forEach(function (item) {
    var label = item.getContentContainer();
    item.labelBBox = label ? label.getBBox() : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  });
};

exports.measureLabels = measureLabels;

/***/ }),
/* 599 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.SeriesFamily = SeriesFamily;

var _type = __webpack_require__(1);

var _extend = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _math = __webpack_require__(31);

var _common = __webpack_require__(4);

var _utils = __webpack_require__(14);

var _date = _interopRequireDefault(__webpack_require__(18));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var round = Math.round,
    abs = Math.abs,
    pow = Math.pow,
    sqrt = Math.sqrt;
var _min = Math.min;
var DEFAULT_BAR_GROUP_PADDING = 0.3;

function validateBarPadding(barPadding) {
  return barPadding < 0 || barPadding > 1 ? undefined : barPadding;
}

function validateBarGroupPadding(barGroupPadding) {
  return barGroupPadding < 0 || barGroupPadding > 1 ? DEFAULT_BAR_GROUP_PADDING : barGroupPadding;
}

function isStackExist(series, arg) {
  return series.some(function (s) {
    return !s.getOptions().ignoreEmptyPoints || s.getPointsByArg(arg, true).some(function (point) {
      return point.hasValue();
    });
  });
}

function correctStackCoordinates(series, currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback) {
  series.forEach(function (series) {
    var stackIndex = seriesStackIndexCallback(currentStacks.indexOf(stack), currentStacks.length);
    var points = series.getPointsByArg(arg, true);
    var barPadding = validateBarPadding(series.getOptions().barPadding);
    var barWidth = series.getOptions().barWidth;
    var offset = getOffset(stackIndex, parameters);
    var width = parameters.width;
    var extraParameters;

    if (stackIndex === -1) {
      return;
    }

    if ((0, _type.isDefined)(barPadding) || (0, _type.isDefined)(barWidth)) {
      extraParameters = calculateParams(barsArea, currentStacks.length, 1 - barPadding, barWidth);
      width = extraParameters.width;

      if (!series.getBarOverlapGroup()) {
        offset = getOffset(stackIndex, extraParameters);
      }
    }

    correctPointCoordinates(points, width, offset);
  });
}

function getStackName(series) {
  return series.getStackName() || series.getBarOverlapGroup();
}

function adjustBarSeriesDimensionsCore(series, options, seriesStackIndexCallback) {
  var _series$, _series$2;

  var commonStacks = [];
  var allArguments = [];
  var seriesInStacks = {};
  var barGroupWidth = options.barGroupWidth;
  var argumentAxis = (_series$ = series[0]) === null || _series$ === void 0 ? void 0 : _series$.getArgumentAxis();
  var interval;

  if ((_series$2 = series[0]) !== null && _series$2 !== void 0 && _series$2.useAggregation()) {
    var _series$3;

    var isDateArgAxis = ((_series$3 = series[0]) === null || _series$3 === void 0 ? void 0 : _series$3.argumentType) === 'datetime';
    var tickInterval = argumentAxis.getTickInterval();
    var aggregationInterval = argumentAxis.getAggregationInterval();
    tickInterval = isDateArgAxis ? _date.default.dateToMilliseconds(tickInterval) : tickInterval;
    aggregationInterval = isDateArgAxis ? _date.default.dateToMilliseconds(aggregationInterval) : aggregationInterval;
    interval = aggregationInterval < tickInterval ? aggregationInterval : tickInterval;
  }

  interval = argumentAxis === null || argumentAxis === void 0 ? void 0 : argumentAxis.getTranslator().getInterval(interval);
  var barsArea = barGroupWidth ? interval > barGroupWidth ? barGroupWidth : interval : interval * (1 - validateBarGroupPadding(options.barGroupPadding));
  series.forEach(function (s, i) {
    var stackName = getStackName(s) || i.toString();
    var argument;

    for (argument in s.pointsByArgument) {
      if (allArguments.indexOf(argument.valueOf()) === -1) {
        allArguments.push(argument.valueOf());
      }
    }

    if (commonStacks.indexOf(stackName) === -1) {
      commonStacks.push(stackName);
      seriesInStacks[stackName] = [];
    }

    seriesInStacks[stackName].push(s);
  });
  allArguments.forEach(function (arg) {
    var currentStacks = commonStacks.reduce(function (stacks, stack) {
      if (isStackExist(seriesInStacks[stack], arg)) {
        stacks.push(stack);
      }

      return stacks;
    }, []);
    var parameters = calculateParams(barsArea, currentStacks.length);
    commonStacks.forEach(function (stack) {
      correctStackCoordinates(seriesInStacks[stack], currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback);
    });
  });
}

function calculateParams(barsArea, count, percentWidth, fixedBarWidth) {
  var spacing;
  var width;

  if (fixedBarWidth) {
    width = _min(fixedBarWidth, barsArea / count);
    spacing = count > 1 ? round((barsArea - round(width) * count) / (count - 1)) : 0;
  } else if ((0, _type.isDefined)(percentWidth)) {
    width = barsArea * percentWidth / count;
    spacing = count > 1 ? round((barsArea - barsArea * percentWidth) / (count - 1)) : 0;
  } else {
    spacing = round(barsArea / count * 0.2);
    width = (barsArea - spacing * (count - 1)) / count;
  }

  return {
    width: width > 1 ? round(width) : 1,
    spacing: spacing,
    middleIndex: count / 2,
    rawWidth: width
  };
}

function getOffset(stackIndex, parameters) {
  var width = parameters.rawWidth < 1 ? parameters.rawWidth : parameters.width;
  return (stackIndex - parameters.middleIndex + 0.5) * width - (parameters.middleIndex - stackIndex - 0.5) * parameters.spacing;
}

function correctPointCoordinates(points, width, offset) {
  (0, _iterator.each)(points, function (_, point) {
    point.correctCoordinates({
      width: width,
      offset: offset
    });
  });
}

function getValueType(value) {
  return value >= 0 ? 'positive' : 'negative';
}

function getVisibleSeries(that) {
  return that.series.filter(function (s) {
    return s.isVisible();
  });
}

function getAbsStackSumByArg(stackKeepers, stackName, argument) {
  var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;
  var negativeStackValue = -(stackKeepers.negative[stackName] || {})[argument] || 0;
  return positiveStackValue + negativeStackValue;
}

function getStackSumByArg(stackKeepers, stackName, argument) {
  var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;
  var negativeStackValue = (stackKeepers.negative[stackName] || {})[argument] || 0;
  return positiveStackValue + negativeStackValue;
}

function getSeriesStackIndexCallback(inverted) {
  if (!inverted) {
    return function (index) {
      return index;
    };
  } else {
    return function (index, stackCount) {
      return stackCount - index - 1;
    };
  }
}

function isInverted(series) {
  return series[0] && series[0].getArgumentAxis().getTranslator().isInverted();
}

function adjustBarSeriesDimensions() {
  var series = getVisibleSeries(this);
  adjustBarSeriesDimensionsCore(series, this._options, getSeriesStackIndexCallback(isInverted(series)));
}

function getFirstValueSign(series) {
  var points = series.getPoints();
  var value;

  for (var i = 0; i < points.length; i++) {
    var point = points[i];
    value = point.initialValue && point.initialValue.valueOf();

    if (abs(value) > 0) {
      break;
    }
  }

  return (0, _math.sign)(value);
}

function adjustStackedSeriesValues() {
  var that = this;
  var negativesAsZeroes = that._options.negativesAsZeroes;
  var series = getVisibleSeries(that);
  var stackKeepers = {
    positive: {},
    negative: {}
  };
  var holesStack = {
    left: {},
    right: {}
  };
  var lastSeriesInPositiveStack = {};
  var lastSeriesInNegativeStack = {};
  series.forEach(function (singleSeries) {
    var stackName = getStackName(singleSeries);
    var hole = false;
    var stack = getFirstValueSign(singleSeries) < 0 ? lastSeriesInNegativeStack : lastSeriesInPositiveStack;
    singleSeries._prevSeries = stack[stackName];
    stack[stackName] = singleSeries;
    singleSeries.holes = (0, _extend.extend)(true, {}, holesStack);
    singleSeries.getPoints().forEach(function (point, index, points) {
      var value = point.initialValue && point.initialValue.valueOf();
      var argument = point.argument.valueOf();
      var stacks = value >= 0 ? stackKeepers.positive : stackKeepers.negative;
      var isNotBarSeries = singleSeries.type !== 'bar';

      if (negativesAsZeroes && value < 0) {
        stacks = stackKeepers.positive;
        value = 0;
        point.resetValue();
      }

      stacks[stackName] = stacks[stackName] || {};
      var currentStack = stacks[stackName];

      if (currentStack[argument]) {
        if (isNotBarSeries) point.correctValue(currentStack[argument]);
        currentStack[argument] += value;
      } else {
        currentStack[argument] = value;
        if (isNotBarSeries) point.resetCorrection();
      }

      if (!point.hasValue()) {
        var prevPoint = points[index - 1];

        if (!hole && prevPoint && prevPoint.hasValue()) {
          argument = prevPoint.argument.valueOf();
          prevPoint._skipSetRightHole = true;
          holesStack.right[argument] = (holesStack.right[argument] || 0) + (prevPoint.value.valueOf() - (isFinite(prevPoint.minValue) ? prevPoint.minValue.valueOf() : 0));
        }

        hole = true;
      } else if (hole) {
        hole = false;
        holesStack.left[argument] = (holesStack.left[argument] || 0) + (point.value.valueOf() - (isFinite(point.minValue) ? point.minValue.valueOf() : 0));
        point._skipSetLeftHole = true;
      }
    });
  });
  series.forEach(function (singleSeries) {
    var holes = singleSeries.holes;
    singleSeries.getPoints().forEach(function (point) {
      var argument = point.argument.valueOf();
      point.resetHoles();
      !point._skipSetLeftHole && point.setHole(holes.left[argument] || holesStack.left[argument] && 0, 'left');
      !point._skipSetRightHole && point.setHole(holes.right[argument] || holesStack.right[argument] && 0, 'right');
      point._skipSetLeftHole = null;
      point._skipSetRightHole = null;
    });
  });
  that._stackKeepers = stackKeepers;
  series.forEach(function (singleSeries) {
    singleSeries.getPoints().forEach(function (point) {
      var argument = point.argument.valueOf();
      var stackName = getStackName(singleSeries);
      var absTotal = getAbsStackSumByArg(stackKeepers, stackName, argument);
      var total = getStackSumByArg(stackKeepers, stackName, argument);
      point.setPercentValue(absTotal, total, holesStack.left[argument], holesStack.right[argument]);
    });
  });
}

function updateStackedSeriesValues() {
  var that = this;
  var series = getVisibleSeries(that);
  var stack = that._stackKeepers;
  var stackKeepers = {
    positive: {},
    negative: {}
  };
  (0, _iterator.each)(series, function (_, singleSeries) {
    var minBarSize = singleSeries.getOptions().minBarSize;
    var valueAxisTranslator = singleSeries.getValueAxis().getTranslator();
    var minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);
    var stackName = singleSeries.getStackName();
    (0, _iterator.each)(singleSeries.getPoints(), function (index, point) {
      if (!point.hasValue()) {
        return;
      }

      var value = point.initialValue && point.initialValue.valueOf();
      var argument = point.argument.valueOf();

      if (that.fullStacked) {
        value = value / getAbsStackSumByArg(stack, stackName, argument) || 0;
      }

      var updateValue = valueAxisTranslator.checkMinBarSize(value, minShownBusinessValue, point.value);
      var valueType = getValueType(updateValue);
      var currentStack = stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};

      if (currentStack[argument]) {
        point.minValue = currentStack[argument];
        currentStack[argument] += updateValue;
      } else {
        currentStack[argument] = updateValue;
      }

      point.value = currentStack[argument];
    });
  });

  if (that.fullStacked) {
    updateFullStackedSeriesValues(series, stackKeepers);
  }
}

function updateFullStackedSeriesValues(series, stackKeepers) {
  (0, _iterator.each)(series, function (_, singleSeries) {
    var stackName = singleSeries.getStackName ? singleSeries.getStackName() : 'default';
    (0, _iterator.each)(singleSeries.getPoints(), function (index, point) {
      var stackSum = getAbsStackSumByArg(stackKeepers, stackName, point.argument.valueOf());

      if (stackSum !== 0) {
        point.value = point.value / stackSum;

        if ((0, _type.isNumeric)(point.minValue)) {
          point.minValue = point.minValue / stackSum;
        }
      }
    });
  });
}

function updateBarSeriesValues() {
  (0, _iterator.each)(this.series, function (_, singleSeries) {
    var minBarSize = singleSeries.getOptions().minBarSize;
    var valueAxisTranslator = singleSeries.getValueAxis().getTranslator();
    var minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);

    if (minShownBusinessValue) {
      (0, _iterator.each)(singleSeries.getPoints(), function (index, point) {
        if (point.hasValue()) {
          point.value = valueAxisTranslator.checkMinBarSize(point.initialValue, minShownBusinessValue);
        }
      });
    }
  });
}

function adjustCandlestickSeriesDimensions() {
  var series = getVisibleSeries(this);
  adjustBarSeriesDimensionsCore(series, {
    barGroupPadding: 0.3
  }, getSeriesStackIndexCallback(isInverted(series)));
}

function adjustBubbleSeriesDimensions() {
  var series = getVisibleSeries(this);

  if (!series.length) {
    return;
  }

  var options = this._options;
  var visibleAreaX = series[0].getArgumentAxis().getVisibleArea();
  var visibleAreaY = series[0].getValueAxis().getVisibleArea();

  var min = _min(visibleAreaX[1] - visibleAreaX[0], visibleAreaY[1] - visibleAreaY[0]);

  var minBubbleArea = pow(options.minBubbleSize, 2);
  var maxBubbleArea = pow(min * options.maxBubbleSize, 2);
  var equalBubbleSize = (min * options.maxBubbleSize + options.minBubbleSize) / 2;
  var minPointSize = Infinity;
  var maxPointSize = -Infinity;
  var pointSize;
  var bubbleArea;
  var sizeProportion;
  (0, _iterator.each)(series, function (_, seriesItem) {
    (0, _iterator.each)(seriesItem.getPoints(), function (_, point) {
      maxPointSize = maxPointSize > point.size ? maxPointSize : point.size;
      minPointSize = minPointSize < point.size ? minPointSize : point.size;
    });
  });
  var sizeDispersion = maxPointSize - minPointSize;
  var areaDispersion = abs(maxBubbleArea - minBubbleArea);
  (0, _iterator.each)(series, function (_, seriesItem) {
    (0, _iterator.each)(seriesItem.getPoints(), function (_, point) {
      if (maxPointSize === minPointSize) {
        pointSize = round(equalBubbleSize);
      } else {
        sizeProportion = abs(point.size - minPointSize) / sizeDispersion;
        bubbleArea = areaDispersion * sizeProportion + minBubbleArea;
        pointSize = round(sqrt(bubbleArea));
      }

      point.correctCoordinates(pointSize);
    });
  });
}

function SeriesFamily(options) {
  var that = this;
  that.type = (0, _utils.normalizeEnum)(options.type);
  that.pane = options.pane;
  that.series = [];
  that.updateOptions(options);

  switch (that.type) {
    case 'bar':
      that.adjustSeriesDimensions = adjustBarSeriesDimensions;
      that.updateSeriesValues = updateBarSeriesValues;
      that.adjustSeriesValues = adjustStackedSeriesValues;
      break;

    case 'rangebar':
      that.adjustSeriesDimensions = adjustBarSeriesDimensions;
      break;

    case 'fullstackedbar':
      that.fullStacked = true;
      that.adjustSeriesDimensions = adjustBarSeriesDimensions;
      that.adjustSeriesValues = adjustStackedSeriesValues;
      that.updateSeriesValues = updateStackedSeriesValues;
      break;

    case 'stackedbar':
      that.adjustSeriesDimensions = adjustBarSeriesDimensions;
      that.adjustSeriesValues = adjustStackedSeriesValues;
      that.updateSeriesValues = updateStackedSeriesValues;
      break;

    case 'fullstackedarea':
    case 'fullstackedline':
    case 'fullstackedspline':
    case 'fullstackedsplinearea':
      that.fullStacked = true;
      that.adjustSeriesValues = adjustStackedSeriesValues;
      break;

    case 'stackedarea':
    case 'stackedsplinearea':
    case 'stackedline':
    case 'stackedspline':
      that.adjustSeriesValues = adjustStackedSeriesValues;
      break;

    case 'candlestick':
    case 'stock':
      that.adjustSeriesDimensions = adjustCandlestickSeriesDimensions;
      break;

    case 'bubble':
      that.adjustSeriesDimensions = adjustBubbleSeriesDimensions;
      break;
  }
}

SeriesFamily.prototype = {
  constructor: SeriesFamily,
  adjustSeriesDimensions: _common.noop,
  adjustSeriesValues: _common.noop,
  updateSeriesValues: _common.noop,
  updateOptions: function updateOptions(options) {
    this._options = options;
  },
  dispose: function dispose() {
    this.series = null;
  },
  add: function add(series) {
    var type = this.type;
    this.series = (0, _utils.map)(series, function (singleSeries) {
      return singleSeries.type === type ? singleSeries : null;
    });
  }
};

/***/ }),
/* 600 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getMargins = getMargins;
exports.Crosshair = Crosshair;

var _utils = __webpack_require__(14);

var _extend = __webpack_require__(0);

var math = Math;
var mathAbs = math.abs;
var mathMin = math.min;
var mathMax = math.max;
var mathFloor = math.floor;
var HORIZONTAL = 'horizontal';
var VERTICAL = 'vertical';
var LABEL_BACKGROUND_PADDING_X = 8;
var LABEL_BACKGROUND_PADDING_Y = 4;
var CENTER = 'center';
var RIGHT = 'right';
var LEFT = 'left';
var TOP = 'top';
var BOTTOM = 'bottom';

function getMargins() {
  return {
    x: LABEL_BACKGROUND_PADDING_X,
    y: LABEL_BACKGROUND_PADDING_Y
  };
}

function getRectangleBBox(bBox) {
  return {
    x: bBox.x - LABEL_BACKGROUND_PADDING_X,
    y: bBox.y - LABEL_BACKGROUND_PADDING_Y,
    width: bBox.width + LABEL_BACKGROUND_PADDING_X * 2,
    height: bBox.height + LABEL_BACKGROUND_PADDING_Y * 2
  };
}

function getLabelCheckerPosition(x, y, isHorizontal, canvas) {
  var params = isHorizontal ? ['x', 'width', 'y', 'height', y, 0] : ['y', 'height', 'x', 'width', x, 1];
  return function (bBox, position, coord) {
    var labelCoord = {
      x: coord.x,
      y: coord.y
    };
    var rectangleBBox = getRectangleBBox(bBox);
    var delta = isHorizontal ? coord.y - bBox.y - bBox.height / 2 : coord.y - bBox.y;
    labelCoord.y = isHorizontal || !isHorizontal && position === BOTTOM ? coord.y + delta : coord.y;

    if (rectangleBBox[params[0]] < 0) {
      labelCoord[params[0]] -= rectangleBBox[params[0]];
    } else if (rectangleBBox[params[0]] + rectangleBBox[params[1]] + delta * params[5] > canvas[params[1]]) {
      labelCoord[params[0]] -= rectangleBBox[params[0]] + rectangleBBox[params[1]] + delta * params[5] - canvas[params[1]];
    }

    if (params[4] - rectangleBBox[params[3]] / 2 < 0) {
      labelCoord[params[2]] -= params[4] - rectangleBBox[params[3]] / 2;
    } else if (params[4] + rectangleBBox[params[3]] / 2 > canvas[params[3]]) {
      labelCoord[params[2]] -= params[4] + rectangleBBox[params[3]] / 2 - canvas[params[3]];
    }

    return labelCoord;
  };
}

function Crosshair(renderer, options, params, group) {
  var that = this;
  that._renderer = renderer;
  that._crosshairGroup = group;
  that._options = {};
  that.update(options, params);
}

Crosshair.prototype = {
  constructor: Crosshair,
  update: function update(options, params) {
    var that = this;
    var canvas = params.canvas;
    that._canvas = {
      top: canvas.top,
      bottom: canvas.height - canvas.bottom,
      left: canvas.left,
      right: canvas.width - canvas.right,
      width: canvas.width,
      height: canvas.height
    };
    that._axes = params.axes;
    that._panes = params.panes;

    that._prepareOptions(options, HORIZONTAL);

    that._prepareOptions(options, VERTICAL);
  },
  dispose: function dispose() {
    var that = this;
    that._renderer = that._crosshairGroup = that._options = that._axes = that._canvas = that._horizontalGroup = that._verticalGroup = that._horizontal = that._vertical = that._circle = that._panes = null;
  },
  _prepareOptions: function _prepareOptions(options, direction) {
    var lineOptions = options[direction + 'Line'];
    this._options[direction] = {
      visible: lineOptions.visible,
      line: {
        stroke: lineOptions.color || options.color,
        'stroke-width': lineOptions.width || options.width,
        dashStyle: lineOptions.dashStyle || options.dashStyle,
        opacity: lineOptions.opacity || options.opacity,
        'stroke-linecap': 'butt'
      },
      label: (0, _extend.extend)(true, {}, options.label, lineOptions.label)
    };
  },
  _createLines: function _createLines(options, sharpParam, group) {
    var lines = [];
    var canvas = this._canvas;
    var points = [canvas.left, canvas.top, canvas.left, canvas.top];

    for (var i = 0; i < 2; i++) {
      lines.push(this._renderer.path(points, 'line').attr(options).sharp(sharpParam).append(group));
    }

    return lines;
  },
  render: function render() {
    var that = this;
    var renderer = that._renderer;
    var options = that._options;
    var verticalOptions = options.vertical;
    var horizontalOptions = options.horizontal;
    var extraOptions = horizontalOptions.visible ? horizontalOptions.line : verticalOptions.line;
    var circleOptions = {
      stroke: extraOptions.stroke,
      'stroke-width': extraOptions['stroke-width'],
      dashStyle: extraOptions.dashStyle,
      opacity: extraOptions.opacity
    };
    var canvas = that._canvas;
    that._horizontal = {};
    that._vertical = {};
    that._circle = renderer.circle(canvas.left, canvas.top, 0).attr(circleOptions).append(that._crosshairGroup);
    that._horizontalGroup = renderer.g().append(that._crosshairGroup);
    that._verticalGroup = renderer.g().append(that._crosshairGroup);

    if (verticalOptions.visible) {
      that._vertical.lines = that._createLines(verticalOptions.line, 'h', that._verticalGroup);
      that._vertical.labels = that._createLabels(that._axes[0], verticalOptions, false, that._verticalGroup);
    }

    if (horizontalOptions.visible) {
      that._horizontal.lines = that._createLines(horizontalOptions.line, 'v', that._horizontalGroup);
      that._horizontal.labels = that._createLabels(that._axes[1], horizontalOptions, true, that._horizontalGroup);
    }

    that.hide();
  },
  _createLabels: function _createLabels(axes, options, isHorizontal, group) {
    var that = this;
    var canvas = that._canvas;
    var renderer = that._renderer;
    var x;
    var y;
    var text;
    var labels = [];
    var background;
    var currentLabelPos;
    var labelOptions = options.label;

    if (labelOptions.visible) {
      axes.forEach(function (axis) {
        var position = axis.getOptions().position;

        if (axis.getTranslator().getBusinessRange().isEmpty()) {
          return;
        }

        currentLabelPos = axis.getLabelsPosition();

        if (isHorizontal) {
          y = canvas.top;
          x = currentLabelPos;
        } else {
          x = canvas.left;
          y = currentLabelPos;
        }

        var align = position === TOP || position === BOTTOM ? CENTER : position === RIGHT ? LEFT : RIGHT;
        background = renderer.rect(0, 0, 0, 0).attr({
          fill: labelOptions.backgroundColor || options.line.stroke
        }).append(group);
        text = renderer.text('0', 0, 0).css((0, _utils.patchFontOptions)(options.label.font)).attr({
          align: align,
          'class': labelOptions.cssClass
        }).append(group);
        labels.push({
          text: text,
          background: background,
          axis: axis,
          options: labelOptions,
          pos: {
            coord: currentLabelPos,
            side: position
          },
          startXY: {
            x: x,
            y: y
          }
        });
      });
    }

    return labels;
  },
  _updateText: function _updateText(value, axisName, labels, point, func) {
    var that = this;
    labels.forEach(function (label) {
      var axis = label.axis;
      var coord = label.startXY;
      var textElement = label.text;
      var backgroundElement = label.background;
      var text = '';

      if (!axis.name || axis.name === axisName) {
        text = axis.getFormattedValue(value, label.options, point);
      }

      if (text) {
        textElement.attr({
          text: text,
          x: coord.x,
          y: coord.y
        });
        textElement.attr(func(textElement.getBBox(), label.pos.side, coord));

        that._updateLinesCanvas(label);

        backgroundElement.attr(getRectangleBBox(textElement.getBBox()));
      } else {
        textElement.attr({
          text: ''
        });
        backgroundElement.attr({
          x: 0,
          y: 0,
          width: 0,
          height: 0
        });
      }
    });
  },
  hide: function hide() {
    this._crosshairGroup.attr({
      visibility: 'hidden'
    });
  },
  _updateLinesCanvas: function _updateLinesCanvas(label) {
    var position = label.pos.side;
    var labelCoord = label.pos.coord;
    var coords = this._linesCanvas;
    var canvas = this._canvas;
    coords[position] = coords[position] !== canvas[position] && mathAbs(coords[position] - canvas[position]) < mathAbs(labelCoord - canvas[position]) ? coords[position] : labelCoord;
  },
  _updateLines: function _updateLines(lines, x, y, r, isHorizontal) {
    var coords = this._linesCanvas;
    var canvas = this._canvas;
    var points = isHorizontal ? [[mathMin(x - r, coords.left), canvas.top, x - r, canvas.top], [x + r, canvas.top, mathMax(coords.right, x + r), canvas.top]] : [[canvas.left, mathMin(coords.top, y - r), canvas.left, y - r], [canvas.left, y + r, canvas.left, mathMax(coords.bottom, y + r)]];

    for (var i = 0; i < 2; i++) {
      lines[i].attr({
        points: points[i]
      }).sharp(isHorizontal ? 'v' : 'h', isHorizontal ? y === canvas.bottom ? -1 : 1 : x === canvas.right ? -1 : 1);
    }
  },
  _resetLinesCanvas: function _resetLinesCanvas() {
    var canvas = this._canvas;
    this._linesCanvas = {
      left: canvas.left,
      right: canvas.right,
      top: canvas.top,
      bottom: canvas.bottom
    };
  },
  _getClipRectForPane: function _getClipRectForPane(x, y) {
    var panes = this._panes;
    var i;
    var coords;

    for (i = 0; i < panes.length; i++) {
      coords = panes[i].coords;

      if (coords.left <= x && coords.right >= x && coords.top <= y && coords.bottom >= y) {
        return panes[i].clipRect;
      }
    }

    return {
      id: null
    };
  },
  show: function show(data) {
    var that = this;
    var point = data.point;
    var pointData = point.getCrosshairData(data.x, data.y);
    var r = point.getPointRadius();
    var horizontal = that._horizontal;
    var vertical = that._vertical;
    var rad = !r ? 0 : r + 3;
    var canvas = that._canvas;
    var x = mathFloor(pointData.x);
    var y = mathFloor(pointData.y);

    if (x >= canvas.left && x <= canvas.right && y >= canvas.top && y <= canvas.bottom) {
      that._crosshairGroup.attr({
        visibility: 'visible'
      });

      that._resetLinesCanvas();

      that._circle.attr({
        cx: x,
        cy: y,
        r: rad,
        'clip-path': that._getClipRectForPane(x, y).id
      });

      if (horizontal.lines) {
        that._updateText(pointData.yValue, pointData.axis, horizontal.labels, point, getLabelCheckerPosition(x, y, true, canvas));

        that._updateLines(horizontal.lines, x, y, rad, true);

        that._horizontalGroup.attr({
          translateY: y - canvas.top
        });
      }

      if (vertical.lines) {
        that._updateText(pointData.xValue, pointData.axis, vertical.labels, point, getLabelCheckerPosition(x, y, false, canvas));

        that._updateLines(vertical.lines, x, y, rad, false);

        that._verticalGroup.attr({
          translateX: x - canvas.left
        });
      }
    } else {
      that.hide();
    }
  }
};

/***/ }),
/* 601 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Translator1D = Translator1D;
var _Number = Number;

function Translator1D() {
  this.setDomain(arguments[0], arguments[1]).setCodomain(arguments[2], arguments[3]).setInverted(false);
}

Translator1D.prototype = {
  constructor: Translator1D,
  setDomain: function setDomain(domain1, domain2) {
    var that = this;
    that._domain1 = _Number(domain1);
    that._domain2 = _Number(domain2);
    that._domainDelta = that._domain2 - that._domain1;
    return that;
  },
  setCodomain: function setCodomain(codomain1, codomain2) {
    var that = this;
    that._codomain1 = _Number(codomain1);
    that._codomain2 = _Number(codomain2);
    that._codomainDelta = that._codomain2 - that._codomain1;
    return that;
  },
  setInverted: function setInverted(state) {
    this.inverted = state;
  },
  getDomain: function getDomain() {
    return [this._domain1, this._domain2];
  },
  getCodomain: function getCodomain() {
    return [this._codomain1, this._codomain2];
  },
  getDomainStart: function getDomainStart() {
    return this._domain1;
  },
  getDomainEnd: function getDomainEnd() {
    return this._domain2;
  },
  getCodomainStart: function getCodomainStart() {
    return this._codomain1;
  },
  getCodomainEnd: function getCodomainEnd() {
    return this._codomain2;
  },
  getDomainRange: function getDomainRange() {
    return this._domainDelta;
  },
  getCodomainRange: function getCodomainRange() {
    return this._codomainDelta;
  },
  translate: function translate(value) {
    var ratio = (_Number(value) - this._domain1) / this._domainDelta;

    this.inverted && (ratio = 1 - ratio);
    return 0 <= ratio && ratio <= 1 ? this._codomain1 + ratio * this._codomainDelta : NaN;
  },
  adjust: function adjust(value) {
    var ratio = (_Number(value) - this._domain1) / this._domainDelta;

    var result = NaN;

    if (ratio < 0) {
      result = this._domain1;
    } else if (ratio > 1) {
      result = this._domain2;
    } else if (0 <= ratio && ratio <= 1) {
      result = _Number(value);
    }

    return result;
  }
};

/***/ }),
/* 602 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.createIndicatorCreator = createIndicatorCreator;
exports.dxGauge = void 0;

var _base_gauge = __webpack_require__(210);

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

var _extend2 = __webpack_require__(0);

var _base_axis = __webpack_require__(349);

var _utils = __webpack_require__(14);

var _common = __webpack_require__(4);

var _isArray = Array.isArray;
var _isFinite = isFinite;
var _Number = Number;
var _min = Math.min;
var _max = Math.max;
var _extend = _extend2.extend;
var _each = _iterator.each;
var SHIFT_ANGLE = 90;
var OPTION_VALUE = 'value';
var OPTION_SUBVALUES = 'subvalues';
var DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 5;
var DEFAULT_NUMBER_MULTIPLIERS = [1, 2, 5];

function processValue(value, fallbackValue) {
  if (value === null) {
    return value;
  }

  return _isFinite(value) ? _Number(value) : fallbackValue;
}

function parseArrayOfNumbers(arg) {
  return _isArray(arg) ? arg : (0, _type.isNumeric)(arg) ? [arg] : null;
}

var dxGauge = _base_gauge.BaseGauge.inherit({
  _initCore: function _initCore() {
    var that = this;
    var renderer = that._renderer;

    that._setupValue(that.option(OPTION_VALUE));

    that.__subvalues = parseArrayOfNumbers(that.option(OPTION_SUBVALUES));

    that._setupSubvalues(that.__subvalues);

    selectMode(that);
    that.callBase.apply(that, arguments);
    that._rangeContainer = new that._factory.RangeContainer({
      renderer: renderer,
      container: renderer.root,
      translator: that._translator,
      themeManager: that._themeManager
    });

    that._initScale();

    that._subvalueIndicatorContainer = that._renderer.g().attr({
      class: 'dxg-subvalue-indicators'
    }).linkOn(that._renderer.root, 'valueIndicator').enableLinks();
  },
  _fontFields: ['scale.label.font', 'valueIndicators.rangebar.text.font', 'valueIndicators.textcloud.text.font', 'indicator.text.font'],
  _initScale: function _initScale() {
    var that = this;
    that._scaleGroup = that._renderer.g().attr({
      'class': 'dxg-scale'
    }).linkOn(that._renderer.root, 'scale');
    that._labelsAxesGroup = that._renderer.g().attr({
      'class': 'dxg-scale-elements'
    }).linkOn(that._renderer.root, 'scale-elements');
    that._scale = new _base_axis.Axis({
      incidentOccurred: that._incidentOccurred,
      renderer: that._renderer,
      axesContainerGroup: that._scaleGroup,
      labelsAxesGroup: that._labelsAxesGroup,
      axisType: that._scaleTypes.type,
      drawingType: that._scaleTypes.drawingType,
      widgetClass: 'dxg',
      getTemplate: function getTemplate() {}
    });
  },
  _disposeCore: function _disposeCore() {
    var that = this;
    that.callBase.apply(that, arguments);

    that._scale.dispose();

    that._scaleGroup.linkOff();

    that._labelsAxesGroup.linkOff();

    that._rangeContainer.dispose();

    that._disposeValueIndicators();

    that._subvalueIndicatorContainer.linkOff();

    that._scale = that._scaleGroup = that._labelsAxesGroup = that._rangeContainer = null;
  },
  _disposeValueIndicators: function _disposeValueIndicators() {
    var that = this;
    that._valueIndicator && that._valueIndicator.dispose();
    that._subvalueIndicatorsSet && that._subvalueIndicatorsSet.dispose();
    that._valueIndicator = that._subvalueIndicatorsSet = null;
  },
  _setupDomainCore: function _setupDomainCore() {
    var that = this;
    var scaleOption = that.option('scale') || {};
    var startValue = that.option('startValue');
    var endValue = that.option('endValue');
    startValue = (0, _type.isNumeric)(startValue) ? _Number(startValue) : (0, _type.isNumeric)(scaleOption.startValue) ? _Number(scaleOption.startValue) : 0;
    endValue = (0, _type.isNumeric)(endValue) ? _Number(endValue) : (0, _type.isNumeric)(scaleOption.endValue) ? _Number(scaleOption.endValue) : 100;
    that._baseValue = startValue < endValue ? startValue : endValue;

    that._translator.setDomain(startValue, endValue);
  },
  _cleanContent: function _cleanContent() {
    var that = this;

    that._rangeContainer.clean();

    that._cleanValueIndicators();
  },
  _measureScale: function _measureScale(scaleOptions) {
    var that = this;
    var majorTick = scaleOptions.tick;
    var majorTickEnabled = majorTick.visible && majorTick.length > 0 && majorTick.width > 0;
    var minorTick = scaleOptions.minorTick;
    var minorTickEnabled = minorTick.visible && minorTick.length > 0 && minorTick.width > 0;
    var label = scaleOptions.label;
    var indentFromTick = Number(label.indentFromTick);

    if (!majorTickEnabled && !minorTickEnabled && !label.visible) {
      return {};
    }

    var textParams = that._scale.measureLabels((0, _extend2.extend)({}, that._canvas));

    var layoutValue = that._getScaleLayoutValue();

    var result = {
      min: layoutValue,
      max: layoutValue
    };

    var coefs = that._getTicksCoefficients(scaleOptions);

    var innerCoef = coefs.inner;
    var outerCoef = coefs.outer;

    if (majorTickEnabled) {
      result.min = _min(result.min, layoutValue - innerCoef * majorTick.length);
      result.max = _max(result.max, layoutValue + outerCoef * majorTick.length);
    }

    if (minorTickEnabled) {
      result.min = _min(result.min, layoutValue - innerCoef * minorTick.length);
      result.max = _max(result.max, layoutValue + outerCoef * minorTick.length);
    }

    label.visible && that._correctScaleIndents(result, indentFromTick, textParams);
    return result;
  },
  _renderContent: function _renderContent() {
    var that = this;

    var scaleOptions = that._prepareScaleSettings();

    that._rangeContainer.render(_extend(that._getOption('rangeContainer'), {
      vertical: that._area.vertical
    }));

    that._renderScale(scaleOptions);

    that._subvalueIndicatorContainer.linkAppend();

    var elements = (0, _utils.map)([that._rangeContainer].concat(that._prepareValueIndicators()), function (element) {
      return element && element.enabled ? element : null;
    });

    that._applyMainLayout(elements, that._measureScale(scaleOptions));

    _each(elements, function (_, element) {
      element.resize(that._getElementLayout(element.getOffset()));
    });

    that._shiftScale(that._getElementLayout(0), scaleOptions);

    that._beginValueChanging();

    that._updateActiveElements();

    that._endValueChanging();
  },
  _prepareScaleSettings: function _prepareScaleSettings() {
    var that = this;
    var userOptions = that.option('scale');
    var scaleOptions = (0, _extend2.extend)(true, {}, that._themeManager.theme('scale'), userOptions);
    scaleOptions.label.indentFromAxis = 0;
    scaleOptions.isHorizontal = !that._area.vertical;
    scaleOptions.forceUserTickInterval |= (0, _type.isDefined)(userOptions) && (0, _type.isDefined)(userOptions.tickInterval) && !(0, _type.isDefined)(userOptions.scaleDivisionFactor);
    scaleOptions.axisDivisionFactor = scaleOptions.scaleDivisionFactor || that._gridSpacingFactor;
    scaleOptions.minorAxisDivisionFactor = scaleOptions.minorScaleDivisionFactor || DEFAULT_MINOR_AXIS_DIVISION_FACTOR;
    scaleOptions.numberMultipliers = DEFAULT_NUMBER_MULTIPLIERS;
    scaleOptions.tickOrientation = that._getTicksOrientation(scaleOptions);

    if (scaleOptions.label.useRangeColors) {
      scaleOptions.label.customizeColor = function () {
        return that._rangeContainer.getColorForValue(this.value);
      };
    }

    return scaleOptions;
  },
  _renderScale: function _renderScale(scaleOptions) {
    var that = this;

    var bounds = that._translator.getDomain();

    var startValue = bounds[0];
    var endValue = bounds[1];

    var angles = that._translator.getCodomain();

    var invert = !!(startValue > endValue ^ scaleOptions.inverted);

    var min = _min(startValue, endValue);

    var max = _max(startValue, endValue);

    scaleOptions.min = min;
    scaleOptions.max = max;
    scaleOptions.startAngle = SHIFT_ANGLE - angles[0];
    scaleOptions.endAngle = SHIFT_ANGLE - angles[1];
    scaleOptions.skipViewportExtending = true;
    scaleOptions.inverted = invert;

    that._scale.updateOptions(scaleOptions);

    that._scale.setBusinessRange({
      axisType: 'continuous',
      dataType: 'numeric',
      min: min,
      max: max,
      invert: invert
    });

    that._updateScaleTickIndent(scaleOptions);

    that._scaleGroup.linkAppend();

    that._labelsAxesGroup.linkAppend();

    that._scale.draw((0, _extend2.extend)({}, that._canvas));
  },
  _updateIndicatorSettings: function _updateIndicatorSettings(settings) {
    var that = this;
    settings.currentValue = settings.baseValue = _isFinite(that._translator.translate(settings.baseValue)) ? _Number(settings.baseValue) : that._baseValue;
    settings.vertical = that._area.vertical;

    if (settings.text && !settings.text.format) {
      settings.text.format = that._defaultFormatOptions;
    }
  },
  _prepareIndicatorSettings: function _prepareIndicatorSettings(options, defaultTypeField) {
    var that = this;

    var theme = that._themeManager.theme('valueIndicators');

    var type = (0, _utils.normalizeEnum)(options.type || that._themeManager.theme(defaultTypeField));

    var settings = _extend(true, {}, theme._default, theme[type], options);

    settings.type = type;
    settings.animation = that._animationSettings;
    settings.containerBackgroundColor = that._containerBackgroundColor;

    that._updateIndicatorSettings(settings);

    return settings;
  },
  _cleanValueIndicators: function _cleanValueIndicators() {
    this._valueIndicator && this._valueIndicator.clean();
    this._subvalueIndicatorsSet && this._subvalueIndicatorsSet.clean();
  },
  _prepareValueIndicators: function _prepareValueIndicators() {
    var that = this;

    that._prepareValueIndicator();

    that.__subvalues !== null && that._prepareSubvalueIndicators();
    return [that._valueIndicator, that._subvalueIndicatorsSet];
  },
  _updateActiveElements: function _updateActiveElements() {
    this._updateValueIndicator();

    this._updateSubvalueIndicators();
  },
  _prepareValueIndicator: function _prepareValueIndicator() {
    var that = this;
    var target = that._valueIndicator;

    var settings = that._prepareIndicatorSettings(that.option('valueIndicator') || {}, 'valueIndicatorType');

    if (target && target.type !== settings.type) {
      target.dispose();
      target = null;
    }

    if (!target) {
      target = that._valueIndicator = that._createIndicator(settings.type, that._renderer.root, 'dxg-value-indicator', 'value-indicator');
    }

    target.render(settings);
  },
  _createSubvalueIndicatorsSet: function _createSubvalueIndicatorsSet() {
    var that = this;
    var root = that._subvalueIndicatorContainer;
    return new ValueIndicatorsSet({
      createIndicator: function createIndicator(type, i) {
        return that._createIndicator(type, root, 'dxg-subvalue-indicator', 'subvalue-indicator', i);
      },
      createPalette: function createPalette(palette) {
        return that._themeManager.createPalette(palette);
      }
    });
  },
  _prepareSubvalueIndicators: function _prepareSubvalueIndicators() {
    var that = this;
    var target = that._subvalueIndicatorsSet;

    var settings = that._prepareIndicatorSettings(that.option('subvalueIndicator') || {}, 'subvalueIndicatorType');

    if (!target) {
      target = that._subvalueIndicatorsSet = that._createSubvalueIndicatorsSet();
    }

    var isRecreate = settings.type !== target.type;
    target.type = settings.type;

    var dummy = that._createIndicator(settings.type, that._renderer.root);

    if (dummy) {
      dummy.dispose();
      target.render(settings, isRecreate);
    }
  },
  _setupValue: function _setupValue(value) {
    this.__value = processValue(value, this.__value);
  },
  _setupSubvalues: function _setupSubvalues(subvalues) {
    var vals = subvalues === undefined ? this.__subvalues : parseArrayOfNumbers(subvalues);
    var i;
    var ii;
    var list;
    if (vals === null) return;

    for (i = 0, ii = vals.length, list = []; i < ii; ++i) {
      list.push(processValue(vals[i], this.__subvalues[i]));
    }

    this.__subvalues = list;
  },
  _updateValueIndicator: function _updateValueIndicator() {
    var that = this;
    that._valueIndicator && that._valueIndicator.value(that.__value, that._noAnimation);
  },
  _updateSubvalueIndicators: function _updateSubvalueIndicators() {
    var that = this;
    that._subvalueIndicatorsSet && that._subvalueIndicatorsSet.values(that.__subvalues, that._noAnimation);
  },
  value: function value(arg) {
    if (arg !== undefined) {
      this._changeValue(arg);

      return this;
    }

    return this.__value;
  },
  subvalues: function subvalues(arg) {
    if (arg !== undefined) {
      this._changeSubvalues(arg);

      return this;
    }

    return this.__subvalues !== null ? this.__subvalues.slice() : undefined;
  },
  _changeValue: function _changeValue(value) {
    var that = this;

    that._setupValue(value);

    that._beginValueChanging();

    that._updateValueIndicator();

    if (that.__value !== that.option(OPTION_VALUE)) {
      that.option(OPTION_VALUE, that.__value);
    }

    that._endValueChanging();
  },
  _changeSubvalues: function _changeSubvalues(subvalues) {
    var that = this;

    if (that.__subvalues !== null) {
      that._setupSubvalues(subvalues);

      that._beginValueChanging();

      that._updateSubvalueIndicators();

      that._endValueChanging();
    } else {
      that.__subvalues = parseArrayOfNumbers(subvalues);

      that._setContentSize();

      that._renderContent();
    }

    if (!(0, _base_gauge.compareArrays)(that.__subvalues, that.option(OPTION_SUBVALUES))) {
      that.option(OPTION_SUBVALUES, that.__subvalues);
    }
  },
  _optionChangesMap: {
    scale: 'DOMAIN',
    rangeContainer: 'MOSTLY_TOTAL',
    valueIndicator: 'MOSTLY_TOTAL',
    subvalueIndicator: 'MOSTLY_TOTAL',
    containerBackgroundColor: 'MOSTLY_TOTAL',
    value: 'VALUE',
    subvalues: 'SUBVALUES',
    valueIndicators: 'MOSTLY_TOTAL'
  },
  _customChangesOrder: ['VALUE', 'SUBVALUES'],
  _change_VALUE: function _change_VALUE() {
    this._changeValue(this.option(OPTION_VALUE));
  },
  _change_SUBVALUES: function _change_SUBVALUES() {
    this._changeSubvalues(this.option(OPTION_SUBVALUES));
  },
  _applyMainLayout: null,
  _getElementLayout: null,
  _createIndicator: function _createIndicator(type, owner, className, trackerType, trackerIndex, _strict) {
    var that = this;

    var indicator = that._factory.createIndicator({
      renderer: that._renderer,
      translator: that._translator,
      owner: owner,
      tracker: that._tracker,
      className: className
    }, type, _strict);

    if (indicator) {
      indicator.type = type;
      indicator._trackerInfo = {
        type: trackerType,
        index: trackerIndex
      };
    }

    return indicator;
  },
  _getApproximateScreenRange: null
});

exports.dxGauge = dxGauge;

function valueGetter(arg) {
  return arg ? arg.value : null;
}

function setupValues(that, fieldName, optionItems) {
  var currentValues = that[fieldName];
  var newValues = _isArray(optionItems) ? (0, _utils.map)(optionItems, valueGetter) : [];
  var i = 0;
  var ii = newValues.length;
  var list = [];

  for (; i < ii; ++i) {
    list.push(processValue(newValues[i], currentValues[i]));
  }

  that[fieldName] = list;
}

function selectMode(gauge) {
  if (gauge.option(OPTION_VALUE) === undefined && gauge.option(OPTION_SUBVALUES) === undefined) {
    if (gauge.option('valueIndicators') !== undefined) {
      disableDefaultMode(gauge);
      selectHardMode(gauge);
    }
  }
}

function disableDefaultMode(that) {
  that.value = that.subvalues = _common.noop;
  that._setupValue = that._setupSubvalues = that._updateValueIndicator = that._updateSubvalueIndicators = null;
}

function selectHardMode(that) {
  that._indicatorValues = [];
  setupValues(that, '_indicatorValues', that.option('valueIndicators'));
  that._valueIndicators = [];
  var _applyMostlyTotalChange = that._applyMostlyTotalChange;

  that._applyMostlyTotalChange = function () {
    setupValues(this, '_indicatorValues', this.option('valueIndicators'));

    _applyMostlyTotalChange.call(this);
  };

  that._updateActiveElements = updateActiveElements_hardMode;
  that._prepareValueIndicators = prepareValueIndicators_hardMode;
  that._disposeValueIndicators = disposeValueIndicators_hardMode;
  that._cleanValueIndicators = cleanValueIndicators_hardMode;
  that.indicatorValue = indicatorValue_hardMode;
}

function updateActiveElements_hardMode() {
  var that = this;

  _each(that._valueIndicators, function (_, valueIndicator) {
    valueIndicator.value(that._indicatorValues[valueIndicator.index], that._noAnimation);
  });
}

function prepareValueIndicators_hardMode() {
  var that = this;
  var valueIndicators = that._valueIndicators || [];
  var userOptions = that.option('valueIndicators');
  var optionList = [];
  var i = 0;
  var ii;

  for (ii = _isArray(userOptions) ? userOptions.length : 0; i < ii; ++i) {
    optionList.push(userOptions[i]);
  }

  for (ii = valueIndicators.length; i < ii; ++i) {
    optionList.push(null);
  }

  var newValueIndicators = [];

  _each(optionList, function (i, userSettings) {
    var valueIndicator = valueIndicators[i];

    if (!userSettings) {
      valueIndicator && valueIndicator.dispose();
      return;
    }

    var settings = that._prepareIndicatorSettings(userSettings, 'valueIndicatorType');

    if (valueIndicator && valueIndicator.type !== settings.type) {
      valueIndicator.dispose();
      valueIndicator = null;
    }

    if (!valueIndicator) {
      valueIndicator = that._createIndicator(settings.type, that._renderer.root, 'dxg-value-indicator', 'value-indicator', i, true);
    }

    if (valueIndicator) {
      valueIndicator.index = i;
      valueIndicator.render(settings);
      newValueIndicators.push(valueIndicator);
    }
  });

  that._valueIndicators = newValueIndicators;
  return that._valueIndicators;
}

function disposeValueIndicators_hardMode() {
  _each(this._valueIndicators, function (_, valueIndicator) {
    valueIndicator.dispose();
  });

  this._valueIndicators = null;
}

function cleanValueIndicators_hardMode() {
  _each(this._valueIndicators, function (_, valueIndicator) {
    valueIndicator.clean();
  });
}

function indicatorValue_hardMode(index, value) {
  return accessPointerValue(this, this._valueIndicators, this._indicatorValues, index, value);
}

function accessPointerValue(that, pointers, values, index, value) {
  if (value !== undefined) {
    if (values[index] !== undefined) {
      values[index] = processValue(value, values[index]);
      pointers[index] && pointers[index].value(values[index]);
    }

    return that;
  } else {
    return values[index];
  }
}

function ValueIndicatorsSet(parameters) {
  this._parameters = parameters;
  this._indicators = [];
}

ValueIndicatorsSet.prototype = {
  constructor: ValueIndicatorsSet,
  dispose: function dispose() {
    var that = this;

    _each(that._indicators, function (_, indicator) {
      indicator.dispose();
    });

    that._parameters = that._options = that._indicators = that._colorPalette = that._palette = null;
    return that;
  },
  clean: function clean() {
    var that = this;
    that._sample && that._sample.clean().dispose();

    _each(that._indicators, function (_, indicator) {
      indicator.clean();
    });

    that._sample = that._options = that._palette = null;
    return that;
  },
  render: function render(options, isRecreate) {
    var that = this;
    that._options = options;
    that._sample = that._parameters.createIndicator(that.type);

    that._sample.render(options);

    that.enabled = that._sample.enabled;
    that._palette = (0, _type.isDefined)(options.palette) ? that._parameters.createPalette(options.palette) : null;

    if (that.enabled) {
      that._generatePalette(that._indicators.length);

      that._indicators = (0, _utils.map)(that._indicators, function (indicator, i) {
        if (isRecreate) {
          indicator.dispose();
          indicator = that._parameters.createIndicator(that.type, i);
        }

        indicator.render(that._getIndicatorOptions(i));
        return indicator;
      });
    }

    return that;
  },
  getOffset: function getOffset() {
    return this._sample.getOffset();
  },
  resize: function resize(layout) {
    var that = this;
    that._layout = layout;

    _each(that._indicators, function (_, indicator) {
      indicator.resize(layout);
    });

    return that;
  },
  measure: function measure(layout) {
    return this._sample.measure(layout);
  },
  _getIndicatorOptions: function _getIndicatorOptions(index) {
    var result = this._options;

    if (this._colorPalette) {
      result = _extend({}, result, {
        color: this._colorPalette[index]
      });
    }

    return result;
  },
  _generatePalette: function _generatePalette(count) {
    var that = this;
    var colors = null;

    if (that._palette) {
      that._palette.reset();

      colors = that._palette.generateColors(count, {
        repeat: true
      });
    }

    that._colorPalette = colors;
  },
  _adjustIndicatorsCount: function _adjustIndicatorsCount(count) {
    var that = this;
    var indicators = that._indicators;
    var i;
    var ii;
    var indicator;
    var indicatorsLen = indicators.length;

    if (indicatorsLen > count) {
      for (i = count, ii = indicatorsLen; i < ii; ++i) {
        indicators[i].clean().dispose();
      }

      that._indicators = indicators.slice(0, count);

      that._generatePalette(indicators.length);
    } else if (indicatorsLen < count) {
      that._generatePalette(count);

      for (i = indicatorsLen, ii = count; i < ii; ++i) {
        indicator = that._parameters.createIndicator(that.type, i);
        indicator.render(that._getIndicatorOptions(i)).resize(that._layout);
        indicators.push(indicator);
      }
    }
  },
  values: function values(arg, _noAnimation) {
    var that = this;
    if (!that.enabled) return;

    if (arg !== undefined) {
      if (!_isArray(arg)) {
        arg = _isFinite(arg) ? [Number(arg)] : null;
      }

      if (arg) {
        that._adjustIndicatorsCount(arg.length);

        _each(that._indicators, function (i, indicator) {
          indicator.value(arg[i], _noAnimation);
        });
      }

      return that;
    }

    return (0, _utils.map)(that._indicators, function (indicator) {
      return indicator.value();
    });
  }
};

function createIndicatorCreator(indicators) {
  return function (parameters, type, _strict) {
    var indicatorType = indicators[(0, _utils.normalizeEnum)(type)] || !_strict && indicators._default;

    return indicatorType ? new indicatorType(parameters) : null;
  };
}

/***/ }),
/* 603 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _iterator = __webpack_require__(3);

var _base_indicators = __webpack_require__(351);

var _type = __webpack_require__(1);

var _Number = Number;
var _isArray = Array.isArray;
var _isFinite = isFinite;

var BaseRangeContainer = _base_indicators.BaseElement.inherit({
  _init: function _init() {
    this._root = this._renderer.g().attr({
      'class': 'dxg-range-container'
    }).linkOn(this._container, 'range-container');
  },
  _dispose: function _dispose() {
    this._root.linkOff();
  },
  clean: function clean() {
    this._root.linkRemove().clear();

    this._options = this.enabled = null;
    return this;
  },
  _getRanges: function _getRanges() {
    var that = this;
    var options = that._options;
    var translator = that._translator;
    var totalStart = translator.getDomain()[0];
    var totalEnd = translator.getDomain()[1];
    var totalDelta = totalEnd - totalStart;
    var isValidSegment = totalDelta >= 0 ? isValidSegmentAsc : isValidSegmentDesc;
    var subtractSegment = totalDelta >= 0 ? subtractSegmentAsc : subtractSegmentDesc;
    var list = [];
    var ranges = [];
    var backgroundRanges = [{
      start: totalStart,
      end: totalEnd
    }];
    var backgroundColor = (0, _type.isString)(options.backgroundColor) ? options.backgroundColor : 'none';
    var width = options.width || {};

    var startWidth = _Number(width > 0 ? width : width.start);

    var endWidth = _Number(width > 0 ? width : width.end);

    var deltaWidth = endWidth - startWidth;

    if (options.ranges !== undefined && !_isArray(options.ranges)) {
      return null;
    }

    if (!(startWidth >= 0 && endWidth >= 0 && startWidth + endWidth > 0)) {
      return null;
    }

    list = (_isArray(options.ranges) ? options.ranges : []).reduce(function (result, rangeOptions, i) {
      rangeOptions = rangeOptions || {};
      var start = translator.adjust(rangeOptions.startValue);
      var end = translator.adjust(rangeOptions.endValue);

      if (_isFinite(start) && _isFinite(end) && isValidSegment(start, end, rangeOptions)) {
        result.push({
          start: start,
          end: end,
          color: rangeOptions.color,
          classIndex: i
        });
      }

      return result;
    }, []);

    var palette = that._themeManager.createPalette(options.palette, {
      type: 'indicatingSet',
      extensionMode: options.paletteExtensionMode,
      keepLastColorInEnd: true,
      count: list.length
    });

    (0, _iterator.each)(list, function (_, item) {
      var paletteColor = palette.getNextColor();
      item.color = (0, _type.isString)(item.color) && item.color || paletteColor || 'none';
      item.className = 'dxg-range dxg-range-' + item.classIndex;
      delete item.classIndex;
    });
    (0, _iterator.each)(list, function (_, item) {
      var i;
      var ii;
      var sub;
      var subs;
      var range;
      var newRanges = [];
      var newBackgroundRanges = [];

      for (i = 0, ii = ranges.length; i < ii; ++i) {
        range = ranges[i];
        subs = subtractSegment(range.start, range.end, item.start, item.end);
        (sub = subs[0]) && (sub.color = range.color) && (sub.className = range.className) && newRanges.push(sub);
        (sub = subs[1]) && (sub.color = range.color) && (sub.className = range.className) && newRanges.push(sub);
      }

      newRanges.push(item);
      ranges = newRanges;

      for (i = 0, ii = backgroundRanges.length; i < ii; ++i) {
        range = backgroundRanges[i];
        subs = subtractSegment(range.start, range.end, item.start, item.end);
        (sub = subs[0]) && newBackgroundRanges.push(sub);
        (sub = subs[1]) && newBackgroundRanges.push(sub);
      }

      backgroundRanges = newBackgroundRanges;
    });
    (0, _iterator.each)(backgroundRanges, function (_, range) {
      range.color = backgroundColor;
      range.className = 'dxg-range dxg-background-range';
      ranges.push(range);
    });
    (0, _iterator.each)(ranges, function (_, range) {
      range.startWidth = (range.start - totalStart) / totalDelta * deltaWidth + startWidth;
      range.endWidth = (range.end - totalStart) / totalDelta * deltaWidth + startWidth;
    });
    return ranges;
  },
  render: function render(options) {
    var that = this;
    that._options = options;

    that._processOptions();

    that._ranges = that._getRanges();

    if (that._ranges) {
      that.enabled = true;

      that._root.linkAppend();
    }

    return that;
  },
  resize: function resize(layout) {
    var that = this;

    that._root.clear();

    if (that._isVisible(layout)) {
      (0, _iterator.each)(that._ranges, function (_, range) {
        that._createRange(range, layout).attr({
          fill: range.color,
          'class': range.className
        }).append(that._root);
      });
    }

    return that;
  },
  _processOptions: null,
  _isVisible: null,
  _createRange: null,
  // S170193
  getColorForValue: function getColorForValue(value) {
    var color = null;
    (0, _iterator.each)(this._ranges, function (_, range) {
      if (range.start <= value && value <= range.end || range.start >= value && value >= range.end) {
        color = range.color;
        return false;
      }
    });
    return color;
  }
});

function subtractSegmentAsc(segmentStart, segmentEnd, otherStart, otherEnd) {
  var result;

  if (otherStart > segmentStart && otherEnd < segmentEnd) {
    result = [{
      start: segmentStart,
      end: otherStart
    }, {
      start: otherEnd,
      end: segmentEnd
    }];
  } else if (otherStart >= segmentEnd || otherEnd <= segmentStart) {
    result = [{
      start: segmentStart,
      end: segmentEnd
    }];
  } else if (otherStart <= segmentStart && otherEnd >= segmentEnd) {
    result = [];
  } else if (otherStart > segmentStart) {
    result = [{
      start: segmentStart,
      end: otherStart
    }];
  } else if (otherEnd < segmentEnd) {
    result = [{
      start: otherEnd,
      end: segmentEnd
    }];
  }

  return result;
}

function subtractSegmentDesc(segmentStart, segmentEnd, otherStart, otherEnd) {
  var result;

  if (otherStart < segmentStart && otherEnd > segmentEnd) {
    result = [{
      start: segmentStart,
      end: otherStart
    }, {
      start: otherEnd,
      end: segmentEnd
    }];
  } else if (otherStart <= segmentEnd || otherEnd >= segmentStart) {
    result = [{
      start: segmentStart,
      end: segmentEnd
    }];
  } else if (otherStart >= segmentStart && otherEnd <= segmentEnd) {
    result = [];
  } else if (otherStart < segmentStart) {
    result = [{
      start: segmentStart,
      end: otherStart
    }];
  } else if (otherEnd > segmentEnd) {
    result = [{
      start: otherEnd,
      end: segmentEnd
    }];
  }

  return result;
}

function areEqualValues(start, end, _ref) {
  var startValue = _ref.startValue,
      endValue = _ref.endValue;
  return endValue === startValue && startValue === start && end === start;
}

function isValidSegmentAsc(start, end, options) {
  return end - start > 0 || areEqualValues(start, end, options);
}

function isValidSegmentDesc(start, end, options) {
  return start - end > 0 || areEqualValues(start, end, options);
}

var _default = BaseRangeContainer;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 604 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.default = void 0;

var _component_registrator = _interopRequireDefault(__webpack_require__(9));

var _object = __webpack_require__(52);

var _extend = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _base_gauge = __webpack_require__(210);

var _common = __webpack_require__(602);

var _utils = __webpack_require__(14);

var circularIndicators = _interopRequireWildcard(__webpack_require__(1076));

var _circular_range_container = _interopRequireDefault(__webpack_require__(1077));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _isFinite = isFinite;
var _normalizeAngle = _utils.normalizeAngle;
var _getCosAndSin = _utils.getCosAndSin;
var _abs = Math.abs;
var _max = Math.max;
var _min = Math.min;
var _round = Math.round;
var _each = _iterator.each;
var PI = Math.PI;

function getSides(startAngle, endAngle) {
  var startCosSin = _getCosAndSin(startAngle);

  var endCosSin = _getCosAndSin(endAngle);

  var startCos = startCosSin.cos;
  var startSin = startCosSin.sin;
  var endCos = endCosSin.cos;
  var endSin = endCosSin.sin;
  return {
    left: startSin <= 0 && endSin >= 0 || startSin <= 0 && endSin <= 0 && startCos <= endCos || startSin >= 0 && endSin >= 0 && startCos >= endCos ? -1 : _min(startCos, endCos, 0),
    right: startSin >= 0 && endSin <= 0 || startSin >= 0 && endSin >= 0 && startCos >= endCos || startSin <= 0 && endSin <= 0 && startCos <= endCos ? 1 : _max(startCos, endCos, 0),
    up: startCos <= 0 && endCos >= 0 || startCos <= 0 && endCos <= 0 && startSin >= endSin || startCos >= 0 && endCos >= 0 && startSin <= endSin ? -1 : -_max(startSin, endSin, 0),
    down: startCos >= 0 && endCos <= 0 || startCos >= 0 && endCos >= 0 && startSin <= endSin || startCos <= 0 && endCos <= 0 && startSin >= endSin ? 1 : -_min(startSin, endSin, 0)
  };
}

var dxCircularGauge = _common.dxGauge.inherit({
  _rootClass: 'dxg-circular-gauge',
  _factoryMethods: {
    rangeContainer: 'createCircularRangeContainer',
    indicator: 'createCircularIndicator'
  },
  _gridSpacingFactor: 17,
  _scaleTypes: {
    type: 'polarAxes',
    drawingType: 'circular'
  },
  _getThemeManagerOptions: function _getThemeManagerOptions() {
    var options = this.callBase.apply(this, arguments);
    options.subTheme = '_circular';
    return options;
  },
  _updateScaleTickIndent: function _updateScaleTickIndent(scaleOptions) {
    var indentFromTick = scaleOptions.label.indentFromTick;
    var length = scaleOptions.tick.visible ? scaleOptions.tick.length : 0;

    var textParams = this._scale.measureLabels((0, _extend.extend)({}, this._canvas));

    var tickCorrection = length;

    if (scaleOptions.orientation === 'inside') {
      tickCorrection = 0;
    } else if (scaleOptions.orientation === 'center') {
      tickCorrection = 0.5 * length;
    }

    scaleOptions.label.indentFromAxis = indentFromTick >= 0 ? indentFromTick + tickCorrection : indentFromTick - tickCorrection - _max(textParams.width, textParams.height);

    this._scale.updateOptions(scaleOptions);
  },
  _setupCodomain: function _setupCodomain() {
    var that = this;
    var geometry = that.option('geometry') || {};
    var startAngle = geometry.startAngle;
    var endAngle = geometry.endAngle;
    var sides;
    startAngle = _isFinite(startAngle) ? _normalizeAngle(startAngle) : 225;
    endAngle = _isFinite(endAngle) ? _normalizeAngle(endAngle) : -45;

    if (_abs(startAngle - endAngle) < 1) {
      endAngle -= 360;
      sides = {
        left: -1,
        up: -1,
        right: 1,
        down: 1
      };
    } else {
      startAngle < endAngle && (endAngle -= 360);
      sides = getSides(startAngle, endAngle);
    }

    that._area = {
      x: 0,
      y: 0,
      radius: 100,
      startCoord: startAngle,
      endCoord: endAngle,
      sides: sides
    };

    that._translator.setCodomain(startAngle, endAngle);
  },
  _shiftScale: function _shiftScale(layout) {
    var scale = this._scale;
    var canvas = scale.getCanvas();
    canvas.width = canvas.height = layout.radius * 2;
    scale.draw(canvas);
    var centerCoords = scale.getCenter();
    scale.shift({
      right: layout.x - centerCoords.x,
      bottom: layout.y - centerCoords.y
    });
  },
  _getScaleLayoutValue: function _getScaleLayoutValue() {
    return this._area.radius;
  },
  _getTicksOrientation: function _getTicksOrientation(scaleOptions) {
    return scaleOptions.orientation;
  },
  _getTicksCoefficients: function _getTicksCoefficients(options) {
    var coefs = {
      inner: 0,
      outer: 1
    };

    if (options.orientation === 'inside') {
      coefs.inner = 1;
      coefs.outer = 0;
    } else if (options.orientation === 'center') {
      coefs.inner = coefs.outer = 0.5;
    }

    return coefs;
  },
  _correctScaleIndents: function _correctScaleIndents(result, indentFromTick, textParams) {
    if (indentFromTick >= 0) {
      result.horizontalOffset = indentFromTick + textParams.width;
      result.verticalOffset = indentFromTick + textParams.height;
    } else {
      result.horizontalOffset = result.verticalOffset = 0;
      result.min -= -indentFromTick + _max(textParams.width, textParams.height);
    }

    result.inverseHorizontalOffset = textParams.width / 2;
    result.inverseVerticalOffset = textParams.height / 2;
  },
  _measureMainElements: function _measureMainElements(elements, scaleMeasurement) {
    var that = this;
    var radius = that._area.radius;
    var maxRadius = 0;
    var minRadius = Infinity;
    var maxHorizontalOffset = 0;
    var maxVerticalOffset = 0;
    var maxInverseHorizontalOffset = 0;
    var maxInverseVerticalOffset = 0;
    var scale = that._scale;

    _each(elements.concat(scale), function (_, element) {
      var bounds = element.measure ? element.measure({
        radius: radius - element.getOffset()
      }) : scaleMeasurement;
      bounds.min > 0 && (minRadius = _min(minRadius, bounds.min));
      bounds.max > 0 && (maxRadius = _max(maxRadius, bounds.max));
      bounds.horizontalOffset > 0 && (maxHorizontalOffset = _max(maxHorizontalOffset, bounds.max + bounds.horizontalOffset));
      bounds.verticalOffset > 0 && (maxVerticalOffset = _max(maxVerticalOffset, bounds.max + bounds.verticalOffset));
      bounds.inverseHorizontalOffset > 0 && (maxInverseHorizontalOffset = _max(maxInverseHorizontalOffset, bounds.inverseHorizontalOffset));
      bounds.inverseVerticalOffset > 0 && (maxInverseVerticalOffset = _max(maxInverseVerticalOffset, bounds.inverseVerticalOffset));
    });

    maxHorizontalOffset = _max(maxHorizontalOffset - maxRadius, 0);
    maxVerticalOffset = _max(maxVerticalOffset - maxRadius, 0);
    return {
      minRadius: minRadius,
      maxRadius: maxRadius,
      horizontalMargin: maxHorizontalOffset,
      verticalMargin: maxVerticalOffset,
      inverseHorizontalMargin: maxInverseHorizontalOffset,
      inverseVerticalMargin: maxInverseVerticalOffset
    };
  },
  _applyMainLayout: function _applyMainLayout(elements, scaleMeasurement) {
    var measurements = this._measureMainElements(elements, scaleMeasurement);

    var area = this._area;
    var sides = area.sides;
    var margins = {
      left: (sides.left < -0.1 ? measurements.horizontalMargin : measurements.inverseHorizontalMargin) || 0,
      right: (sides.right > 0.1 ? measurements.horizontalMargin : measurements.inverseHorizontalMargin) || 0,
      top: (sides.up < -0.1 ? measurements.verticalMargin : measurements.inverseVerticalMargin) || 0,
      bottom: (sides.down > 0.1 ? measurements.verticalMargin : measurements.inverseVerticalMargin) || 0
    };
    var rect = selectRectByAspectRatio(this._innerRect, (sides.down - sides.up) / (sides.right - sides.left), margins);

    var radius = _min(getWidth(rect) / (sides.right - sides.left), getHeight(rect) / (sides.down - sides.up));

    radius = radius - measurements.maxRadius + area.radius;
    var x = rect.left - getWidth(rect) * sides.left / (sides.right - sides.left);
    var y = rect.top - getHeight(rect) * sides.up / (sides.down - sides.up);
    area.x = _round(x);
    area.y = _round(y);
    area.radius = radius;
    rect.left -= margins.left;
    rect.right += margins.right;
    rect.top -= margins.top;
    rect.bottom += margins.bottom;
    this._innerRect = rect;
  },
  _getElementLayout: function _getElementLayout(offset) {
    return {
      x: this._area.x,
      y: this._area.y,
      radius: _round(this._area.radius - offset)
    };
  },
  _getApproximateScreenRange: function _getApproximateScreenRange() {
    var that = this;
    var area = that._area;

    var r = _min(that._canvas.width / (area.sides.right - area.sides.left), that._canvas.height / (area.sides.down - area.sides.up));

    r > area.totalRadius && (r = area.totalRadius);
    r = 0.8 * r;
    return -that._translator.getCodomainRange() * r * PI / 180;
  },
  _getDefaultSize: function _getDefaultSize() {
    return {
      width: 300,
      height: 300
    };
  },
  _factory: (0, _object.clone)(_base_gauge.BaseGauge.prototype._factory)
});

function getWidth(rect) {
  return rect.right - rect.left;
}

function getHeight(rect) {
  return rect.bottom - rect.top;
}

function selectRectByAspectRatio(srcRect, aspectRatio, margins) {
  var rect = (0, _extend.extend)({}, srcRect);
  var selfAspectRatio;
  var width = 0;
  var height = 0;
  margins = margins || {};

  if (aspectRatio > 0) {
    rect.left += margins.left || 0;
    rect.right -= margins.right || 0;
    rect.top += margins.top || 0;
    rect.bottom -= margins.bottom || 0;

    if (getWidth(rect) > 0 && getHeight(rect) > 0) {
      selfAspectRatio = getHeight(rect) / getWidth(rect);

      if (selfAspectRatio > 1) {
        aspectRatio < selfAspectRatio ? width = getWidth(rect) : height = getHeight(rect);
      } else {
        aspectRatio > selfAspectRatio ? height = getHeight(rect) : width = getWidth(rect);
      }

      width > 0 || (width = height / aspectRatio);
      height > 0 || (height = width * aspectRatio);
      width = (getWidth(rect) - width) / 2;
      height = (getHeight(rect) - height) / 2;
      rect.left += width;
      rect.right -= width;
      rect.top += height;
      rect.bottom -= height;
    } else {
      rect.left = rect.right = (rect.left + rect.right) / 2;
      rect.top = rect.bottom = (rect.top + rect.bottom) / 2;
    }
  }

  return rect;
}

var indicators = dxCircularGauge.prototype._factory.indicators = {};
dxCircularGauge.prototype._factory.createIndicator = (0, _common.createIndicatorCreator)(indicators);
indicators._default = circularIndicators._default;
indicators['rectangleneedle'] = circularIndicators['rectangleneedle'];
indicators['triangleneedle'] = circularIndicators['triangleneedle'];
indicators['twocolorneedle'] = circularIndicators['twocolorneedle'];
indicators['trianglemarker'] = circularIndicators['trianglemarker'];
indicators['textcloud'] = circularIndicators['textcloud'];
indicators['rangebar'] = circularIndicators['rangebar'];
dxCircularGauge.prototype._factory.RangeContainer = _circular_range_container.default;
(0, _component_registrator.default)('dxCircularGauge', dxCircularGauge);
var _default = dxCircularGauge;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 605 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.projection = exports.Projection = void 0;

var _extend = __webpack_require__(0);

var _event_emitter = __webpack_require__(606);

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _Number = Number;
var _min = Math.min;
var _max = Math.max;
var _abs = Math.abs;
var _round = Math.round;
var _ln = Math.log;
var _pow = Math.pow;
var TWO_TO_LN2 = 2 / Math.LN2; // T224204
// The value is selected so that bounds range of 1 angular second can be defined
// 1 angular second is (1 / 3600) degrees or (1 / 3600 / 180) after projection
// The value 10 times less than projected 1 angular second is chosen

var MIN_BOUNDS_RANGE = 1 / 3600 / 180 / 10;
var DEFAULT_MIN_ZOOM = 1;
var DEFAULT_MAX_ZOOM = 1 << 8;
var DEFAULT_CENTER = [NaN, NaN];
var DEFAULT_ENGINE_NAME = 'mercator';

function floatsEqual(f1, f2) {
  return _abs(f1 - f2) < 1E-8;
}

function arraysEqual(a1, a2) {
  return floatsEqual(a1[0], a2[0]) && floatsEqual(a1[1], a2[1]);
}

function parseAndClamp(value, minValue, maxValue, defaultValue) {
  var val = _Number(value);

  return isFinite(val) ? _min(_max(val, minValue), maxValue) : defaultValue;
}

function parseAndClampArray(value, minValue, maxValue, defaultValue) {
  return [parseAndClamp(value[0], minValue[0], maxValue[0], defaultValue[0]), parseAndClamp(value[1], minValue[1], maxValue[1], defaultValue[1])];
}

function getEngine(engine) {
  return engine instanceof Engine && engine || projection.get(engine) || projection(engine) || projection.get(DEFAULT_ENGINE_NAME);
}

var Projection = function Projection(parameters) {
  var that = this;

  that._initEvents();

  that._params = parameters;
  that._engine = getEngine();
  that._center = that._engine.center();

  that._adjustCenter();
};

exports.Projection = Projection;
Projection.prototype = {
  constructor: Projection,
  _minZoom: DEFAULT_MIN_ZOOM,
  _maxZoom: DEFAULT_MAX_ZOOM,
  _zoom: DEFAULT_MIN_ZOOM,
  _center: DEFAULT_CENTER,
  _canvas: {},
  _scale: [],
  dispose: function dispose() {
    this._disposeEvents();
  },
  setEngine: function setEngine(value) {
    var that = this;
    var engine = getEngine(value);

    if (that._engine !== engine) {
      that._engine = engine;

      that._fire('engine');

      if (that._changeCenter(engine.center())) {
        that._triggerCenterChanged();
      }

      if (that._changeZoom(that._minZoom)) {
        that._triggerZoomChanged();
      }

      that._adjustCenter();

      that._setupScreen();
    }
  },
  setBounds: function setBounds(bounds) {
    if (bounds !== undefined) {
      this.setEngine(this._engine.original().bounds(bounds));
    }
  },
  _setupScreen: function _setupScreen() {
    var that = this;
    var canvas = that._canvas;
    var width = canvas.width;
    var height = canvas.height;
    var engine = that._engine;
    var aspectRatio = engine.ar();
    that._x0 = canvas.left + width / 2;
    that._y0 = canvas.top + height / 2;
    var min = [that.project([engine.min()[0], 0])[0], that.project([0, engine.min()[1]])[1]];
    var max = [that.project([engine.max()[0], 0])[0], that.project([0, engine.max()[1]])[1]];
    var screenAR = width / height;

    var boundsAR = _abs(max[0] - min[0]) / _abs(max[1] - min[1]);

    var correction;

    if (isNaN(boundsAR) || boundsAR === 0 || _min(screenAR, aspectRatio) <= aspectRatio * boundsAR && aspectRatio * boundsAR <= _max(screenAR, aspectRatio)) {
      correction = 1;
    } else {
      correction = boundsAR > 1 ? boundsAR : 1 / boundsAR;
    }

    if (aspectRatio * boundsAR >= screenAR) {
      that._xRadius = width / 2 / correction;
      that._yRadius = width / 2 / (aspectRatio * correction);
    } else {
      that._xRadius = height / 2 * (aspectRatio / correction);
      that._yRadius = height / 2 / correction;
    }

    that._fire('screen');
  },
  setSize: function setSize(canvas) {
    this._canvas = canvas;

    this._setupScreen();
  },
  getCanvas: function getCanvas() {
    return this._canvas;
  },
  _toScreen: function _toScreen(coordinates) {
    return [this._x0 + this._xRadius * coordinates[0], this._y0 + this._yRadius * coordinates[1]];
  },
  _fromScreen: function _fromScreen(coordinates) {
    return [(coordinates[0] - this._x0) / this._xRadius, (coordinates[1] - this._y0) / this._yRadius];
  },
  _toTransformed: function _toTransformed(coordinates) {
    return [coordinates[0] * this._zoom + this._xCenter, coordinates[1] * this._zoom + this._yCenter];
  },
  _toTransformedFast: function _toTransformedFast(coordinates) {
    return [coordinates[0] * this._zoom, coordinates[1] * this._zoom];
  },
  _fromTransformed: function _fromTransformed(coordinates) {
    return [(coordinates[0] - this._xCenter) / this._zoom, (coordinates[1] - this._yCenter) / this._zoom];
  },
  _adjustCenter: function _adjustCenter() {
    var that = this;

    var center = that._engine.project(that._center);

    that._xCenter = -center[0] * that._zoom || 0;
    that._yCenter = -center[1] * that._zoom || 0;
  },
  project: function project(coordinates) {
    return this._engine.project(coordinates);
  },
  transform: function transform(coordinates) {
    return this._toScreen(this._toTransformedFast(coordinates));
  },
  isInvertible: function isInvertible() {
    return this._engine.isInvertible();
  },
  getSquareSize: function getSquareSize(size) {
    return [size[0] * this._zoom * this._xRadius, size[1] * this._zoom * this._yRadius];
  },
  getZoom: function getZoom() {
    return this._zoom;
  },
  _changeZoom: function _changeZoom(value) {
    var that = this;
    var oldZoom = that._zoom;
    var newZoom = that._zoom = parseAndClamp(value, that._minZoom, that._maxZoom, that._minZoom);
    var isChanged = !floatsEqual(oldZoom, newZoom);

    if (isChanged) {
      that._adjustCenter();

      that._fire('zoom');
    }

    return isChanged;
  },
  setZoom: function setZoom(value) {
    if (this._engine.isInvertible() && this._changeZoom(value)) {
      this._triggerZoomChanged();
    }
  },
  getScaledZoom: function getScaledZoom() {
    return _round((this._scale.length - 1) * _ln(this._zoom) / _ln(this._maxZoom));
  },
  setScaledZoom: function setScaledZoom(scaledZoom) {
    this.setZoom(this._scale[_round(scaledZoom)]);
  },
  changeScaledZoom: function changeScaledZoom(deltaZoom) {
    this.setZoom(this._scale[_max(_min(_round(this.getScaledZoom() + deltaZoom), this._scale.length - 1), 0)]);
  },
  getZoomScalePartition: function getZoomScalePartition() {
    return this._scale.length - 1;
  },
  _setupScaling: function _setupScaling() {
    var that = this;

    var k = _max(_round(TWO_TO_LN2 * _ln(that._maxZoom)), 4);

    var step = _pow(that._maxZoom, 1 / k);

    var zoom = that._minZoom;
    that._scale = [zoom];

    for (var i = 1; i <= k; ++i) {
      that._scale.push(zoom *= step);
    }
  },
  setMaxZoom: function setMaxZoom(maxZoom) {
    var that = this;
    that._minZoom = DEFAULT_MIN_ZOOM;
    that._maxZoom = parseAndClamp(maxZoom, that._minZoom, _Number.MAX_VALUE, DEFAULT_MAX_ZOOM);

    that._setupScaling();

    if (that._zoom > that._maxZoom) {
      that.setZoom(that._maxZoom);
    }

    that._fire('max-zoom');
  },
  getCenter: function getCenter() {
    return this._center.slice();
  },
  setCenter: function setCenter(value) {
    if (this._engine.isInvertible() && this._changeCenter(value || [])) {
      this._triggerCenterChanged();
    }
  },
  _changeCenter: function _changeCenter(value) {
    var that = this;
    var engine = that._engine;
    var oldCenter = that._center;
    var newCenter = that._center = parseAndClampArray(value, engine.min(), engine.max(), engine.center());
    var isChanged = !arraysEqual(oldCenter, newCenter);

    if (isChanged) {
      that._adjustCenter();

      that._fire('center');
    }

    return isChanged;
  },
  _triggerCenterChanged: function _triggerCenterChanged() {
    this._params.centerChanged(this.getCenter());
  },
  _triggerZoomChanged: function _triggerZoomChanged() {
    this._params.zoomChanged(this.getZoom());
  },
  setCenterByPoint: function setCenterByPoint(coordinates, screenPosition) {
    var that = this;

    var p = that._engine.project(coordinates);

    var q = that._fromScreen(screenPosition);

    that.setCenter(that._engine.unproject([-q[0] / that._zoom + p[0], -q[1] / that._zoom + p[1]]));
  },
  beginMoveCenter: function beginMoveCenter() {
    if (this._engine.isInvertible()) {
      this._moveCenter = this._center;
    }
  },
  endMoveCenter: function endMoveCenter() {
    var that = this;

    if (that._moveCenter) {
      if (!arraysEqual(that._moveCenter, that._center)) {
        that._triggerCenterChanged();
      }

      that._moveCenter = null;
    }
  },
  moveCenter: function moveCenter(shift) {
    var that = this;

    if (that._moveCenter) {
      var current = that.toScreenPoint(that._center);

      that._changeCenter(that.fromScreenPoint([current[0] + shift[0], current[1] + shift[1]]));
    }
  },
  getViewport: function getViewport() {
    var that = this;
    var unproject = that._engine.unproject;
    var lt = unproject(that._fromTransformed([-1, -1]));
    var lb = unproject(that._fromTransformed([-1, +1]));
    var rt = unproject(that._fromTransformed([+1, -1]));
    var rb = unproject(that._fromTransformed([+1, +1]));
    var minMax = findMinMax([selectFarthestPoint(lt[0], lb[0], rt[0], rb[0]), selectFarthestPoint(lt[1], rt[1], lb[1], rb[1])], [selectFarthestPoint(rt[0], rb[0], lt[0], lb[0]), selectFarthestPoint(lb[1], rb[1], lt[1], rt[1])]);
    return [].concat(minMax.min, minMax.max);
  },
  // T254127
  // There should be no expectation that if viewport is got with `getViewport` and set with `setViewport`
  // then center and zoom will be retained - in general case they will be not.
  // Such retaining requires invertibility of projection which is generally not available
  // Invertibility means that `project(unproject([x, y])) === [x, y]` and `unproject(project([x, y])) === [x, y]` for any reasonable `(x, y)`
  // For example:
  // the "mercator" is non invertible - longitude is invertible, latitude is not (because of tan and log)
  // the "equirectangular" is invertible (it uses simple linear transformations)
  setViewport: function setViewport(viewport) {
    var engine = this._engine;
    var data = viewport ? getZoomAndCenterFromViewport(engine.project, engine.unproject, viewport) : [this._minZoom, engine.center()];
    this.setZoom(data[0]);
    this.setCenter(data[1]);
  },
  getTransform: function getTransform() {
    return {
      translateX: this._xCenter * this._xRadius,
      translateY: this._yCenter * this._yRadius
    };
  },
  fromScreenPoint: function fromScreenPoint(coordinates) {
    return this._engine.unproject(this._fromTransformed(this._fromScreen(coordinates)));
  },
  toScreenPoint: function toScreenPoint(coordinates) {
    return this._toScreen(this._toTransformed(this._engine.project(coordinates)));
  },
  _eventNames: ['engine', 'screen', 'center', 'zoom', 'max-zoom']
};
(0, _event_emitter.makeEventEmitter)(Projection);

function selectFarthestPoint(point1, point2, basePoint1, basePoint2) {
  var basePoint = (basePoint1 + basePoint2) / 2;
  return _abs(point1 - basePoint) > _abs(point2 - basePoint) ? point1 : point2;
}

function selectClosestPoint(point1, point2, basePoint1, basePoint2) {
  var basePoint = (basePoint1 + basePoint2) / 2;
  return _abs(point1 - basePoint) < _abs(point2 - basePoint) ? point1 : point2;
}

function getZoomAndCenterFromViewport(project, unproject, viewport) {
  var lt = project([viewport[0], viewport[3]]);
  var lb = project([viewport[0], viewport[1]]);
  var rt = project([viewport[2], viewport[3]]);
  var rb = project([viewport[2], viewport[1]]);
  var l = selectClosestPoint(lt[0], lb[0], rt[0], rb[0]);
  var r = selectClosestPoint(rt[0], rb[0], lt[0], lb[0]);
  var t = selectClosestPoint(lt[1], rt[1], lb[1], rb[1]);
  var b = selectClosestPoint(lb[1], rb[1], lt[1], rt[1]);
  return [2 / _max(_abs(l - r), _abs(t - b)), unproject([(l + r) / 2, (t + b) / 2])];
}

function setMinMax(engine, p1, p2) {
  var _findMinMax = findMinMax(p1, p2),
      min = _findMinMax.min,
      max = _findMinMax.max;

  engine.min = returnArray(min);
  engine.max = returnArray(max);
}

var Engine = /*#__PURE__*/function () {
  function Engine(parameters) {
    var that = this;
    var project = createProjectMethod(parameters.to);
    var unproject = parameters.from ? createUnprojectMethod(parameters.from) : returnValue(DEFAULT_CENTER);
    that.project = project;
    that.unproject = unproject;
    that.original = returnValue(that);

    that.source = function () {
      return (0, _extend.extend)({}, parameters);
    };

    that.isInvertible = returnValue(!!parameters.from);
    that.ar = returnValue(parameters.aspectRatio > 0 ? _Number(parameters.aspectRatio) : 1);
    that.center = returnArray(unproject([0, 0]));
    setMinMax(that, [unproject([-1, 0])[0], unproject([0, +1])[1]], [unproject([+1, 0])[0], unproject([0, -1])[1]]);
  }

  var _proto = Engine.prototype;

  _proto.aspectRatio = function aspectRatio(_aspectRatio) {
    var engine = new Engine((0, _extend.extend)(this.source(), {
      aspectRatio: _aspectRatio
    }));
    engine.original = this.original;
    engine.min = this.min;
    engine.max = this.max;
    return engine;
  };

  _proto.bounds = function bounds(_bounds) {
    _bounds = _bounds || [];
    var parameters = this.source();
    var min = this.min();
    var max = this.max();
    var b1 = parseAndClampArray([_bounds[0], _bounds[1]], min, max, min);
    var b2 = parseAndClampArray([_bounds[2], _bounds[3]], min, max, max);
    var p1 = parameters.to(b1);
    var p2 = parameters.to(b2);

    var delta = _min(_abs(p2[0] - p1[0]) > MIN_BOUNDS_RANGE ? _abs(p2[0] - p1[0]) : 2, _abs(p2[1] - p1[1]) > MIN_BOUNDS_RANGE ? _abs(p2[1] - p1[1]) : 2);

    if (delta < 2) {
      (0, _extend.extend)(parameters, createProjectUnprojectMethods(parameters.to, parameters.from, p1, p2, delta));
    }

    var engine = new Engine(parameters);
    engine.original = this.original;
    setMinMax(engine, b1, b2);
    return engine;
  };

  return Engine;
}();

function invertVerticalAxis(pair) {
  return [pair[0], -pair[1]];
}

function createProjectMethod(method) {
  return function (arg) {
    return invertVerticalAxis(method(arg));
  };
}

function createUnprojectMethod(method) {
  return function (arg) {
    return method(invertVerticalAxis(arg));
  };
}

function returnValue(value) {
  return function () {
    return value;
  };
}

function returnArray(value) {
  return function () {
    return value.slice();
  };
}

function findMinMax(p1, p2) {
  return {
    min: [_min(p1[0], p2[0]), _min(p1[1], p2[1])],
    max: [_max(p1[0], p2[0]), _max(p1[1], p2[1])]
  };
}

var projection = function projection(parameters) {
  return parameters && parameters.to ? new Engine(parameters) : null;
};

exports.projection = projection;
var projectionsCache = {};

projection.get = function (name) {
  return projectionsCache[name] || null;
};

projection.add = function (name, engine) {
  engine = engine instanceof Engine && engine || projection(engine);

  if (!projectionsCache[name] && engine) {
    projectionsCache[name] = engine;
  }

  return projection; // For chaining
};

function createProjectUnprojectMethods(project, unproject, p1, p2, delta) {
  var x0 = (p1[0] + p2[0]) / 2 - delta / 2;
  var y0 = (p1[1] + p2[1]) / 2 - delta / 2;
  var k = 2 / delta;
  return {
    to: function to(coordinates) {
      var _project = project(coordinates),
          _project2 = _slicedToArray(_project, 2),
          p0 = _project2[0],
          p1 = _project2[1];

      return [-1 + (p0 - x0) * k, -1 + (p1 - y0) * k];
    },
    from: function from(coordinates) {
      return unproject([x0 + (coordinates[0] + 1) / k, y0 + (coordinates[1] + 1) / k]);
    }
  };
}

/***/ }),
/* 606 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.makeEventEmitter = makeEventEmitter;

var _callbacks = _interopRequireDefault(__webpack_require__(28));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var eventEmitterMethods = {
  _initEvents: function _initEvents() {
    var names = this._eventNames;
    var i;
    var ii = names.length;
    var events = this._events = {};

    for (i = 0; i < ii; ++i) {
      events[names[i]] = (0, _callbacks.default)();
    }
  },
  _disposeEvents: function _disposeEvents() {
    var events = this._events;
    var name;

    for (name in events) {
      events[name].empty();
    }

    this._events = null;
  },
  on: function on(handlers) {
    var events = this._events;
    var name;

    for (name in handlers) {
      events[name].add(handlers[name]);
    }

    return dispose;

    function dispose() {
      for (name in handlers) {
        events[name].remove(handlers[name]);
      }
    }
  },
  _fire: function _fire(name, arg) {
    this._events[name].fire(arg);
  }
};

function makeEventEmitter(target) {
  var proto = target.prototype;
  var name;

  for (name in eventEmitterMethods) {
    proto[name] = eventEmitterMethods[name];
  }
}

/***/ }),
/* 607 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "projection", {
  enumerable: true,
  get: function get() {
    return _projection.projection;
  }
});

var _projection = __webpack_require__(605);

var _min = Math.min;
var _max = Math.max;
var _sin = Math.sin;
var _asin = Math.asin;
var _tan = Math.tan;
var _atan = Math.atan;
var _exp = Math.exp;
var _log = Math.log;
var PI = Math.PI;
var PI_DIV_4 = PI / 4;
var GEO_LON_BOUND = 180;
var GEO_LAT_BOUND = 90;
var RADIANS = PI / 180;
var MERCATOR_LAT_BOUND = (2 * _atan(_exp(PI)) - PI / 2) / RADIANS;
var MILLER_LAT_BOUND = (2.5 * _atan(_exp(0.8 * PI)) - 0.625 * PI) / RADIANS;

function clamp(value, threshold) {
  return _max(_min(value, +threshold), -threshold);
} // https://en.wikipedia.org/wiki/Mercator_projection


_projection.projection.add('mercator', (0, _projection.projection)({
  aspectRatio: 1,
  to: function to(coordinates) {
    return [coordinates[0] / GEO_LON_BOUND, _log(_tan(PI_DIV_4 + clamp(coordinates[1], MERCATOR_LAT_BOUND) * RADIANS / 2)) / PI];
  },
  from: function from(coordinates) {
    return [coordinates[0] * GEO_LON_BOUND, (2 * _atan(_exp(coordinates[1] * PI)) - PI / 2) / RADIANS];
  }
})); // https://en.wikipedia.org/wiki/Equirectangular_projection


_projection.projection.add('equirectangular', (0, _projection.projection)({
  aspectRatio: 2,
  to: function to(coordinates) {
    return [coordinates[0] / GEO_LON_BOUND, coordinates[1] / GEO_LAT_BOUND];
  },
  from: function from(coordinates) {
    return [coordinates[0] * GEO_LON_BOUND, coordinates[1] * GEO_LAT_BOUND];
  }
})); // https://en.wikipedia.org/wiki/Lambert_cylindrical_equal-area_projection


_projection.projection.add('lambert', (0, _projection.projection)({
  aspectRatio: 2,
  to: function to(coordinates) {
    return [coordinates[0] / GEO_LON_BOUND, _sin(clamp(coordinates[1], GEO_LAT_BOUND) * RADIANS)];
  },
  from: function from(coordinates) {
    return [coordinates[0] * GEO_LON_BOUND, _asin(clamp(coordinates[1], 1)) / RADIANS];
  }
})); // https://en.wikipedia.org/wiki/Miller_cylindrical_projection


_projection.projection.add('miller', (0, _projection.projection)({
  aspectRatio: 1,
  to: function to(coordinates) {
    return [coordinates[0] / GEO_LON_BOUND, 1.25 * _log(_tan(PI_DIV_4 + clamp(coordinates[1], MILLER_LAT_BOUND) * RADIANS * 0.4)) / PI];
  },
  from: function from(coordinates) {
    return [coordinates[0] * GEO_LON_BOUND, (2.5 * _atan(_exp(0.8 * coordinates[1] * PI)) - 0.625 * PI) / RADIANS];
  }
}));

/***/ }),
/* 608 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _type = __webpack_require__(1);

var _base_widget = _interopRequireDefault(__webpack_require__(119));

var _extend2 = __webpack_require__(0);

var _index = __webpack_require__(8);

var _pointer = _interopRequireDefault(__webpack_require__(25));

var _utils = __webpack_require__(14);

var _translator2d = __webpack_require__(350);

var _common = __webpack_require__(4);

var _tooltip = __webpack_require__(140);

var _export = __webpack_require__(118);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_LINE_SPACING = 2;
var EVENT_NS = 'sparkline-tooltip';
var POINTER_ACTION = (0, _index.addNamespace)([_pointer.default.down, _pointer.default.move], EVENT_NS);
var _extend = _extend2.extend;
var _floor = Math.floor;

function inCanvas(_ref, x, y) {
  var width = _ref.width,
      height = _ref.height;
  return (0, _utils.pointInCanvas)({
    left: 0,
    top: 0,
    right: width,
    bottom: height,
    width: width,
    height: height
  }, x, y);
}

function pointerHandler(_ref2) {
  var data = _ref2.data;
  var that = data.widget;

  that._enableOutHandler();

  that._showTooltip();
}

function generateDefaultCustomizeTooltipCallback(fontOptions, rtlEnabled) {
  var lineSpacing = fontOptions.lineSpacing;
  var lineHeight = (lineSpacing !== undefined && lineSpacing !== null ? lineSpacing : DEFAULT_LINE_SPACING) + fontOptions.size;
  return function (customizeObject) {
    var html = '';
    var vt = customizeObject.valueText;

    for (var i = 0; i < vt.length; i += 2) {
      html += '<tr><td>' + vt[i] + '</td><td style=\'width: 15px\'></td><td style=\'text-align: ' + (rtlEnabled ? 'left' : 'right') + '\'>' + vt[i + 1] + '</td></tr>';
    }

    return {
      html: '<table style=\'border-spacing:0px; line-height: ' + lineHeight + 'px\'>' + html + '</table>'
    };
  };
}

function generateCustomizeTooltipCallback(customizeTooltip, fontOptions, rtlEnabled) {
  var defaultCustomizeTooltip = generateDefaultCustomizeTooltipCallback(fontOptions, rtlEnabled);

  if ((0, _type.isFunction)(customizeTooltip)) {
    return function (customizeObject) {
      var res = customizeTooltip.call(customizeObject, customizeObject);

      if (!('html' in res) && !('text' in res)) {
        _extend(res, defaultCustomizeTooltip.call(customizeObject, customizeObject));
      }

      return res;
    };
  } else {
    return defaultCustomizeTooltip;
  }
}

function createAxis(isHorizontal) {
  var translator = new _translator2d.Translator2D({}, {}, {
    shiftZeroValue: !isHorizontal,
    isHorizontal: !!isHorizontal
  });
  return {
    getTranslator: function getTranslator() {
      return translator;
    },
    update: function update(range, canvas, options) {
      translator.update(range, canvas, options);
    },
    getVisibleArea: function getVisibleArea() {
      var visibleArea = translator.getCanvasVisibleArea();
      return [visibleArea.min, visibleArea.max];
    },
    visualRange: _common.noop,
    calculateInterval: _common.noop,
    getMarginOptions: function getMarginOptions() {
      return {};
    }
  };
}
/* eslint-disable-next-line */


var _initTooltip;

var BaseSparkline = _base_widget.default.inherit({
  _getLayoutItems: _common.noop,
  _useLinks: false,
  _themeDependentChanges: ['OPTIONS'],
  _initCore: function _initCore() {
    var that = this;
    that._tooltipTracker = that._renderer.root;

    that._tooltipTracker.attr({
      'pointer-events': 'visible'
    });

    that._createHtmlElements();

    that._initTooltipEvents();

    that._argumentAxis = createAxis(true);
    that._valueAxis = createAxis();
  },
  _getDefaultSize: function _getDefaultSize() {
    return this._defaultSize;
  },
  _disposeCore: function _disposeCore() {
    this._disposeWidgetElements();

    this._disposeTooltipEvents();

    this._ranges = null;
  },
  _optionChangesOrder: ['OPTIONS'],
  _change_OPTIONS: function _change_OPTIONS() {
    this._prepareOptions();

    this._change(['UPDATE']);
  },
  _customChangesOrder: ['UPDATE'],
  _change_UPDATE: function _change_UPDATE() {
    this._update();
  },
  _update: function _update() {
    var that = this;

    if (that._tooltipShown) {
      that._tooltipShown = false;

      that._tooltip.hide();
    }

    that._cleanWidgetElements();

    that._updateWidgetElements();

    that._drawWidgetElements();
  },
  _updateWidgetElements: function _updateWidgetElements() {
    var canvas = this._getCorrectCanvas();

    this._updateRange();

    this._argumentAxis.update(this._ranges.arg, canvas, this._getStick());

    this._valueAxis.update(this._ranges.val, canvas);
  },
  _getStick: function _getStick() {},
  _applySize: function _applySize(rect) {
    this._allOptions.size = {
      width: rect[2] - rect[0],
      height: rect[3] - rect[1]
    };

    this._change(['UPDATE']);
  },
  _setupResizeHandler: _common.noop,
  _prepareOptions: function _prepareOptions() {
    return _extend(true, {}, this._themeManager.theme(), this.option());
  },
  _getTooltipCoords: function _getTooltipCoords() {
    var canvas = this._canvas;

    var rootOffset = this._renderer.getRootOffset();

    return {
      x: canvas.width / 2 + rootOffset.left,
      y: canvas.height / 2 + rootOffset.top
    };
  },
  _initTooltipEvents: function _initTooltipEvents() {
    var data = {
      widget: this
    };

    this._renderer.root.off('.' + EVENT_NS).on(POINTER_ACTION, data, pointerHandler);
  },
  _showTooltip: function _showTooltip() {
    var that = this;
    var tooltip;

    if (!that._tooltipShown) {
      that._tooltipShown = true;
      tooltip = that._getTooltip();
      tooltip.isEnabled() && that._tooltip.show(that._getTooltipData(), that._getTooltipCoords(), {});
    }
  },
  _hideTooltip: function _hideTooltip() {
    if (this._tooltipShown) {
      this._tooltipShown = false;

      this._tooltip.hide();
    }
  },
  _stopCurrentHandling: function _stopCurrentHandling() {
    this._hideTooltip();
  },
  _enableOutHandler: function _enableOutHandler() {
    var that = this;

    if (that._outHandler) {
      return;
    }

    var handler = function handler(_ref3) {
      var pageX = _ref3.pageX,
          pageY = _ref3.pageY;

      var _that$_renderer$getRo = that._renderer.getRootOffset(),
          left = _that$_renderer$getRo.left,
          top = _that$_renderer$getRo.top;

      var x = _floor(pageX - left);

      var y = _floor(pageY - top);

      if (!inCanvas(that._canvas, x, y)) {
        that._hideTooltip();

        that._disableOutHandler();
      }
    };

    _events_engine.default.on(_dom_adapter.default.getDocument(), POINTER_ACTION, handler);

    this._outHandler = handler;
  },
  _disableOutHandler: function _disableOutHandler() {
    this._outHandler && _events_engine.default.off(_dom_adapter.default.getDocument(), POINTER_ACTION, this._outHandler);
    this._outHandler = null;
  },
  _disposeTooltipEvents: function _disposeTooltipEvents() {
    this._tooltipTracker.off();

    this._disableOutHandler();

    this._renderer.root.off('.' + EVENT_NS);
  },
  _getTooltip: function _getTooltip() {
    var that = this;

    if (!that._tooltip) {
      _initTooltip.apply(this, arguments);

      that._setTooltipRendererOptions(that._tooltipRendererOptions);

      that._tooltipRendererOptions = null;

      that._setTooltipOptions();
    }

    return that._tooltip;
  }
});

var _default = BaseSparkline; // PLUGINS_SECTION

exports.default = _default;
BaseSparkline.addPlugin(_tooltip.plugin); // These are sparklines specifics on using tooltip - they cannot be omitted because of tooltip laziness.

_initTooltip = BaseSparkline.prototype._initTooltip;
BaseSparkline.prototype._initTooltip = _common.noop;
var _disposeTooltip = BaseSparkline.prototype._disposeTooltip;

BaseSparkline.prototype._disposeTooltip = function () {
  if (this._tooltip) {
    _disposeTooltip.apply(this, arguments);
  }
};

BaseSparkline.prototype._setTooltipRendererOptions = function () {
  var options = this._getRendererOptions();

  if (this._tooltip) {
    this._tooltip.setRendererOptions(options);
  } else {
    this._tooltipRendererOptions = options;
  }
};

BaseSparkline.prototype._setTooltipOptions = function () {
  var tooltip = this._tooltip;

  var options = tooltip && this._getOption('tooltip');

  tooltip && tooltip.update(_extend({}, options, {
    customizeTooltip: generateCustomizeTooltipCallback(options.customizeTooltip, options.font, this.option('rtlEnabled')),
    enabled: options.enabled && this._isTooltipEnabled()
  }));
}; // PLUGINS_SECTION
// T422022


var exportPlugin = (0, _extend2.extend)(true, {}, _export.plugin, {
  init: _common.noop,
  dispose: _common.noop,
  customize: null,
  members: {
    _getExportMenuOptions: null
  }
});
BaseSparkline.addPlugin(exportPlugin);
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 609 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _tilingSquarified = _interopRequireDefault(__webpack_require__(610));

var _tiling = __webpack_require__(187);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _max = Math.max;

function accumulate(total, current) {
  return _max(total, current);
}

function squarified(data) {
  return (0, _tilingSquarified.default)(data, accumulate, false);
}

(0, _tiling.addAlgorithm)('squarified', squarified);
var _default = squarified;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 610 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = _default;

var _tiling = __webpack_require__(187);

var _max = Math.max;
var _round = Math.round;

function compare(a, b) {
  return b.value - a.value;
}

function getAspectRatio(value) {
  return _max(value, 1 / value);
}

function findAppropriateCollection(nodes, head, context) {
  var bestAspectRatio = Infinity;
  var nextAspectRatio;
  var sum = 0;
  var nextSum;
  var i;
  var j;
  var ii = nodes.length;
  var coeff = context.areaToValue / context.staticSide;
  var totalAspectRatio;

  for (i = head; i < ii;) {
    nextSum = sum + nodes[i].value;
    totalAspectRatio = context.staticSide / coeff / nextSum;
    nextAspectRatio = 0;

    for (j = head; j <= i; ++j) {
      nextAspectRatio = context.accumulate(nextAspectRatio, getAspectRatio(totalAspectRatio * nodes[j].value / nextSum), j - head + 1);
    }

    if (nextAspectRatio < bestAspectRatio) {
      bestAspectRatio = nextAspectRatio;
      sum = nextSum;
      ++i;
    } else {
      break;
    }
  }

  return {
    sum: sum,
    count: i - head,
    side: _round(coeff * sum)
  };
}

function getArea(rect) {
  return (rect[2] - rect[0]) * (rect[3] - rect[1]);
}

function doStep(nodes, head, context) {
  var sidesData = (0, _tiling.buildSidesData)(context.rect, context.directions, context.staticSideIndex);
  var area = getArea(context.rect);
  var rowData = area > 0 ? findAppropriateCollection(nodes, head, {
    areaToValue: area / context.sum,
    accumulate: context.accumulate,
    staticSide: sidesData.staticSide
  }) : {
    sum: 1,
    side: sidesData.variedSide,
    count: nodes.length - head
  };
  (0, _tiling.calculateRectangles)(nodes, head, context.rect, sidesData, rowData);
  context.sum -= rowData.sum;
  return head + rowData.count;
}

function _default(data, accumulate, isFixedStaticSide) {
  var items = data.items;
  var ii = items.length;
  var i;
  var context = {
    sum: data.sum,
    rect: data.rect,
    directions: data.directions,
    accumulate: accumulate
  };

  if (isFixedStaticSide) {
    context.staticSideIndex = (0, _tiling.getStaticSideIndex)(context.rect);
  }

  items.sort(compare);

  for (i = 0; i < ii;) {
    i = doStep(items, i, context);
  }
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 611 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _colorizing = __webpack_require__(246);

function discreteColorizer(options, themeManager, root) {
  var palette = themeManager.createPalette(options.palette, {
    useHighlight: true,
    extensionMode: options.paletteExtensionMode,
    count: options.colorizeGroups ? getNodesCount(root) : getLeafsCount(root)
  });
  return (options.colorizeGroups ? discreteGroupColorizer : discreteLeafColorizer)(palette, root);
}

function getLeafsCount(root) {
  var allNodes = root.nodes.slice();
  var i;
  var ii = allNodes.length;
  var count = 0;
  var node;

  for (i = 0; i < ii; ++i) {
    node = allNodes[i];

    if (node.isNode()) {
      count = Math.max(count, getLeafsCount(node));
    } else {
      count += 1;
    }
  }

  return count;
}

function discreteLeafColorizer(palette) {
  var colors = palette.generateColors();
  return function (node) {
    return colors[node.index];
  };
}

function getNodesCount(root) {
  var allNodes = root.nodes.slice();
  var i;
  var ii = allNodes.length;
  var count = 0;
  var node;

  for (i = 0; i < ii; ++i) {
    node = allNodes[i];

    if (node.isNode()) {
      count += getNodesCount(node) + 1;
    }
  }

  return count;
}

function prepareDiscreteGroupColors(palette, root) {
  var colors = {};
  var allNodes = root.nodes.slice();
  var i;
  var ii = allNodes.length;
  var node;

  for (i = 0; i < ii; ++i) {
    node = allNodes[i];

    if (node.isNode()) {
      allNodes = allNodes.concat(node.nodes);
      ii = allNodes.length;
    } else if (!colors[node.parent._id]) {
      colors[node.parent._id] = palette.getNextColor();
    }
  }

  return colors;
}

function discreteGroupColorizer(palette, root) {
  var colors = prepareDiscreteGroupColors(palette, root);
  return function (node) {
    return colors[node._id];
  };
}

(0, _colorizing.addColorizer)('discrete', discreteColorizer);
var _default = discreteColorizer;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 612 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _tree_map = _interopRequireDefault(__webpack_require__(120));

var _node = _interopRequireDefault(__webpack_require__(211));

var _helpers = __webpack_require__(184);

var _common = __webpack_require__(352);

var _utils = __webpack_require__(14);

__webpack_require__(188);

__webpack_require__(613);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var proto = _tree_map.default.prototype;
var nodeProto = _node.default.prototype;
var STATE_CODE = 1;
proto._eventsMap.onHoverChanged = {
  name: 'hoverChanged'
};
(0, _helpers.expand)(proto._handlers, 'calculateAdditionalStates', function (states, options) {
  states[1] = options.hoverStyle ? (0, _common.buildRectAppearance)(options.hoverStyle) : {};
});

_tree_map.default.addChange({
  code: 'HOVER_ENABLED',
  handler: function handler() {
    var hoverEnabled = (0, _utils.parseScalar)(this._getOption('hoverEnabled', true), true);

    if (!hoverEnabled) {
      this.clearHover();
    }

    this._hoverEnabled = hoverEnabled;
  },
  isThemeDependent: true,
  isOptionChange: true,
  option: 'hoverEnabled'
});

nodeProto.statesMap[1] = 1;
nodeProto.additionalStates.push(1);
(0, _helpers.expand)(proto, '_extendProxyType', function (proto) {
  var that = this;

  proto.setHover = function () {
    that._hoverNode(this._id);
  };

  proto.isHovered = function () {
    return that._hoverIndex === this._id;
  };
});
(0, _helpers.expand)(proto, '_onNodesCreated', function () {
  this._hoverIndex = -1;
});
(0, _helpers.expand)(proto, '_changeGroupSettings', function () {
  var that = this;
  that._groupHoverEnabled = (0, _utils.parseScalar)(that._getOption('group').hoverEnabled, true);

  if (!that._groupHoverEnabled) {
    that.clearHover();
  }
});

proto._applyHoverState = function (index, state) {
  setNodeStateRecursive(this._nodes[index], STATE_CODE, state);

  this._eventTrigger('hoverChanged', {
    node: this._nodes[index].proxy
  });
};

function setNodeStateRecursive(node, code, state) {
  var nodes = node.isNode() && node.nodes;
  var i;
  var ii = nodes && nodes.length;
  node.setState(code, state);

  for (i = 0; i < ii; ++i) {
    setNodeStateRecursive(nodes[i], code, state);
  }
}

proto._hoverNode = function (index) {
  var that = this;
  var currentIndex = that._hoverIndex;

  if (that._hoverEnabled && currentIndex !== index) {
    if (!that._groupHoverEnabled && index >= 0 && that._nodes[index].isNode()) {
      that.clearHover();
      return;
    }

    that._context.suspend();

    that._hoverIndex = -1;

    if (currentIndex >= 0) {
      that._applyHoverState(currentIndex, false);
    }

    that._hoverIndex = index;

    if (index >= 0) {
      that._applyHoverState(index, true);
    }

    that._context.resume();
  }
};

proto.clearHover = function () {
  this._hoverNode(-1);
};

/***/ }),
/* 613 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _tree_map = _interopRequireDefault(__webpack_require__(120));

var _node = _interopRequireDefault(__webpack_require__(211));

var _common = __webpack_require__(4);

var _extend2 = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var proto = _tree_map.default.prototype;
var nodeProto = _node.default.prototype;
var handlers = proto._handlers;
var _calculateState = handlers.calculateState;
var _buildState = nodeProto._buildState;

handlers.calculateState = function (options) {
  var states = {
    0: _calculateState(options)
  };
  handlers.calculateAdditionalStates(states, options);
  return states;
};

handlers.calculateAdditionalStates = _common.noop;
nodeProto.code = 0;
nodeProto.statesMap = {
  0: 0
};
nodeProto.additionalStates = [];

nodeProto._buildState = function (state, extra) {
  var states = {
    0: _buildState(state[0], extra)
  };

  if (this.additionalStates.length) {
    buildAdditionalStates(states, states[0], state, this.additionalStates);
  }

  return states;
};

nodeProto._getState = function () {
  return this.state[this.statesMap[this.code]];
};

nodeProto.setState = function (code, state) {
  if (state) {
    this.code |= code;
  } else {
    this.code &= ~code;
  }

  this.ctx.change(['TILES']);
};

function buildAdditionalStates(states, base, source, list) {
  var i;
  var ii = list.length;

  for (i = 0; i < ii; ++i) {
    states[list[i]] = (0, _extend2.extend)({}, base, source[list[i]]);
  }
}

/***/ }),
/* 614 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _helpers = __webpack_require__(184);

var _tree_map = _interopRequireDefault(__webpack_require__(120));

__webpack_require__(188);

var _tooltip = __webpack_require__(140);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var proto = _tree_map.default.prototype;
(0, _helpers.expand)(proto, '_extendProxyType', function (proto) {
  var that = this;

  proto.showTooltip = function (coords) {
    that._showTooltip(this._id, coords);
  };
});
(0, _helpers.expand)(proto, '_onNodesCreated', function () {
  if (this._tooltipIndex >= 0) {
    this._tooltip.hide();
  }

  this._tooltipIndex = -1;
});
(0, _helpers.expand)(proto, '_onTilingPerformed', function () {
  if (this._tooltipIndex >= 0) {
    this._moveTooltip(this._nodes[this._tooltipIndex]);
  }
});

function getCoords(coords, rect, renderer) {
  var offset = renderer.getRootOffset();
  return coords || rect && [(rect[0] + rect[2]) / 2 + offset.left, (rect[1] + rect[3]) / 2 + offset.top] || [-1000, -1000];
}

proto._showTooltip = function (index, coords) {
  var that = this;
  var tooltip = that._tooltip;
  var node = that._nodes[index];

  if (that._tooltipIndex === index) {
    that._moveTooltip(node, coords);

    return;
  }

  var callback = function callback(result) {
    if (result === undefined) {
      return;
    }

    if (!result) {
      tooltip.hide();
    }

    that._tooltipIndex = result ? index : -1;
  };

  var xy = getCoords(coords, node.rect, this._renderer);
  callback(tooltip.show({
    value: node.value,
    valueText: tooltip.formatValue(node.value),
    node: node.proxy
  }, {
    x: xy[0],
    y: xy[1],
    offset: 0
  }, {
    node: node.proxy
  }, undefined, callback));
};

proto._moveTooltip = function (node, coords) {
  var xy = getCoords(coords, node.rect, this._renderer);

  this._tooltip.move(xy[0], xy[1], 0);
};

proto.hideTooltip = function () {
  if (this._tooltipIndex >= 0) {
    this._tooltipIndex = -1;

    this._tooltip.hide();
  }
}; // PLUGINS_SECTION\


_tree_map.default.addPlugin(_tooltip.plugin);

/***/ }),
/* 615 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _tiling = __webpack_require__(1115);

var _tiling2 = _interopRequireDefault(__webpack_require__(1116));

var _tiling3 = _interopRequireDefault(__webpack_require__(1117));

var _common = __webpack_require__(4);

var _base_widget = _interopRequireDefault(__webpack_require__(119));

var _component_registrator = _interopRequireDefault(__webpack_require__(9));

var _item = _interopRequireDefault(__webpack_require__(1118));

var _data_source = __webpack_require__(186);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NODES_CREATE_CHANGE = 'NODES_CREATE';
(0, _tiling.addAlgorithm)('dynamicslope', _tiling2.default, true);
(0, _tiling.addAlgorithm)('dynamicheight', _tiling3.default);

function invertFigure(figure) {
  return figure.map(function (coord, index) {
    return index % 2 ? 1 - coord : coord;
  });
}

function getLegendItemState(itemState) {
  return {
    fill: itemState.fill,
    hatching: itemState.hatching
  };
}

var dxFunnel = _base_widget.default.inherit({
  _rootClass: 'dxf-funnel',
  _rootClassPrefix: 'dxf',
  _proxyData: [],
  _optionChangesMap: {
    dataSource: 'DATA_SOURCE',
    neckWidth: NODES_CREATE_CHANGE,
    neckHeight: NODES_CREATE_CHANGE,
    inverted: NODES_CREATE_CHANGE,
    algorithm: NODES_CREATE_CHANGE,
    item: NODES_CREATE_CHANGE,
    valueField: NODES_CREATE_CHANGE,
    argumentField: NODES_CREATE_CHANGE,
    colorField: NODES_CREATE_CHANGE,
    palette: NODES_CREATE_CHANGE,
    paletteExtensionMode: NODES_CREATE_CHANGE,
    sortData: NODES_CREATE_CHANGE
  },
  _themeDependentChanges: [NODES_CREATE_CHANGE],
  _getDefaultSize: function _getDefaultSize() {
    return {
      width: 400,
      height: 400
    };
  },
  _themeSection: 'funnel',
  _fontFields: ['legend.title.font', 'legend.title.subtitle.font', 'legend.font'],
  _optionChangesOrder: ['DATA_SOURCE'],
  _initialChanges: ['DATA_SOURCE'],
  _initCore: function _initCore() {
    this._group = this._renderer.g().append(this._renderer.root);
    this._items = [];
  },
  _eventsMap: {
    onHoverChanged: {
      name: 'hoverChanged'
    },
    onSelectionChanged: {
      name: 'selectionChanged'
    }
  },
  _disposeCore: _common.noop,
  _applySize: function _applySize(rect) {
    this._rect = rect.slice();

    this._change(['TILING']);

    return this._rect;
  },
  _getAlignmentRect: function _getAlignmentRect() {
    return this._rect;
  },
  _change_TILING: function _change_TILING() {
    var that = this;
    var items = that._items;
    var rect = that._rect;

    var convertCoord = function convertCoord(coord, index) {
      var offset = index % 2;
      return rect[0 + offset] + (rect[2 + offset] - rect[0 + offset]) * coord;
    };

    this._group.clear();

    items.forEach(function (item, index) {
      var coords = item.figure.map(convertCoord);

      var element = that._renderer.path([], 'area').attr({
        points: coords
      }).append(that._group);

      item.coords = coords;
      item.element = element;
    });

    this._requestChange(['TILES']);
  },
  _customChangesOrder: [NODES_CREATE_CHANGE, 'LAYOUT', 'TILING', 'TILES', 'DRAWN'],
  _dataSourceChangedHandler: function _dataSourceChangedHandler() {
    this._requestChange([NODES_CREATE_CHANGE]);
  },
  _change_DRAWN: function _change_DRAWN() {
    this._drawn();
  },
  _change_DATA_SOURCE: function _change_DATA_SOURCE() {
    this._change(['DRAWN']);

    this._updateDataSource();
  },
  _change_NODES_CREATE: function _change_NODES_CREATE() {
    this._buildNodes();
  },
  _change_TILES: function _change_TILES() {
    this._applyTilesAppearance();
  },
  _suspend: function _suspend() {
    if (!this._applyingChanges) {
      this._suspendChanges();
    }
  },
  _resume: function _resume() {
    if (!this._applyingChanges) {
      this._resumeChanges();
    }
  },
  _applyTilesAppearance: function _applyTilesAppearance() {
    this._items.forEach(function (item) {
      var state = item.getState();
      item.element.smartAttr(item.states[state]);
    });
  },
  _hitTestTargets: function _hitTestTargets(x, y) {
    var that = this;
    var data;

    this._proxyData.some(function (callback) {
      data = callback.call(that, x, y);

      if (data) {
        return true;
      }
    });

    return data;
  },
  clearHover: function clearHover() {
    this._suspend();

    this._items.forEach(function (item) {
      item.isHovered() && item.hover(false);
    });

    this._resume();
  },
  clearSelection: function clearSelection() {
    this._suspend();

    this._items.forEach(function (item) {
      item.isSelected() && item.select(false);
    });

    this._resume();
  },
  _getData: function _getData() {
    var that = this;
    var data = that._dataSourceItems() || [];

    var valueField = that._getOption('valueField', true);

    var argumentField = that._getOption('argumentField', true);

    var colorField = that._getOption('colorField', true);

    var processedData = data.reduce(function (d, item) {
      var value = Number(item[valueField]);

      if (value >= 0) {
        d[0].push({
          value: value,
          color: item[colorField],
          argument: item[argumentField],
          dataItem: item
        });
        d[1] += value;
      }

      return d;
    }, [[], 0]);
    var items = processedData[0];

    if (data.length > 0 && items.length === 0) {
      that._incidentOccurred('E2005', valueField);
    }

    if (!processedData[1]) {
      return [];
    }

    if (that._getOption('sortData', true)) {
      items.sort(function (a, b) {
        return b.value - a.value;
      });
    }

    return items;
  },
  _buildNodes: function _buildNodes() {
    var that = this;

    var data = that._getData();

    var algorithm = (0, _tiling.getAlgorithm)(that._getOption('algorithm', true));
    var percents = algorithm.normalizeValues(data);

    var itemOptions = that._getOption('item');

    var figures = algorithm.getFigures(percents, that._getOption('neckWidth', true), that._getOption('neckHeight', true));

    var palette = that._themeManager.createPalette(that._getOption('palette', true), {
      useHighlight: true,
      extensionMode: that._getOption('paletteExtensionMode', true),
      count: figures.length
    });

    that._items = figures.map(function (figure, index) {
      var curData = data[index];
      var node = new _item.default(that, {
        figure: figure,
        data: curData,
        percent: percents[index],
        id: index,
        color: curData.color || palette.getNextColor(),
        itemOptions: itemOptions
      });
      return node;
    });

    if (that._getOption('inverted', true)) {
      that._items.forEach(function (item) {
        item.figure = invertFigure(item.figure);
      });
    }

    that._renderer.initHatching();

    that._change(['TILING', 'DRAWN']);
  },
  _showTooltip: _common.noop,
  hideTooltip: _common.noop,
  getAllItems: function getAllItems() {
    return this._items.slice();
  },
  _getLegendData: function _getLegendData() {
    return this._items.map(function (item) {
      var states = item.states;
      return {
        id: item.id,
        visible: true,
        text: item.argument,
        item: item,
        states: {
          normal: getLegendItemState(states.normal),
          hover: getLegendItemState(states.hover),
          selection: getLegendItemState(states.selection)
        }
      };
    });
  },
  _getMinSize: function _getMinSize() {
    var adaptiveLayout = this._getOption('adaptiveLayout');

    return [adaptiveLayout.width, adaptiveLayout.height];
  }
});

(0, _component_registrator.default)('dxFunnel', dxFunnel);
var _default = dxFunnel; // PLUGINS_SECTION

exports.default = _default;
dxFunnel.addPlugin(_data_source.plugin);
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 616 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _constants = __webpack_require__(617);

var _common = __webpack_require__(4);

var _node_item = _interopRequireDefault(__webpack_require__(1123));

var _link_item = _interopRequireDefault(__webpack_require__(1124));

var _layout = __webpack_require__(1125);

var _type = __webpack_require__(1);

var _base_widget = _interopRequireDefault(__webpack_require__(119));

var _component_registrator = _interopRequireDefault(__webpack_require__(9));

var _data_source = __webpack_require__(186);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function moveLabel(node, labelOptions, availableLabelWidth, rect) {
  if (node._label.getBBox().width > availableLabelWidth) {
    node.labelText.applyEllipsis(availableLabelWidth);
  }

  var bBox = node._label.getBBox();

  var verticalOffset = labelOptions.verticalOffset;
  var horizontalOffset = labelOptions.horizontalOffset;
  var labelOffsetY = Math.round(node.rect.y + node.rect.height / 2 - bBox.y - bBox.height / 2) + verticalOffset;
  var labelOffsetX = node.rect.x + horizontalOffset + node.rect.width - bBox.x;

  if (labelOffsetX + bBox.width >= rect[2] - rect[0]) {
    labelOffsetX = node.rect.x - horizontalOffset - bBox.x - bBox.width;
  }

  if (labelOffsetY >= rect[3]) {
    labelOffsetY = rect[3];
  }

  if (labelOffsetY - bBox.height < rect[1]) {
    labelOffsetY = node.rect.y - bBox.y + verticalOffset;
  }

  node.labelText.attr({
    translateX: labelOffsetX,
    translateY: labelOffsetY
  });
}

function getConnectedLinks(layout, nodeName, linkType) {
  var result = [];
  var attrName = linkType === 'in' ? '_to' : '_from';
  var invertedAttrName = linkType === 'in' ? '_from' : '_to';
  layout.links.map(function (link) {
    return link[attrName]._name === nodeName;
  }).forEach(function (connected, idx) {
    connected && result.push({
      index: idx,
      weight: layout.links[idx]._weight,
      node: layout.links[idx][invertedAttrName]._name
    });
  });
  return result;
}

var dxSankey = _base_widget.default.inherit({
  _rootClass: 'dxs-sankey',
  _rootClassPrefix: 'dxs',
  _proxyData: [],
  _optionChangesMap: {
    dataSource: 'DATA_SOURCE',
    sortData: 'DATA_SOURCE',
    alignment: 'DATA_SOURCE',
    node: 'BUILD_LAYOUT',
    link: 'BUILD_LAYOUT',
    palette: 'BUILD_LAYOUT',
    paletteExtensionMode: 'BUILD_LAYOUT'
  },
  _themeDependentChanges: ['BUILD_LAYOUT'],
  _getDefaultSize: function _getDefaultSize() {
    return {
      width: 400,
      height: 400
    };
  },
  _themeSection: 'sankey',
  _fontFields: ['label.font'],
  _optionChangesOrder: ['DATA_SOURCE'],
  _initialChanges: ['DATA_SOURCE'],
  _initCore: function _initCore() {
    this._groupLinks = this._renderer.g().append(this._renderer.root);
    this._groupNodes = this._renderer.g().append(this._renderer.root);
    this._groupLabels = this._renderer.g().attr({
      class: this._rootClassPrefix + '-labels'
    }).append(this._renderer.root);
    this._drawLabels = true;
    this._nodes = [];
    this._links = [];
    this._gradients = [];
  },
  _disposeCore: _common.noop,
  _applySize: function _applySize(rect) {
    this._rect = rect.slice();

    var adaptiveLayout = this._getOption('adaptiveLayout');

    if (adaptiveLayout.keepLabels || this._rect[2] - this._rect[0] > adaptiveLayout.width) {
      this._drawLabels = true;
    } else {
      this._drawLabels = false;
    }

    this._change(['BUILD_LAYOUT']);

    return this._rect;
  },
  _eventsMap: {
    onNodeHoverChanged: {
      name: 'nodeHoverChanged'
    },
    onLinkHoverChanged: {
      name: 'linkHoverChanged'
    }
  },
  _customChangesOrder: ['BUILD_LAYOUT', 'NODES_DRAW', 'LINKS_DRAW', 'LABELS', 'DRAWN'],
  _dataSourceChangedHandler: function _dataSourceChangedHandler() {
    this._requestChange(['BUILD_LAYOUT']);
  },
  _change_DRAWN: function _change_DRAWN() {
    this._drawn();
  },
  _change_DATA_SOURCE: function _change_DATA_SOURCE() {
    this._change(['DRAWN']);

    this._updateDataSource();
  },
  _change_LABELS: function _change_LABELS() {
    this._applyLabelsAppearance();
  },
  _change_BUILD_LAYOUT: function _change_BUILD_LAYOUT() {
    this._groupNodes.clear();

    this._groupLinks.clear();

    this._groupLabels.clear();

    this._buildLayout();
  },
  _change_NODES_DRAW: function _change_NODES_DRAW() {
    var that = this;
    var nodes = that._nodes;
    nodes.forEach(function (node, index) {
      var element = that._renderer.rect().attr(node.rect).append(that._groupNodes);

      node.element = element;
    });

    this._applyNodesAppearance();
  },
  _change_LINKS_DRAW: function _change_LINKS_DRAW() {
    var that = this;
    var links = that._links;
    links.forEach(function (link, index) {
      var group = that._renderer.g().attr({
        class: 'link',
        'data-link-idx': index
      }).append(that._groupLinks);

      link.overlayElement = that._renderer.path([], 'area').attr({
        d: link.d
      }).append(group);
      link.element = that._renderer.path([], 'area').attr({
        d: link.d
      }).append(group);
    });

    this._applyLinksAppearance();
  },
  _suspend: function _suspend() {
    if (!this._applyingChanges) {
      this._suspendChanges();
    }
  },
  _resume: function _resume() {
    if (!this._applyingChanges) {
      this._resumeChanges();
    }
  },
  _showTooltip: _common.noop,
  hideTooltip: _common.noop,
  clearHover: function clearHover() {
    this._suspend();

    this._nodes.forEach(function (node) {
      node.isHovered() && node.hover(false);
    });

    this._links.forEach(function (link) {
      link.isHovered() && link.hover(false);
      link.isAdjacentNodeHovered() && link.adjacentNodeHover(false);
    });

    this._resume();
  },
  _applyNodesAppearance: function _applyNodesAppearance() {
    this._nodes.forEach(function (node) {
      var state = node.getState();
      node.element.smartAttr(node.states[state]);
    });
  },
  _applyLinksAppearance: function _applyLinksAppearance() {
    this._links.forEach(function (link) {
      var state = link.getState();
      link.element.smartAttr(link.states[state]);
      link.overlayElement.smartAttr(link.overlayStates[state]);
    });
  },
  _hitTestTargets: function _hitTestTargets(x, y) {
    var that = this;
    var data;

    this._proxyData.some(function (callback) {
      data = callback.call(that, x, y);

      if (data) {
        return true;
      }
    });

    return data;
  },
  _getData: function _getData() {
    var that = this;
    var data = that._dataSourceItems() || [];

    var sourceField = that._getOption('sourceField', true);

    var targetField = that._getOption('targetField', true);

    var weightField = that._getOption('weightField', true);

    var processedData = [];
    data.forEach(function (item) {
      var hasItemOwnProperty = Object.prototype.hasOwnProperty.bind(item);

      if (!hasItemOwnProperty(sourceField)) {
        that._incidentOccurred('E2007', sourceField);
      } else if (!hasItemOwnProperty(targetField)) {
        that._incidentOccurred('E2007', targetField);
      } else if (!hasItemOwnProperty(weightField)) {
        that._incidentOccurred('E2007', weightField);
      } else {
        if (!(0, _type.isString)(item[sourceField])) {
          that._incidentOccurred('E2008', sourceField);
        } else if (!(0, _type.isString)(item[targetField])) {
          that._incidentOccurred('E2008', targetField);
        } else if (!(0, _type.isNumeric)(item[weightField]) || item[weightField] <= 0) {
          that._incidentOccurred('E2009', weightField);
        } else {
          processedData.push([item[sourceField], item[targetField], item[weightField]]);
        }
      }
    });
    return processedData;
  },
  _buildLayout: function _buildLayout() {
    var _this = this;

    var that = this;

    var data = that._getData();

    var availableRect = this._rect;

    var nodeOptions = that._getOption('node');

    var sortData = that._getOption('sortData');

    var layoutBuilder = that._getOption('layoutBuilder', true) || _layout.layout;

    var rect = {
      x: availableRect[0],
      y: availableRect[1],
      width: availableRect[2] - availableRect[0],
      height: availableRect[3] - availableRect[1]
    };
    var layout = layoutBuilder.computeLayout(data, sortData, {
      availableRect: rect,
      nodePadding: nodeOptions.padding,
      nodeWidth: nodeOptions.width,
      nodeAlign: that._getOption('alignment', true)
    }, that._incidentOccurred);
    that._layoutMap = layout;

    if (!Object.prototype.hasOwnProperty.call(layout, 'error')) {
      var nodeColors = {};
      var nodeIdx = 0;

      var linkOptions = that._getOption('link');

      var totalNodesNum = layout.nodes.map(function (item) {
        return item.length;
      }).reduce(function (previousValue, currentValue) {
        return previousValue + currentValue;
      }, 0);

      var palette = that._themeManager.createPalette(that._getOption('palette', true), {
        useHighlight: true,
        extensionMode: that._getOption('paletteExtensionMode', true),
        count: totalNodesNum
      });

      that._nodes = [];
      that._links = [];

      that._gradients.forEach(function (gradient) {
        gradient.dispose();
      });

      that._gradients = [];
      that._shadowFilter && that._shadowFilter.dispose();
      layout.nodes.forEach(function (cascadeNodes) {
        cascadeNodes.forEach(function (node) {
          var color = nodeOptions.color || palette.getNextColor();
          var nodeItem = new _node_item.default(that, {
            id: nodeIdx,
            color: color,
            rect: node,
            options: nodeOptions,
            linksIn: getConnectedLinks(layout, node._name, 'in'),
            linksOut: getConnectedLinks(layout, node._name, 'out')
          });

          that._nodes.push(nodeItem);

          nodeIdx++;
          nodeColors[node._name] = color;
        });
      });
      layout.links.forEach(function (link) {
        var gradient = null;

        if (linkOptions.colorMode === _constants.COLOR_MODE_GRADIENT) {
          gradient = that._renderer.linearGradient([{
            offset: '0%',
            'stop-color': nodeColors[link._from._name]
          }, {
            offset: '100%',
            'stop-color': nodeColors[link._to._name]
          }]);

          _this._gradients.push(gradient);
        }

        var color = linkOptions.color;

        if (linkOptions.colorMode === _constants.COLOR_MODE_SOURCE) {
          color = nodeColors[link._from._name];
        } else if (linkOptions.colorMode === _constants.COLOR_MODE_TARGET) {
          color = nodeColors[link._to._name];
        }

        var linkItem = new _link_item.default(that, {
          d: link.d,
          boundingRect: link._boundingRect,
          color: color,
          options: linkOptions,
          connection: {
            source: link._from._name,
            target: link._to._name,
            weight: link._weight
          },
          gradient: gradient
        });

        that._links.push(linkItem);
      });

      that._renderer.initHatching();

      that._change(['NODES_DRAW', 'LINKS_DRAW', 'LABELS']);
    }

    that._change(['DRAWN']);
  },
  _applyLabelsAppearance: function _applyLabelsAppearance() {
    var that = this;

    var labelOptions = that._getOption('label');

    var availableWidth = that._rect[2] - that._rect[0];

    var nodeOptions = that._getOption('node');

    that._shadowFilter = that._renderer.shadowFilter('-50%', '-50%', '200%', '200%').attr(labelOptions.shadow);

    that._groupLabels.clear();

    if (that._drawLabels && labelOptions.visible) {
      // emtpy space between cascades with 'labelOptions.horizontalOffset' subtracted
      var availableLabelWidth = (availableWidth - (nodeOptions.width + labelOptions.horizontalOffset) - that._layoutMap.cascades.length * nodeOptions.width) / (that._layoutMap.cascades.length - 1) - labelOptions.horizontalOffset;

      that._nodes.forEach(function (node) {
        that._createLabel(node, labelOptions, that._shadowFilter.id);

        moveLabel(node, labelOptions, availableLabelWidth, that._rect);
      }); // test and handle labels overlapping here


      if (labelOptions.overlappingBehavior !== 'none') {
        that._nodes.forEach(function (thisNode) {
          var thisBox = thisNode._label.getBBox();

          that._nodes.forEach(function (otherNode) {
            var otherBox = otherNode._label.getBBox();

            if (thisNode.id !== otherNode.id && _layout.layout.overlap(thisBox, otherBox)) {
              if (labelOptions.overlappingBehavior === 'ellipsis') {
                thisNode.labelText.applyEllipsis(otherBox.x - thisBox.x);
              } else if (labelOptions.overlappingBehavior === 'hide') {
                thisNode.labelText.remove();
              }
            }
          });
        });
      }
    }
  },
  _createLabel: function _createLabel(node, labelOptions, filter) {
    var textData = labelOptions.customizeText(node);
    var settings = node.getLabelAttributes(labelOptions, filter);

    if (textData) {
      node._label = this._renderer.g().append(this._groupLabels);
      node.labelText = this._renderer.text(textData).attr(settings.attr).css(settings.css);
      node.labelText.append(node._label);
    }
  },
  _getMinSize: function _getMinSize() {
    var adaptiveLayout = this._getOption('adaptiveLayout');

    return [adaptiveLayout.width, adaptiveLayout.height];
  },
  getAllNodes: function getAllNodes() {
    return this._nodes.slice();
  },
  getAllLinks: function getAllLinks() {
    return this._links.slice();
  }
});

(0, _component_registrator.default)('dxSankey', dxSankey);
var _default = dxSankey; // PLUGINS_SECTION

exports.default = _default;
dxSankey.addPlugin(_data_source.plugin);
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 617 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.COLOR_MODE_NONE = exports.COLOR_MODE_TARGET = exports.COLOR_MODE_SOURCE = exports.COLOR_MODE_GRADIENT = void 0;
var COLOR_MODE_GRADIENT = 'gradient';
exports.COLOR_MODE_GRADIENT = COLOR_MODE_GRADIENT;
var COLOR_MODE_SOURCE = 'source';
exports.COLOR_MODE_SOURCE = COLOR_MODE_SOURCE;
var COLOR_MODE_TARGET = 'target';
exports.COLOR_MODE_TARGET = COLOR_MODE_TARGET;
var COLOR_MODE_NONE = 'none';
exports.COLOR_MODE_NONE = COLOR_MODE_NONE;

/***/ }),
/* 618 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;
var WHITE = 'white';
var GRAY = 'gray';
var BLACK = 'black';
var routines = {
  maxOfArray: function maxOfArray(arr, callback) {
    var m = 0;

    var callback_function = function callback_function(v) {
      return v;
    };

    if (callback) {
      callback_function = callback;
    }

    for (var i = 0; i < arr.length; i++) {
      if (callback_function(arr[i]) > m) m = callback_function(arr[i]);
    }

    return m;
  }
};

var getVertices = function getVertices(links) {
  var vert = [];
  links.forEach(function (link) {
    if (vert.indexOf(link[0]) === -1) {
      vert.push(link[0]);
    }

    if (vert.indexOf(link[1]) === -1) {
      vert.push(link[1]);
    }
  });
  return vert;
};

var getAdjacentVertices = function getAdjacentVertices(links, vertex) {
  var avert = [];
  links.forEach(function (link) {
    if (link[0] === vertex && avert.indexOf(link[1]) === -1) {
      avert.push(link[1]);
    }
  });
  return avert;
};

var getReverseAdjacentVertices = function getReverseAdjacentVertices(links, vertex) {
  var avert = [];
  links.forEach(function (link) {
    if (link[1] === vertex && avert.indexOf(link[0]) === -1) {
      avert.push(link[0]);
    }
  });
  return avert;
};

var struct = {
  _hasCycle: false,
  _sortedList: [],
  hasCycle: function hasCycle(links) {
    var _this = this;

    // detects if the graph has cycle
    // sorts the vertices (modifies the _sortedList variable)
    this._hasCycle = false;
    this._sortedList = [];
    var vertices = {};
    var allVertices = getVertices(links);
    allVertices.forEach(function (vertex) {
      vertices[vertex] = {
        color: WHITE
      };
    });
    allVertices.forEach(function (vertex) {
      if (vertices[vertex].color === WHITE) {
        _this._depthFirstSearch(links, vertices, vertex);
      }
    });

    this._sortedList.reverse();

    return this._hasCycle;
  },
  _depthFirstSearch: function _depthFirstSearch(links, vertices, vertex) {
    vertices[vertex].color = GRAY;
    var averts = getAdjacentVertices(links, vertex);

    for (var a = 0; a < averts.length; a++) {
      if (vertices[averts[a]].color === WHITE) {
        this._depthFirstSearch(links, vertices, averts[a]);
      } else if (vertices[averts[a]].color === GRAY) {
        this._hasCycle = true;
      }
    }

    this._sortedList.push({
      name: vertex,
      lp: null,
      incoming: getReverseAdjacentVertices(links, vertex),
      outgoing: getAdjacentVertices(links, vertex)
    });

    vertices[vertex].color = BLACK;
  },
  computeLongestPaths: function computeLongestPaths(links) {
    // calculates longets paths for all vertices
    // method expects sorted vertices array to be in this._sortedList
    var sortedVertices = this._sortedList;
    sortedVertices.forEach(function (vertex) {
      var averts = getReverseAdjacentVertices(links, vertex.name); // neigbours who INCOME to the vertex

      if (averts.length === 0) {
        vertex.lp = 0; // 'lp' means 'Longest Path'
      } else {
        var maxLP = []; // get max through avertex.lp and add 1 to it

        averts.forEach(function (adjacentVertex) {
          maxLP.push(sortedVertices.filter(function (sv) {
            return sv.name === adjacentVertex;
          })[0].lp);
        });
        vertex.lp = routines.maxOfArray(maxLP) + 1;
      }
    });
    return this._sortedList;
  }
};
var _default = {
  struct: struct,
  routines: routines,
  getVertices: getVertices,
  getAdjacentVertices: getAdjacentVertices,
  getReverseAdjacentVertices: getReverseAdjacentVertices
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 619 */,
/* 620 */,
/* 621 */,
/* 622 */,
/* 623 */,
/* 624 */,
/* 625 */,
/* 626 */,
/* 627 */,
/* 628 */,
/* 629 */,
/* 630 */,
/* 631 */,
/* 632 */,
/* 633 */,
/* 634 */,
/* 635 */,
/* 636 */,
/* 637 */,
/* 638 */,
/* 639 */,
/* 640 */,
/* 641 */,
/* 642 */,
/* 643 */,
/* 644 */,
/* 645 */,
/* 646 */,
/* 647 */,
/* 648 */,
/* 649 */,
/* 650 */,
/* 651 */,
/* 652 */,
/* 653 */,
/* 654 */,
/* 655 */,
/* 656 */,
/* 657 */,
/* 658 */,
/* 659 */,
/* 660 */,
/* 661 */,
/* 662 */,
/* 663 */,
/* 664 */,
/* 665 */,
/* 666 */,
/* 667 */,
/* 668 */,
/* 669 */,
/* 670 */,
/* 671 */,
/* 672 */,
/* 673 */,
/* 674 */,
/* 675 */,
/* 676 */,
/* 677 */,
/* 678 */,
/* 679 */,
/* 680 */,
/* 681 */,
/* 682 */,
/* 683 */,
/* 684 */,
/* 685 */,
/* 686 */,
/* 687 */,
/* 688 */,
/* 689 */,
/* 690 */,
/* 691 */,
/* 692 */,
/* 693 */,
/* 694 */,
/* 695 */,
/* 696 */,
/* 697 */,
/* 698 */,
/* 699 */,
/* 700 */,
/* 701 */,
/* 702 */,
/* 703 */,
/* 704 */,
/* 705 */,
/* 706 */,
/* 707 */,
/* 708 */,
/* 709 */,
/* 710 */,
/* 711 */,
/* 712 */,
/* 713 */,
/* 714 */,
/* 715 */,
/* 716 */,
/* 717 */,
/* 718 */,
/* 719 */,
/* 720 */,
/* 721 */,
/* 722 */,
/* 723 */,
/* 724 */,
/* 725 */,
/* 726 */,
/* 727 */,
/* 728 */,
/* 729 */,
/* 730 */,
/* 731 */,
/* 732 */,
/* 733 */,
/* 734 */,
/* 735 */,
/* 736 */,
/* 737 */,
/* 738 */,
/* 739 */,
/* 740 */,
/* 741 */,
/* 742 */,
/* 743 */,
/* 744 */,
/* 745 */,
/* 746 */,
/* 747 */,
/* 748 */,
/* 749 */,
/* 750 */,
/* 751 */,
/* 752 */,
/* 753 */,
/* 754 */,
/* 755 */,
/* 756 */,
/* 757 */,
/* 758 */,
/* 759 */,
/* 760 */,
/* 761 */,
/* 762 */,
/* 763 */,
/* 764 */,
/* 765 */,
/* 766 */,
/* 767 */,
/* 768 */,
/* 769 */,
/* 770 */,
/* 771 */,
/* 772 */,
/* 773 */,
/* 774 */,
/* 775 */,
/* 776 */,
/* 777 */,
/* 778 */,
/* 779 */,
/* 780 */,
/* 781 */,
/* 782 */,
/* 783 */,
/* 784 */,
/* 785 */,
/* 786 */,
/* 787 */,
/* 788 */,
/* 789 */,
/* 790 */,
/* 791 */,
/* 792 */,
/* 793 */,
/* 794 */,
/* 795 */,
/* 796 */,
/* 797 */,
/* 798 */,
/* 799 */,
/* 800 */,
/* 801 */,
/* 802 */,
/* 803 */,
/* 804 */,
/* 805 */,
/* 806 */,
/* 807 */,
/* 808 */,
/* 809 */,
/* 810 */,
/* 811 */,
/* 812 */,
/* 813 */,
/* 814 */,
/* 815 */,
/* 816 */,
/* 817 */,
/* 818 */,
/* 819 */,
/* 820 */,
/* 821 */,
/* 822 */,
/* 823 */,
/* 824 */,
/* 825 */,
/* 826 */,
/* 827 */,
/* 828 */,
/* 829 */,
/* 830 */,
/* 831 */,
/* 832 */,
/* 833 */,
/* 834 */,
/* 835 */,
/* 836 */,
/* 837 */,
/* 838 */,
/* 839 */,
/* 840 */,
/* 841 */,
/* 842 */,
/* 843 */,
/* 844 */,
/* 845 */,
/* 846 */,
/* 847 */,
/* 848 */,
/* 849 */,
/* 850 */,
/* 851 */,
/* 852 */,
/* 853 */,
/* 854 */,
/* 855 */,
/* 856 */,
/* 857 */,
/* 858 */,
/* 859 */,
/* 860 */,
/* 861 */,
/* 862 */,
/* 863 */,
/* 864 */,
/* 865 */,
/* 866 */,
/* 867 */,
/* 868 */,
/* 869 */,
/* 870 */,
/* 871 */,
/* 872 */,
/* 873 */,
/* 874 */,
/* 875 */,
/* 876 */,
/* 877 */,
/* 878 */,
/* 879 */,
/* 880 */,
/* 881 */,
/* 882 */,
/* 883 */,
/* 884 */,
/* 885 */,
/* 886 */,
/* 887 */,
/* 888 */,
/* 889 */,
/* 890 */,
/* 891 */,
/* 892 */,
/* 893 */,
/* 894 */,
/* 895 */,
/* 896 */,
/* 897 */,
/* 898 */,
/* 899 */,
/* 900 */,
/* 901 */,
/* 902 */,
/* 903 */,
/* 904 */,
/* 905 */,
/* 906 */,
/* 907 */,
/* 908 */,
/* 909 */,
/* 910 */,
/* 911 */,
/* 912 */,
/* 913 */,
/* 914 */,
/* 915 */,
/* 916 */,
/* 917 */,
/* 918 */,
/* 919 */,
/* 920 */,
/* 921 */,
/* 922 */,
/* 923 */,
/* 924 */,
/* 925 */,
/* 926 */,
/* 927 */,
/* 928 */,
/* 929 */,
/* 930 */,
/* 931 */,
/* 932 */,
/* 933 */,
/* 934 */,
/* 935 */,
/* 936 */,
/* 937 */,
/* 938 */,
/* 939 */,
/* 940 */,
/* 941 */,
/* 942 */,
/* 943 */,
/* 944 */,
/* 945 */,
/* 946 */,
/* 947 */,
/* 948 */,
/* 949 */,
/* 950 */,
/* 951 */,
/* 952 */,
/* 953 */,
/* 954 */,
/* 955 */,
/* 956 */,
/* 957 */,
/* 958 */,
/* 959 */,
/* 960 */,
/* 961 */,
/* 962 */,
/* 963 */,
/* 964 */,
/* 965 */,
/* 966 */,
/* 967 */,
/* 968 */,
/* 969 */,
/* 970 */,
/* 971 */,
/* 972 */,
/* 973 */,
/* 974 */,
/* 975 */,
/* 976 */,
/* 977 */,
/* 978 */,
/* 979 */,
/* 980 */,
/* 981 */,
/* 982 */,
/* 983 */,
/* 984 */,
/* 985 */,
/* 986 */,
/* 987 */,
/* 988 */,
/* 989 */,
/* 990 */,
/* 991 */,
/* 992 */,
/* 993 */,
/* 994 */,
/* 995 */,
/* 996 */,
/* 997 */,
/* 998 */,
/* 999 */,
/* 1000 */,
/* 1001 */,
/* 1002 */,
/* 1003 */,
/* 1004 */,
/* 1005 */,
/* 1006 */,
/* 1007 */,
/* 1008 */,
/* 1009 */,
/* 1010 */,
/* 1011 */,
/* 1012 */,
/* 1013 */,
/* 1014 */,
/* 1015 */,
/* 1016 */,
/* 1017 */,
/* 1018 */,
/* 1019 */,
/* 1020 */,
/* 1021 */,
/* 1022 */,
/* 1023 */,
/* 1024 */,
/* 1025 */,
/* 1026 */,
/* 1027 */,
/* 1028 */,
/* 1029 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint-disable import/no-commonjs */
var DevExpress = __webpack_require__(191);

__webpack_require__(272); /// BUNDLER_PARTS

/* Viz core (dx.module-viz-core.js) */


var viz = DevExpress.viz = __webpack_require__(1030);

viz.currentTheme = __webpack_require__(57).currentTheme;
viz.registerTheme = __webpack_require__(57).registerTheme;
viz.exportFromMarkup = __webpack_require__(341).exportFromMarkup;
viz.getMarkup = __webpack_require__(341).getMarkup;
viz.exportWidgets = __webpack_require__(341).exportWidgets;
viz.currentPalette = __webpack_require__(208).currentPalette;
viz.getPalette = __webpack_require__(208).getPalette;
viz.generateColors = __webpack_require__(208).generateColors;
viz.registerPalette = __webpack_require__(208).registerPalette;
viz.refreshTheme = __webpack_require__(57).refreshTheme;
/* Charts (dx.module-viz-charts.js) */

viz.dxChart = __webpack_require__(1031);
viz.dxPieChart = __webpack_require__(1067);
viz.dxPolarChart = __webpack_require__(1068);
/* Gauges (dx.module-viz-gauges.js) */

viz.dxLinearGauge = __webpack_require__(1069);
viz.dxCircularGauge = __webpack_require__(1075);
viz.dxBarGauge = __webpack_require__(1078);
/* Range selector (dx.module-viz-rangeselector.js) */

viz.dxRangeSelector = __webpack_require__(1080);
/* Vector map (dx.module-viz-vectormap.js) */

viz.dxVectorMap = __webpack_require__(1088);
viz.map = {};
viz.map.sources = {};
viz.map.projection = __webpack_require__(607).projection;
/* Sparklines (dx.module-viz-sparklines.js) */

viz.dxSparkline = __webpack_require__(1099);
viz.dxBullet = __webpack_require__(1101);
/* Treemap */

viz.dxTreeMap = __webpack_require__(1103);
/* Funnel */

viz.dxFunnel = __webpack_require__(1114);
/* Sankey */

viz.dxSankey = __webpack_require__(1122); /// BUNDLER_PARTS_END

viz.BaseWidget = __webpack_require__(119);
viz.getTheme = __webpack_require__(57).getTheme; // Keep it for backward compatibility after renaming findTheme to getTheme

viz.findTheme = __webpack_require__(57).getTheme; // We need to keep this method as we suggested it to users

viz.refreshAll = __webpack_require__(57).refreshTheme;
viz.refreshPaths = __webpack_require__(585).refreshPaths;
viz.gauges = {
  __internals: {}
};
viz._dashboard = {};
viz._dashboard.Renderer = __webpack_require__(183).Renderer;
viz._dashboard.SvgElement = __webpack_require__(183).SvgElement;
viz._dashboard.patchFontOptions = __webpack_require__(14).patchFontOptions;
module.exports = viz;

/***/ }),
/* 1030 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(146);

/* global DevExpress */

/* eslint-disable import/no-commonjs */
module.exports = DevExpress.viz = DevExpress.viz || {};

/***/ }),
/* 1031 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _common = __webpack_require__(4);

var _extend2 = __webpack_require__(0);

var _array = __webpack_require__(12);

var _window = __webpack_require__(7);

var _iterator = __webpack_require__(3);

var _component_registrator = _interopRequireDefault(__webpack_require__(9));

var _utils = __webpack_require__(585);

var _utils2 = __webpack_require__(14);

var _type = __webpack_require__(1);

var _math = __webpack_require__(31);

var _base_chart = __webpack_require__(342);

var _multi_axes_synchronizer = _interopRequireDefault(__webpack_require__(1055));

var _advanced_chart = __webpack_require__(593);

var _scroll_bar = __webpack_require__(1064);

var _crosshair = __webpack_require__(600);

var _range_data_calculator = _interopRequireDefault(__webpack_require__(241));

var _layout_manager = __webpack_require__(591);

var _range = __webpack_require__(141);

var _shutter_zoom = _interopRequireDefault(__webpack_require__(1065));

var _zoom_and_pan = _interopRequireDefault(__webpack_require__(1066));

var _annotations = __webpack_require__(244);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_PANE_NAME = 'default';
var VISUAL_RANGE = 'VISUAL_RANGE';
var DEFAULT_PANES = [{
  name: DEFAULT_PANE_NAME,
  border: {}
}];
var DISCRETE = 'discrete';
var _isArray = Array.isArray;

function getFirstAxisNameForPane(axes, paneName, defaultPane) {
  var result;

  for (var i = 0; i < axes.length; i++) {
    if (axes[i].pane === paneName || axes[i].pane === undefined && paneName === defaultPane) {
      result = axes[i].name;
      break;
    }
  }

  if (!result) {
    result = axes[0].name;
  }

  return result;
}

function changeVisibilityAxisGrids(axis, gridVisibility, minorGridVisibility) {
  var gridOpt = axis.getOptions().grid;
  var minorGridOpt = axis.getOptions().minorGrid;
  gridOpt.visible = gridVisibility;
  minorGridOpt && (minorGridOpt.visible = minorGridVisibility);
}

function hideGridsOnNonFirstValueAxisForPane(axesForPane) {
  var axisShown = false;
  var hiddenStubAxis = [];
  var minorGridVisibility = axesForPane.some(function (axis) {
    var minorGridOptions = axis.getOptions().minorGrid;
    return minorGridOptions && minorGridOptions.visible;
  });
  var gridVisibility = axesForPane.some(function (axis) {
    var gridOptions = axis.getOptions().grid;
    return gridOptions && gridOptions.visible;
  });

  if (axesForPane.length > 1) {
    axesForPane.forEach(function (axis) {
      var gridOpt = axis.getOptions().grid;

      if (axisShown) {
        changeVisibilityAxisGrids(axis, false, false);
      } else if (gridOpt && gridOpt.visible) {
        if (axis.getTranslator().getBusinessRange().isEmpty()) {
          changeVisibilityAxisGrids(axis, false, false);
          hiddenStubAxis.push(axis);
        } else {
          axisShown = true;
          changeVisibilityAxisGrids(axis, gridVisibility, minorGridVisibility);
        }
      }
    });
    !axisShown && hiddenStubAxis.length && changeVisibilityAxisGrids(hiddenStubAxis[0], gridVisibility, minorGridVisibility);
  }
}

function findAxisOptions(valueAxes, valueAxesOptions, axisName) {
  var result;
  var axInd;

  for (axInd = 0; axInd < valueAxesOptions.length; axInd++) {
    if (valueAxesOptions[axInd].name === axisName) {
      result = valueAxesOptions[axInd];
      result.priority = axInd;
      break;
    }
  }

  if (!result) {
    for (axInd = 0; axInd < valueAxes.length; axInd++) {
      if (valueAxes[axInd].name === axisName) {
        result = valueAxes[axInd].getOptions();
        result.priority = valueAxes[axInd].priority;
        break;
      }
    }
  }

  return result;
}

function findAxis(paneName, axisName, axes) {
  var axis;
  var i;

  for (i = 0; i < axes.length; i++) {
    axis = axes[i];

    if (axis.name === axisName && axis.pane === paneName) {
      return axis;
    }
  }

  if (paneName) {
    return findAxis(undefined, axisName, axes);
  }
}

function compareAxes(a, b) {
  return a.priority - b.priority;
} // checks if pane with provided name exists in this panes array


function doesPaneExist(panes, paneName) {
  var found = false;
  (0, _iterator.each)(panes, function (_, pane) {
    if (pane.name === paneName) {
      found = true;
      return false;
    }
  });
  return found;
} // utilities used in axes rendering


function accumulate(field, src1, src2, auxSpacing) {
  var val1 = src1[field] || 0;
  var val2 = src2[field] || 0;
  return val1 + val2 + (val1 && val2 ? auxSpacing : 0);
}

function pickMax(field, src1, src2) {
  return pickMaxValue(src1[field], src2[field]);
}

function pickMaxValue(val1, val2) {
  return Math.max(val1 || 0, val2 || 0);
}

function getAxisMargins(axis) {
  return axis.getMargins();
}

function getHorizontalAxesMargins(axes, getMarginsFunc) {
  return axes.reduce(function (margins, axis) {
    var _axis$getOrthogonalAx;

    var axisMargins = getMarginsFunc(axis);
    var paneMargins = margins.panes[axis.pane] = margins.panes[axis.pane] || {};
    var spacing = axis.getMultipleAxesSpacing();
    paneMargins.top = accumulate('top', paneMargins, axisMargins, spacing);
    paneMargins.bottom = accumulate('bottom', paneMargins, axisMargins, spacing);
    paneMargins.left = pickMax('left', paneMargins, axisMargins);
    paneMargins.right = pickMax('right', paneMargins, axisMargins);
    margins.top = pickMax('top', paneMargins, margins);
    margins.bottom = pickMax('bottom', paneMargins, margins);
    margins.left = pickMax('left', paneMargins, margins);
    margins.right = pickMax('right', paneMargins, margins);
    var orthogonalAxis = (_axis$getOrthogonalAx = axis.getOrthogonalAxis) === null || _axis$getOrthogonalAx === void 0 ? void 0 : _axis$getOrthogonalAx.call(axis);

    if (orthogonalAxis && orthogonalAxis.customPositionIsAvailable() && (!axis.customPositionIsBoundaryOrthogonalAxis() || !orthogonalAxis.customPositionEqualsToPredefined())) {
      margins[orthogonalAxis.getResolvedBoundaryPosition()] = 0;
    }

    return margins;
  }, {
    panes: {}
  });
}

function getVerticalAxesMargins(axes) {
  return axes.reduce(function (margins, axis) {
    var axisMargins = axis.getMargins();
    var paneMargins = margins.panes[axis.pane] = margins.panes[axis.pane] || {};
    var spacing = axis.getMultipleAxesSpacing();
    paneMargins.top = pickMax('top', paneMargins, axisMargins);
    paneMargins.bottom = pickMax('bottom', paneMargins, axisMargins);
    paneMargins.left = accumulate('left', paneMargins, axisMargins, spacing);
    paneMargins.right = accumulate('right', paneMargins, axisMargins, spacing);
    margins.top = pickMax('top', paneMargins, margins);
    margins.bottom = pickMax('bottom', paneMargins, margins);
    margins.left = pickMax('left', paneMargins, margins);
    margins.right = pickMax('right', paneMargins, margins);
    return margins;
  }, {
    panes: {}
  });
}

function performActionOnAxes(axes, action, actionArgument1, actionArgument2, actionArgument3) {
  axes.forEach(function (axis) {
    axis[action](actionArgument1 && actionArgument1[axis.pane], actionArgument2 && actionArgument2[axis.pane] || actionArgument2, actionArgument3);
  });
}

function shrinkCanvases(isRotated, canvases, sizes, verticalMargins, horizontalMargins) {
  function getMargin(side, margins, pane) {
    var m = (isRotated ? ['left', 'right'] : ['top', 'bottom']).indexOf(side) === -1 ? margins : margins.panes[pane] || {};
    return m[side];
  }

  function getMaxMargin(side, margins1, margins2, pane) {
    return pickMaxValue(getMargin(side, margins1, pane), getMargin(side, margins2, pane));
  }

  var getOriginalField = function getOriginalField(field) {
    return "original".concat(field[0].toUpperCase()).concat(field.slice(1));
  };

  function shrink(canvases, paneNames, sizeField, startMargin, endMargin, oppositeMargins) {
    paneNames = paneNames.sort(function (p1, p2) {
      return canvases[p2][startMargin] - canvases[p1][startMargin];
    });
    paneNames.forEach(function (pane) {
      var canvas = canvases[pane];
      oppositeMargins.forEach(function (margin) {
        canvas[margin] = canvas[getOriginalField(margin)] + getMaxMargin(margin, verticalMargins, horizontalMargins, pane);
      });
    });
    var firstPane = canvases[paneNames[0]];
    var emptySpace = paneNames.reduce(function (space, paneName) {
      space -= getMaxMargin(startMargin, verticalMargins, horizontalMargins, paneName) + getMaxMargin(endMargin, verticalMargins, horizontalMargins, paneName);
      return space;
    }, firstPane[sizeField] - firstPane[getOriginalField(endMargin)] - canvases[paneNames[paneNames.length - 1]][getOriginalField(startMargin)]) - _utils2.PANE_PADDING * (paneNames.length - 1);
    emptySpace -= Object.keys(sizes).reduce(function (prev, key) {
      return prev + (!(0, _utils2.isRelativeHeightPane)(sizes[key]) ? sizes[key].height : 0);
    }, 0);
    paneNames.reduce(function (offset, pane) {
      var canvas = canvases[pane];
      var paneSize = sizes[pane];
      offset -= getMaxMargin(endMargin, verticalMargins, horizontalMargins, pane);
      canvas[endMargin] = firstPane[sizeField] - offset;
      offset -= !(0, _utils2.isRelativeHeightPane)(paneSize) ? paneSize.height : Math.floor(emptySpace * paneSize.height);
      canvas[startMargin] = offset;
      offset -= getMaxMargin(startMargin, verticalMargins, horizontalMargins, pane) + _utils2.PANE_PADDING;
      return offset;
    }, firstPane[sizeField] - firstPane[getOriginalField(endMargin)] - (emptySpace < 0 ? emptySpace : 0));
  }

  var paneNames = Object.keys(canvases);

  if (!isRotated) {
    shrink(canvases, paneNames, 'height', 'top', 'bottom', ['left', 'right']);
  } else {
    shrink(canvases, paneNames, 'width', 'left', 'right', ['top', 'bottom']);
  }

  return canvases;
}

function drawAxesWithTicks(axes, condition, canvases, panesBorderOptions) {
  if (condition) {
    performActionOnAxes(axes, 'createTicks', canvases);

    _multi_axes_synchronizer.default.synchronize(axes);
  }

  performActionOnAxes(axes, 'draw', !condition && canvases, panesBorderOptions);
}

function shiftAxis(side1, side2) {
  var shifts = {};
  return function (axis) {
    if (!axis.customPositionIsAvailable() || axis.customPositionEqualsToPredefined()) {
      var shift = shifts[axis.pane] = shifts[axis.pane] || {
        top: 0,
        left: 0,
        bottom: 0,
        right: 0
      };
      var spacing = axis.getMultipleAxesSpacing();
      var margins = axis.getMargins();
      axis.shift(shift);
      shift[side1] = accumulate(side1, shift, margins, spacing);
      shift[side2] = accumulate(side2, shift, margins, spacing);
    } else {
      axis.shift({
        top: 0,
        left: 0,
        bottom: 0,
        right: 0
      });
    }
  };
}

function getCommonSize(side, margins) {
  var size = 0;
  var pane;
  var paneMargins;

  for (pane in margins.panes) {
    paneMargins = margins.panes[pane];
    size = size + (side === 'height' ? paneMargins.top + paneMargins.bottom : paneMargins.left + paneMargins.right);
  }

  return size;
}

function checkUsedSpace(sizeShortage, side, axes, getMarginFunc) {
  var size = 0;

  if (sizeShortage[side] > 0) {
    size = getCommonSize(side, getMarginFunc(axes, getAxisMargins));
    performActionOnAxes(axes, 'hideTitle');
    sizeShortage[side] -= size - getCommonSize(side, getMarginFunc(axes, getAxisMargins));
  }

  if (sizeShortage[side] > 0) {
    performActionOnAxes(axes, 'hideOuterElements');
  }
}

function axisAnimationEnabled(drawOptions, pointsToAnimation) {
  var pointsCount = pointsToAnimation.reduce(function (sum, count) {
    return sum + count;
  }, 0) / pointsToAnimation.length;
  return drawOptions.animate && pointsCount <= drawOptions.animationPointsLimit;
}

function collectMarkersInfoBySeries(allSeries, filteredSeries, argAxis) {
  var series = [];
  var overloadedSeries = {};
  var argVisualRange = argAxis.visualRange();
  var argTranslator = argAxis.getTranslator();

  var argViewPortFilter = _range_data_calculator.default.getViewPortFilter(argVisualRange || {});

  filteredSeries.forEach(function (s) {
    var valAxis = s.getValueAxis();
    var valVisualRange = valAxis.getCanvasRange();
    var valTranslator = valAxis.getTranslator();
    var seriesIndex = allSeries.indexOf(s);

    var valViewPortFilter = _range_data_calculator.default.getViewPortFilter(valVisualRange || {});

    overloadedSeries[seriesIndex] = {};
    filteredSeries.forEach(function (sr) {
      return overloadedSeries[seriesIndex][allSeries.indexOf(sr)] = 0;
    });
    var seriesPoints = [];
    s.getPoints().filter(function (p) {
      return p.getOptions().visible && argViewPortFilter(p.argument) && (valViewPortFilter(p.getMinValue(true)) || valViewPortFilter(p.getMaxValue(true)));
    }).forEach(function (p) {
      var tp = {
        seriesIndex: seriesIndex,
        argument: p.argument,
        value: p.getMaxValue(true),
        size: p.bubbleSize || p.getOptions().size
      };

      if (p.getMinValue(true) !== p.getMaxValue(true)) {
        var mp = (0, _extend2.extend)({}, tp);
        mp.value = p.getMinValue(true);
        mp.x = argTranslator.to(mp.argument, 1);
        mp.y = valTranslator.to(mp.value, 1);
        seriesPoints.push(mp);
      }

      tp.x = argTranslator.to(tp.argument, 1);
      tp.y = valTranslator.to(tp.value, 1);
      seriesPoints.push(tp);
    });
    overloadedSeries[seriesIndex].pointsCount = seriesPoints.length;
    overloadedSeries[seriesIndex].total = 0;
    overloadedSeries[seriesIndex].continuousSeries = 0;
    series.push({
      name: s.name,
      index: seriesIndex,
      points: seriesPoints
    });
  });
  return {
    series: series,
    overloadedSeries: overloadedSeries
  };
}

function applyAutoHidePointMarkers(allSeries, filteredSeries, overloadedSeries, argAxis) {
  var argAxisType = argAxis.getOptions().type;
  filteredSeries.forEach(function (s) {
    var seriesIndex = allSeries.indexOf(s);
    s.autoHidePointMarkers = false;
    var tickCount = argAxis.getTicksValues().majorTicksValues.length;

    if (s.autoHidePointMarkersEnabled() && (argAxisType === DISCRETE || overloadedSeries[seriesIndex].pointsCount > tickCount)) {
      for (var index in overloadedSeries[seriesIndex]) {
        var i = parseInt(index);

        if (isNaN(i) || overloadedSeries[seriesIndex].total / overloadedSeries[seriesIndex].continuousSeries < 3) {
          continue;
        }

        if (i === seriesIndex) {
          if (overloadedSeries[i][i] * 2 >= overloadedSeries[i].pointsCount) {
            s.autoHidePointMarkers = true;
            break;
          }
        } else if (overloadedSeries[seriesIndex].total >= overloadedSeries[seriesIndex].pointsCount) {
          s.autoHidePointMarkers = true;
          break;
        }
      }
    }
  });
}

function fastHidingPointMarkersByArea(canvas, markersInfo, series) {
  var area = canvas.width * canvas.height;
  var seriesPoints = markersInfo.series;

  var _loop = function _loop(i) {
    var currentSeries = series.filter(function (s) {
      return s.name === seriesPoints[i].name;
    })[0];
    var points = seriesPoints[i].points;
    var pointSize = points.length ? points[0].size : 0;
    var pointsArea = pointSize * pointSize * points.length;

    if (currentSeries.autoHidePointMarkersEnabled() && pointsArea >= area / seriesPoints.length) {
      var index = seriesPoints[i].index;
      currentSeries.autoHidePointMarkers = true;
      seriesPoints.splice(i, 1);
      series.splice(series.indexOf(currentSeries), 1);
      delete markersInfo.overloadedSeries[index];
    }
  };

  for (var i = seriesPoints.length - 1; i >= 0; i--) {
    _loop(i);
  }
}

function updateMarkersInfo(points, overloadedSeries) {
  var isContinuousSeries = false;

  for (var i = 0; i < points.length - 1; i++) {
    var curPoint = points[i];
    var size = curPoint.size;

    if ((0, _type.isDefined)(curPoint.x) && (0, _type.isDefined)(curPoint.y)) {
      for (var j = i + 1; j < points.length; j++) {
        var nextPoint = points[j];
        var next_x = nextPoint === null || nextPoint === void 0 ? void 0 : nextPoint.x;
        var next_y = nextPoint === null || nextPoint === void 0 ? void 0 : nextPoint.y;

        if (!(0, _type.isDefined)(next_x) || Math.abs(curPoint.x - next_x) >= size) {
          isContinuousSeries &= j !== i + 1;
          break;
        } else {
          var distance = (0, _type.isDefined)(next_x) && (0, _type.isDefined)(next_y) && Math.sqrt(Math.pow(curPoint.x - next_x, 2) + Math.pow(curPoint.y - next_y, 2));

          if (distance && distance < size) {
            overloadedSeries[curPoint.seriesIndex][nextPoint.seriesIndex]++;
            overloadedSeries[curPoint.seriesIndex].total++;

            if (!isContinuousSeries) {
              overloadedSeries[curPoint.seriesIndex].continuousSeries++;
              isContinuousSeries = true;
            }
          }
        }
      }
    }
  }
} // utilities used in axes rendering


var dxChart = _advanced_chart.AdvancedChart.inherit({
  _themeSection: 'chart',
  _fontFields: ['crosshair.label.font'],
  _initCore: function _initCore() {
    this.paneAxis = {};
    this.callBase();
  },
  _init: function _init() {
    this._containerInitialHeight = (0, _window.hasWindow)() ? this._$element.height() : 0;
    this.callBase();
  },
  _correctAxes: function _correctAxes() {
    this._correctValueAxes(true);
  },
  _getExtraOptions: _common.noop,
  _createPanes: function _createPanes() {
    var that = this;
    var panes = that.option('panes');
    var panesNameCounter = 0;
    var defaultPane;

    if (!panes || _isArray(panes) && !panes.length) {
      panes = DEFAULT_PANES;
    }

    that.callBase();
    defaultPane = that.option('defaultPane');
    panes = (0, _extend2.extend)(true, [], _isArray(panes) ? panes : [panes]);
    (0, _iterator.each)(panes, function (_, pane) {
      pane.name = !(0, _type.isDefined)(pane.name) ? DEFAULT_PANE_NAME + panesNameCounter++ : pane.name;
    });

    if ((0, _type.isDefined)(defaultPane)) {
      if (!doesPaneExist(panes, defaultPane)) {
        that._incidentOccurred('W2101', [defaultPane]);

        defaultPane = panes[panes.length - 1].name;
      }
    } else {
      defaultPane = panes[panes.length - 1].name;
    }

    that.defaultPane = defaultPane;
    panes = that._isRotated() ? panes.reverse() : panes;
    return panes;
  },
  _getAxisRenderingOptions: function _getAxisRenderingOptions() {
    return {
      axisType: 'xyAxes',
      drawingType: 'linear'
    };
  },
  _prepareAxisOptions: function _prepareAxisOptions(typeSelector, userOptions, rotated) {
    return {
      isHorizontal: typeSelector === 'argumentAxis' !== rotated,
      containerColor: this._themeManager.getOptions('containerBackgroundColor')
    };
  },
  _checkPaneName: function _checkPaneName(seriesTheme) {
    var paneList = (0, _utils2.map)(this.panes, function (pane) {
      return pane.name;
    });
    seriesTheme.pane = seriesTheme.pane || this.defaultPane;
    return (0, _array.inArray)(seriesTheme.pane, paneList) !== -1;
  },
  _initCustomPositioningAxes: function _initCustomPositioningAxes() {
    var that = this;
    var argumentAxis = that.getArgumentAxis();
    var valueAxisName = argumentAxis.getOptions().customPositionAxis;

    var valueAxis = that._valueAxes.filter(function (v) {
      return v.pane === argumentAxis.pane && (!valueAxisName || valueAxisName === v.name);
    })[0];

    that._valueAxes.forEach(function (v) {
      if (argumentAxis !== v.getOrthogonalAxis()) {
        v.getOrthogonalAxis = function () {
          return argumentAxis;
        };

        v.customPositionIsBoundaryOrthogonalAxis = function () {
          return argumentAxis.customPositionIsBoundary();
        };
      }
    });

    if ((0, _type.isDefined)(valueAxis) && valueAxis !== argumentAxis.getOrthogonalAxis()) {
      argumentAxis.getOrthogonalAxis = function () {
        return valueAxis;
      };

      argumentAxis.customPositionIsBoundaryOrthogonalAxis = function () {
        return that._valueAxes.some(function (v) {
          return v.customPositionIsBoundary();
        });
      };
    } else if ((0, _type.isDefined)(argumentAxis.getOrthogonalAxis()) && !(0, _type.isDefined)(valueAxis)) {
      argumentAxis.getOrthogonalAxis = _common.noop;
    }
  },
  _getAllAxes: function _getAllAxes() {
    return this._argumentAxes.concat(this._valueAxes);
  },
  _resetAxesAnimation: function _resetAxesAnimation(isFirstDrawing, isHorizontal) {
    var axes = (0, _type.isDefined)(isHorizontal) ? isHorizontal ^ this._isRotated() ? this._argumentAxes : this._valueAxes : this._getAllAxes();
    axes.forEach(function (a) {
      a.resetApplyingAnimation(isFirstDrawing);
    });
  },
  _axesBoundaryPositioning: function _axesBoundaryPositioning() {
    var that = this;

    var allAxes = that._getAllAxes();

    var boundaryStateChanged = false;
    allAxes.forEach(function (a) {
      if (!a.customPositionIsAvailable()) {
        return false;
      }

      var prevBoundaryState = a.customPositionIsBoundary();
      a._customBoundaryPosition = a.getCustomBoundaryPosition();
      boundaryStateChanged |= prevBoundaryState !== a.customPositionIsBoundary();
    });
    return boundaryStateChanged;
  },
  _getValueAxis: function _getValueAxis(paneName, axisName) {
    var that = this;
    var valueAxes = that._valueAxes;
    var valueAxisOptions = that.option('valueAxis') || {};
    var valueAxesOptions = _isArray(valueAxisOptions) ? valueAxisOptions : [valueAxisOptions];

    var rotated = that._isRotated();

    var crosshairMargins = that._getCrosshairMargins();

    var axisOptions;
    var axis;
    axisName = axisName || getFirstAxisNameForPane(valueAxes, paneName, that.defaultPane);
    axis = findAxis(paneName, axisName, valueAxes);

    if (!axis) {
      axisOptions = findAxisOptions(valueAxes, valueAxesOptions, axisName);

      if (!axisOptions) {
        that._incidentOccurred('W2102', [axisName]);

        axisOptions = {
          name: axisName,
          priority: valueAxes.length
        };
      }

      axis = that._createAxis(false, that._populateAxesOptions('valueAxis', axisOptions, {
        pane: paneName,
        name: axisName,
        optionPath: _isArray(valueAxisOptions) ? "valueAxis[".concat(axisOptions.priority, "]") : 'valueAxis',
        crosshairMargin: rotated ? crosshairMargins.y : crosshairMargins.x
      }, rotated));
      axis.applyVisualRangeSetter(that._getVisualRangeSetter());
      valueAxes.push(axis);
    }

    axis.setPane(paneName);
    return axis;
  },
  _correctValueAxes: function _correctValueAxes(needHideGrids) {
    var that = this;

    var synchronizeMultiAxes = that._themeManager.getOptions('synchronizeMultiAxes');

    var valueAxes = that._valueAxes;
    var paneWithAxis = {};
    that.series.forEach(function (series) {
      var axis = series.getValueAxis();
      paneWithAxis[axis.pane] = true;
    });
    that.panes.forEach(function (pane) {
      var paneName = pane.name;

      if (!paneWithAxis[paneName]) {
        that._getValueAxis(paneName); // creates an value axis if there is no one for pane

      }

      if (needHideGrids && synchronizeMultiAxes) {
        hideGridsOnNonFirstValueAxisForPane(valueAxes.filter(function (axis) {
          return axis.pane === paneName;
        }));
      }
    });
    that._valueAxes = valueAxes.filter(function (axis) {
      if (!axis.pane) {
        axis.setPane(that.defaultPane);
      }

      return doesPaneExist(that.panes, axis.pane);
    }).sort(compareAxes);
    var defaultAxis = this.getValueAxis();

    that._valueAxes.forEach(function (axis) {
      var optionPath = axis.getOptions().optionPath;

      if (optionPath) {
        var axesWithSamePath = that._valueAxes.filter(function (a) {
          return a.getOptions().optionPath === optionPath;
        });

        if (axesWithSamePath.length > 1) {
          if (axesWithSamePath.some(function (a) {
            return a === defaultAxis;
          })) {
            axesWithSamePath.forEach(function (a) {
              if (a !== defaultAxis) {
                a.getOptions().optionPath = null;
              }
            });
          } else {
            axesWithSamePath.forEach(function (a, i) {
              if (i !== 0) {
                a.getOptions().optionPath = null;
              }
            });
          }
        }
      }
    });
  },
  _getSeriesForPane: function _getSeriesForPane(paneName) {
    var paneSeries = [];
    (0, _iterator.each)(this.series, function (_, oneSeries) {
      if (oneSeries.pane === paneName) {
        paneSeries.push(oneSeries);
      }
    });
    return paneSeries;
  },
  _createPanesBorderOptions: function _createPanesBorderOptions() {
    var commonBorderOptions = this._themeManager.getOptions('commonPaneSettings').border;

    var panesBorderOptions = {};
    this.panes.forEach(function (pane) {
      return panesBorderOptions[pane.name] = (0, _extend2.extend)(true, {}, commonBorderOptions, pane.border);
    });
    return panesBorderOptions;
  },
  _createScrollBar: function _createScrollBar() {
    var that = this;
    var scrollBarOptions = that._themeManager.getOptions('scrollBar') || {};
    var scrollBarGroup = that._scrollBarGroup;

    if (scrollBarOptions.visible) {
      scrollBarOptions.rotated = that._isRotated();
      that._scrollBar = (that._scrollBar || new _scroll_bar.ScrollBar(that._renderer, scrollBarGroup)).update(scrollBarOptions);
    } else {
      scrollBarGroup.linkRemove();
      that._scrollBar && that._scrollBar.dispose();
      that._scrollBar = null;
    }
  },
  _executeAppendAfterSeries: function _executeAppendAfterSeries(append) {
    append();
  },
  _prepareToRender: function _prepareToRender(drawOptions) {
    var panesBorderOptions = this._createPanesBorderOptions();

    this._createPanesBackground();

    this._appendAxesGroups();

    this._adjustViewport();

    return panesBorderOptions;
  },
  _adjustViewport: function _adjustViewport() {
    var that = this;

    var adjustOnZoom = that._themeManager.getOptions('adjustOnZoom');

    if (!adjustOnZoom) {
      return;
    }

    that._valueAxes.forEach(function (axis) {
      return axis.adjust();
    });
  },
  _recreateSizeDependentObjects: function _recreateSizeDependentObjects(isCanvasChanged) {
    var that = this;

    var series = that._getVisibleSeries();

    var useAggregation = series.some(function (s) {
      return s.useAggregation();
    });

    var zoomChanged = that._isZooming();

    if (!useAggregation) {
      return;
    }

    that._argumentAxes.forEach(function (axis) {
      axis.updateCanvas(that._canvas, true);
    });

    series.forEach(function (series) {
      if (series.useAggregation() && (isCanvasChanged || zoomChanged || !series._useAllAggregatedPoints)) {
        series.createPoints();
      }
    });

    that._processSeriesFamilies();
  },
  _isZooming: function _isZooming() {
    var that = this;
    var argumentAxis = that.getArgumentAxis();

    if (!argumentAxis || !argumentAxis.getTranslator()) {
      return false;
    }

    var businessRange = argumentAxis.getTranslator().getBusinessRange();
    var zoomRange = argumentAxis.getViewport();
    var min = zoomRange ? zoomRange.min : 0;
    var max = zoomRange ? zoomRange.max : 0;

    if (businessRange.axisType === 'logarithmic') {
      min = (0, _utils2.getLog)(min, businessRange.base);
      max = (0, _utils2.getLog)(max, businessRange.base);
    }

    var viewportDistance = businessRange.axisType === DISCRETE ? (0, _utils2.getCategoriesInfo)(businessRange.categories, min, max).categories.length : Math.abs(max - min);
    var precision = (0, _math.getPrecision)(viewportDistance);
    precision = precision > 1 ? Math.pow(10, precision - 2) : 1;
    var zoomChanged = Math.round((that._zoomLength - viewportDistance) * precision) / precision !== 0;
    that._zoomLength = viewportDistance;
    return zoomChanged;
  },
  _handleSeriesDataUpdated: function _handleSeriesDataUpdated() {
    var that = this;
    var viewport = new _range.Range();
    that.series.forEach(function (s) {
      viewport.addRange(s.getArgumentRange());
    });

    that._argumentAxes.forEach(function (axis) {
      axis.updateCanvas(that._canvas, true);
      axis.setBusinessRange(viewport, that._axesReinitialized);
    });

    that.callBase();
  },
  _isLegendInside: function _isLegendInside() {
    return this._legend && this._legend.getPosition() === 'inside';
  },
  _isRotated: function _isRotated() {
    return this._themeManager.getOptions('rotated');
  },
  _getLayoutTargets: function _getLayoutTargets() {
    return this.panes;
  },
  _applyClipRects: function _applyClipRects(panesBorderOptions) {
    var that = this;

    that._drawPanesBorders(panesBorderOptions);

    that._createClipRectsForPanes();

    that._applyClipRectsForAxes();

    that._fillPanesBackground();
  },
  _updateLegendPosition: function _updateLegendPosition(drawOptions, legendHasInsidePosition) {
    var that = this;

    if (drawOptions.drawLegend && that._legend && legendHasInsidePosition) {
      var panes = that.panes;
      var newCanvas = (0, _extend2.extend)({}, panes[0].canvas);
      var layoutManager = new _layout_manager.LayoutManager();
      newCanvas.right = panes[panes.length - 1].canvas.right;
      newCanvas.bottom = panes[panes.length - 1].canvas.bottom;
      layoutManager.layoutInsideLegend(that._legend, newCanvas);
    }
  },
  _allowLegendInsidePosition: function _allowLegendInsidePosition() {
    return true;
  },
  _applyExtraSettings: function _applyExtraSettings(series) {
    var that = this;

    var paneIndex = that._getPaneIndex(series.pane);

    var panesClipRects = that._panesClipRects;
    var wideClipRect = panesClipRects.wide[paneIndex];
    series.setClippingParams(panesClipRects.base[paneIndex].id, wideClipRect && wideClipRect.id, that._getPaneBorderVisibility(paneIndex));
  },
  _updatePanesCanvases: function _updatePanesCanvases(drawOptions) {
    if (!drawOptions.recreateCanvas) {
      return;
    }

    (0, _utils2.updatePanesCanvases)(this.panes, this._canvas, this._isRotated());
  },
  _normalizePanesHeight: function _normalizePanesHeight() {
    (0, _utils2.normalizePanesHeight)(this.panes);
  },
  _renderScaleBreaks: function _renderScaleBreaks() {
    this._valueAxes.concat(this._argumentAxes).forEach(function (axis) {
      axis.drawScaleBreaks();
    });
  },
  _getArgFilter: function _getArgFilter() {
    return _range_data_calculator.default.getViewPortFilter(this.getArgumentAxis().visualRange() || {});
  },
  _applyPointMarkersAutoHiding: function _applyPointMarkersAutoHiding() {
    var that = this;
    var allSeries = that.series;

    if (!that._themeManager.getOptions('autoHidePointMarkers')) {
      allSeries.forEach(function (s) {
        return s.autoHidePointMarkers = false;
      });
      return;
    }

    that.panes.forEach(function (_ref) {
      var borderCoords = _ref.borderCoords,
          name = _ref.name;
      var series = allSeries.filter(function (s) {
        return s.pane === name && s.usePointsToDefineAutoHiding();
      });
      var argAxis = that.getArgumentAxis();
      var markersInfo = collectMarkersInfoBySeries(allSeries, series, argAxis);
      fastHidingPointMarkersByArea(borderCoords, markersInfo, series);

      if (markersInfo.series.length) {
        var argVisualRange = argAxis.visualRange();
        var argAxisIsDiscrete = argAxis.getOptions().type === DISCRETE;
        var sortingCallback = argAxisIsDiscrete ? function (p1, p2) {
          return argVisualRange.categories.indexOf(p1.argument) - argVisualRange.categories.indexOf(p2.argument);
        } : function (p1, p2) {
          return p1.argument - p2.argument;
        };
        var points = [];
        markersInfo.series.forEach(function (s) {
          return points = points.concat(s.points);
        });
        points.sort(sortingCallback);
        updateMarkersInfo(points, markersInfo.overloadedSeries);
        applyAutoHidePointMarkers(allSeries, series, markersInfo.overloadedSeries, argAxis);
      }
    });
  },
  _renderAxes: function _renderAxes(drawOptions, panesBorderOptions) {
    function calculateTitlesWidth(axes) {
      return axes.map(function (axis) {
        if (!axis.getTitle) return 0;
        var title = axis.getTitle();
        return title ? title.bBox.width : 0;
      });
    }

    var that = this;

    var rotated = that._isRotated();

    var synchronizeMultiAxes = that._themeManager.getOptions('synchronizeMultiAxes');

    var scrollBar = that._scrollBar ? [that._scrollBar] : [];
    var extendedArgAxes = that._isArgumentAxisBeforeScrollBar() ? that._argumentAxes.concat(scrollBar) : scrollBar.concat(that._argumentAxes);
    var verticalAxes = rotated ? that._argumentAxes : that._valueAxes;
    var verticalElements = rotated ? extendedArgAxes : that._valueAxes;
    var horizontalAxes = rotated ? that._valueAxes : that._argumentAxes;
    var horizontalElements = rotated ? that._valueAxes : extendedArgAxes;
    var allAxes = verticalAxes.concat(horizontalAxes);
    var allElements = allAxes.concat(scrollBar);
    var verticalAxesFirstDrawing = verticalAxes.some(function (v) {
      return v.isFirstDrawing();
    });

    that._normalizePanesHeight();

    that._updatePanesCanvases(drawOptions);

    var panesCanvases = that.panes.reduce(function (canvases, pane) {
      canvases[pane.name] = (0, _extend2.extend)({}, pane.canvas);
      return canvases;
    }, {});
    var paneSizes = that.panes.reduce(function (sizes, pane) {
      sizes[pane.name] = {
        height: pane.height,
        unit: pane.unit
      };
      return sizes;
    }, {});
    var cleanPanesCanvases = (0, _extend2.extend)(true, {}, panesCanvases);

    that._initCustomPositioningAxes();

    var needCustomAdjustAxes = that._axesBoundaryPositioning();

    if (!drawOptions.adjustAxes && !needCustomAdjustAxes) {
      drawAxesWithTicks(verticalAxes, !rotated && synchronizeMultiAxes, panesCanvases, panesBorderOptions);
      drawAxesWithTicks(horizontalAxes, rotated && synchronizeMultiAxes, panesCanvases, panesBorderOptions);
      performActionOnAxes(allAxes, 'prepareAnimation');

      that._renderScaleBreaks();

      horizontalAxes.forEach(function (a) {
        return a.resolveOverlappingForCustomPositioning(verticalAxes);
      });
      verticalAxes.forEach(function (a) {
        return a.resolveOverlappingForCustomPositioning(horizontalAxes);
      });
      return false;
    }

    if (needCustomAdjustAxes) {
      allAxes.forEach(function (a) {
        return a.customPositionIsAvailable() && a.shift({
          top: 0,
          left: 0,
          bottom: 0,
          right: 0
        });
      });
    }

    if (that._scrollBar) {
      that._scrollBar.setPane(that.panes);
    }

    var vAxesMargins = {
      panes: {}
    };
    var hAxesMargins = getHorizontalAxesMargins(horizontalElements, function (axis) {
      return axis.estimateMargins(panesCanvases[axis.pane]);
    });
    panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);

    var drawAxesAndSetCanvases = function drawAxesAndSetCanvases(isHorizontal) {
      var axes = isHorizontal ? horizontalAxes : verticalAxes;
      var condition = (isHorizontal ? rotated : !rotated) && synchronizeMultiAxes;
      drawAxesWithTicks(axes, condition, panesCanvases, panesBorderOptions);

      if (isHorizontal) {
        hAxesMargins = getHorizontalAxesMargins(horizontalElements, getAxisMargins);
      } else {
        vAxesMargins = getVerticalAxesMargins(verticalElements);
      }

      panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);
    };

    drawAxesAndSetCanvases(false);
    drawAxesAndSetCanvases(true);

    if (!that._changesApplying && that._estimateTickIntervals(verticalAxes, panesCanvases)) {
      drawAxesAndSetCanvases(false);
    }

    var oldTitlesWidth = calculateTitlesWidth(verticalAxes);

    var visibleSeries = that._getVisibleSeries();

    var pointsToAnimation = that._getPointsToAnimation(visibleSeries);

    var axesIsAnimated = axisAnimationEnabled(drawOptions, pointsToAnimation);
    performActionOnAxes(allElements, 'updateSize', panesCanvases, axesIsAnimated);
    horizontalElements.forEach(shiftAxis('top', 'bottom'));
    verticalElements.forEach(shiftAxis('left', 'right'));

    that._renderScaleBreaks();

    that.panes.forEach(function (pane) {
      (0, _extend2.extend)(pane.canvas, panesCanvases[pane.name]);
    });

    that._valueAxes.forEach(function (axis) {
      axis.setInitRange();
    });

    verticalAxes.forEach(function (axis, i) {
      var _axis$hasWrap;

      if ((_axis$hasWrap = axis.hasWrap) !== null && _axis$hasWrap !== void 0 && _axis$hasWrap.call(axis)) {
        var title = axis.getTitle();
        var newTitleWidth = title ? title.bBox.width : 0;
        var offset = newTitleWidth - oldTitlesWidth[i];

        if (axis.getOptions().position === 'right') {
          vAxesMargins.right += offset;
        } else {
          vAxesMargins.left += offset;
          that.panes.forEach(function (_ref2) {
            var name = _ref2.name;
            return vAxesMargins.panes[name].left += offset;
          });
        }

        panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);
        performActionOnAxes(allElements, 'updateSize', panesCanvases, false, false);
        oldTitlesWidth = calculateTitlesWidth(verticalAxes);
      }
    });

    if (verticalAxes.some(function (v) {
      return v.customPositionIsAvailable() && v.getCustomPosition() !== v._axisPosition;
    })) {
      axesIsAnimated && that._resetAxesAnimation(verticalAxesFirstDrawing, false);
      performActionOnAxes(verticalAxes, 'updateSize', panesCanvases, axesIsAnimated);
    }

    horizontalAxes.forEach(function (a) {
      return a.resolveOverlappingForCustomPositioning(verticalAxes);
    });
    verticalAxes.forEach(function (a) {
      return a.resolveOverlappingForCustomPositioning(horizontalAxes);
    });
    return cleanPanesCanvases;
  },
  _getExtraTemplatesItems: function _getExtraTemplatesItems() {
    var that = this;
    var allAxes = (that._argumentAxes || []).concat(that._valueAxes || []);

    var elements = that._collectTemplatesFromItems(allAxes);

    return {
      items: elements.items,
      groups: elements.groups,
      launchRequest: function launchRequest() {
        allAxes.forEach(function (a) {
          a.setRenderedState(true);
        });
      },
      doneRequest: function doneRequest() {
        allAxes.forEach(function (a) {
          a.setRenderedState(false);
        });
      }
    };
  },
  _estimateTickIntervals: function _estimateTickIntervals(axes, canvases) {
    return axes.some(function (axis) {
      return axis.estimateTickInterval(canvases[axis.pane]);
    });
  },
  checkForMoreSpaceForPanesCanvas: function checkForMoreSpaceForPanesCanvas() {
    var that = this;

    var rotated = that._isRotated();

    var panesAreCustomSized = that.panes.filter(function (p) {
      return p.unit;
    }).length === that.panes.length;
    var needSpace = false;

    if (panesAreCustomSized) {
      var needHorizontalSpace = 0;
      var needVerticalSpace = 0;

      if (rotated) {
        var argAxisRightMargin = that.getArgumentAxis().getMargins().right;
        var rightPanesIndent = Math.min.apply(Math, that.panes.map(function (p) {
          return p.canvas.right;
        }));
        needHorizontalSpace = that._canvas.right + argAxisRightMargin - rightPanesIndent;
      } else {
        var argAxisBottomMargin = that.getArgumentAxis().getMargins().bottom;
        var bottomPanesIndent = Math.min.apply(Math, that.panes.map(function (p) {
          return p.canvas.bottom;
        }));
        needVerticalSpace = that._canvas.bottom + argAxisBottomMargin - bottomPanesIndent;
      }

      needSpace = needHorizontalSpace > 0 || needVerticalSpace > 0 ? {
        width: needHorizontalSpace,
        height: needVerticalSpace
      } : false;

      if (needVerticalSpace !== 0) {
        var realSize = that.getSize();
        var customSize = that.option('size');
        var container = that._$element[0];
        var containerHasStyledHeight = !!parseInt(container.style.height) || that._containerInitialHeight !== 0;

        if (!rotated && !(customSize && customSize.height) && !containerHasStyledHeight) {
          that._forceResize(realSize.width, realSize.height + needVerticalSpace);

          needSpace = false;
        }
      }
    } else {
      needSpace = that.layoutManager.needMoreSpaceForPanesCanvas(that._getLayoutTargets(), rotated, function (pane) {
        return {
          width: rotated && !!pane.unit,
          height: !rotated && !!pane.unit
        };
      });
    }

    return needSpace;
  },
  _forceResize: function _forceResize(width, height) {
    this._renderer.resize(width, height);

    this._updateSize();

    this._setContentSize();

    this._preserveOriginalCanvas();

    this._updateCanvasClipRect(this._canvas);
  },
  _shrinkAxes: function _shrinkAxes(sizeShortage, panesCanvases) {
    if (!sizeShortage || !panesCanvases) {
      return;
    }

    this._renderer.stopAllAnimations(true);

    var that = this;

    var rotated = that._isRotated();

    var scrollBar = that._scrollBar ? [that._scrollBar] : [];
    var extendedArgAxes = that._isArgumentAxisBeforeScrollBar() ? that._argumentAxes.concat(scrollBar) : scrollBar.concat(that._argumentAxes);
    var verticalAxes = rotated ? extendedArgAxes : that._valueAxes;
    var horizontalAxes = rotated ? that._valueAxes : extendedArgAxes;
    var allAxes = verticalAxes.concat(horizontalAxes);

    if (sizeShortage.width || sizeShortage.height) {
      checkUsedSpace(sizeShortage, 'height', horizontalAxes, getHorizontalAxesMargins);
      checkUsedSpace(sizeShortage, 'width', verticalAxes, getVerticalAxesMargins);
      performActionOnAxes(allAxes, 'updateSize', panesCanvases);
      var paneSizes = that.panes.reduce(function (sizes, pane) {
        sizes[pane.name] = {
          height: pane.height,
          unit: pane.unit
        };
        return sizes;
      }, {});
      panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, getVerticalAxesMargins(verticalAxes), getHorizontalAxesMargins(horizontalAxes, getAxisMargins));
      performActionOnAxes(allAxes, 'updateSize', panesCanvases);
      horizontalAxes.forEach(shiftAxis('top', 'bottom'));
      verticalAxes.forEach(shiftAxis('left', 'right'));
      that.panes.forEach(function (pane) {
        return (0, _extend2.extend)(pane.canvas, panesCanvases[pane.name]);
      });
    }
  },
  _isArgumentAxisBeforeScrollBar: function _isArgumentAxisBeforeScrollBar() {
    var that = this;
    var argumentAxis = that.getArgumentAxis();

    if (that._scrollBar) {
      var _argumentAxis$getOpti;

      var argAxisPosition = argumentAxis.getResolvedBoundaryPosition();
      var argAxisLabelPosition = (_argumentAxis$getOpti = argumentAxis.getOptions().label) === null || _argumentAxis$getOpti === void 0 ? void 0 : _argumentAxis$getOpti.position;

      var scrollBarPosition = that._scrollBar.getOptions().position;

      return argumentAxis.hasNonBoundaryPosition() || scrollBarPosition === argAxisPosition && argAxisLabelPosition !== scrollBarPosition;
    }

    return false;
  },
  _getPanesParameters: function _getPanesParameters() {
    var that = this;
    var panes = that.panes;
    var i;
    var params = [];

    for (i = 0; i < panes.length; i++) {
      if (that._getPaneBorderVisibility(i)) {
        params.push({
          coords: panes[i].borderCoords,
          clipRect: that._panesClipRects.fixed[i]
        });
      }
    }

    return params;
  },
  _createCrosshairCursor: function _createCrosshairCursor() {
    var that = this;
    var options = that._themeManager.getOptions('crosshair') || {};
    var argumentAxis = that.getArgumentAxis();
    var axes = !that._isRotated() ? [[argumentAxis], that._valueAxes] : [that._valueAxes, [argumentAxis]];
    var parameters = {
      canvas: that._getCommonCanvas(),
      panes: that._getPanesParameters(),
      axes: axes
    };

    if (!options || !options.enabled) {
      return;
    }

    if (!that._crosshair) {
      that._crosshair = new _crosshair.Crosshair(that._renderer, options, parameters, that._crosshairCursorGroup);
    } else {
      that._crosshair.update(options, parameters);
    }

    that._crosshair.render();
  },
  _getCommonCanvas: function _getCommonCanvas() {
    var i;
    var canvas;
    var commonCanvas;
    var panes = this.panes;

    for (i = 0; i < panes.length; i++) {
      canvas = panes[i].canvas;

      if (!commonCanvas) {
        // TODO
        commonCanvas = (0, _extend2.extend)({}, canvas);
      } else {
        commonCanvas.right = canvas.right;
        commonCanvas.bottom = canvas.bottom;
      }
    }

    return commonCanvas;
  },
  _createPanesBackground: function _createPanesBackground() {
    var that = this;

    var defaultBackgroundColor = that._themeManager.getOptions('commonPaneSettings').backgroundColor;

    var backgroundColor;
    var renderer = that._renderer;
    var rect;
    var i;
    var rects = [];

    that._panesBackgroundGroup.clear();

    for (i = 0; i < that.panes.length; i++) {
      backgroundColor = that.panes[i].backgroundColor || defaultBackgroundColor;

      if (!backgroundColor || backgroundColor === 'none') {
        rects.push(null);
        continue;
      }

      rect = renderer.rect(0, 0, 0, 0).attr({
        fill: backgroundColor,
        'stroke-width': 0
      }).append(that._panesBackgroundGroup);
      rects.push(rect);
    }

    that.panesBackground = rects;
  },
  _fillPanesBackground: function _fillPanesBackground() {
    var that = this;
    var bc;
    (0, _iterator.each)(that.panes, function (i, pane) {
      bc = pane.borderCoords;

      if (that.panesBackground[i] !== null) {
        that.panesBackground[i].attr({
          x: bc.left,
          y: bc.top,
          width: bc.width,
          height: bc.height
        });
      }
    });
  },
  _calcPaneBorderCoords: function _calcPaneBorderCoords(pane) {
    var canvas = pane.canvas;
    var bc = pane.borderCoords = pane.borderCoords || {};
    bc.left = canvas.left;
    bc.top = canvas.top;
    bc.right = canvas.width - canvas.right;
    bc.bottom = canvas.height - canvas.bottom;
    bc.width = Math.max(bc.right - bc.left, 0);
    bc.height = Math.max(bc.bottom - bc.top, 0);
  },
  _drawPanesBorders: function _drawPanesBorders(panesBorderOptions) {
    var that = this;

    var rotated = that._isRotated();

    that._panesBorderGroup.linkRemove().clear();

    (0, _iterator.each)(that.panes, function (i, pane) {
      var borderOptions = panesBorderOptions[pane.name];
      var attr = {
        fill: 'none',
        stroke: borderOptions.color,
        'stroke-opacity': borderOptions.opacity,
        'stroke-width': borderOptions.width,
        dashStyle: borderOptions.dashStyle,
        'stroke-linecap': 'square'
      };

      that._calcPaneBorderCoords(pane, rotated);

      if (!borderOptions.visible) {
        return;
      }

      var bc = pane.borderCoords;
      var segmentRectParams = (0, _utils.prepareSegmentRectPoints)(bc.left, bc.top, bc.width, bc.height, borderOptions);

      that._renderer.path(segmentRectParams.points, segmentRectParams.pathType).attr(attr).append(that._panesBorderGroup);
    });

    that._panesBorderGroup.linkAppend();
  },
  _createClipRect: function _createClipRect(clipArray, index, left, top, width, height) {
    var that = this;
    var clipRect = clipArray[index];

    if (!clipRect) {
      clipRect = that._renderer.clipRect(left, top, width, height);
      clipArray[index] = clipRect;
    } else {
      clipRect.attr({
        x: left,
        y: top,
        width: width,
        height: height
      });
    }
  },
  _createClipRectsForPanes: function _createClipRectsForPanes() {
    var that = this;
    var canvas = that._canvas;
    (0, _iterator.each)(that.panes, function (i, pane) {
      var needWideClipRect = false;
      var bc = pane.borderCoords;
      var left = bc.left;
      var top = bc.top;
      var width = bc.width;
      var height = bc.height;
      var panesClipRects = that._panesClipRects;

      that._createClipRect(panesClipRects.fixed, i, left, top, width, height);

      that._createClipRect(panesClipRects.base, i, left, top, width, height);

      (0, _iterator.each)(that.series, function (_, series) {
        if (series.pane === pane.name && (series.isFinancialSeries() || series.areErrorBarsVisible())) {
          needWideClipRect = true;
        }
      });

      if (needWideClipRect) {
        if (that._isRotated()) {
          top = 0;
          height = canvas.height;
        } else {
          left = 0;
          width = canvas.width;
        }

        that._createClipRect(panesClipRects.wide, i, left, top, width, height);
      } else {
        panesClipRects.wide[i] = null;
      }
    });
  },
  _applyClipRectsForAxes: function _applyClipRectsForAxes() {
    var that = this;

    var axes = that._getAllAxes();

    var chartCanvasClipRectID = that._getCanvasClipRectID();

    for (var i = 0; i < axes.length; i++) {
      var elementsClipRectID = that._getElementsClipRectID(axes[i].pane);

      axes[i].applyClipRects(elementsClipRectID, chartCanvasClipRectID);
    }
  },
  _getPaneBorderVisibility: function _getPaneBorderVisibility(paneIndex) {
    var commonPaneBorderVisible = this._themeManager.getOptions('commonPaneSettings').border.visible;

    var pane = this.panes[paneIndex] || {};
    var paneBorder = pane.border || {};
    return 'visible' in paneBorder ? paneBorder.visible : commonPaneBorderVisible;
  },
  _getCanvasForPane: function _getCanvasForPane(paneName) {
    var panes = this.panes;
    var panesNumber = panes.length;
    var i;

    for (i = 0; i < panesNumber; i++) {
      if (panes[i].name === paneName) {
        return panes[i].canvas;
      }
    }
  },
  _getTrackerSettings: function _getTrackerSettings() {
    var that = this;
    var themeManager = that._themeManager;
    return (0, _extend2.extend)(this.callBase(), {
      chart: that,
      rotated: that._isRotated(),
      crosshair: that._getCrosshairOptions().enabled ? that._crosshair : null,
      stickyHovering: themeManager.getOptions('stickyHovering')
    });
  },
  _resolveLabelOverlappingStack: function _resolveLabelOverlappingStack() {
    var that = this;

    var isRotated = that._isRotated();

    var shiftDirection = isRotated ? function (box, length) {
      return {
        x: box.x - length,
        y: box.y
      };
    } : function (box, length) {
      return {
        x: box.x,
        y: box.y - length
      };
    };
    (0, _iterator.each)(that._getStackPoints(), function (_, stacks) {
      (0, _iterator.each)(stacks, function (_, points) {
        _base_chart.overlapping.resolveLabelOverlappingInOneDirection(points, that._getCommonCanvas(), isRotated, shiftDirection, function (a, b) {
          var coordPosition = isRotated ? 1 : 0;
          var figureCenter1 = a.labels[0].getFigureCenter()[coordPosition];
          var figureCenter12 = b.labels[0].getFigureCenter()[coordPosition];

          if (figureCenter1 - figureCenter12 === 0) {
            return (a.value() - b.value()) * (a.labels[0].getPoint().series.getValueAxis().getTranslator().isInverted() ? -1 : 1);
          }

          return 0;
        });
      });
    });
  },
  _getStackPoints: function _getStackPoints() {
    var stackPoints = {};

    var visibleSeries = this._getVisibleSeries();

    (0, _iterator.each)(visibleSeries, function (_, singleSeries) {
      var points = singleSeries.getPoints();
      var stackName = singleSeries.getStackName() || null;
      (0, _iterator.each)(points, function (_, point) {
        var argument = point.argument;

        if (!stackPoints[argument]) {
          stackPoints[argument] = {};
        }

        if (!stackPoints[argument][stackName]) {
          stackPoints[argument][stackName] = [];
        }

        stackPoints[argument][stackName].push(point);
      });
    });
    return stackPoints;
  },
  _getCrosshairOptions: function _getCrosshairOptions() {
    return this._getOption('crosshair');
  },
  // API
  zoomArgument: function zoomArgument(min, max) {
    var that = this;

    if (!that._initialized || !(0, _type.isDefined)(min) && !(0, _type.isDefined)(max)) {
      return;
    }

    that.getArgumentAxis().visualRange([min, max]);
  },
  resetVisualRange: function resetVisualRange() {
    var that = this;
    var axes = that._argumentAxes;
    var nonVirtualArgumentAxis = that.getArgumentAxis();
    axes.forEach(function (axis) {
      axis.resetVisualRange(nonVirtualArgumentAxis !== axis);

      that._applyCustomVisualRangeOption(axis);
    });
    that.callBase();
  },
  // T218011 for dashboards
  getVisibleArgumentBounds: function getVisibleArgumentBounds() {
    var translator = this._argumentAxes[0].getTranslator();

    var range = translator.getBusinessRange();
    var isDiscrete = range.axisType === DISCRETE;
    var categories = range.categories;
    return {
      minVisible: isDiscrete ? range.minVisible || categories[0] : range.minVisible,
      maxVisible: isDiscrete ? range.maxVisible || categories[categories.length - 1] : range.maxVisible
    };
  },
  _change_FULL_RENDER: function _change_FULL_RENDER() {
    this.callBase();

    if (this._changes.has(VISUAL_RANGE)) {
      this._raiseZoomEndHandlers();
    }
  },
  _getAxesForScaling: function _getAxesForScaling() {
    return [this.getArgumentAxis()].concat(this._valueAxes);
  },
  _applyVisualRangeByVirtualAxes: function _applyVisualRangeByVirtualAxes(axis, range) {
    var that = this;

    if (axis.isArgumentAxis) {
      if (axis !== that.getArgumentAxis()) {
        return true;
      }

      that._argumentAxes.filter(function (a) {
        return a !== axis;
      }).forEach(function (a) {
        return a.visualRange(range, {
          start: true,
          end: true
        });
      });
    }

    return false;
  },
  _raiseZoomEndHandlers: function _raiseZoomEndHandlers() {
    this._argumentAxes.forEach(function (axis) {
      return axis.handleZoomEnd();
    });

    this.callBase();
  },
  _setOptionsByReference: function _setOptionsByReference() {
    this.callBase();
    (0, _extend2.extend)(this._optionsByReference, {
      'argumentAxis.visualRange': true
    });
  },
  option: function option() {
    var option = this.callBase.apply(this, arguments);

    var valueAxis = this._options.silent('valueAxis');

    if ((0, _type.type)(valueAxis) === 'array') {
      for (var i = 0; i < valueAxis.length; i++) {
        var optionPath = "valueAxis[".concat(i, "].visualRange");
        this._optionsByReference[optionPath] = true;
      }
    }

    return option;
  },
  _notifyVisualRange: function _notifyVisualRange() {
    var that = this;
    var argAxis = that._argumentAxes[0];
    var argumentVisualRange = (0, _utils2.convertVisualRangeObject)(argAxis.visualRange(), !_isArray(that.option('argumentAxis.visualRange')));

    if (!argAxis.skipEventRising || !(0, _utils2.rangesAreEqual)(argumentVisualRange, that.option('argumentAxis.visualRange'))) {
      that.option('argumentAxis.visualRange', argumentVisualRange);
    } else {
      argAxis.skipEventRising = null;
    }

    that.callBase();
  }
});

dxChart.addPlugin(_shutter_zoom.default);
dxChart.addPlugin(_zoom_and_pan.default);
dxChart.addPlugin(_annotations.plugins.core);
dxChart.addPlugin(_annotations.plugins.chart);
(0, _component_registrator.default)('dxChart', dxChart);
var _default = dxChart;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1032 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.AnimationController = AnimationController;
exports.animationSvgStep = exports.easingFunctions = void 0;

var _frame = __webpack_require__(122);

var noop = function noop() {};

var easingFunctions = {
  easeOutCubic: function easeOutCubic(pos, start, end) {
    return pos === 1 ? end : (1 - Math.pow(1 - pos, 3)) * (end - start) + +start;
  },
  linear: function linear(pos, start, end) {
    return pos === 1 ? end : pos * (end - start) + +start;
  }
};
exports.easingFunctions = easingFunctions;
var animationSvgStep = {
  segments: function segments(elem, params, progress, easing, currentParams) {
    var from = params.from;
    var to = params.to;
    var curSeg;
    var seg;
    var i;
    var j;
    var segments = [];

    for (i = 0; i < from.length; i++) {
      curSeg = from[i];
      seg = [curSeg[0]];

      if (curSeg.length > 1) {
        for (j = 1; j < curSeg.length; j++) {
          seg.push(easing(progress, curSeg[j], to[i][j]));
        }
      }

      segments.push(seg);
    }

    currentParams.segments = params.end && progress === 1 ? params.end : segments;
    elem.attr({
      segments: segments
    });
  },
  arc: function arc(elem, params, progress, easing) {
    var from = params.from;
    var to = params.to;
    var current = {};

    for (var i in from) {
      current[i] = easing(progress, from[i], to[i]);
    }

    elem.attr(current);
  },
  transform: function transform(elem, params, progress, easing, currentParams) {
    var from = params.from;
    var to = params.to;
    var current = {};

    for (var i in from) {
      current[i] = currentParams[i] = easing(progress, from[i], to[i]);
    }

    elem.attr(current);
  },
  base: function base(elem, params, progress, easing, currentParams, attributeName) {
    var obj = {};
    obj[attributeName] = currentParams[attributeName] = easing(progress, params.from, params.to);
    elem.attr(obj);
  },
  _: noop,
  complete: function complete(element, currentSettings) {
    element.attr(currentSettings);
  }
};
exports.animationSvgStep = animationSvgStep;

function step(now) {
  var that = this;
  var animateStep = that._animateStep;
  var attrName;
  that._progress = that._calcProgress(now);

  for (attrName in that.params) {
    var anim = animateStep[attrName] || animateStep.base;
    anim(that.element, that.params[attrName], that._progress, that._easing, that._currentParams, attrName);
  }

  that.options.step && that.options.step(that._easing(that._progress, 0, 1), that._progress);
  if (that._progress === 1) return that.stop();
  return true;
}

function delayTick(now) {
  if (now - this._startTime >= this.delay) {
    this.tick = step;
  }

  return true;
}

function start(now) {
  this._startTime = now;
  this.tick = this.delay ? delayTick : step;
  return true;
}

function Animation(element, params, options) {
  var that = this;
  that._progress = 0;
  that.element = element;
  that.params = params;
  that.options = options;
  that.duration = options.partitionDuration ? options.duration * options.partitionDuration : options.duration;
  that.delay = options.delay && options.duration * options.delay || 0;
  that._animateStep = options.animateStep || animationSvgStep;
  that._easing = easingFunctions[options.easing] || easingFunctions['easeOutCubic'];
  that._currentParams = {};
  that.tick = start;
}

Animation.prototype = {
  _calcProgress: function _calcProgress(now) {
    return Math.min(1, (now - this.delay - this._startTime) / this.duration);
  },
  stop: function stop(disableComplete) {
    var that = this;
    var options = that.options;
    var animateStep = that._animateStep;
    that.stop = that.tick = noop;
    animateStep.complete && animateStep.complete(that.element, that._currentParams);
    options.complete && !disableComplete && options.complete();
  }
};

function AnimationController(element) {
  var that = this;
  that._animationCount = 0;
  that._timerId = null;
  that._animations = {};
  that.element = element;
}

AnimationController.prototype = {
  _loop: function _loop() {
    var that = this;
    var animations = that._animations;
    var activeAnimation = 0;
    var now = new Date().getTime();
    var an;
    var endAnimation = that._endAnimation;

    for (an in animations) {
      if (!animations[an].tick(now)) {
        delete animations[an];
      }

      activeAnimation++;
    }

    if (activeAnimation === 0) {
      that.stop();
      that._endAnimationTimer = endAnimation && setTimeout(function () {
        if (that._animationCount === 0) {
          endAnimation();
          that._endAnimation = null;
        }
      });
      return;
    }

    that._timerId = _frame.requestAnimationFrame.call(null, function () {
      that._loop();
    }, that.element);
  },
  addAnimation: function addAnimation(animation) {
    var that = this;
    that._animations[that._animationCount++] = animation;
    clearTimeout(that._endAnimationTimer);

    if (!that._timerId) {
      clearTimeout(that._startDelay);
      that._startDelay = setTimeout(function () {
        that._timerId = 1;

        that._loop();
      }, 0);
    }
  },
  animateElement: function animateElement(elem, params, options) {
    if (elem && params && options) {
      elem.animation && elem.animation.stop();
      this.addAnimation(elem.animation = new Animation(elem, params, options));
    }
  },
  onEndAnimation: function onEndAnimation(endAnimation) {
    this._animationCount ? this._endAnimation = endAnimation : endAnimation();
  },
  dispose: function dispose() {
    this.stop();
    this.element = null;
  },
  stop: function stop() {
    var that = this;
    that._animations = {};
    that._animationCount = 0;
    (0, _frame.cancelAnimationFrame)(that._timerId);
    clearTimeout(that._startDelay);
    clearTimeout(that._endAnimationTimer);
    that._timerId = null;
  },
  lock: function lock() {
    var an;
    var animations = this._animations;
    var unstoppable; // T261694

    var hasUnstoppableInAnimations;

    for (an in animations) {
      unstoppable = animations[an].options.unstoppable;
      hasUnstoppableInAnimations = hasUnstoppableInAnimations || unstoppable;

      if (!unstoppable) {
        animations[an].stop(true);
        delete animations[an];
      }
    }

    !hasUnstoppableInAnimations && this.stop();
  }
};

/***/ }),
/* 1033 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _themes = __webpack_require__(57);

var WHITE = '#ffffff';
var BLACK = '#000000';
var LIGHT_GREY = '#d3d3d3';
var GREY_GREEN = '#303030';
var SOME_GREY = '#2b2b2b';
var RED = '#ff0000';
var PRIMARY_TITLE_COLOR = '#232323';
var SECONDARY_TITLE_COLOR = '#767676';
var NONE = 'none';
var SOLID = 'solid';
var TOP = 'top';
var RIGHT = 'right';
var BOTTOM = 'bottom';
var LEFT = 'left';
var CENTER = 'center';
var INSIDE = 'inside';
var OUTSIDE = 'outside';
(0, _themes.registerTheme)({
  name: 'generic.light',
  isDefault: true,
  font: {
    color: SECONDARY_TITLE_COLOR,
    family: '\'Segoe UI\', \'Helvetica Neue\', \'Trebuchet MS\', Verdana, sans-serif',
    weight: 400,
    size: 12,
    cursor: 'default'
  },
  redrawOnResize: true,
  backgroundColor: WHITE,
  primaryTitleColor: PRIMARY_TITLE_COLOR,
  secondaryTitleColor: SECONDARY_TITLE_COLOR,
  gridColor: LIGHT_GREY,
  axisColor: SECONDARY_TITLE_COLOR,
  title: {
    backgroundColor: WHITE,
    font: {
      size: 28,
      family: '\'Segoe UI Light\', \'Helvetica Neue Light\', \'Segoe UI\', \'Helvetica Neue\', \'Trebuchet MS\', Verdana, sans-serif',
      weight: 200
    },
    subtitle: {
      font: {
        size: 16
      },
      offset: 0,
      wordWrap: 'normal',
      textOverflow: 'ellipsis'
    },
    wordWrap: 'normal',
    textOverflow: 'ellipsis'
  },
  loadingIndicator: {
    text: 'Loading...'
  },
  'export': {
    backgroundColor: WHITE,
    margin: 10,
    font: {
      size: 14,
      color: PRIMARY_TITLE_COLOR,
      weight: 400
    },
    button: {
      margin: {
        top: 8,
        left: 10,
        right: 10,
        bottom: 8
      },
      'default': {
        color: '#333',
        borderColor: '#ddd',
        backgroundColor: WHITE
      },
      hover: {
        color: '#333',
        borderColor: '#bebebe',
        backgroundColor: '#e6e6e6'
      },
      focus: {
        color: BLACK,
        borderColor: '#9d9d9d',
        backgroundColor: '#e6e6e6'
      },
      active: {
        color: '#333',
        borderColor: '#9d9d9d',
        backgroundColor: '#d4d4d4'
      }
    },
    shadowColor: LIGHT_GREY
  },
  tooltip: {
    enabled: false,
    border: {
      width: 1,
      color: LIGHT_GREY,
      dashStyle: SOLID,
      visible: true
    },
    font: {
      color: PRIMARY_TITLE_COLOR
    },
    color: WHITE,
    arrowLength: 10,
    paddingLeftRight: 18,
    paddingTopBottom: 15,
    textAlignment: 'center',
    shared: false,
    location: CENTER,
    shadow: {
      opacity: 0.4,
      offsetX: 0,
      offsetY: 4,
      blur: 2,
      color: BLACK
    },
    interactive: false
  },
  legend: {
    hoverMode: 'includePoints',
    verticalAlignment: TOP,
    horizontalAlignment: RIGHT,
    position: OUTSIDE,
    visible: true,
    margin: 10,
    markerSize: 12,
    border: {
      visible: false,
      width: 1,
      cornerRadius: 0,
      dashStyle: SOLID
    },
    paddingLeftRight: 20,
    paddingTopBottom: 15,
    columnCount: 0,
    rowCount: 0,
    columnItemSpacing: 20,
    rowItemSpacing: 8,
    title: {
      backgroundColor: WHITE,
      margin: {
        left: 0,
        bottom: 9,
        right: 0,
        top: 0
      },
      font: {
        size: 18,
        weight: 200
      },
      subtitle: {
        offset: 0,
        font: {
          size: 14
        },
        wordWrap: 'none',
        textOverflow: 'ellipsis'
      },
      wordWrap: 'none',
      textOverflow: 'ellipsis'
    }
  },
  'chart:common': {
    animation: {
      enabled: true,
      duration: 1000,
      easing: 'easeOutCubic',
      maxPointCountSupported: 300
    },
    commonSeriesSettings: {
      border: {
        visible: false,
        width: 2
      },
      showInLegend: true,
      visible: true,
      hoverMode: 'nearestPoint',
      selectionMode: 'includePoints',
      hoverStyle: {
        hatching: {
          direction: RIGHT,
          width: 2,
          step: 6,
          opacity: 0.75
        },
        border: {
          visible: false,
          width: 3
        }
      },
      selectionStyle: {
        hatching: {
          direction: RIGHT,
          width: 2,
          step: 6,
          opacity: 0.5
        },
        border: {
          visible: false,
          width: 3
        }
      },
      valueErrorBar: {
        displayMode: 'auto',
        value: 1,
        color: BLACK,
        lineWidth: 2,
        edgeLength: 8
      },
      label: {
        visible: false,
        alignment: CENTER,
        rotationAngle: 0,
        horizontalOffset: 0,
        verticalOffset: 0,
        radialOffset: 0,
        showForZeroValues: true,
        customizeText: undefined,
        maxLabelCount: undefined,
        position: OUTSIDE,
        font: {
          color: WHITE
        },
        border: {
          visible: false,
          width: 1,
          color: LIGHT_GREY,
          dashStyle: SOLID
        },
        connector: {
          visible: false,
          width: 1
        }
      }
    },
    seriesSelectionMode: 'single',
    pointSelectionMode: 'single',
    equalRowHeight: true,
    dataPrepareSettings: {
      checkTypeForAllData: false,
      convertToAxisDataType: true,
      sortingMethod: true
    },
    title: {
      margin: 10
    },
    adaptiveLayout: {
      width: 80,
      height: 80,
      keepLabels: true
    },
    _rtl: {
      legend: {
        itemTextPosition: LEFT
      }
    },
    resolveLabelOverlapping: NONE
  },
  'chart:common:axis': {
    visible: true,
    valueMarginsEnabled: true,
    placeholderSize: null,
    logarithmBase: 10,
    discreteAxisDivisionMode: 'betweenLabels',
    width: 1,
    label: {
      visible: true
    },
    grid: {
      visible: false,
      width: 1
    },
    minorGrid: {
      visible: false,
      width: 1,
      opacity: 0.3
    },
    tick: {
      visible: true,
      width: 1,
      length: 7,
      shift: 3
    },
    minorTick: {
      visible: false,
      width: 1,
      opacity: 0.3,
      length: 7,
      shift: 3
    },
    stripStyle: {
      paddingLeftRight: 10,
      paddingTopBottom: 5
    },
    constantLineStyle: {
      width: 1,
      color: BLACK,
      dashStyle: SOLID,
      label: {
        visible: true,
        position: INSIDE
      }
    },
    marker: {
      label: {}
    }
  },
  'chart:common:annotation': {
    font: {
      color: '#333333'
    },
    tooltipEnabled: true,
    border: {
      width: 1,
      color: '#dddddd',
      dashStyle: SOLID,
      visible: true
    },
    color: WHITE,
    opacity: 0.9,
    arrowLength: 14,
    arrowWidth: 14,
    paddingLeftRight: 10,
    paddingTopBottom: 10,
    shadow: {
      opacity: 0.15,
      offsetX: 0,
      offsetY: 1,
      blur: 4,
      color: BLACK
    },
    image: {
      width: 30,
      height: 30
    },
    wordWrap: 'normal',
    textOverflow: 'ellipsis',
    allowDragging: false
  },
  chart: {
    commonSeriesSettings: {
      type: 'line',
      stack: 'default',
      aggregation: {
        enabled: undefined
      },
      'point': {
        visible: true,
        symbol: 'circle',
        size: 12,
        border: {
          visible: false,
          width: 1
        },
        hoverMode: 'onlyPoint',
        selectionMode: 'onlyPoint',
        hoverStyle: {
          border: {
            visible: true,
            width: 4
          }
        },
        selectionStyle: {
          border: {
            visible: true,
            width: 4
          }
        }
      },
      'scatter': {},
      'line': {
        width: 2,
        dashStyle: SOLID,
        hoverStyle: {
          width: 3,
          hatching: {
            direction: NONE
          }
        },
        selectionStyle: {
          width: 3
        }
      },
      'stackedline': {
        width: 2,
        dashStyle: SOLID,
        hoverStyle: {
          width: 3,
          hatching: {
            direction: NONE
          }
        },
        selectionStyle: {
          width: 3
        }
      },
      'stackedspline': {
        width: 2,
        dashStyle: SOLID,
        hoverStyle: {
          width: 3,
          hatching: {
            direction: NONE
          }
        },
        selectionStyle: {
          width: 3
        }
      },
      'fullstackedline': {
        width: 2,
        dashStyle: SOLID,
        hoverStyle: {
          width: 3,
          hatching: {
            direction: NONE
          }
        },
        selectionStyle: {
          width: 3
        }
      },
      'fullstackedspline': {
        width: 2,
        dashStyle: SOLID,
        hoverStyle: {
          width: 3,
          hatching: {
            direction: NONE
          }
        },
        selectionStyle: {
          width: 3
        }
      },
      'stepline': {
        width: 2,
        dashStyle: SOLID,
        hoverStyle: {
          width: 3,
          hatching: {
            direction: NONE
          }
        },
        selectionStyle: {
          width: 3
        }
      },
      'area': {
        point: {
          visible: false
        },
        opacity: 0.5
      },
      'stackedarea': {
        point: {
          visible: false
        },
        opacity: 0.5
      },
      'fullstackedarea': {
        point: {
          visible: false
        },
        opacity: 0.5
      },
      'fullstackedsplinearea': {
        point: {
          visible: false
        },
        opacity: 0.5
      },
      'steparea': {
        border: {
          visible: true,
          width: 2
        },
        point: {
          visible: false
        },
        hoverStyle: {
          border: {
            visible: true,
            width: 3
          }
        },
        selectionStyle: {
          border: {
            visible: true,
            width: 3
          }
        },
        opacity: 0.5
      },
      'spline': {
        width: 2,
        hoverStyle: {
          width: 3,
          hatching: {
            direction: NONE
          }
        },
        selectionStyle: {
          width: 3
        }
      },
      'splinearea': {
        point: {
          visible: false
        },
        opacity: 0.5
      },
      'stackedsplinearea': {
        point: {
          visible: false
        },
        opacity: 0.5
      },
      'bar': {
        cornerRadius: 0,
        point: {
          hoverStyle: {
            border: {
              visible: false
            }
          },
          selectionStyle: {
            border: {
              visible: false
            }
          }
        }
      },
      'stackedbar': {
        cornerRadius: 0,
        point: {
          hoverStyle: {
            border: {
              visible: false
            }
          },
          selectionStyle: {
            border: {
              visible: false
            }
          }
        },
        label: {
          position: INSIDE
        }
      },
      'fullstackedbar': {
        cornerRadius: 0,
        point: {
          hoverStyle: {
            border: {
              visible: false
            }
          },
          selectionStyle: {
            border: {
              visible: false
            }
          }
        },
        label: {
          position: INSIDE
        }
      },
      'rangebar': {
        cornerRadius: 0,
        point: {
          hoverStyle: {
            border: {
              visible: false
            }
          },
          selectionStyle: {
            border: {
              visible: false
            }
          }
        }
      },
      'rangearea': {
        point: {
          visible: false
        },
        opacity: 0.5
      },
      'rangesplinearea': {
        point: {
          visible: false
        },
        opacity: 0.5
      },
      'bubble': {
        opacity: 0.5,
        point: {
          hoverStyle: {
            border: {
              visible: false
            }
          },
          selectionStyle: {
            border: {
              visible: false
            }
          }
        }
      },
      'candlestick': {
        width: 1,
        reduction: {
          color: RED
        },
        hoverStyle: {
          width: 3,
          hatching: {
            direction: NONE
          }
        },
        selectionStyle: {
          width: 3
        },
        point: {
          border: {
            visible: true
          }
        }
      },
      'stock': {
        width: 1,
        reduction: {
          color: RED
        },
        hoverStyle: {
          width: 3,
          hatching: {
            direction: NONE
          }
        },
        selectionStyle: {
          width: 3
        },
        point: {
          border: {
            visible: true
          }
        }
      }
    },
    crosshair: {
      enabled: false,
      color: '#f05b41',
      width: 1,
      dashStyle: SOLID,
      label: {
        visible: false,
        font: {
          color: WHITE,
          size: 12
        }
      },
      verticalLine: {
        visible: true
      },
      horizontalLine: {
        visible: true
      }
    },
    commonAxisSettings: {
      multipleAxesSpacing: 5,
      forceUserTickInterval: false,
      breakStyle: {
        width: 5,
        color: '#ababab',
        line: 'waved'
      },
      label: {
        displayMode: 'standard',
        overlappingBehavior: 'hide',
        indentFromAxis: 10,
        wordWrap: 'normal',
        textOverflow: 'none'
      },
      title: {
        font: {
          size: 16
        },
        margin: 6,
        alignment: CENTER
      },
      constantLineStyle: {
        paddingLeftRight: 10,
        paddingTopBottom: 10
      }
    },
    horizontalAxis: {
      position: BOTTOM,
      axisDivisionFactor: 70,
      label: {
        rotationAngle: 90,
        staggeringSpacing: 5,
        alignment: CENTER
      },
      stripStyle: {
        label: {
          horizontalAlignment: CENTER,
          verticalAlignment: TOP
        }
      },
      constantLineStyle: {
        label: {
          horizontalAlignment: RIGHT,
          verticalAlignment: TOP
        }
      },
      constantLines: []
    },
    verticalAxis: {
      position: LEFT,
      axisDivisionFactor: 40,
      label: {
        alignment: RIGHT
      },
      stripStyle: {
        label: {
          horizontalAlignment: LEFT,
          verticalAlignment: CENTER
        }
      },
      constantLineStyle: {
        label: {
          horizontalAlignment: LEFT,
          verticalAlignment: TOP
        }
      },
      constantLines: []
    },
    argumentAxis: {
      endOnTick: false,
      workWeek: [1, 2, 3, 4, 5]
    },
    valueAxis: {
      grid: {
        visible: true
      },
      autoBreaksEnabled: false,
      maxAutoBreakCount: 4
    },
    commonPaneSettings: {
      backgroundColor: NONE,
      border: {
        color: LIGHT_GREY,
        width: 1,
        visible: false,
        top: true,
        bottom: true,
        left: true,
        right: true,
        dashStyle: SOLID
      }
    },
    scrollBar: {
      visible: false,
      offset: 5,
      color: 'gray',
      width: 10
    },
    adjustOnZoom: true,
    autoHidePointMarkers: true,
    rotated: false,
    synchronizeMultiAxes: true,
    stickyHovering: true,
    barGroupPadding: 0.3,
    minBubbleSize: 12,
    maxBubbleSize: 0.2,
    zoomAndPan: {
      dragBoxStyle: {
        color: '#2a2a2a',
        opacity: 0.2
      },
      panKey: 'shift',
      allowMouseWheel: true,
      allowTouchGestures: true
    }
  },
  pie: {
    innerRadius: 0.5,
    minDiameter: 0.5,
    type: 'pie',
    dataPrepareSettings: {
      _skipArgumentSorting: true
    },
    commonSeriesSettings: {
      pie: {
        border: {
          visible: false,
          width: 2,
          color: WHITE
        },
        hoverStyle: {
          hatching: {
            direction: RIGHT,
            width: 4,
            step: 10,
            opacity: 0.75
          },
          border: {
            visible: false,
            width: 2
          }
        },
        selectionStyle: {
          hatching: {
            direction: RIGHT,
            width: 4,
            step: 10,
            opacity: 0.5
          },
          border: {
            visible: false,
            width: 2
          }
        }
      },
      doughnut: {
        border: {
          visible: false,
          width: 2,
          color: WHITE
        },
        hoverStyle: {
          hatching: {
            direction: RIGHT,
            width: 4,
            step: 10,
            opacity: 0.75
          },
          border: {
            visible: false,
            width: 2
          }
        },
        selectionStyle: {
          hatching: {
            direction: RIGHT,
            width: 4,
            step: 10,
            opacity: 0.5
          },
          border: {
            visible: false,
            width: 2
          }
        }
      },
      donut: {
        border: {
          visible: false,
          width: 2,
          color: WHITE
        },
        hoverStyle: {
          hatching: {
            direction: RIGHT,
            width: 4,
            step: 10,
            opacity: 0.75
          },
          border: {
            visible: false,
            width: 2
          }
        },
        selectionStyle: {
          hatching: {
            direction: RIGHT,
            width: 4,
            step: 10,
            opacity: 0.5
          },
          border: {
            visible: false,
            width: 2
          }
        }
      },
      label: {
        textOverflow: 'ellipsis',
        wordWrap: 'normal'
      }
    },
    legend: {
      hoverMode: 'allArgumentPoints',
      backgroundColor: NONE
    },
    adaptiveLayout: {
      keepLabels: false
    }
  },
  gauge: {
    scale: {
      tick: {
        visible: true,
        length: 5,
        width: 2,
        opacity: 1
      },
      minorTick: {
        visible: false,
        length: 3,
        width: 1,
        opacity: 1
      },
      label: {
        visible: true,
        alignment: CENTER,
        hideFirstOrLast: 'last',
        overlappingBehavior: 'hide'
      },
      position: TOP,
      endOnTick: false
    },
    rangeContainer: {
      offset: 0,
      width: 5,
      backgroundColor: '#808080'
    },
    valueIndicators: {
      _default: {
        color: '#c2c2c2'
      },
      'rangebar': {
        space: 2,
        size: 10,
        color: '#cbc5cf',
        backgroundColor: NONE,
        text: {
          indent: 0,
          font: {
            size: 14,
            color: null
          }
        }
      },
      'twocolorneedle': {
        secondColor: '#e18e92'
      },
      'trianglemarker': {
        space: 2,
        length: 14,
        width: 13,
        color: '#8798a5'
      },
      'textcloud': {
        arrowLength: 5,
        horizontalOffset: 6,
        verticalOffset: 3,
        color: '#679ec5',
        text: {
          font: {
            color: WHITE,
            size: 18
          }
        }
      }
    },
    indicator: {
      hasPositiveMeaning: true,
      layout: {
        horizontalAlignment: CENTER,
        verticalAlignment: BOTTOM
      },
      text: {
        font: {
          size: 18
        }
      }
    },
    _circular: {
      scale: {
        scaleDivisionFactor: 17,
        orientation: OUTSIDE,
        label: {
          indentFromTick: 10
        }
      },
      rangeContainer: {
        orientation: OUTSIDE
      },
      valueIndicatorType: 'rectangleneedle',
      subvalueIndicatorType: 'trianglemarker',
      valueIndicators: {
        _type: 'rectangleneedle',
        _default: {
          offset: 20,
          indentFromCenter: 0,
          width: 2,
          spindleSize: 14,
          spindleGapSize: 10,
          beginAdaptingAtRadius: 50
        },
        'triangleneedle': {
          width: 4
        },
        'twocolorneedle': {
          space: 2,
          secondFraction: 0.4
        },
        'rangebar': {
          offset: 30
        },
        'trianglemarker': {
          offset: 6
        },
        'textcloud': {
          offset: -6
        }
      }
    },
    _linear: {
      scale: {
        scaleDivisionFactor: 25,
        horizontalOrientation: RIGHT,
        verticalOrientation: BOTTOM,
        label: {
          indentFromTick: -10
        }
      },
      rangeContainer: {
        horizontalOrientation: RIGHT,
        verticalOrientation: BOTTOM
      },
      valueIndicatorType: 'rangebar',
      subvalueIndicatorType: 'trianglemarker',
      valueIndicators: {
        _type: 'rectangle',
        _default: {
          offset: 2.5,
          length: 15,
          width: 15
        },
        'rectangle': {
          width: 10
        },
        'rangebar': {
          offset: 10,
          horizontalOrientation: RIGHT,
          verticalOrientation: BOTTOM
        },
        'trianglemarker': {
          offset: 10,
          horizontalOrientation: LEFT,
          verticalOrientation: TOP
        },
        'textcloud': {
          offset: -1,
          horizontalOrientation: LEFT,
          verticalOrientation: TOP
        }
      }
    }
  },
  barGauge: {
    backgroundColor: '#e0e0e0',
    relativeInnerRadius: 0.3,
    barSpacing: 4,
    resolveLabelOverlapping: 'hide',
    label: {
      indent: 20,
      connectorWidth: 2,
      font: {
        size: 16
      }
    },
    legend: {
      visible: false
    },
    indicator: {
      hasPositiveMeaning: true,
      layout: {
        horizontalAlignment: CENTER,
        verticalAlignment: BOTTOM
      },
      text: {
        font: {
          size: 18
        }
      }
    }
  },
  rangeSelector: {
    scale: {
      valueMarginsEnabled: true,
      width: 1,
      color: BLACK,
      opacity: 0.1,
      showCustomBoundaryTicks: true,
      label: {
        overlappingBehavior: 'hide',
        alignment: CENTER,
        visible: true,
        topIndent: 7,
        font: {
          size: 11
        }
      },
      tick: {
        width: 1,
        color: BLACK,
        opacity: 0.17,
        visible: true,
        length: 12
      },
      minorTick: {
        width: 1,
        color: BLACK,
        opacity: 0.05,
        visible: true,
        length: 12
      },
      marker: {
        width: 1,
        color: '#000000',
        opacity: 0.1,
        visible: true,
        separatorHeight: 33,
        topIndent: 10,
        textLeftIndent: 7,
        textTopIndent: 11,
        label: {}
      },
      logarithmBase: 10,
      workWeek: [1, 2, 3, 4, 5],
      breakStyle: {
        width: 5,
        color: '#ababab',
        line: 'waved'
      },
      endOnTick: false
    },
    selectedRangeColor: '#606060',
    sliderMarker: {
      visible: true,
      paddingTopBottom: 2,
      paddingLeftRight: 4,
      color: '#606060',
      invalidRangeColor: RED,
      font: {
        color: WHITE,
        size: 11
      }
    },
    sliderHandle: {
      width: 1,
      color: BLACK,
      opacity: 0.2
    },
    shutter: {
      opacity: 0.75
    },
    background: {
      color: '#c0bae1',
      visible: true,
      image: {
        location: 'full'
      }
    },
    behavior: {
      snapToTicks: true,
      animationEnabled: true,
      moveSelectedRangeByClick: true,
      manualRangeSelectionEnabled: true,
      allowSlidersSwap: true,
      callValueChanged: 'onMovingComplete'
    },
    redrawOnResize: true,
    chart: {
      barGroupPadding: 0.3,
      minBubbleSize: 12,
      maxBubbleSize: 0.2,
      topIndent: 0.1,
      bottomIndent: 0,
      valueAxis: {
        inverted: false,
        logarithmBase: 10
      },
      commonSeriesSettings: {
        type: 'area',
        aggregation: {
          enabled: undefined
        },
        point: {
          visible: false
        },
        scatter: {
          point: {
            visible: true
          }
        }
      }
    }
  },
  map: {
    title: {
      margin: 10
    },
    background: {
      borderWidth: 1,
      borderColor: '#cacaca'
    },
    layer: {
      label: {
        enabled: false,
        stroke: WHITE,
        'stroke-width': 1,
        'stroke-opacity': 0.7,
        font: {
          color: SOME_GREY,
          size: 12
        }
      }
    },
    'layer:area': {
      borderWidth: 1,
      borderColor: WHITE,
      color: '#d2d2d2',
      hoveredBorderColor: GREY_GREEN,
      selectedBorderWidth: 2,
      selectedBorderColor: GREY_GREEN,
      label: {
        'stroke-width': 2,
        font: {
          size: 16
        }
      }
    },
    'layer:line': {
      borderWidth: 2,
      color: '#ba8365',
      hoveredColor: '#a94813',
      selectedBorderWidth: 3,
      selectedColor: '#e55100',
      label: {
        'stroke-width': 2,
        font: {
          size: 16
        }
      }
    },
    'layer:marker': {
      label: {
        enabled: true,
        'stroke-width': 1,
        font: {
          size: 12
        }
      }
    },
    'layer:marker:dot': {
      borderWidth: 2,
      borderColor: WHITE,
      size: 8,
      selectedStep: 2,
      backStep: 18,
      backColor: WHITE,
      backOpacity: 0.32,
      shadow: true
    },
    'layer:marker:bubble': {
      minSize: 20,
      maxSize: 50,
      hoveredBorderWidth: 1,
      hoveredBorderColor: GREY_GREEN,
      selectedBorderWidth: 2,
      selectedBorderColor: GREY_GREEN
    },
    'layer:marker:pie': {
      size: 50,
      hoveredBorderWidth: 1,
      hoveredBorderColor: GREY_GREEN,
      selectedBorderWidth: 2,
      selectedBorderColor: GREY_GREEN
    },
    'layer:marker:image': {
      size: 20
    },
    legend: {
      verticalAlignment: BOTTOM,
      horizontalAlignment: RIGHT,
      position: INSIDE,
      backgroundOpacity: 0.65,
      border: {
        visible: true
      },
      paddingLeftRight: 16,
      paddingTopBottom: 12
    },
    controlBar: {
      borderColor: '#5d5d5d',
      borderWidth: 3,
      color: WHITE,
      margin: 20,
      opacity: 0.3
    },
    _rtl: {
      legend: {
        itemTextPosition: LEFT
      }
    }
  },
  treeMap: {
    tile: {
      border: {
        width: 1,
        opacity: 0.2,
        color: '#000000'
      },
      color: '#5f8b95',
      hoverStyle: {
        hatching: {
          opacity: 0.75,
          step: 6,
          width: 2,
          direction: 'right'
        },
        border: {}
      },
      selectionStyle: {
        hatching: {
          opacity: 0.5,
          step: 6,
          width: 2,
          direction: 'right'
        },
        border: {
          opacity: 1
        }
      },
      label: {
        visible: true,
        paddingLeftRight: 5,
        paddingTopBottom: 4,
        font: {
          color: '#ffffff',
          weight: 600
        },
        shadow: {
          opacity: 0.6,
          offsetX: 0,
          offsetY: 1,
          blur: 2,
          color: '#000000'
        },
        wordWrap: 'normal',
        textOverflow: 'ellipsis'
      }
    },
    group: {
      padding: 4,
      border: {
        width: 1
      },
      color: '#eeeeee',
      hoverStyle: {
        hatching: {
          opacity: 0,
          step: 6,
          width: 2,
          direction: 'right'
        },
        border: {}
      },
      selectionStyle: {
        hatching: {
          opacity: 0,
          step: 6,
          width: 2,
          direction: 'right'
        },
        border: {}
      },
      label: {
        visible: true,
        paddingLeftRight: 5,
        paddingTopBottom: 4,
        font: {
          color: SECONDARY_TITLE_COLOR,
          weight: 600
        },
        textOverflow: 'ellipsis'
      }
    },
    title: {
      subtitle: {}
    },
    tooltip: {},
    loadingIndicator: {}
  },
  sparkline: {
    lineColor: '#666666',
    lineWidth: 2,
    areaOpacity: 0.2,
    minColor: '#e8c267',
    maxColor: '#e55253',
    barPositiveColor: '#a9a9a9',
    barNegativeColor: '#d7d7d7',
    winColor: '#a9a9a9',
    lossColor: '#d7d7d7',
    firstLastColor: '#666666',
    pointSymbol: 'circle',
    pointColor: WHITE,
    pointSize: 4,
    type: 'line',
    argumentField: 'arg',
    valueField: 'val',
    winlossThreshold: 0,
    showFirstLast: true,
    showMinMax: false,
    tooltip: {
      enabled: true
    }
  },
  bullet: {
    color: '#e8c267',
    targetColor: '#666666',
    targetWidth: 4,
    showTarget: true,
    showZeroLevel: true,
    tooltip: {
      enabled: true
    }
  },
  polar: {
    commonSeriesSettings: {
      type: 'scatter',
      closed: true,
      'point': {
        visible: true,
        symbol: 'circle',
        size: 12,
        border: {
          visible: false,
          width: 1
        },
        hoverMode: 'onlyPoint',
        selectionMode: 'onlyPoint',
        hoverStyle: {
          border: {
            visible: true,
            width: 4
          },
          size: 12
        },
        selectionStyle: {
          border: {
            visible: true,
            width: 4
          },
          size: 12
        }
      },
      'scatter': {},
      'line': {
        width: 2,
        dashStyle: SOLID,
        hoverStyle: {
          width: 3,
          hatching: {
            direction: NONE
          }
        },
        selectionStyle: {
          width: 3
        }
      },
      'area': {
        point: {
          visible: false
        },
        opacity: 0.5
      },
      'stackedline': {
        width: 2
      },
      'bar': {
        opacity: 0.8
      },
      'stackedbar': {
        opacity: 0.8
      }
    },
    adaptiveLayout: {
      width: 80,
      height: 80,
      keepLabels: true
    },
    barGroupPadding: 0.3,
    commonAxisSettings: {
      visible: true,
      forceUserTickInterval: false,
      label: {
        overlappingBehavior: 'hide',
        indentFromAxis: 5
      },
      grid: {
        visible: true
      },
      minorGrid: {
        visible: true
      },
      tick: {
        visible: true
      },
      title: {
        font: {
          size: 16
        },
        margin: 10
      }
    },
    argumentAxis: {
      startAngle: 0,
      firstPointOnStartAngle: false,
      period: undefined
    },
    valueAxis: {
      endOnTick: false,
      tick: {
        visible: false
      }
    },
    horizontalAxis: {
      position: TOP,
      axisDivisionFactor: 50,
      label: {
        alignment: CENTER
      }
    },
    verticalAxis: {
      position: TOP,
      axisDivisionFactor: 30,
      label: {
        alignment: RIGHT
      }
    }
  },
  funnel: {
    sortData: true,
    valueField: 'val',
    colorField: 'color',
    argumentField: 'arg',
    hoverEnabled: true,
    selectionMode: 'single',
    item: {
      border: {
        visible: false,
        width: 2,
        color: WHITE
      },
      hoverStyle: {
        hatching: {
          opacity: 0.75,
          step: 6,
          width: 2,
          direction: RIGHT
        },
        border: {}
      },
      selectionStyle: {
        hatching: {
          opacity: 0.5,
          step: 6,
          width: 2,
          direction: RIGHT
        },
        border: {}
      }
    },
    title: {
      margin: 10
    },
    adaptiveLayout: {
      width: 80,
      height: 80,
      keepLabels: true
    },
    legend: {
      visible: false
    },
    _rtl: {
      legend: {
        itemTextPosition: LEFT
      }
    },
    tooltip: {
      customizeTooltip: function customizeTooltip(info) {
        return {
          text: info.item.argument + ' ' + info.valueText
        };
      }
    },
    inverted: false,
    algorithm: 'dynamicSlope',
    neckWidth: 0,
    neckHeight: 0,
    resolveLabelOverlapping: 'shift',
    label: {
      textOverflow: 'ellipsis',
      wordWrap: 'normal',
      visible: true,
      horizontalAlignment: RIGHT,
      horizontalOffset: 0,
      verticalOffset: 0,
      showForZeroValues: false,
      customizeText: function customizeText(info) {
        return info.item.argument + ' ' + info.valueText;
      },
      position: 'columns',
      font: {
        color: WHITE
      },
      border: {
        visible: false,
        width: 1,
        color: LIGHT_GREY,
        dashStyle: SOLID
      },
      connector: {
        visible: true,
        width: 1,
        opacity: 0.5
      }
    }
  },
  sankey: {
    sourceField: 'source',
    targetField: 'target',
    weightField: 'weight',
    hoverEnabled: true,
    alignment: CENTER,
    adaptiveLayout: {
      width: 80,
      height: 80,
      keepLabels: true
    },
    label: {
      visible: true,
      horizontalOffset: 8,
      verticalOffset: 0,
      overlappingBehavior: 'ellipsis',
      useNodeColors: false,
      font: {
        color: BLACK,
        weight: 500
      },
      border: {
        visible: false,
        width: 2,
        color: WHITE
      },
      customizeText: function customizeText(info) {
        return info.title;
      },
      shadow: {
        opacity: 0.2,
        offsetX: 0,
        offsetY: 1,
        blur: 1,
        color: WHITE
      }
    },
    title: {
      margin: 10,
      font: {
        size: 28,
        weight: 200
      },
      subtitle: {
        font: {
          size: 16
        }
      }
    },
    tooltip: {
      enabled: true
    },
    node: {
      padding: 30,
      width: 8,
      opacity: 1,
      border: {
        color: WHITE,
        width: 1,
        visible: false
      },
      hoverStyle: {
        hatching: {
          opacity: 0.75,
          step: 6,
          width: 2,
          direction: RIGHT
        },
        border: {}
      }
    },
    link: {
      color: '#888888',
      colorMode: 'none',
      opacity: 0.3,
      border: {
        color: WHITE,
        width: 1,
        visible: false
      },
      hoverStyle: {
        opacity: 0.5,
        hatching: {
          opacity: 0.75,
          step: 6,
          width: 2,
          direction: RIGHT
        },
        border: {}
      }
    }
  }
});
(0, _themes.registerTheme)({
  name: 'generic.light.compact'
}, 'generic.light');

/***/ }),
/* 1034 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _themes = __webpack_require__(57);

var WHITE = '#ffffff';
var BLACK = '#000000';
var SOME_GREY = '#2b2b2b';
var RANGE_COLOR = '#b5b5b5';
var GREY_GREEN = '#303030';
var AREA_LAYER_COLOR = '#686868';
var LINE_COLOR = '#c7c7c7';
var TARGET_COLOR = '#8e8e8e';
var POSITIVE_COLOR = '#b8b8b8';
var BORDER_COLOR = '#494949';
(0, _themes.registerTheme)({
  name: 'generic.dark',
  font: {
    color: '#808080'
  },
  backgroundColor: '#2a2a2a',
  primaryTitleColor: '#dedede',
  secondaryTitleColor: '#a3a3a3',
  gridColor: '#555555',
  axisColor: '#a3a3a3',
  'export': {
    backgroundColor: '#2a2a2a',
    font: {
      color: '#dbdbdb'
    },
    button: {
      'default': {
        color: '#dedede',
        borderColor: '#4d4d4d',
        backgroundColor: '#2e2e2e'
      },
      hover: {
        color: '#dedede',
        borderColor: '#6c6c6c',
        backgroundColor: '#444'
      },
      focus: {
        color: '#dedede',
        borderColor: '#8d8d8d',
        backgroundColor: '#444444'
      },
      active: {
        color: '#dedede',
        borderColor: '#8d8d8d',
        backgroundColor: '#555555'
      }
    },
    shadowColor: '#292929'
  },
  tooltip: {
    color: SOME_GREY,
    border: {
      color: BORDER_COLOR
    },
    font: {
      color: '#929292'
    }
  },
  'chart:common': {
    commonSeriesSettings: {
      label: {
        border: {
          color: BORDER_COLOR
        }
      },
      valueErrorBar: {
        color: WHITE
      }
    }
  },
  'chart:common:axis': {
    constantLineStyle: {
      color: WHITE
    }
  },
  'chart:common:annotation': {
    font: {
      color: '#929292'
    },
    border: {
      color: BORDER_COLOR
    },
    color: SOME_GREY,
    shadow: {
      opacity: 0.008,
      offsetY: 4,
      blur: 8
    }
  },
  chart: {
    commonPaneSettings: {
      border: {
        color: BORDER_COLOR
      }
    },
    commonAxisSettings: {
      breakStyle: {
        color: '#818181'
      }
    },
    zoomAndPan: {
      dragBoxStyle: {
        color: WHITE
      }
    }
  },
  gauge: {
    rangeContainer: {
      backgroundColor: RANGE_COLOR
    },
    valueIndicators: {
      _default: {
        color: RANGE_COLOR
      },
      'rangebar': {
        color: '#84788b'
      },
      'twocolorneedle': {
        secondColor: '#ba544d'
      },
      'trianglemarker': {
        color: '#b7918f'
      },
      'textcloud': {
        color: '#ba544d'
      }
    }
  },
  barGauge: {
    backgroundColor: '#3c3c3c'
  },
  rangeSelector: {
    scale: {
      tick: {
        color: WHITE,
        opacity: 0.32
      },
      minorTick: {
        color: WHITE,
        opacity: 0.1
      },
      breakStyle: {
        color: '#818181'
      }
    },
    selectedRangeColor: RANGE_COLOR,
    sliderMarker: {
      color: RANGE_COLOR,
      font: {
        color: GREY_GREEN
      }
    },
    sliderHandle: {
      color: WHITE,
      opacity: 0.2
    },
    shutter: {
      color: SOME_GREY,
      opacity: 0.9
    }
  },
  map: {
    background: {
      borderColor: '#3f3f3f'
    },
    layer: {
      label: {
        stroke: BLACK,
        font: {
          color: WHITE
        }
      }
    },
    'layer:area': {
      borderColor: GREY_GREEN,
      color: AREA_LAYER_COLOR,
      hoveredBorderColor: WHITE,
      selectedBorderColor: WHITE
    },
    'layer:line': {
      color: '#c77244',
      hoveredColor: '#ff5d04',
      selectedColor: '#ff784f'
    },
    'layer:marker:bubble': {
      hoveredBorderColor: WHITE,
      selectedBorderColor: WHITE
    },
    'layer:marker:pie': {
      hoveredBorderColor: WHITE,
      selectedBorderColor: WHITE
    },
    legend: {
      border: {
        color: '#3f3f3f'
      },
      font: {
        color: WHITE
      }
    },
    controlBar: {
      borderColor: LINE_COLOR,
      color: GREY_GREEN
    }
  },
  treeMap: {
    group: {
      color: '#4c4c4c',
      label: {
        font: {
          color: '#a3a3a3'
        }
      }
    }
  },
  sparkline: {
    lineColor: LINE_COLOR,
    firstLastColor: LINE_COLOR,
    barPositiveColor: POSITIVE_COLOR,
    barNegativeColor: TARGET_COLOR,
    winColor: POSITIVE_COLOR,
    lossColor: TARGET_COLOR,
    pointColor: GREY_GREEN
  },
  bullet: {
    targetColor: TARGET_COLOR
  },
  funnel: {
    item: {
      border: {
        color: '#2a2a2a'
      }
    }
  },
  sankey: {
    label: {
      font: {
        color: WHITE
      },
      shadow: {
        opacity: 0
      }
    },
    node: {
      border: {
        color: '#2a2a2a'
      }
    },
    link: {
      color: '#888888',
      border: {
        color: '#2a2a2a'
      },
      hoverStyle: {
        color: '#bbbbbb'
      }
    }
  }
}, 'generic.light');
(0, _themes.registerTheme)({
  name: 'generic.dark.compact'
}, 'generic.dark');

/***/ }),
/* 1035 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _themes = __webpack_require__(57);

var WHITE = '#ffffff';
var BLACK = '#000000';
var CONTRAST_ACTIVE = '#cf00da';
var MARKER_COLOR = '#f8ca00';
var AREA_LAYER_COLOR = '#686868';
(0, _themes.registerTheme)({
  name: 'generic.contrast',
  defaultPalette: 'Bright',
  // CONTRAST_ACTIVE
  font: {
    color: WHITE
  },
  backgroundColor: BLACK,
  primaryTitleColor: WHITE,
  secondaryTitleColor: WHITE,
  gridColor: WHITE,
  axisColor: WHITE,
  'export': {
    backgroundColor: BLACK,
    font: {
      color: WHITE
    },
    button: {
      'default': {
        color: WHITE,
        borderColor: WHITE,
        backgroundColor: BLACK
      },
      hover: {
        color: WHITE,
        borderColor: WHITE,
        backgroundColor: '#cf00d7'
      },
      focus: {
        color: WHITE,
        borderColor: '#cf00d7',
        backgroundColor: BLACK
      },
      active: {
        color: BLACK,
        borderColor: WHITE,
        backgroundColor: WHITE
      }
    },
    borderColor: WHITE,
    menuButtonColor: BLACK,
    activeBackgroundColor: WHITE,
    activeColor: BLACK,
    selectedBorderColor: CONTRAST_ACTIVE,
    selectedColor: CONTRAST_ACTIVE,
    shadowColor: 'none'
  },
  tooltip: {
    border: {
      color: WHITE
    },
    font: {
      color: WHITE
    },
    color: BLACK
  },
  'chart:common': {
    commonSeriesSettings: {
      valueErrorBar: {
        color: WHITE
      },
      hoverStyle: {
        hatching: {
          opacity: 0.5
        }
      },
      selectionStyle: {
        hatching: {
          opacity: 0.35
        }
      },
      label: {
        font: {
          color: WHITE
        },
        border: {
          color: WHITE
        }
      }
    }
  },
  'chart:common:axis': {
    constantLineStyle: {
      color: WHITE
    }
  },
  'chart:common:annotation': {
    font: {
      color: WHITE
    },
    border: {
      color: WHITE
    },
    color: BLACK
  },
  chart: {
    commonSeriesSettings: {},
    crosshair: {
      color: '#cf00d7'
    },
    commonPaneSettings: {
      backgroundColor: BLACK,
      border: {
        color: WHITE
      }
    },
    scrollBar: {
      color: WHITE
    },
    commonAxisSettings: {
      breakStyle: {
        color: '#cf00d7'
      }
    },
    zoomAndPan: {
      dragBoxStyle: {
        color: WHITE,
        opacity: 0.7
      }
    }
  },
  pie: {
    commonSeriesSettings: {
      pie: {
        hoverStyle: {
          hatching: {
            opacity: 0.5
          }
        },
        selectionStyle: {
          hatching: {
            opacity: 0.35
          }
        }
      },
      doughnut: {
        hoverStyle: {
          hatching: {
            opacity: 0.5
          }
        },
        selectionStyle: {
          hatching: {
            opacity: 0.35
          }
        }
      },
      donut: {
        hoverStyle: {
          hatching: {
            opacity: 0.5
          }
        },
        selectionStyle: {
          hatching: {
            opacity: 0.35
          }
        }
      }
    }
  },
  gauge: {
    rangeContainer: {
      backgroundColor: WHITE
    },
    valueIndicators: {
      _default: {
        color: WHITE
      },
      'rangebar': {
        color: WHITE,
        backgroundColor: BLACK
      },
      'twocolorneedle': {
        secondColor: WHITE
      },
      'trianglemarker': {
        color: WHITE
      },
      'textcloud': {
        color: WHITE,
        text: {
          font: {
            color: BLACK
          }
        }
      }
    }
  },
  barGauge: {
    backgroundColor: '#3c3c3c'
  },
  rangeSelector: {
    scale: {
      tick: {
        color: WHITE,
        opacity: 0.4
      },
      minorTick: {
        color: WHITE,
        opacity: 0.12
      },
      breakStyle: {
        color: '#cf00d7'
      }
    },
    selectedRangeColor: CONTRAST_ACTIVE,
    sliderMarker: {
      color: CONTRAST_ACTIVE
    },
    sliderHandle: {
      color: CONTRAST_ACTIVE,
      opacity: 1
    },
    shutter: {
      opacity: 0.75
    },
    background: {
      color: BLACK
    }
  },
  map: {
    background: {
      borderColor: WHITE
    },
    layer: {
      label: {
        stroke: BLACK,
        font: {
          color: WHITE
        }
      }
    },
    'layer:area': {
      borderColor: BLACK,
      color: AREA_LAYER_COLOR,
      hoveredBorderColor: WHITE,
      selectedBorderColor: WHITE,
      label: {
        font: {
          opacity: 1
        }
      }
    },
    'layer:line': {
      color: '#267cff',
      hoveredColor: '#f613ff',
      selectedColor: WHITE
    },
    'layer:marker:dot': {
      borderColor: BLACK,
      color: MARKER_COLOR,
      backColor: BLACK,
      backOpacity: 0.32
    },
    'layer:marker:bubble': {
      color: MARKER_COLOR,
      hoveredBorderColor: WHITE,
      selectedBorderColor: WHITE
    },
    'layer:marker:pie': {
      hoveredBorderColor: WHITE,
      selectedBorderColor: WHITE
    },
    controlBar: {
      borderColor: WHITE,
      color: BLACK,
      opacity: 0.3
    }
  },
  treeMap: {
    tile: {
      color: '#70c92f'
    },
    group: {
      color: '#797979',
      label: {
        font: {
          color: WHITE
        }
      }
    }
  },
  sparkline: {
    pointColor: BLACK
  },
  bullet: {},
  polar: {
    commonSeriesSettings: {}
  },
  funnel: {
    label: {
      connector: {
        opacity: 1
      }
    }
  },
  sankey: {
    label: {
      font: {
        color: WHITE
      },
      shadow: {
        opacity: 0
      }
    },
    node: {
      border: {
        visible: true,
        width: 1,
        color: WHITE
      }
    },
    link: {
      opacity: 0.5,
      border: {
        visible: true,
        width: 1,
        color: WHITE
      },
      hoverStyle: {
        opacity: 0.9
      }
    }
  }
}, 'generic.light');
(0, _themes.registerTheme)({
  name: 'generic.contrast.compact'
}, 'generic.contrast');

/***/ }),
/* 1036 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _themes = __webpack_require__(57);

var ACCENT_COLOR = '#f05b41';
var BACKGROUND_COLOR = '#fff';
var TITLE_COLOR = '#333';
var SUBTITLE_COLOR = '#8899a8';
var TEXT_COLOR = '#707070';
var BORDER_COLOR = '#dee1e3';
(0, _themes.registerTheme)({
  name: 'generic.carmine',
  defaultPalette: 'Carmine',
  backgroundColor: BACKGROUND_COLOR,
  primaryTitleColor: TITLE_COLOR,
  secondaryTitleColor: SUBTITLE_COLOR,
  gridColor: BORDER_COLOR,
  axisColor: TEXT_COLOR,
  'export': {
    backgroundColor: BACKGROUND_COLOR,
    font: {
      color: TITLE_COLOR
    },
    button: {
      'default': {
        color: TITLE_COLOR,
        borderColor: '#b1b7bd',
        backgroundColor: BACKGROUND_COLOR
      },
      hover: {
        color: TITLE_COLOR,
        borderColor: '#b1b7bd',
        backgroundColor: '#faf2f0'
      },
      focus: {
        color: TITLE_COLOR,
        borderColor: '#6d7781',
        backgroundColor: '#faf2f0'
      },
      active: {
        color: TITLE_COLOR,
        borderColor: '#6d7781',
        backgroundColor: '#f5e7e4'
      }
    }
  },
  legend: {
    font: {
      color: TEXT_COLOR
    }
  },
  tooltip: {
    color: BACKGROUND_COLOR,
    border: {
      color: BORDER_COLOR
    },
    font: {
      color: TITLE_COLOR
    }
  },
  'chart:common': {
    commonSeriesSettings: {
      label: {
        border: {
          color: BORDER_COLOR
        }
      }
    }
  },
  'chart:common:annotation': {
    font: {
      color: TITLE_COLOR
    },
    border: {
      color: BORDER_COLOR
    },
    color: BACKGROUND_COLOR
  },
  chart: {
    commonPaneSettings: {
      border: {
        color: BORDER_COLOR
      }
    },
    commonAxisSettings: {
      breakStyle: {
        color: '#c1c5c7'
      }
    }
  },
  rangeSelector: {
    scale: {
      breakStyle: {
        color: '#c1c5c7'
      },
      tick: {
        opacity: 0.12
      }
    },
    selectedRangeColor: ACCENT_COLOR,
    sliderMarker: {
      color: ACCENT_COLOR
    },
    sliderHandle: {
      color: ACCENT_COLOR,
      opacity: 0.5
    }
  },
  sparkline: {
    pointColor: BACKGROUND_COLOR,
    minColor: '#f0ad4e',
    maxColor: '#f74d61'
  },
  treeMap: {
    group: {
      color: BORDER_COLOR,
      label: {
        font: {
          color: SUBTITLE_COLOR
        }
      }
    }
  },
  bullet: {
    color: ACCENT_COLOR
  },
  gauge: {
    valueIndicators: {
      'rangebar': {
        color: ACCENT_COLOR
      },
      'textcloud': {
        color: ACCENT_COLOR
      }
    }
  }
}, 'generic.light');
(0, _themes.registerTheme)({
  name: 'generic.carmine.compact'
}, 'generic.carmine');

/***/ }),
/* 1037 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _themes = __webpack_require__(57);

var ACCENT_COLOR = '#3debd3';
var BACKGROUND_COLOR = '#465672';
var TITLE_COLOR = '#fff';
var SUBTITLE_COLOR = '#919bac';
var TEXT_COLOR = '#c7ccd4';
var BORDER_COLOR = '#596980';
(0, _themes.registerTheme)({
  name: 'generic.darkmoon',
  defaultPalette: 'Dark Moon',
  backgroundColor: BACKGROUND_COLOR,
  primaryTitleColor: TITLE_COLOR,
  secondaryTitleColor: SUBTITLE_COLOR,
  gridColor: BORDER_COLOR,
  axisColor: TEXT_COLOR,
  'export': {
    backgroundColor: BACKGROUND_COLOR,
    font: {
      color: TITLE_COLOR
    },
    button: {
      'default': {
        color: TITLE_COLOR,
        borderColor: '#7a889e',
        backgroundColor: BACKGROUND_COLOR
      },
      hover: {
        color: TITLE_COLOR,
        borderColor: '#9da8b8',
        backgroundColor: '#596e92'
      },
      focus: {
        color: TITLE_COLOR,
        borderColor: '#c4cad4',
        backgroundColor: '#596e92'
      },
      active: {
        color: TITLE_COLOR,
        borderColor: '#c4cad4',
        backgroundColor: '#6b80a4'
      }
    }
  },
  legend: {
    font: {
      color: TEXT_COLOR
    }
  },
  tooltip: {
    color: '#62789e',
    border: {
      color: BORDER_COLOR
    },
    font: {
      color: TITLE_COLOR
    }
  },
  'chart:common': {
    commonSeriesSettings: {
      label: {
        border: {
          color: BORDER_COLOR
        }
      }
    }
  },
  'chart:common:annotation': {
    font: {
      color: TITLE_COLOR
    },
    border: {
      color: BORDER_COLOR
    },
    color: '#62789e'
  },
  chart: {
    commonPaneSettings: {
      border: {
        color: BORDER_COLOR
      }
    },
    commonAxisSettings: {
      breakStyle: {
        color: '#73869e'
      }
    }
  },
  gauge: {
    valueIndicators: {
      'rangebar': {
        color: ACCENT_COLOR
      },
      'textcloud': {
        color: ACCENT_COLOR,
        text: {
          font: {
            color: BACKGROUND_COLOR
          }
        }
      }
    }
  },
  barGauge: {
    backgroundColor: '#526280'
  },
  funnel: {
    item: {
      border: {
        color: BACKGROUND_COLOR
      }
    }
  },
  sparkline: {
    pointColor: BACKGROUND_COLOR,
    minColor: '#f0ad4e',
    maxColor: '#f9517e'
  },
  treeMap: {
    group: {
      color: BORDER_COLOR,
      label: {
        font: {
          color: TITLE_COLOR
        }
      }
    }
  },
  map: {
    background: {
      borderColor: BORDER_COLOR
    },
    'layer:area': {
      color: '#97a3b6',
      borderColor: BACKGROUND_COLOR
    }
  },
  rangeSelector: {
    shutter: {
      color: BACKGROUND_COLOR
    },
    scale: {
      breakStyle: {
        color: '#73869e'
      },
      tick: {
        opacity: 0.2
      }
    },
    selectedRangeColor: ACCENT_COLOR,
    sliderMarker: {
      color: ACCENT_COLOR,
      font: {
        color: '#000'
      }
    },
    sliderHandle: {
      color: ACCENT_COLOR,
      opacity: 0.5
    }
  },
  bullet: {
    color: ACCENT_COLOR
  },
  sankey: {
    link: {
      border: {
        color: BACKGROUND_COLOR
      }
    },
    node: {
      border: {
        color: BACKGROUND_COLOR
      }
    }
  }
}, 'generic.dark');
(0, _themes.registerTheme)({
  name: 'generic.darkmoon.compact'
}, 'generic.darkmoon');

/***/ }),
/* 1038 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _themes = __webpack_require__(57);

var ACCENT_COLOR = '#7ab8eb';
var BACKGROUND_COLOR = '#fff';
var TITLE_COLOR = '#333';
var SUBTITLE_COLOR = '#99a1a8';
var TEXT_COLOR = '#707070';
var BORDER_COLOR = '#e8eaeb';
(0, _themes.registerTheme)({
  name: 'generic.softblue',
  defaultPalette: 'Soft Blue',
  backgroundColor: BACKGROUND_COLOR,
  primaryTitleColor: TITLE_COLOR,
  secondaryTitleColor: SUBTITLE_COLOR,
  gridColor: BORDER_COLOR,
  axisColor: TEXT_COLOR,
  'export': {
    backgroundColor: BACKGROUND_COLOR,
    font: {
      color: TITLE_COLOR
    },
    button: {
      'default': {
        color: TITLE_COLOR,
        borderColor: '#c9d0d4',
        backgroundColor: BACKGROUND_COLOR
      },
      hover: {
        color: TITLE_COLOR,
        borderColor: '#a7b2b9',
        backgroundColor: '#e6e6e6'
      },
      focus: {
        color: TITLE_COLOR,
        borderColor: '#82929b',
        backgroundColor: '#e6e6e6'
      },
      active: {
        color: TITLE_COLOR,
        borderColor: '#82929b',
        backgroundColor: '#d4d4d4'
      }
    }
  },
  legend: {
    font: {
      color: TEXT_COLOR
    }
  },
  tooltip: {
    color: BACKGROUND_COLOR,
    border: {
      color: BORDER_COLOR
    },
    font: {
      color: TITLE_COLOR
    }
  },
  'chart:common': {
    commonSeriesSettings: {
      label: {
        border: {
          color: BORDER_COLOR
        }
      }
    }
  },
  'chart:common:annotation': {
    color: BACKGROUND_COLOR,
    border: {
      color: BORDER_COLOR
    },
    font: {
      color: TITLE_COLOR
    }
  },
  chart: {
    commonPaneSettings: {
      border: {
        color: BORDER_COLOR
      }
    },
    commonAxisSettings: {
      breakStyle: {
        color: '#cfd2d3'
      }
    }
  },
  rangeSelector: {
    scale: {
      breakStyle: {
        color: '#cfd2d3'
      },
      tick: {
        opacity: 0.12
      }
    },
    selectedRangeColor: ACCENT_COLOR,
    sliderMarker: {
      color: ACCENT_COLOR
    },
    sliderHandle: {
      color: ACCENT_COLOR,
      opacity: 0.5
    }
  },
  sparkline: {
    pointColor: BACKGROUND_COLOR,
    minColor: '#f0ad4e',
    maxColor: '#d9534f'
  },
  treeMap: {
    group: {
      color: BORDER_COLOR,
      label: {
        font: {
          color: SUBTITLE_COLOR
        }
      }
    }
  },
  bullet: {
    color: ACCENT_COLOR
  },
  gauge: {
    valueIndicators: {
      'rangebar': {
        color: ACCENT_COLOR
      },
      'textcloud': {
        color: ACCENT_COLOR
      }
    }
  }
}, 'generic.light');
(0, _themes.registerTheme)({
  name: 'generic.softblue.compact'
}, 'generic.softblue');

/***/ }),
/* 1039 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _themes = __webpack_require__(57);

var ACCENT_COLOR = '#9c63ff';
var BACKGROUND_COLOR = '#17171f';
var TITLE_COLOR = '#f5f6f7';
var SUBTITLE_COLOR = '#fff';
var TEXT_COLOR = '#b2b2b6';
var BORDER_COLOR = '#343840';
(0, _themes.registerTheme)({
  name: 'generic.darkviolet',
  defaultPalette: 'Dark Violet',
  backgroundColor: BACKGROUND_COLOR,
  primaryTitleColor: TITLE_COLOR,
  secondaryTitleColor: SUBTITLE_COLOR,
  gridColor: BORDER_COLOR,
  axisColor: TEXT_COLOR,
  'export': {
    backgroundColor: BACKGROUND_COLOR,
    font: {
      color: TITLE_COLOR
    },
    button: {
      'default': {
        color: TITLE_COLOR,
        borderColor: '#414152',
        backgroundColor: BACKGROUND_COLOR
      },
      hover: {
        color: TITLE_COLOR,
        borderColor: '#5c5c74',
        backgroundColor: '#2d2d3c'
      },
      focus: {
        color: TITLE_COLOR,
        borderColor: '#7c7c97',
        backgroundColor: '#2d2d3c'
      },
      active: {
        color: TITLE_COLOR,
        borderColor: '#7c7c97',
        backgroundColor: '#3c3c51'
      }
    }
  },
  legend: {
    font: {
      color: TEXT_COLOR
    }
  },
  tooltip: {
    color: BACKGROUND_COLOR,
    border: {
      color: '#414152'
    },
    font: {
      color: TITLE_COLOR
    }
  },
  'chart:common': {
    commonSeriesSettings: {
      label: {
        border: {
          color: BORDER_COLOR
        }
      }
    }
  },
  'chart:common:annotation': {
    font: {
      color: TITLE_COLOR
    },
    border: {
      color: '#414152'
    },
    color: BACKGROUND_COLOR
  },
  chart: {
    commonPaneSettings: {
      border: {
        color: BORDER_COLOR
      }
    },
    commonAxisSettings: {
      breakStyle: {
        color: '#575e6b'
      }
    }
  },
  funnel: {
    item: {
      border: {
        color: BACKGROUND_COLOR
      }
    }
  },
  sparkline: {
    pointColor: BACKGROUND_COLOR,
    minColor: '#f0ad4e',
    maxColor: '#d9534f'
  },
  treeMap: {
    group: {
      color: BORDER_COLOR,
      label: {
        font: {
          color: SUBTITLE_COLOR
        }
      }
    }
  },
  rangeSelector: {
    shutter: {
      color: BACKGROUND_COLOR
    },
    scale: {
      breakStyle: {
        color: '#575e6b'
      },
      tick: {
        opacity: 0.2
      }
    },
    selectedRangeColor: ACCENT_COLOR,
    sliderMarker: {
      color: ACCENT_COLOR,
      font: {
        color: '#fff'
      }
    },
    sliderHandle: {
      color: ACCENT_COLOR,
      opacity: 0.5
    }
  },
  bullet: {
    color: ACCENT_COLOR
  },
  gauge: {
    valueIndicators: {
      'rangebar': {
        color: ACCENT_COLOR
      },
      'textcloud': {
        color: ACCENT_COLOR
      }
    }
  },
  sankey: {
    link: {
      border: {
        color: BACKGROUND_COLOR
      }
    },
    node: {
      border: {
        color: BACKGROUND_COLOR
      }
    }
  }
}, 'generic.dark');
(0, _themes.registerTheme)({
  name: 'generic.darkviolet.compact'
}, 'generic.darkviolet');

/***/ }),
/* 1040 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _themes = __webpack_require__(57);

var ACCENT_COLOR = '#3cbab2';
var BACKGROUND_COLOR = '#f5f5f5';
var TITLE_COLOR = '#28484f';
var SUBTITLE_COLOR = '#7eb2be';
var TEXT_COLOR = '#657c80';
var BORDER_COLOR = '#dedede';
(0, _themes.registerTheme)({
  name: 'generic.greenmist',
  defaultPalette: 'Green Mist',
  backgroundColor: BACKGROUND_COLOR,
  primaryTitleColor: TITLE_COLOR,
  secondaryTitleColor: SUBTITLE_COLOR,
  gridColor: BORDER_COLOR,
  axisColor: TEXT_COLOR,
  'export': {
    backgroundColor: BACKGROUND_COLOR,
    font: {
      color: TITLE_COLOR
    },
    button: {
      'default': {
        color: TITLE_COLOR,
        borderColor: '#a2b4b8',
        backgroundColor: BACKGROUND_COLOR
      },
      hover: {
        color: TITLE_COLOR,
        borderColor: '#7f989e',
        backgroundColor: 'rgba(222, 222, 222, 0.4)'
      },
      focus: {
        color: TITLE_COLOR,
        borderColor: '#5f777c',
        backgroundColor: 'rgba(222, 222, 222, 0.4)'
      },
      active: {
        color: TITLE_COLOR,
        borderColor: '#5f777c',
        backgroundColor: 'rgba(222, 222, 222, 0.8)'
      }
    }
  },
  legend: {
    font: {
      color: TEXT_COLOR
    }
  },
  tooltip: {
    color: '#fff',
    border: {
      color: BORDER_COLOR
    },
    font: {
      color: TITLE_COLOR
    }
  },
  'chart:common': {
    commonSeriesSettings: {
      label: {
        border: {
          color: BORDER_COLOR
        }
      }
    }
  },
  'chart:common:annotation': {
    color: '#fff',
    border: {
      color: BORDER_COLOR
    },
    font: {
      color: TITLE_COLOR
    }
  },
  chart: {
    commonPaneSettings: {
      border: {
        color: BORDER_COLOR
      }
    },
    commonAxisSettings: {
      breakStyle: {
        color: '#c1c1c1'
      }
    }
  },
  funnel: {
    item: {
      border: {
        color: BACKGROUND_COLOR
      }
    }
  },
  sparkline: {
    pointColor: BACKGROUND_COLOR,
    minColor: '#ffc852',
    maxColor: '#f74a5e'
  },
  treeMap: {
    group: {
      color: BORDER_COLOR,
      label: {
        font: {
          color: SUBTITLE_COLOR
        }
      }
    }
  },
  rangeSelector: {
    shutter: {
      color: BACKGROUND_COLOR
    },
    scale: {
      breakStyle: {
        color: '#c1c1c1'
      },
      tick: {
        opacity: 0.12
      }
    },
    selectedRangeColor: ACCENT_COLOR,
    sliderMarker: {
      color: ACCENT_COLOR
    },
    sliderHandle: {
      color: ACCENT_COLOR,
      opacity: 0.5
    }
  },
  bullet: {
    color: ACCENT_COLOR
  },
  gauge: {
    valueIndicators: {
      'rangebar': {
        color: ACCENT_COLOR
      },
      'textcloud': {
        color: ACCENT_COLOR
      }
    }
  }
}, 'generic.light');
(0, _themes.registerTheme)({
  name: 'generic.greenmist.compact'
}, 'generic.greenmist');

/***/ }),
/* 1041 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _themes = __webpack_require__(57);

var FONT_FAMILY = '\'Roboto\', \'RobotoFallback\', \'Helvetica\', \'Arial\', sans-serif';
var LIGHT_TITLE_COLOR = 'rgba(0,0,0,0.87)';
var LIGHT_LABEL_COLOR = 'rgba(0,0,0,0.54)';
var DARK_TITLE_COLOR = 'rgba(255,255,255,0.87)';
var DARK_LABEL_COLOR = 'rgba(255,255,255,0.54)';
var DARK_BACKGROUND_COLOR = '#363640';
var WHITE = '#ffffff';
var BLACK = '#000000';
var RANGE_COLOR = '#b5b5b5';
var AREA_LAYER_COLOR = '#686868';
var LINE_COLOR = '#c7c7c7';
var TARGET_COLOR = '#8e8e8e';
var POSITIVE_COLOR = '#b8b8b8';
var LABEL_BORDER_COLOR = '#494949';
var BREAK_STYLE_COLOR = '#818181';
(0, _themes.registerTheme)({
  name: 'material',
  defaultPalette: 'Material',
  font: {
    family: FONT_FAMILY
  },
  title: {
    margin: {
      top: 20,
      bottom: 20,
      left: 0,
      right: 0
    },
    font: {
      size: 20,
      family: FONT_FAMILY,
      weight: 500
    },
    horizontalAlignment: 'left',
    subtitle: {
      font: {
        size: 14
      },
      horizontalAlignment: 'left'
    }
  },
  tooltip: {
    shadow: {
      opacity: 0
    },
    border: {
      visible: false
    },
    paddingLeftRight: 8,
    paddingTopBottom: 6,
    arrowLength: 0,
    location: 'edge',
    color: '#616161',
    font: {
      color: WHITE
    },
    cornerRadius: 4
  },
  chart: {
    commonAxisSettings: {
      minorTick: {
        opacity: 0.5
      },
      label: {
        font: {
          size: 11
        }
      }
    },
    commonAnnotationSettings: {
      font: {
        color: WHITE
      },
      border: {
        color: '#616161'
      },
      color: '#616161',
      arrowLength: 14,
      arrowWidth: 0,
      shadow: {
        opacity: 0.08,
        offsetY: 4,
        blur: 8
      },
      cornerRadius: 4
    }
  },
  pie: {
    title: {
      horizontalAlignment: 'center',
      subtitle: {
        horizontalAlignment: 'center'
      }
    }
  },
  polar: {
    commonAxisSettings: {
      minorTick: {
        opacity: 0.5
      }
    },
    title: {
      horizontalAlignment: 'center',
      subtitle: {
        horizontalAlignment: 'center'
      }
    }
  },
  funnel: {
    title: {
      horizontalAlignment: 'center',
      subtitle: {
        horizontalAlignment: 'center'
      }
    }
  },
  gauge: {
    title: {
      horizontalAlignment: 'center',
      subtitle: {
        horizontalAlignment: 'center'
      }
    }
  },
  barGauge: {
    title: {
      horizontalAlignment: 'center',
      subtitle: {
        horizontalAlignment: 'center'
      }
    }
  },
  rangeSelector: {
    sliderHandle: {
      opacity: 0.5
    }
  },
  treeMap: {
    group: {
      label: {
        font: {
          weight: 500
        }
      }
    }
  }
}, 'generic.light');
(0, _themes.registerTheme)({
  name: 'material.light',
  gridColor: '#e0e0e0',
  axisColor: LIGHT_LABEL_COLOR,
  primaryTitleColor: LIGHT_TITLE_COLOR,
  legend: {
    font: {
      color: LIGHT_LABEL_COLOR
    }
  },
  chart: {
    scrollBar: {
      color: '#bfbfbf',
      opacity: 0.7
    }
  },
  gauge: {
    rangeContainer: {
      backgroundColor: 'rgba(0,0,0,0.2)'
    }
  },
  barGauge: {
    backgroundColor: '#efefef'
  }
}, 'material');
(0, _themes.registerTheme)({
  name: 'material.dark',
  gridColor: '#515159',
  backgroundColor: DARK_BACKGROUND_COLOR,
  axisColor: DARK_LABEL_COLOR,
  font: {
    color: DARK_LABEL_COLOR
  },
  primaryTitleColor: DARK_TITLE_COLOR,
  secondaryTitleColor: DARK_TITLE_COLOR,
  tooltip: {
    color: '#000'
  },
  'export': {
    backgroundColor: DARK_BACKGROUND_COLOR,
    font: {
      color: '#dbdbdb'
    },
    button: {
      'default': {
        color: '#dedede',
        borderColor: '#4d4d4d',
        backgroundColor: DARK_BACKGROUND_COLOR
      },
      hover: {
        color: '#dedede',
        borderColor: '#6c6c6c',
        backgroundColor: '#3f3f4b'
      },
      focus: {
        color: '#dedede',
        borderColor: '#8d8d8d',
        backgroundColor: '#494956'
      },
      active: {
        color: '#dedede',
        borderColor: '#8d8d8d',
        backgroundColor: '#494956'
      }
    },
    shadowColor: '#292929'
  },
  'chart:common': {
    commonSeriesSettings: {
      label: {
        border: {
          color: LABEL_BORDER_COLOR
        }
      },
      valueErrorBar: {
        color: WHITE
      }
    }
  },
  'chart:common:axis': {
    constantLineStyle: {
      color: WHITE
    }
  },
  'chart:common:annotation': {
    border: {
      color: '#000'
    },
    color: '#000'
  },
  chart: {
    commonPaneSettings: {
      border: {
        color: LABEL_BORDER_COLOR
      }
    },
    commonAxisSettings: {
      breakStyle: {
        color: BREAK_STYLE_COLOR
      }
    },
    zoomAndPan: {
      dragBoxStyle: {
        color: WHITE
      }
    }
  },
  gauge: {
    rangeContainer: {
      backgroundColor: RANGE_COLOR
    },
    valueIndicators: {
      _default: {
        color: RANGE_COLOR
      },
      'rangebar': {
        color: '#84788b'
      },
      'twocolorneedle': {
        secondColor: '#ba544d'
      },
      'trianglemarker': {
        color: '#b7918f'
      },
      'textcloud': {
        color: '#ba544d'
      }
    }
  },
  barGauge: {
    backgroundColor: '#3c3c3c'
  },
  rangeSelector: {
    scale: {
      tick: {
        color: WHITE,
        opacity: 0.32
      },
      minorTick: {
        color: WHITE,
        opacity: 0.1
      },
      breakStyle: {
        color: BREAK_STYLE_COLOR
      }
    },
    selectedRangeColor: RANGE_COLOR,
    sliderMarker: {
      color: RANGE_COLOR,
      font: {
        color: DARK_BACKGROUND_COLOR
      }
    },
    sliderHandle: {
      color: WHITE,
      opacity: 0.2
    },
    shutter: {
      color: WHITE,
      opacity: 0.1
    }
  },
  map: {
    background: {
      borderColor: '#3f3f3f'
    },
    layer: {
      label: {
        stroke: BLACK,
        font: {
          color: WHITE
        }
      }
    },
    'layer:area': {
      borderColor: DARK_BACKGROUND_COLOR,
      color: AREA_LAYER_COLOR,
      hoveredBorderColor: WHITE,
      selectedBorderColor: WHITE
    },
    'layer:line': {
      color: '#c77244',
      hoveredColor: '#ff5d04',
      selectedColor: '#ff784f'
    },
    'layer:marker:bubble': {
      hoveredBorderColor: WHITE,
      selectedBorderColor: WHITE
    },
    'layer:marker:pie': {
      hoveredBorderColor: WHITE,
      selectedBorderColor: WHITE
    },
    legend: {
      border: {
        color: '#3f3f3f'
      },
      font: {
        color: WHITE
      }
    },
    controlBar: {
      borderColor: LINE_COLOR,
      color: DARK_BACKGROUND_COLOR
    }
  },
  treeMap: {
    group: {
      color: '#4c4c4c',
      label: {
        font: {
          color: '#a3a3a3'
        }
      }
    }
  },
  sparkline: {
    lineColor: LINE_COLOR,
    firstLastColor: LINE_COLOR,
    barPositiveColor: POSITIVE_COLOR,
    barNegativeColor: TARGET_COLOR,
    winColor: POSITIVE_COLOR,
    lossColor: TARGET_COLOR,
    pointColor: DARK_BACKGROUND_COLOR
  },
  bullet: {
    targetColor: TARGET_COLOR
  },
  funnel: {
    item: {
      border: {
        color: DARK_BACKGROUND_COLOR
      }
    }
  },
  sankey: {
    label: {
      font: {
        color: WHITE
      }
    }
  }
}, 'material');

function registerMaterialColorScheme(accentName, themeName, accentColor) {
  (0, _themes.registerTheme)({
    name: 'material.' + accentName + '.' + themeName,
    rangeSelector: {
      selectedRangeColor: accentColor,
      sliderMarker: {
        color: accentColor
      },
      sliderHandle: {
        color: accentColor
      }
    },
    map: {
      'layer:marker:dot': {
        color: accentColor
      },
      'layer:marker:bubble': {
        color: accentColor
      },
      legend: {
        markerColor: accentColor
      }
    },
    bullet: {
      color: accentColor
    },
    gauge: {
      valueIndicators: {
        'rangebar': {
          color: accentColor
        },
        'textcloud': {
          color: accentColor
        }
      }
    }
  }, 'material.' + themeName);
}

var materialAccents = {
  'blue': '#03a9f4',
  'lime': '#cddc39',
  'orange': '#ff5722',
  'purple': '#9c27b0',
  'teal': '#009688'
};

for (var accent in materialAccents) {
  if (Object.prototype.hasOwnProperty.call(materialAccents, accent)) {
    var color = materialAccents[accent];
    registerMaterialColorScheme(accent, 'light', color);
    registerMaterialColorScheme(accent, 'dark', color);
    (0, _themes.registerTheme)({
      name: "material.".concat(accent, ".light.compact")
    }, "material.".concat(accent, ".light"));
    (0, _themes.registerTheme)({
      name: "material.".concat(accent, ".dark.compact")
    }, "material.".concat(accent, ".dark"));
  }
}

/***/ }),
/* 1042 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _utils = __webpack_require__(14);

var _min = Math.min;
var _max = Math.max;
var _round = Math.round;
var ALIGN_START = 0;
var ALIGN_MIDDLE = 1;
var ALIGN_END = 2;
var horizontalAlignmentMap = {
  left: ALIGN_START,
  center: ALIGN_MIDDLE,
  right: ALIGN_END
};
var verticalAlignmentMap = {
  top: ALIGN_START,
  center: ALIGN_MIDDLE,
  bottom: ALIGN_END
};
var sideMap = {
  horizontal: 0,
  vertical: 1
};
var slicersMap = {};
var BBOX_CEIL_CORRECTION = 2;

slicersMap[ALIGN_START] = function (a, b, size) {
  return [a, _min(b, a + size)];
};

slicersMap[ALIGN_MIDDLE] = function (a, b, size) {
  return [_max(a, (a + b - size) / 2), _min(b, (a + b + size) / 2)];
};

slicersMap[ALIGN_END] = function (a, b, size) {
  return [_max(a, b - size), b];
};

function pickValue(value, map, defaultValue) {
  var val = (0, _utils.normalizeEnum)(value);
  return val in map ? map[val] : defaultValue;
}

function normalizeLayoutOptions(options) {
  var side = pickValue(options.side, sideMap, 1);
  var alignment = [pickValue(options.horizontalAlignment, horizontalAlignmentMap, ALIGN_MIDDLE), pickValue(options.verticalAlignment, verticalAlignmentMap, ALIGN_START)];
  return {
    side: side,
    primary: bringToEdge(alignment[side]),
    secondary: alignment[1 - side],
    weak: options.weak,
    priority: options.priority || 0,
    header: options.header,
    position: options.position
  };
}

function bringToEdge(primary) {
  return primary < 2 ? 0 : 2;
}

function getConjugateSide(side) {
  return 1 - side;
}

function getSlice(alignment, a, b, size) {
  return slicersMap[alignment](a, b, size);
}

function getShrink(alignment, size) {
  return (alignment > 0 ? -1 : +1) * size;
}

function processForward(item, rect, minSize) {
  var side = item.side;
  var size = item.element.measure([rect[2] - rect[0], rect[3] - rect[1]]);
  var minSide = item.position === 'indside' ? 0 : minSize[side];
  var isValid = size[side] < rect[2 + side] - rect[side] - minSide;

  if (isValid) {
    if (item.position !== 'inside') {
      rect[item.primary + side] += getShrink(item.primary, size[side]);
    }

    item.size = size;
  }

  return isValid;
}

function processRectBackward(item, rect, alignmentRect) {
  var primarySide = item.side;
  var secondarySide = getConjugateSide(primarySide);
  var itemRect = [];
  var secondary = getSlice(item.secondary, alignmentRect[secondarySide], alignmentRect[2 + secondarySide], item.size[secondarySide]);
  itemRect[primarySide] = _round(itemRect[2 + primarySide] = rect[item.primary + primarySide] + (item.position === 'inside' ? getShrink(item.primary, item.size[primarySide]) : 0));
  itemRect[item.primary + primarySide] = _round(rect[item.primary + primarySide] - getShrink(item.primary, item.size[primarySide]));

  if (item.position !== 'inside') {
    rect[item.primary + primarySide] = itemRect[item.primary + primarySide];
  }

  itemRect[secondarySide] = _round(secondary[0]);
  itemRect[2 + secondarySide] = _round(secondary[1]);
  return itemRect;
}

function processBackward(item, rect, alignmentRect, fitRect, size, targetRect) {
  var itemRect = processRectBackward(item, rect, alignmentRect);
  var itemFitRect = processRectBackward(item, fitRect, fitRect);

  if (size[item.side] > 0) {
    size[item.side] -= item.size[item.side];
    targetRect[item.primary + item.side] = itemRect[item.primary + item.side];
    item.element.freeSpace();
  } else {
    item.element.move(itemRect, itemFitRect);
  }
}

function Layout() {
  this._targets = [];
}

Layout.prototype = {
  constructor: Layout,
  dispose: function dispose() {
    this._targets = null;
  },
  add: function add(target) {
    this._targets.push(target);
  },
  // Note on possible improvement.
  // "createTargets" part depends on options of a target while the following cycle depends on container size - those areas do not intersect.
  // When any of options are changed targets have to be recreated and cycle has to be executed. But when container size is changed there is no
  // need to recreate targets - only cycle has to be executed.
  forward: function forward(targetRect, minSize) {
    var rect = targetRect.slice();
    var targets = createTargets(this._targets);
    var i;
    var ii = targets.length;
    var cache = [];

    for (i = 0; i < ii; ++i) {
      if (processForward(targets[i], rect, minSize)) {
        cache.push(targets[i]);
      } else {
        targets[i].element.freeSpace();
      }
    }

    this._cache = cache.reverse();
    return rect;
  },
  backward: function backward(targetRect, alignmentRect) {
    var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];
    var backwardRect = targetRect.slice();
    var fitRect = targetRect.slice();
    var targets = this._cache;
    var targetSide = 0;
    var target;
    var i;
    var ii = targets.length;

    for (i = 0; i < ii; ++i) {
      target = targets[i];

      if (target.side !== targetSide) {
        backwardRect = targetRect.slice();
      }

      processBackward(target, backwardRect, alignmentRect, fitRect, size, targetRect);
      targetSide = target.side;
    }

    return size;
  }
};

function createTargets(targets) {
  var i;
  var ii = targets.length;
  var collection = [];
  var layout;

  for (i = 0; i < ii; ++i) {
    layout = targets[i].layoutOptions();

    if (layout) {
      layout = normalizeLayoutOptions(layout);
      layout.element = targets[i];
      collection.push(layout);
    }
  }

  collection.sort(function (a, b) {
    return b.side - a.side || a.priority - b.priority;
  });
  collection = processWeakItems(collection);
  return collection;
}

function processWeakItems(collection) {
  var weakItem = collection.filter(function (item) {
    return item.weak === true;
  })[0];
  var headerItem;

  if (weakItem) {
    headerItem = collection.filter(function (item) {
      return weakItem.primary === item.primary && item.side === weakItem.side && item !== weakItem;
    })[0];
  }

  if (weakItem && headerItem) {
    return [makeHeader(headerItem, weakItem)].concat(collection.filter(function (item) {
      return !(item === headerItem || item === weakItem);
    }));
  }

  return collection;
}

function processBackwardHeaderRect(element, rect) {
  var rectCopy = rect.slice();
  var itemRect = processRectBackward(element, rectCopy, rectCopy);
  itemRect[element.side] = rect[element.side];
  itemRect[2 + element.side] = rect[2 + element.side];
  return itemRect;
}

function makeHeader(header, weakElement) {
  var side = header.side;
  var primary = header.primary;
  var secondary = header.secondary;
  return {
    side: side,
    primary: primary,
    secondary: secondary,
    priority: 0,
    element: {
      measure: function measure(targetSize) {
        var result = targetSize.slice();
        var weakSize = weakElement.element.measure(targetSize.slice());
        targetSize[primary] -= weakSize[primary];
        var headerSize = header.element.measure(targetSize.slice());
        result[side] = weakSize[side] = headerSize[side] = Math.max(headerSize[side], weakSize[side]);
        weakElement.size = weakSize;
        header.size = headerSize;
        return result;
      },
      move: function move(rect, fitRect) {
        if (fitRect[2] - fitRect[0] < header.size[0] + weakElement.size[0] - BBOX_CEIL_CORRECTION) {
          this.freeSpace();
          return;
        }

        var weakRect = processBackwardHeaderRect(weakElement, fitRect);
        fitRect[2 + weakElement.primary] = weakRect[weakElement.primary];
        var headerFitReact = processBackwardHeaderRect(header, fitRect);

        if (fitRect[2 + weakElement.primary] < rect[2 + weakElement.primary] && header.size[header.primary] > rect[2 + header.primary] - rect[header.primary]) {
          rect[2 + weakElement.primary] = fitRect[2 + weakElement.primary];
        }

        var headerRect = processBackwardHeaderRect(header, rect);

        if (headerRect[2 + weakElement.primary] > fitRect[2 + weakElement.primary]) {
          rect[2 + weakElement.primary] = fitRect[2 + weakElement.primary];
          headerRect = processBackwardHeaderRect(header, rect);
        }

        weakElement.element.move(weakRect);
        header.element.move(headerRect, headerFitReact);
      },
      freeSpace: function freeSpace() {
        header.element.freeSpace();
        weakElement.element.freeSpace();
      }
    }
  };
}

var _default = Layout;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1043 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.createEventTrigger = createEventTrigger;
exports.createResizeHandler = createResizeHandler;
exports.createIncidentOccurred = void 0;

var _version = __webpack_require__(169);

var _string = __webpack_require__(40);

var _errors_warnings = _interopRequireDefault(__webpack_require__(586));

var _iterator = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ERROR_MESSAGES = _errors_warnings.default.ERROR_MESSAGES;

function createEventTrigger(eventsMap, callbackGetter) {
  var triggers = {};
  (0, _iterator.each)(eventsMap, function (name, info) {
    if (info.name) {
      createEvent(name);
    }
  });
  var changes;

  triggerEvent.change = function (name) {
    var eventInfo = eventsMap[name];

    if (eventInfo) {
      (changes = changes || {})[name] = eventInfo;
    }

    return !!eventInfo;
  };

  triggerEvent.applyChanges = function () {
    if (changes) {
      (0, _iterator.each)(changes, function (name, eventInfo) {
        createEvent(eventInfo.newName || name);
      });
      changes = null;
    }
  };

  triggerEvent.dispose = function () {
    eventsMap = callbackGetter = triggers = null;
  };

  return triggerEvent;

  function createEvent(name) {
    var eventInfo = eventsMap[name];
    triggers[eventInfo.name] = callbackGetter(name);
  }

  function triggerEvent(name, arg, complete) {
    triggers[name](arg);
    complete && complete();
  }
}

var createIncidentOccurred = function createIncidentOccurred(widgetName, eventTrigger) {
  return function incidentOccurred(id, args) {
    eventTrigger('incidentOccurred', {
      target: {
        id: id,
        type: id[0] === 'E' ? 'error' : 'warning',
        args: args,
        text: _string.format.apply(null, [ERROR_MESSAGES[id]].concat(args || [])),
        widget: widgetName,
        version: _version.version
      }
    });
  };
};

exports.createIncidentOccurred = createIncidentOccurred;

function createResizeHandler(callback) {
  var timeout;

  var handler = function handler() {
    clearTimeout(timeout);
    timeout = setTimeout(callback, 100);
  };

  handler.dispose = function () {
    clearTimeout(timeout);
    return this;
  };

  return handler;
}

/***/ }),
/* 1044 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Point = Point;

var _consts = _interopRequireDefault(__webpack_require__(161));

var _symbol_point = _interopRequireDefault(__webpack_require__(162));

var _bar_point = _interopRequireDefault(__webpack_require__(240));

var _bubble_point = _interopRequireDefault(__webpack_require__(1045));

var _pie_point = _interopRequireDefault(__webpack_require__(587));

var _range_symbol_point = _interopRequireDefault(__webpack_require__(588));

var _range_bar_point = _interopRequireDefault(__webpack_require__(1046));

var _candlestick_point = _interopRequireDefault(__webpack_require__(589));

var _stock_point = _interopRequireDefault(__webpack_require__(1047));

var _polar_point = __webpack_require__(1048);

var _utils = __webpack_require__(14);

var _extend2 = __webpack_require__(0);

var _type = __webpack_require__(1);

var _common = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mixins = {};
var _extend = _extend2.extend;
var statesConsts = _consts.default.states;
var SYMBOL_POINT = 'symbolPoint';
var POLAR_SYMBOL_POINT = 'polarSymbolPoint';
var BAR_POINT = 'barPoint';
var POLAR_BAR_POINT = 'polarBarPoint';
var PIE_POINT = 'piePoint';
var SELECTED_STATE = statesConsts.selectedMark;
var HOVER_STATE = statesConsts.hoverMark;
var NORMAL_STATE = statesConsts.normalMark;
var HOVER = statesConsts.hover;
var NORMAL = statesConsts.normal;
var SELECTION = statesConsts.selection;
var pointTypes = {
  chart: {
    'scatter': SYMBOL_POINT,
    'line': SYMBOL_POINT,
    'spline': SYMBOL_POINT,
    'stepline': SYMBOL_POINT,
    'stackedline': SYMBOL_POINT,
    'fullstackedline': SYMBOL_POINT,
    'stackedspline': SYMBOL_POINT,
    'fullstackedspline': SYMBOL_POINT,
    'stackedsplinearea': SYMBOL_POINT,
    'fullstackedsplinearea': SYMBOL_POINT,
    'area': SYMBOL_POINT,
    'splinearea': SYMBOL_POINT,
    'steparea': SYMBOL_POINT,
    'stackedarea': SYMBOL_POINT,
    'fullstackedarea': SYMBOL_POINT,
    'rangearea': 'rangeSymbolPoint',
    'bar': BAR_POINT,
    'stackedbar': BAR_POINT,
    'fullstackedbar': BAR_POINT,
    'rangebar': 'rangeBarPoint',
    'bubble': 'bubblePoint',
    'stock': 'stockPoint',
    'candlestick': 'candlestickPoint'
  },
  pie: {
    'pie': PIE_POINT,
    'doughnut': PIE_POINT,
    'donut': PIE_POINT
  },
  polar: {
    'scatter': POLAR_SYMBOL_POINT,
    'line': POLAR_SYMBOL_POINT,
    'area': POLAR_SYMBOL_POINT,
    'bar': POLAR_BAR_POINT,
    'stackedbar': POLAR_BAR_POINT
  }
};

function isNoneMode(mode) {
  return (0, _utils.normalizeEnum)(mode) === 'none';
}

function Point(series, dataItem, options) {
  this.fullState = NORMAL_STATE;
  this.series = series;
  this.update(dataItem, options);
  this._viewCounters = {
    hover: 0,
    selection: 0
  };
  this._emptySettings = {
    fill: null,
    stroke: null,
    dashStyle: null
  };
}

mixins.symbolPoint = _symbol_point.default;
mixins.barPoint = _bar_point.default;
mixins.bubblePoint = _bubble_point.default;
mixins.piePoint = _pie_point.default;
mixins.rangeSymbolPoint = _range_symbol_point.default;
mixins.rangeBarPoint = _range_bar_point.default;
mixins.candlestickPoint = _candlestick_point.default;
mixins.stockPoint = _stock_point.default;
mixins.polarSymbolPoint = _polar_point.polarSymbolPoint;
mixins.polarBarPoint = _polar_point.polarBarPoint;
Point.prototype = {
  constructor: Point,
  getColor: function getColor() {
    if (!this.hasValue() && !this._styles.usePointCustomOptions) {
      this.series.customizePoint(this, this._dataItem);
    }

    return this._styles.normal.fill || this.series.getColor();
  },
  _getStyle: function _getStyle() {
    return this._styles[this._currentStyle || 'normal'];
  },
  update: function update(dataItem, options) {
    this.updateOptions(options);
    this.updateData(dataItem);
  },
  updateData: function updateData(dataItem) {
    var that = this;
    var argumentWasChanged = that.argument !== dataItem.argument;
    that.argument = that.initialArgument = that.originalArgument = dataItem.argument;
    that.tag = dataItem.tag;
    that.index = dataItem.index;
    that._dataItem = dataItem;
    that.data = dataItem.data;
    that.lowError = dataItem.lowError;
    that.highError = dataItem.highError;
    that.aggregationInfo = dataItem.aggregationInfo;

    that._updateData(dataItem, argumentWasChanged);

    !that.hasValue() && that.setInvisibility();

    that._fillStyle();

    that._updateLabelData();
  },
  deleteMarker: function deleteMarker() {
    var that = this;

    if (that.graphic) {
      that.graphic.dispose();
    }

    that.graphic = null;
  },
  draw: function draw(renderer, groups, animationEnabled, firstDrawing) {
    var that = this;

    if (that._needDeletingOnDraw || that.series.autoHidePointMarkers && !that.isSelected()) {
      that.deleteMarker();
      that._needDeletingOnDraw = false;
    }

    if (that._needClearingOnDraw) {
      that.clearMarker();
      that._needClearingOnDraw = false;
    }

    if (!that._hasGraphic()) {
      that.getMarkerVisibility() && !that.series.autoHidePointMarkers && that._drawMarker(renderer, groups.markers, animationEnabled, firstDrawing);
    } else {
      that._updateMarker(animationEnabled, this._getStyle(), groups.markers);
    }

    that._drawLabel();

    that._drawErrorBar(renderer, groups.errorBars, animationEnabled);

    return that;
  },
  _getViewStyle: function _getViewStyle() {
    var state = NORMAL_STATE;
    var fullState = this.fullState;
    var styles = [NORMAL, HOVER, SELECTION, SELECTION];

    if (this._viewCounters.hover) {
      state |= HOVER_STATE;
    }

    if (this._viewCounters.selection) {
      state |= SELECTED_STATE;
    }

    if (isNoneMode(this.getOptions().selectionMode)) {
      fullState &= ~SELECTED_STATE;
    }

    if (isNoneMode(this.getOptions().hoverMode)) {
      fullState &= ~HOVER_STATE;
    }

    state |= fullState;
    return styles[state];
  },
  applyView: function applyView(legendCallback) {
    var style = this._getViewStyle();

    var that = this;
    that._currentStyle = style;

    if (!that.graphic && that.series.autoHidePointMarkers && (style === SELECTION || style === HOVER)) {
      that._drawMarker(that.series.getRenderer(), that.series.getMarkersGroup());
    }

    if (that.graphic) {
      if (that.series.autoHidePointMarkers && style !== SELECTION && style !== HOVER) {
        that.deleteMarker();
      } else {
        if (style === 'normal') {
          that.clearMarker();
        } else {
          that.graphic.toForeground();
        }

        that._updateMarker(true, that._styles[style], undefined, legendCallback);
      }
    }
  },
  setView: function setView(style) {
    this._viewCounters[style]++;
    this.applyView();
  },
  resetView: function resetView(style) {
    var viewCounters = this._viewCounters;
    --viewCounters[style];

    if (viewCounters[style] < 0) {
      // T661080
      viewCounters[style] = 0;
    }

    this.applyView();
  },
  releaseHoverState: function releaseHoverState() {
    var that = this;

    if (that.graphic && !that.isSelected()) {
      that.graphic.toBackground();
    }
  },
  select: function select() {
    this.series.selectPoint(this);
  },
  clearSelection: function clearSelection() {
    this.series.deselectPoint(this);
  },
  hover: function hover() {
    this.series.hoverPoint(this);
  },
  clearHover: function clearHover() {
    this.series.clearPointHover();
  },
  showTooltip: function showTooltip() {
    this.series.showPointTooltip(this);
  },
  hideTooltip: function hideTooltip() {
    this.series.hidePointTooltip(this);
  },
  _checkLabelsChanging: function _checkLabelsChanging(oldType, newType) {
    var isNewRange = ~newType.indexOf('range');
    var isOldRange = ~oldType.indexOf('range');
    return isOldRange && !isNewRange || !isOldRange && isNewRange;
  },
  updateOptions: function updateOptions(newOptions) {
    if (!newOptions) {
      return;
    }

    var that = this;
    var oldOptions = that._options;
    var widgetType = newOptions.widgetType;
    var oldType = oldOptions && oldOptions.type;
    var newType = newOptions.type;
    var newPointTypeMixin = pointTypes[widgetType][newType];

    if (oldType !== newType) {
      that._needDeletingOnDraw = true;
      that._needClearingOnDraw = false;

      if (oldType) {
        that._checkLabelsChanging(oldType, newType) && that.deleteLabel();

        that._resetType(mixins[pointTypes[oldType]]);
      }

      that._setType(mixins[newPointTypeMixin]);
    } else {
      that._needDeletingOnDraw = that._checkSymbol(oldOptions, newOptions);
      that._needClearingOnDraw = that._checkCustomize(oldOptions, newOptions);
    }

    that._options = newOptions;

    that._fillStyle();

    that._updateLabelOptions(newPointTypeMixin);
  },
  translate: function translate() {
    if (this.hasValue()) {
      this._translate();

      this.translated = true;
    }
  },
  _checkCustomize: function _checkCustomize(oldOptions, newOptions) {
    return oldOptions.styles.usePointCustomOptions && !newOptions.styles.usePointCustomOptions;
  },
  _getCustomLabelVisibility: function _getCustomLabelVisibility() {
    return this._styles.useLabelCustomOptions ? !!this._options.label.visible : null;
  },
  getBoundingRect: function getBoundingRect() {
    return this._getGraphicBBox();
  },
  _resetType: function _resetType(methods) {
    for (var methodName in methods) {
      delete this[methodName];
    }
  },
  _setType: function _setType(methods) {
    for (var methodName in methods) {
      this[methodName] = methods[methodName];
    }
  },
  isInVisibleArea: function isInVisibleArea() {
    return this.inVisibleArea;
  },
  isSelected: function isSelected() {
    return !!(this.fullState & SELECTED_STATE);
  },
  isHovered: function isHovered() {
    return !!(this.fullState & HOVER_STATE);
  },
  getOptions: function getOptions() {
    return this._options;
  },
  animate: function animate(complete, settings, partitionDuration) {
    if (!this.graphic) {
      complete && complete();
      return;
    }

    this.graphic.animate(settings, {
      partitionDuration: partitionDuration
    }, complete);
  },
  getCoords: function getCoords(min) {
    var that = this;

    if (!min) {
      return {
        x: that.x,
        y: that.y
      };
    }

    if (!that._options.rotated) {
      return {
        x: that.x,
        y: that.minY + (that.y - that.minY ? 0 : 1)
      };
    }

    return {
      x: that.minX - (that.x - that.minX ? 0 : 1),
      y: that.y
    };
  },
  getDefaultCoords: function getDefaultCoords() {
    var that = this;
    return !that._options.rotated ? {
      x: that.x,
      y: that.defaultY
    } : {
      x: that.defaultX,
      y: that.y
    };
  },
  setDefaultCoords: function setDefaultCoords() {
    var coords = this.getDefaultCoords();
    this.x = coords.x;
    this.y = coords.y;
  },
  _getVisibleArea: function _getVisibleArea() {
    return this.series.getVisibleArea();
  },
  _getArgTranslator: function _getArgTranslator() {
    return this.series.getArgumentAxis().getTranslator();
  },
  _getValTranslator: function _getValTranslator() {
    return this.series.getValueAxis().getTranslator();
  },
  _calculateVisibility: function _calculateVisibility(x, y, width, height) {
    var that = this;

    var visibleArea = that._getVisibleArea();

    var rotated = that._options.rotated;

    if (visibleArea.minX > x + (width || 0) || visibleArea.maxX < x || visibleArea.minY > y + (height || 0) || visibleArea.maxY < y || rotated && (0, _type.isDefined)(width) && width !== 0 && (visibleArea.minX === x + width || visibleArea.maxX === x) || !rotated && (0, _type.isDefined)(height) && height !== 0 && (visibleArea.minY === y + height || visibleArea.maxY === y)) {
      that.inVisibleArea = false;
    } else {
      that.inVisibleArea = true;
    }
  },
  isArgumentCorrect: function isArgumentCorrect() {
    return this.series._argumentChecker(this.argument);
  },
  isValueCorrect: function isValueCorrect() {
    var valueChecker = this.series._valueChecker;
    return valueChecker(this.getMinValue()) && valueChecker(this.getMaxValue());
  },
  hasValue: function hasValue() {
    return this.value !== null && this.minValue !== null && this.isArgumentCorrect() && this.isValueCorrect();
  },
  hasCoords: _common.noop,
  correctPosition: _common.noop,
  correctRadius: _common.noop,
  correctLabelRadius: _common.noop,
  getCrosshairData: _common.noop,
  getPointRadius: _common.noop,
  _populatePointShape: _common.noop,
  _checkSymbol: _common.noop,
  getMarkerCoords: _common.noop,
  hide: _common.noop,
  show: _common.noop,
  hideMarker: _common.noop,
  setInvisibility: _common.noop,
  clearVisibility: _common.noop,
  isVisible: _common.noop,
  resetCorrection: _common.noop,
  correctValue: _common.noop,
  resetValue: _common.noop,
  setPercentValue: _common.noop,
  correctCoordinates: _common.noop,
  coordsIn: _common.noop,
  getTooltipParams: _common.noop,
  applyWordWrap: _common.noop,
  setLabelTrackerData: _common.noop,
  updateLabelCoord: _common.noop,
  drawLabel: _common.noop,
  correctLabelPosition: _common.noop,
  getMinValue: _common.noop,
  getMaxValue: _common.noop,
  _drawErrorBar: _common.noop,
  getMarkerVisibility: _common.noop,
  dispose: function dispose() {
    var that = this;
    that.deleteMarker();
    that.deleteLabel();
    that._errorBar && this._errorBar.dispose();
    that._options = that._styles = that.series = that._errorBar = null;
  },
  getTooltipFormatObject: function getTooltipFormatObject(tooltip, stackPoints) {
    var that = this;

    var tooltipFormatObject = that._getFormatObject(tooltip);

    var sharedTooltipValuesArray = [];
    var tooltipStackPointsFormatObject = [];

    if (stackPoints) {
      stackPoints.forEach(function (point) {
        if (!point.isVisible()) return;

        var formatObject = point._getFormatObject(tooltip);

        tooltipStackPointsFormatObject.push(formatObject);
        sharedTooltipValuesArray.push(formatObject.seriesName + ': ' + formatObject.valueText);
      });

      _extend(tooltipFormatObject, {
        points: tooltipStackPointsFormatObject,
        valueText: sharedTooltipValuesArray.join('\n'),
        stackName: that.series.getStackName() || null
      });
    }

    var aggregationInfo = that.aggregationInfo;

    if (aggregationInfo) {
      var axis = that.series.getArgumentAxis();
      var rangeText = axis.formatRange(aggregationInfo.intervalStart, aggregationInfo.intervalEnd, aggregationInfo.aggregationInterval);

      if (rangeText) {
        tooltipFormatObject.valueText += "\n".concat(rangeText);
      }
    }

    return tooltipFormatObject;
  },
  setHole: function setHole(holeValue, position) {
    var that = this;
    var minValue = isFinite(that.minValue) ? that.minValue : 0;

    if ((0, _type.isDefined)(holeValue)) {
      if (position === 'left') {
        that.leftHole = that.value - holeValue;
        that.minLeftHole = minValue - holeValue;
      } else {
        that.rightHole = that.value - holeValue;
        that.minRightHole = minValue - holeValue;
      }
    }
  },
  resetHoles: function resetHoles() {
    this.leftHole = null;
    this.minLeftHole = null;
    this.rightHole = null;
    this.minRightHole = null;
  },
  getLabel: function getLabel() {
    return this._label;
  },
  getLabels: function getLabels() {
    return [this._label];
  },
  getCenterCoord: function getCenterCoord() {
    return {
      x: this.x,
      y: this.y
    };
  }
};

/***/ }),
/* 1045 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _extend2 = __webpack_require__(0);

var _symbol_point = _interopRequireDefault(__webpack_require__(162));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extend = _extend2.extend;
var MIN_BUBBLE_HEIGHT = 20;

var _default = _extend({}, _symbol_point.default, {
  correctCoordinates: function correctCoordinates(diameter) {
    this.bubbleSize = diameter / 2;
  },
  _drawMarker: function _drawMarker(renderer, group, animationEnabled) {
    var that = this;

    var attr = _extend({
      translateX: that.x,
      translateY: that.y
    }, that._getStyle());

    that.graphic = renderer.circle(0, 0, animationEnabled ? 0 : that.bubbleSize).smartAttr(attr).data({
      'chart-data-point': that
    }).append(group);
  },
  getTooltipParams: function getTooltipParams(location) {
    var that = this;
    var graphic = that.graphic;

    if (!graphic) {
      return;
    }

    var height = graphic.getBBox().height;
    return {
      x: that.x,
      y: that.y,
      offset: height < MIN_BUBBLE_HEIGHT || location === 'edge' ? height / 2 : 0
    };
  },
  _getLabelFormatObject: function _getLabelFormatObject() {
    var formatObject = _symbol_point.default._getLabelFormatObject.call(this);

    formatObject.size = this.initialSize;
    return formatObject;
  },
  _updateData: function _updateData(data) {
    _symbol_point.default._updateData.call(this, data);

    this.size = this.initialSize = data.size;
  },
  _getGraphicBBox: function _getGraphicBBox() {
    var that = this;
    return that._getSymbolBBox(that.x, that.y, that.bubbleSize);
  },
  _updateMarker: function _updateMarker(animationEnabled, style) {
    var that = this;

    if (!animationEnabled) {
      style = _extend({
        r: that.bubbleSize,
        translateX: that.x,
        translateY: that.y
      }, style);
    }

    that.graphic.smartAttr(style);
  },
  _getFormatObject: function _getFormatObject(tooltip) {
    var formatObject = _symbol_point.default._getFormatObject.call(this, tooltip);

    formatObject.sizeText = tooltip.formatValue(this.initialSize);
    return formatObject;
  },
  _storeTrackerR: function _storeTrackerR() {
    return this.bubbleSize;
  },
  _getLabelCoords: function _getLabelCoords(label) {
    var coords;

    if (label.getLayoutOptions().position === 'inside') {
      coords = this._getLabelCoordOfPosition(label, 'inside');
    } else {
      coords = _symbol_point.default._getLabelCoords.call(this, label);
    }

    return coords;
  }
});

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1046 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _common = __webpack_require__(4);

var _extend2 = __webpack_require__(0);

var _bar_point = _interopRequireDefault(__webpack_require__(240));

var _range_symbol_point = _interopRequireDefault(__webpack_require__(588));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extend = _extend2.extend;

var _default = _extend({}, _bar_point.default, {
  deleteLabel: _range_symbol_point.default.deleteLabel,
  _getFormatObject: _range_symbol_point.default._getFormatObject,
  clearVisibility: function clearVisibility() {
    var graphic = this.graphic;

    if (graphic && graphic.attr('visibility')) {
      graphic.attr({
        visibility: null
      });
    }
  },
  setInvisibility: function setInvisibility() {
    var graphic = this.graphic;

    if (graphic && graphic.attr('visibility') !== 'hidden') {
      graphic.attr({
        visibility: 'hidden'
      });
    }

    this._topLabel.draw(false);

    this._bottomLabel.draw(false);
  },
  getTooltipParams: function getTooltipParams(location) {
    var that = this;
    var edgeLocation = location === 'edge';
    var x;
    var y;

    if (that._options.rotated) {
      x = edgeLocation ? that.x + that.width : that.x + that.width / 2;
      y = that.y + that.height / 2;
    } else {
      x = that.x + that.width / 2;
      y = edgeLocation ? that.y : that.y + that.height / 2;
    }

    return {
      x: x,
      y: y,
      offset: 0
    };
  },
  _translate: function _translate() {
    var that = this;
    var barMethods = _bar_point.default;

    barMethods._translate.call(that);

    if (that._options.rotated) {
      that.width = that.width || 1;
    } else {
      that.height = that.height || 1;
    }
  },
  hasCoords: _range_symbol_point.default.hasCoords,
  _updateData: _range_symbol_point.default._updateData,
  _getLabelPosition: _range_symbol_point.default._getLabelPosition,
  _getLabelMinFormatObject: _range_symbol_point.default._getLabelMinFormatObject,
  _updateLabelData: _range_symbol_point.default._updateLabelData,
  _updateLabelOptions: _range_symbol_point.default._updateLabelOptions,
  getCrosshairData: _range_symbol_point.default.getCrosshairData,
  _createLabel: _range_symbol_point.default._createLabel,
  _checkOverlay: _range_symbol_point.default._checkOverlay,
  _checkLabelsOverlay: _range_symbol_point.default._checkLabelsOverlay,
  _getOverlayCorrections: _range_symbol_point.default._getOverlayCorrections,
  _drawLabel: _range_symbol_point.default._drawLabel,
  _getLabelCoords: _range_symbol_point.default._getLabelCoords,
  getLabel: _range_symbol_point.default.getLabel,
  getLabels: _range_symbol_point.default.getLabels,
  getBoundingRect: _common.noop,
  getMinValue: _range_symbol_point.default.getMinValue,
  getMaxValue: _range_symbol_point.default.getMaxValue
});

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1047 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _extend2 = __webpack_require__(0);

var _type = __webpack_require__(1);

var _candlestick_point = _interopRequireDefault(__webpack_require__(589));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extend = _extend2.extend;
var _isNumeric = _type.isNumeric;

var _default = _extend({}, _candlestick_point.default, {
  _getPoints: function _getPoints() {
    var that = this;
    var createPoint = that._options.rotated ? function (x, y) {
      return [y, x];
    } : function (x, y) {
      return [x, y];
    };

    var openYExist = _isNumeric(that.openY);

    var closeYExist = _isNumeric(that.closeY);

    var x = that.x;
    var width = that.width;
    var points = [].concat(createPoint(x, that.highY));
    openYExist && (points = points.concat(createPoint(x, that.openY)));
    openYExist && (points = points.concat(createPoint(x - width / 2, that.openY)));
    openYExist && (points = points.concat(createPoint(x, that.openY)));
    closeYExist && (points = points.concat(createPoint(x, that.closeY)));
    closeYExist && (points = points.concat(createPoint(x + width / 2, that.closeY)));
    closeYExist && (points = points.concat(createPoint(x, that.closeY)));
    points = points.concat(createPoint(x, that.lowY));
    return points;
  },
  _drawMarkerInGroup: function _drawMarkerInGroup(group, attributes, renderer) {
    this.graphic = renderer.path(this._getPoints(), 'line').attr({
      'stroke-linecap': 'square'
    }).attr(attributes).data({
      'chart-data-point': this
    }).sharp().append(group);
  },
  _getMinTrackerWidth: function _getMinTrackerWidth() {
    var width = 2 + this._styles.normal['stroke-width'];
    return width + width % 2;
  }
});

exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1048 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.polarBarPoint = exports.polarSymbolPoint = void 0;

var _extend2 = __webpack_require__(0);

var _symbol_point = _interopRequireDefault(__webpack_require__(162));

var _bar_point = _interopRequireDefault(__webpack_require__(240));

var _pie_point = _interopRequireDefault(__webpack_require__(587));

var _type = __webpack_require__(1);

var _utils = __webpack_require__(14);

var _consts = _interopRequireDefault(__webpack_require__(161));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extend = _extend2.extend;
var _math = Math;
var _max = _math.max;
var RADIAL_LABEL_INDENT = _consts.default.radialLabelIndent;
var ERROR_BARS_ANGLE_OFFSET = 90;
var CANVAS_POSITION_START = 'canvas_position_start';
var CANVAS_POSITION_END = 'canvas_position_end';
var CANVAS_POSITION_DEFAULT = 'canvas_position_default';

var polarSymbolPoint = _extend({}, _symbol_point.default, {
  _getLabelCoords: _pie_point.default._getLabelCoords,
  _getElementCoords: _pie_point.default._getElementCoords,
  _moveLabelOnCanvas: function _moveLabelOnCanvas(coord, visibleArea, labelBBox) {
    var x = coord.x;
    var y = coord.y;

    if (visibleArea.minX > x) {
      x = visibleArea.minX;
    }

    if (visibleArea.maxX < x + labelBBox.width) {
      x = visibleArea.maxX - labelBBox.width;
    }

    if (visibleArea.minY > y) {
      y = visibleArea.minY;
    }

    if (visibleArea.maxY < y + labelBBox.height) {
      y = visibleArea.maxY - labelBBox.height;
    }

    return {
      x: x,
      y: y
    };
  },
  _getLabelPosition: function _getLabelPosition() {
    return 'outside';
  },
  _getCoords: function _getCoords(argument, value) {
    var axis = this.series.getValueAxis();
    var startAngle = axis.getAngles()[0];

    var angle = this._getArgTranslator().translate(argument);

    var radius = this._getValTranslator().translate(value);

    var coords = (0, _utils.convertPolarToXY)(axis.getCenter(), axis.getAngles()[0], angle, radius);
    coords.angle = angle + startAngle - 90, coords.radius = radius;
    return coords;
  },
  _translate: function _translate() {
    var that = this;
    var center = that.series.getValueAxis().getCenter();

    var coord = that._getCoords(that.argument, that.value);

    var translator = that._getValTranslator();

    var maxRadius = translator.isInverted() ? translator.translate(CANVAS_POSITION_START) : translator.translate(CANVAS_POSITION_END);
    var normalizedRadius = (0, _type.isDefined)(coord.radius) && coord.radius >= 0 ? coord.radius : null;
    that.vx = (0, _utils.normalizeAngle)(coord.angle);
    that.vy = that.radiusOuter = that.radiusLabels = normalizedRadius;
    that.radiusLabels += RADIAL_LABEL_INDENT;
    that.radius = normalizedRadius;
    that.middleAngle = -coord.angle;
    that.angle = -coord.angle;
    that.x = coord.x;
    that.y = coord.y;
    that.defaultX = that.centerX = center.x;
    that.defaultY = that.centerY = center.y;

    that._translateErrorBars();

    that.inVisibleArea = that._checkRadiusForVisibleArea(normalizedRadius, maxRadius);
  },
  _checkRadiusForVisibleArea: function _checkRadiusForVisibleArea(radius, maxRadius) {
    return (0, _type.isDefined)(radius) && radius <= maxRadius;
  },
  _translateErrorBars: function _translateErrorBars() {
    var that = this;
    var errorBars = that._options.errorBars;

    var translator = that._getValTranslator();

    if (!errorBars) {
      return;
    }

    (0, _type.isDefined)(that.lowError) && (that._lowErrorCoord = that.centerY - translator.translate(that.lowError));
    (0, _type.isDefined)(that.highError) && (that._highErrorCoord = that.centerY - translator.translate(that.highError));
    that._errorBarPos = that.centerX;
    that._baseErrorBarPos = errorBars.type === 'stdDeviation' ? that._lowErrorCoord + (that._highErrorCoord - that._lowErrorCoord) / 2 : that.centerY - that.radius;
  },
  _getTranslates: function _getTranslates(animationEnabled) {
    return animationEnabled ? this.getDefaultCoords() : {
      x: this.x,
      y: this.y
    };
  },
  getDefaultCoords: function getDefaultCoords() {
    var cosSin = (0, _utils.getCosAndSin)(-this.angle);

    var radius = this._getValTranslator().translate(CANVAS_POSITION_DEFAULT);

    var x = this.defaultX + radius * cosSin.cos;
    var y = this.defaultY + radius * cosSin.sin;
    return {
      x: x,
      y: y
    };
  },
  _addLabelAlignmentAndOffset: function _addLabelAlignmentAndOffset(label, coord) {
    return coord;
  },
  _checkLabelPosition: function _checkLabelPosition(label, coord) {
    var that = this;

    var visibleArea = that._getVisibleArea();

    var graphicBBox = that._getGraphicBBox();

    if (that._isPointInVisibleArea(visibleArea, graphicBBox)) {
      coord = that._moveLabelOnCanvas(coord, visibleArea, label.getBoundingRect());
    }

    return coord;
  },
  _getErrorBarSettings: function _getErrorBarSettings(errorBarOptions, animationEnabled) {
    var settings = _symbol_point.default._getErrorBarSettings.call(this, errorBarOptions, animationEnabled);

    settings.rotate = ERROR_BARS_ANGLE_OFFSET - this.angle;
    settings.rotateX = this.centerX;
    settings.rotateY = this.centerY;
    return settings;
  },
  getCoords: function getCoords(min) {
    return min ? this.getDefaultCoords() : {
      x: this.x,
      y: this.y
    };
  }
});

exports.polarSymbolPoint = polarSymbolPoint;

var polarBarPoint = _extend({}, _bar_point.default, {
  _translateErrorBars: polarSymbolPoint._translateErrorBars,
  _getErrorBarSettings: polarSymbolPoint._getErrorBarSettings,
  _moveLabelOnCanvas: polarSymbolPoint._moveLabelOnCanvas,
  _getLabelCoords: _pie_point.default._getLabelCoords,
  _getElementCoords: _pie_point.default._getElementCoords,
  _getLabelConnector: _pie_point.default._getLabelConnector,
  getTooltipParams: _pie_point.default.getTooltipParams,
  _getLabelPosition: _pie_point.default._getLabelPosition,
  _getCoords: polarSymbolPoint._getCoords,
  _translate: function _translate() {
    var that = this;

    var translator = that._getValTranslator();

    var businessRange = translator.getBusinessRange();
    var maxRadius = translator.isInverted() ? translator.translate(CANVAS_POSITION_START) : translator.translate(CANVAS_POSITION_END);
    that.radiusInner = translator.translate(that.minValue);

    polarSymbolPoint._translate.call(that);

    if (that.radiusInner === null) {
      that.radiusInner = that.radius = maxRadius;
    } else if (that.radius === null) {
      that.radius = that.value >= businessRange.minVisible ? maxRadius : 0;
    } else if (that.radius > maxRadius) {
      that.radius = maxRadius;
    }

    that.radiusOuter = that.radiusLabels = _max(that.radiusInner, that.radius);
    that.radiusLabels += RADIAL_LABEL_INDENT;
    that.radiusInner = that.defaultRadius = _math.min(that.radiusInner, that.radius);
    that.middleAngle = that.angle = -(0, _utils.normalizeAngle)(that.middleAngleCorrection - that.angle);
  },
  _checkRadiusForVisibleArea: function _checkRadiusForVisibleArea(radius) {
    return (0, _type.isDefined)(radius) || this._getValTranslator().translate(this.minValue) > 0;
  },
  _getErrorBarBaseEdgeLength: function _getErrorBarBaseEdgeLength() {
    var coord = this.getMarkerCoords();
    return _math.PI * coord.outerRadius * _math.abs(coord.startAngle - coord.endAngle) / 180;
  },
  getMarkerCoords: function getMarkerCoords() {
    return {
      x: this.centerX,
      y: this.centerY,
      outerRadius: this.radiusOuter,
      innerRadius: this.defaultRadius,
      startAngle: this.middleAngle - this.interval / 2,
      endAngle: this.middleAngle + this.interval / 2
    };
  },
  _drawMarker: function _drawMarker(renderer, group, animationEnabled) {
    var that = this;

    var styles = that._getStyle();

    var coords = that.getMarkerCoords();
    var innerRadius = coords.innerRadius;
    var outerRadius = coords.outerRadius;

    var start = that._getCoords(that.argument, CANVAS_POSITION_DEFAULT);

    var x = coords.x;
    var y = coords.y;

    if (animationEnabled) {
      innerRadius = 0;
      outerRadius = 0;
      x = start.x;
      y = start.y;
    }

    that.graphic = renderer.arc(x, y, innerRadius, outerRadius, coords.startAngle, coords.endAngle).attr(styles).data({
      'chart-data-point': that
    }).append(group);
  },
  _checkLabelPosition: function _checkLabelPosition(label, coord) {
    var that = this;

    var visibleArea = that._getVisibleArea();

    var angleFunctions = (0, _utils.getCosAndSin)(that.middleAngle);
    var x = that.centerX + that.defaultRadius * angleFunctions.cos;
    var y = that.centerY - that.defaultRadius * angleFunctions.sin;

    if (x > visibleArea.minX && x < visibleArea.maxX && y > visibleArea.minY && y < visibleArea.maxY) {
      coord = that._moveLabelOnCanvas(coord, visibleArea, label.getBoundingRect());
    }

    return coord;
  },
  _addLabelAlignmentAndOffset: function _addLabelAlignmentAndOffset(label, coord) {
    return coord;
  },
  correctCoordinates: function correctCoordinates(correctOptions) {
    this.middleAngleCorrection = correctOptions.offset;
    this.interval = correctOptions.width;
  },
  coordsIn: function coordsIn(x, y) {
    var val = (0, _utils.convertXYToPolar)(this.series.getValueAxis().getCenter(), x, y);
    var coords = this.getMarkerCoords();
    var isBetweenAngles = coords.startAngle < coords.endAngle ? -val.phi >= coords.startAngle && -val.phi <= coords.endAngle : -val.phi <= coords.startAngle && -val.phi >= coords.endAngle;
    return val.r >= coords.innerRadius && val.r <= coords.outerRadius && isBetweenAngles;
  }
});

exports.polarBarPoint = polarBarPoint;

/***/ }),
/* 1049 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.chart = void 0;

var _extend2 = __webpack_require__(0);

var _type = __webpack_require__(1);

var _utils = __webpack_require__(14);

var _common = __webpack_require__(4);

var _scatter_series = __webpack_require__(139);

var _bar_series = __webpack_require__(185);

var _area_series = __webpack_require__(209);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _extend = _extend2.extend;
var barSeries = _bar_series.chart.bar;
var areaSeries = _area_series.chart.area;
var chart = {};
exports.chart = chart;
var baseRangeSeries = {
  areErrorBarsVisible: _common.noop,
  _createErrorBarGroup: _common.noop,
  _checkData: function _checkData(data, skippedFields) {
    var valueFields = this.getValueFields();
    return _scatter_series.chart._checkData.call(this, data, skippedFields, {
      minValue: valueFields[0],
      value: valueFields[1]
    }) && data.minValue === data.minValue;
  },
  getValueRangeInitialValue: _scatter_series.chart.getValueRangeInitialValue,
  _getPointDataSelector: function _getPointDataSelector(data) {
    var _this = this;

    var valueFields = this.getValueFields();
    var val1Field = valueFields[0];
    var val2Field = valueFields[1];
    var tagField = this.getTagField();
    var argumentField = this.getArgumentField();
    return function (data) {
      return {
        tag: data[tagField],
        minValue: _this._processEmptyValue(data[val1Field]),
        value: _this._processEmptyValue(data[val2Field]),
        argument: data[argumentField],
        data: data
      };
    };
  },
  _defaultAggregator: 'range',
  _aggregators: {
    range: function range(_ref, series) {
      var _data$reduce;

      var intervalStart = _ref.intervalStart,
          intervalEnd = _ref.intervalEnd,
          data = _ref.data;

      if (!data.length) {
        return;
      }

      var valueFields = series.getValueFields();
      var val1Field = valueFields[0];
      var val2Field = valueFields[1];
      var result = data.reduce(function (result, item) {
        var val1 = item[val1Field];
        var val2 = item[val2Field];

        if (!(0, _type.isDefined)(val1) || !(0, _type.isDefined)(val2)) {
          return result;
        }

        result[val1Field] = Math.min(result[val1Field], Math.min(val1, val2));
        result[val2Field] = Math.max(result[val2Field], Math.max(val1, val2));
        return result;
      }, (_data$reduce = {}, _defineProperty(_data$reduce, val1Field, Infinity), _defineProperty(_data$reduce, val2Field, -Infinity), _defineProperty(_data$reduce, series.getArgumentField(), series._getIntervalCenter(intervalStart, intervalEnd)), _data$reduce));

      if (!isFinite(result[val1Field]) || !isFinite(result[val2Field])) {
        if (data.filter(function (i) {
          return i[val1Field] === null && i[val2Field] === null;
        }).length === data.length) {
          result[val1Field] = result[val2Field] = null;
        } else {
          return;
        }
      }

      return result;
    }
  },
  getValueFields: function getValueFields() {
    return [this._options.rangeValue1Field || 'val1', this._options.rangeValue2Field || 'val2'];
  },
  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {
    var oppositeCoord = null;
    var rotated = this._options.rotated;
    var isOpposite = !isArgument && !rotated || isArgument && rotated;
    var coordName = isOpposite ? 'vy' : 'vx';
    var minCoordName = rotated ? 'minX' : 'minY';
    var oppositeCoordName = isOpposite ? 'vx' : 'vy';
    var points = this.getPoints();

    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      var tmpCoord = void 0;

      if (isArgument) {
        tmpCoord = p.getCenterCoord()[coordName[1]] === coord ? p[oppositeCoordName] : undefined;
      } else {
        var coords = [Math.min(p[coordName], p[minCoordName]), Math.max(p[coordName], p[minCoordName])];
        tmpCoord = coord >= coords[0] && coord <= coords[1] ? p[oppositeCoordName] : undefined;
      }

      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
        oppositeCoord = tmpCoord;
        break;
      }
    }

    return oppositeCoord;
  }
};
chart['rangebar'] = _extend({}, barSeries, baseRangeSeries);
chart['rangearea'] = _extend({}, areaSeries, {
  _drawPoint: function _drawPoint(options) {
    var point = options.point;

    if (point.isInVisibleArea()) {
      point.clearVisibility();
      point.draw(this._renderer, options.groups);

      this._drawnPoints.push(point);

      if (!point.visibleTopMarker) {
        point.hideMarker('top');
      }

      if (!point.visibleBottomMarker) {
        point.hideMarker('bottom');
      }
    } else {
      point.setInvisibility();
    }
  },
  _prepareSegment: function _prepareSegment(points, rotated) {
    var processedPoints = this._processSinglePointsAreaSegment(points, rotated);

    var processedMinPointsCoords = (0, _utils.map)(processedPoints, function (pt) {
      return pt.getCoords(true);
    });
    return {
      line: processedPoints,
      bottomLine: processedMinPointsCoords,
      area: (0, _utils.map)(processedPoints, function (pt) {
        return pt.getCoords();
      }).concat(processedMinPointsCoords.slice().reverse()),
      singlePointSegment: processedPoints !== points
    };
  },
  _getDefaultSegment: function _getDefaultSegment(segment) {
    var defaultSegment = areaSeries._getDefaultSegment.call(this, segment);

    defaultSegment.bottomLine = defaultSegment.line;
    return defaultSegment;
  },
  _removeElement: function _removeElement(element) {
    areaSeries._removeElement.call(this, element);

    element.bottomLine && element.bottomLine.remove();
  },
  _drawElement: function _drawElement(segment, group) {
    var that = this;

    var drawnElement = areaSeries._drawElement.call(that, segment, group);

    drawnElement.bottomLine = that._bordersGroup && that._createBorderElement(segment.bottomLine, {
      'stroke-width': that._styles.normal.border['stroke-width']
    }).append(that._bordersGroup);
    return drawnElement;
  },
  _applyStyle: function _applyStyle(style) {
    var that = this;
    var elementsGroup = that._elementsGroup;
    var bordersGroup = that._bordersGroup;
    elementsGroup && elementsGroup.smartAttr(style.elements);
    bordersGroup && bordersGroup.attr(style.border);
    (that._graphics || []).forEach(function (graphic) {
      graphic.line && graphic.line.attr({
        'stroke-width': style.border['stroke-width']
      });
      graphic.bottomLine && graphic.bottomLine.attr({
        'stroke-width': style.border['stroke-width']
      });
    });
  },
  _updateElement: function _updateElement(element, segment, animate, complete) {
    var bottomLineParams = {
      points: segment.bottomLine
    };
    var bottomBorderElement = element.bottomLine;

    areaSeries._updateElement.apply(this, arguments);

    if (bottomBorderElement) {
      animate ? bottomBorderElement.animate(bottomLineParams) : bottomBorderElement.attr(bottomLineParams);
    }
  }
}, baseRangeSeries);

/***/ }),
/* 1050 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.chart = void 0;

var _line_series = __webpack_require__(242);

var _scatter_series = __webpack_require__(139);

var _area_series = __webpack_require__(209);

var _bar_series = __webpack_require__(185);

var _extend2 = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _common = __webpack_require__(4);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var lineSeries = _line_series.chart.line;
var areaSeries = _area_series.chart.area;
var chartBarSeries = _bar_series.chart.bar;
var polarBarSeries = _bar_series.polar.bar;
var _extend = _extend2.extend;
var _each = _iterator.each;
var _noop = _common.noop;
var chart = {};
exports.chart = chart;
chart.bubble = _extend({}, _scatter_series.chart, {
  _calculateErrorBars: _noop,
  _getMainColor: chartBarSeries._getMainColor,
  _createPointStyles: chartBarSeries._createPointStyles,
  _updatePointsVisibility: chartBarSeries._updatePointsVisibility,
  _getOptionsForPoint: chartBarSeries._getOptionsForPoint,
  _applyMarkerClipRect: lineSeries._applyElementsClipRect,
  _parsePointStyle: polarBarSeries._parsePointStyle,
  _createLegendState: areaSeries._createLegendState,
  _setMarkerGroupSettings: polarBarSeries._setMarkerGroupSettings,
  areErrorBarsVisible: _noop,
  _createErrorBarGroup: _noop,
  _checkData: function _checkData(data, skippedFields) {
    return _scatter_series.chart._checkData.call(this, data, skippedFields, {
      value: this.getValueFields()[0],
      size: this.getSizeField()
    });
  },
  _getPointDataSelector: function _getPointDataSelector(data, options) {
    var sizeField = this.getSizeField();

    var baseGetter = _scatter_series.chart._getPointDataSelector.call(this);

    return function (data) {
      var pointData = baseGetter(data);
      pointData.size = data[sizeField];
      return pointData;
    };
  },
  _aggregators: {
    avg: function avg(_ref, series) {
      var _ref2;

      var data = _ref.data,
          intervalStart = _ref.intervalStart,
          intervalEnd = _ref.intervalEnd;

      if (!data.length) {
        return;
      }

      var valueField = series.getValueFields()[0];
      var sizeField = series.getSizeField();
      var aggregate = data.reduce(function (result, item) {
        result[0] += item[valueField];
        result[1] += item[sizeField];
        result[2]++;
        return result;
      }, [0, 0, 0]);
      return _ref2 = {}, _defineProperty(_ref2, valueField, aggregate[0] / aggregate[2]), _defineProperty(_ref2, sizeField, aggregate[1] / aggregate[2]), _defineProperty(_ref2, series.getArgumentField(), series._getIntervalCenter(intervalStart, intervalEnd)), _ref2;
    }
  },
  getValueFields: function getValueFields() {
    return [this._options.valueField || 'val'];
  },
  getSizeField: function getSizeField() {
    return this._options.sizeField || 'size';
  },
  _animate: function _animate() {
    var that = this;
    var lastPointIndex = that._drawnPoints.length - 1;
    var labelsGroup = that._labelsGroup;

    var labelAnimFunc = function labelAnimFunc() {
      labelsGroup && labelsGroup.animate({
        opacity: 1
      }, {
        duration: that._defaultDuration
      });
    };

    _each(that._drawnPoints || [], function (i, p) {
      p.animate(i === lastPointIndex ? labelAnimFunc : undefined, {
        r: p.bubbleSize,
        translateX: p.x,
        translateY: p.y
      });
    });
  },
  _patchMarginOptions: function _patchMarginOptions(options) {
    options.processBubbleSize = true;
    return options;
  }
});

/***/ }),
/* 1051 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.donut = exports.doughnut = exports.pie = void 0;

var _common = __webpack_require__(4);

var _iterator = __webpack_require__(3);

var _scatter_series = __webpack_require__(139);

var _utils = __webpack_require__(14);

var _extend2 = __webpack_require__(0);

var _bar_series = __webpack_require__(185);

// there are pie, doughnut
var chartScatterSeries = _scatter_series.chart;
var barSeries = _bar_series.chart.bar;
var _extend = _extend2.extend;
var _each = _iterator.each;
var _noop = _common.noop;
var _map = _utils.map;
var _isFinite = isFinite;
var _max = Math.max;
var ANIMATION_DURATION = 0.7;
var INSIDE = 'inside';

var pie = _extend({}, barSeries, {
  _setGroupsSettings: function _setGroupsSettings() {
    chartScatterSeries._setGroupsSettings.apply(this, arguments);

    this._labelsGroup.attr({
      'pointer-events': null
    });
  },
  _createErrorBarGroup: _noop,
  _drawPoint: function _drawPoint(options) {
    var point = options.point;
    var legendCallback = this._legendCallback;

    chartScatterSeries._drawPoint.call(this, options);

    !point.isVisible() && point.setInvisibility();
    point.isSelected() && legendCallback();
  },
  _getOldPoint: function _getOldPoint(data, oldPointsByArgument, index) {
    var point = (this._points || [])[index];

    if (point) {
      oldPointsByArgument[point.argument.valueOf()] = oldPointsByArgument[point.argument.valueOf()].filter(function (p) {
        return p !== point;
      });
    }

    return point;
  },
  adjustLabels: function adjustLabels(moveLabelsFromCenter) {
    return (this._points || []).reduce(function (r, p) {
      if (p._label.isVisible()) {
        p.setLabelTrackerData();
        r = p.applyWordWrap(moveLabelsFromCenter) || r;
        p.updateLabelCoord(moveLabelsFromCenter);
        return r;
      }
    }, false);
  },
  _applyElementsClipRect: _noop,
  getColor: _noop,
  areErrorBarsVisible: _noop,
  drawLabelsWOPoints: function drawLabelsWOPoints() {
    var that = this;

    if (that._options.label.position === INSIDE) {
      return false;
    }

    that._labelsGroup.append(that._extGroups.labelsGroup);

    (that._points || []).forEach(function (point) {
      point.drawLabel();
    });
    return true;
  },
  getPointsCount: function getPointsCount() {
    var _this = this;

    return this._data.filter(function (d) {
      return _this._checkData(d);
    }).length;
  },
  setMaxPointsCount: function setMaxPointsCount(count) {
    this._pointsCount = count;
  },
  _getCreatingPointOptions: function _getCreatingPointOptions(data, dataIndex) {
    return this._getPointOptions(data, dataIndex);
  },
  _updateOptions: function _updateOptions(options) {
    this.labelSpace = 0;
    this.innerRadius = this.type === 'pie' ? 0 : options.innerRadius;
  },
  _checkData: function _checkData(data, skippedFields) {
    var base = barSeries._checkData.call(this, data, skippedFields, {
      value: this.getValueFields()[0]
    });

    return this._options.paintNullPoints ? base : base && data.value !== null;
  },
  _createGroups: chartScatterSeries._createGroups,
  _setMarkerGroupSettings: function _setMarkerGroupSettings() {
    this._markersGroup.attr({
      'class': 'dxc-markers'
    });
  },
  _getMainColor: function _getMainColor(data, point) {
    var pointsByArg = this.getPointsByArg(data.argument);
    var argumentIndex = point ? pointsByArg.indexOf(point) : pointsByArg.length;
    return this._options.mainSeriesColor(data.argument, argumentIndex, this._pointsCount);
  },
  _getPointOptions: function _getPointOptions(data) {
    return this._parsePointOptions(this._preparePointOptions(), this._options.label, data);
  },
  _getRangeData: function _getRangeData() {
    return this._rangeData;
  },
  _createPointStyles: function _createPointStyles(pointOptions, data, point) {
    var that = this;

    var mainColor = pointOptions.color || that._getMainColor(data, point);

    return {
      normal: that._parsePointStyle(pointOptions, mainColor, mainColor),
      hover: that._parsePointStyle(pointOptions.hoverStyle, mainColor, mainColor),
      selection: that._parsePointStyle(pointOptions.selectionStyle, mainColor, mainColor),
      legendStyles: {
        normal: that._createLegendState(pointOptions, mainColor),
        hover: that._createLegendState(pointOptions.hoverStyle, mainColor),
        selection: that._createLegendState(pointOptions.selectionStyle, mainColor)
      }
    };
  },
  _getArrangeMinShownValue: function _getArrangeMinShownValue(points, total) {
    var minSegmentSize = this._options.minSegmentSize;
    var totalMinSegmentSize = 0;
    var totalNotMinValues = 0;
    total = total || points.length;

    _each(points, function (_, point) {
      if (point.isVisible()) {
        if (point.normalInitialValue < minSegmentSize * total / 360) {
          totalMinSegmentSize += minSegmentSize;
        } else {
          totalNotMinValues += point.normalInitialValue;
        }
      }
    });

    return totalMinSegmentSize < 360 ? minSegmentSize * totalNotMinValues / (360 - totalMinSegmentSize) : 0;
  },
  _applyArrangeCorrection: function _applyArrangeCorrection(points, minShownValue, total) {
    var options = this._options;
    var isClockWise = options.segmentsDirection !== 'anticlockwise';
    var shiftedAngle = _isFinite(options.startAngle) ? (0, _utils.normalizeAngle)(options.startAngle) : 0;
    var minSegmentSize = options.minSegmentSize;
    var percent;
    var correction = 0;
    var zeroTotalCorrection = 0;

    if (total === 0) {
      total = points.filter(function (el) {
        return el.isVisible();
      }).length;
      zeroTotalCorrection = 1;
    }

    _each(isClockWise ? points : points.concat([]).reverse(), function (_, point) {
      var val = point.isVisible() ? zeroTotalCorrection || point.normalInitialValue : 0;
      var updatedZeroValue;

      if (minSegmentSize && point.isVisible() && val < minShownValue) {
        updatedZeroValue = minShownValue;
      }

      percent = val / total;
      point.correctValue(correction, percent, zeroTotalCorrection + (updatedZeroValue || 0));
      point.shiftedAngle = shiftedAngle;
      correction = correction + (updatedZeroValue || val);
    });

    this._rangeData = {
      val: {
        min: 0,
        max: correction
      }
    };
  },
  _removePoint: function _removePoint(point) {
    var points = this.getPointsByArg(point.argument);
    points.splice(points.indexOf(point), 1); // T485210

    point.dispose();
  },
  arrangePoints: function arrangePoints() {
    var that = this;
    var originalPoints = that._points || [];
    var minSegmentSize = that._options.minSegmentSize;
    var minShownValue;
    var isAllPointsNegative = true;
    var i = 0;
    var len = originalPoints.length;

    while (i < len && isAllPointsNegative) {
      isAllPointsNegative = originalPoints[i].value <= 0;
      i++;
    }

    var points = that._points = _map(originalPoints, function (point) {
      if (point.value === null || !isAllPointsNegative && point.value < 0) {
        that._removePoint(point);

        return null;
      } else {
        return point;
      }
    });

    var maxValue = points.reduce(function (max, p) {
      return _max(max, Math.abs(p.initialValue));
    }, 0);
    points.forEach(function (p) {
      p.normalInitialValue = p.initialValue / (maxValue !== 0 ? maxValue : 1);
    });
    var total = points.reduce(function (total, point) {
      return total + (point.isVisible() ? point.normalInitialValue : 0);
    }, 0);

    if (minSegmentSize) {
      minShownValue = this._getArrangeMinShownValue(points, total);
    }

    that._applyArrangeCorrection(points, minShownValue, total);
  },
  correctPosition: function correctPosition(correction, canvas) {
    _each(this._points, function (_, point) {
      point.correctPosition(correction);
    });

    this.setVisibleArea(canvas);
  },
  correctRadius: function correctRadius(correction) {
    this._points.forEach(function (point) {
      point.correctRadius(correction);
    });
  },
  correctLabelRadius: function correctLabelRadius(labelRadius) {
    this._points.forEach(function (point) {
      point.correctLabelRadius(labelRadius);
    });
  },
  setVisibleArea: function setVisibleArea(canvas) {
    this._visibleArea = {
      minX: canvas.left,
      maxX: canvas.width - canvas.right,
      minY: canvas.top,
      maxY: canvas.height - canvas.bottom
    };
  },
  _applyVisibleArea: _noop,
  _animate: function _animate(firstDrawing) {
    var that = this;
    var points = that._points;
    var pointsCount = points && points.length;

    var completeFunc = function completeFunc() {
      that._animateComplete();
    };

    var animatePoint;

    if (firstDrawing) {
      animatePoint = function animatePoint(p, i) {
        p.animate(i === pointsCount - 1 ? completeFunc : undefined, ANIMATION_DURATION, (1 - ANIMATION_DURATION) * i / (pointsCount - 1));
      };
    } else {
      animatePoint = function animatePoint(p, i) {
        p.animate(i === pointsCount - 1 ? completeFunc : undefined);
      };
    }

    points.forEach(animatePoint);
  },
  getVisiblePoints: function getVisiblePoints() {
    return _map(this._points, function (p) {
      return p.isVisible() ? p : null;
    });
  },
  getPointsByKeys: function getPointsByKeys(arg, argumentIndex) {
    var pointsByArg = this.getPointsByArg(arg);
    return pointsByArg[argumentIndex] && [pointsByArg[argumentIndex]] || [];
  }
});

exports.pie = pie;
var doughnut = pie;
exports.doughnut = doughnut;
var donut = pie;
exports.donut = donut;

/***/ }),
/* 1052 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.candlestick = exports.stock = void 0;

var _scatter_series = __webpack_require__(139);

var _bar_series = __webpack_require__(185);

var _extend2 = __webpack_require__(0);

var _type = __webpack_require__(1);

var _utils = __webpack_require__(14);

var _common = __webpack_require__(4);

// there are stock, candlestick
var barSeries = _bar_series.chart.bar;
var DEFAULT_FINANCIAL_POINT_SIZE = 10;
var stock = (0, _extend2.extend)({}, _scatter_series.chart, {
  _animate: _common.noop,
  _applyMarkerClipRect: function _applyMarkerClipRect(settings) {
    settings['clip-path'] = this._forceClipping ? this._paneClipRectID : this._widePaneClipRectID;
  },
  _updatePointsVisibility: barSeries._updatePointsVisibility,
  _getOptionsForPoint: barSeries._getOptionsForPoint,
  _createErrorBarGroup: _common.noop,
  areErrorBarsVisible: _common.noop,
  _createGroups: _scatter_series.chart._createGroups,
  _setMarkerGroupSettings: function _setMarkerGroupSettings() {
    var that = this;
    var markersGroup = that._markersGroup;

    var styles = that._createPointStyles(that._getMarkerGroupOptions());

    var defaultStyle = (0, _extend2.extend)(styles.normal, {
      'class': 'default-markers'
    });
    var defaultPositiveStyle = (0, _extend2.extend)(styles.positive.normal, {
      'class': 'default-positive-markers'
    });
    var reductionStyle = (0, _extend2.extend)(styles.reduction.normal, {
      'class': 'reduction-markers'
    });
    var reductionPositiveStyle = (0, _extend2.extend)(styles.reductionPositive.normal, {
      'class': 'reduction-positive-markers'
    });
    var markerSettings = {
      'class': 'dxc-markers'
    };

    that._applyMarkerClipRect(markerSettings);

    markersGroup.attr(markerSettings);

    that._createGroup('defaultMarkersGroup', markersGroup, markersGroup, defaultStyle);

    that._createGroup('reductionMarkersGroup', markersGroup, markersGroup, reductionStyle);

    that._createGroup('defaultPositiveMarkersGroup', markersGroup, markersGroup, defaultPositiveStyle);

    that._createGroup('reductionPositiveMarkersGroup', markersGroup, markersGroup, reductionPositiveStyle);
  },
  _setGroupsSettings: function _setGroupsSettings() {
    _scatter_series.chart._setGroupsSettings.call(this, false);
  },
  _getCreatingPointOptions: function _getCreatingPointOptions() {
    var that = this;
    var defaultPointOptions;
    var creatingPointOptions = that._predefinedPointOptions;

    if (!creatingPointOptions) {
      defaultPointOptions = this._getPointOptions();
      that._predefinedPointOptions = creatingPointOptions = (0, _extend2.extend)(true, {
        styles: {}
      }, defaultPointOptions);
      creatingPointOptions.styles.normal = creatingPointOptions.styles.positive.normal = creatingPointOptions.styles.reduction.normal = creatingPointOptions.styles.reductionPositive.normal = {
        'stroke-width': defaultPointOptions.styles && defaultPointOptions.styles.normal && defaultPointOptions.styles.normal['stroke-width']
      };
    }

    return creatingPointOptions;
  },
  _checkData: function _checkData(data, skippedFields) {
    var valueFields = this.getValueFields();
    return _scatter_series.chart._checkData.call(this, data, skippedFields, {
      openValue: valueFields[0],
      highValue: valueFields[1],
      lowValue: valueFields[2],
      closeValue: valueFields[3]
    }) && data.highValue === data.highValue && data.lowValue === data.lowValue;
  },
  _getPointDataSelector: function _getPointDataSelector(data, options) {
    var _this = this;

    var that = this;
    var level;
    var valueFields = that.getValueFields();
    var argumentField = that.getArgumentField();
    var openValueField = valueFields[0];
    var highValueField = valueFields[1];
    var lowValueField = valueFields[2];
    var closeValueField = valueFields[3];
    that.level = that._options.reduction.level;

    switch ((0, _utils.normalizeEnum)(that.level)) {
      case 'open':
        level = openValueField;
        break;

      case 'high':
        level = highValueField;
        break;

      case 'low':
        level = lowValueField;
        break;

      default:
        level = closeValueField;
        that.level = 'close';
        break;
    }

    var prevLevelValue;
    return function (data) {
      var reductionValue = data[level];
      var isReduction = false;

      if ((0, _type.isDefined)(reductionValue)) {
        if ((0, _type.isDefined)(prevLevelValue)) {
          isReduction = reductionValue < prevLevelValue;
        }

        prevLevelValue = reductionValue;
      }

      return {
        argument: data[argumentField],
        highValue: _this._processEmptyValue(data[highValueField]),
        lowValue: _this._processEmptyValue(data[lowValueField]),
        closeValue: _this._processEmptyValue(data[closeValueField]),
        openValue: _this._processEmptyValue(data[openValueField]),
        reductionValue: reductionValue,
        tag: data[that.getTagField()],
        isReduction: isReduction,
        data: data
      };
    };
  },
  _parsePointStyle: function _parsePointStyle(style, defaultColor, innerColor) {
    return {
      stroke: style.color || defaultColor,
      'stroke-width': style.width,
      fill: style.color || innerColor
    };
  },
  _getDefaultStyle: function _getDefaultStyle(options) {
    var that = this;
    var mainPointColor = options.color || that._options.mainSeriesColor;
    return {
      normal: that._parsePointStyle(options, mainPointColor, mainPointColor),
      hover: that._parsePointStyle(options.hoverStyle, mainPointColor, mainPointColor),
      selection: that._parsePointStyle(options.selectionStyle, mainPointColor, mainPointColor)
    };
  },
  _getReductionStyle: function _getReductionStyle(options) {
    var that = this;
    var reductionColor = options.reduction.color;
    return {
      normal: that._parsePointStyle({
        color: reductionColor,
        width: options.width,
        hatching: options.hatching
      }, reductionColor, reductionColor),
      hover: that._parsePointStyle(options.hoverStyle, reductionColor, reductionColor),
      selection: that._parsePointStyle(options.selectionStyle, reductionColor, reductionColor)
    };
  },
  _createPointStyles: function _createPointStyles(pointOptions) {
    var that = this;
    var innerColor = that._options.innerColor;

    var styles = that._getDefaultStyle(pointOptions);

    var positiveStyle = (0, _extend2.extend)(true, {}, styles);

    var reductionStyle = that._getReductionStyle(pointOptions);

    var reductionPositiveStyle = (0, _extend2.extend)(true, {}, reductionStyle);
    positiveStyle.normal.fill = positiveStyle.hover.fill = positiveStyle.selection.fill = innerColor;
    reductionPositiveStyle.normal.fill = reductionPositiveStyle.hover.fill = reductionPositiveStyle.selection.fill = innerColor;
    styles.positive = positiveStyle;
    styles.reduction = reductionStyle;
    styles.reductionPositive = reductionPositiveStyle;
    return styles;
  },
  _endUpdateData: function _endUpdateData() {
    delete this._predefinedPointOptions;
  },
  _defaultAggregator: 'ohlc',
  _aggregators: {
    'ohlc': function ohlc(_ref, series) {
      var intervalStart = _ref.intervalStart,
          intervalEnd = _ref.intervalEnd,
          data = _ref.data;

      if (!data.length) {
        return;
      }

      var result = {};
      var valueFields = series.getValueFields();
      var highValueField = valueFields[1];
      var lowValueField = valueFields[2];
      result[highValueField] = -Infinity;
      result[lowValueField] = Infinity;
      result = data.reduce(function (result, item) {
        if (item[highValueField] !== null) {
          result[highValueField] = Math.max(result[highValueField], item[highValueField]);
        }

        if (item[lowValueField] !== null) {
          result[lowValueField] = Math.min(result[lowValueField], item[lowValueField]);
        }

        return result;
      }, result);
      result[valueFields[0]] = data[0][valueFields[0]];
      result[valueFields[3]] = data[data.length - 1][valueFields[3]];

      if (!isFinite(result[highValueField])) {
        result[highValueField] = null;
      }

      if (!isFinite(result[lowValueField])) {
        result[lowValueField] = null;
      }

      result[series.getArgumentField()] = series._getIntervalCenter(intervalStart, intervalEnd);
      return result;
    }
  },
  getValueFields: function getValueFields() {
    var options = this._options;
    return [options.openValueField || 'open', options.highValueField || 'high', options.lowValueField || 'low', options.closeValueField || 'close'];
  },
  getArgumentField: function getArgumentField() {
    return this._options.argumentField || 'date';
  },
  _patchMarginOptions: function _patchMarginOptions(options) {
    var pointOptions = this._getCreatingPointOptions();

    var styles = pointOptions.styles;
    var border = [styles.normal, styles.hover, styles.selection].reduce(function (max, style) {
      return Math.max(max, style['stroke-width']);
    }, 0);
    options.size = DEFAULT_FINANCIAL_POINT_SIZE + border;
    options.sizePointNormalState = DEFAULT_FINANCIAL_POINT_SIZE;
    return options;
  },
  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {
    var oppositeCoord = null;
    var points = this.getVisiblePoints();

    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      var tmpCoord = void 0;

      if (isArgument) {
        tmpCoord = p.vx === coord ? (p.openY + p.closeY) / 2 : undefined;
      } else {
        var coords = [Math.min(p.lowY, p.highY), Math.max(p.lowY, p.highY)];
        tmpCoord = coord >= coords[0] && coord <= coords[1] ? p.vx : undefined;
      }

      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
        oppositeCoord = tmpCoord;
        break;
      }
    }

    return oppositeCoord;
  },
  usePointsToDefineAutoHiding: function usePointsToDefineAutoHiding() {
    return false;
  }
});
exports.stock = stock;
var candlestick = (0, _extend2.extend)({}, stock, {
  _parsePointStyle: function _parsePointStyle(style, defaultColor, innerColor) {
    var color = style.color || innerColor;

    var base = stock._parsePointStyle.call(this, style, defaultColor, color);

    base.fill = color;
    base.hatching = style.hatching;
    return base;
  }
});
exports.candlestick = candlestick;

/***/ }),
/* 1053 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.polar = exports.chart = void 0;

var _common = __webpack_require__(4);

var _extend2 = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _area_series = __webpack_require__(209);

var _bar_series = __webpack_require__(185);

var _line_series = __webpack_require__(242);

var _utils = __webpack_require__(14);

var _object = __webpack_require__(52);

// there stackedline, fullstackedline, stackedbar, fullstackedbar, stackedarea, fullstackedarea
var chartAreaSeries = _area_series.chart.area;
var chartBarSeries = _bar_series.chart.bar;
var baseStackedSeries = {
  _calculateErrorBars: _common.noop,
  _updateOptions: function _updateOptions(options) {
    this._stackName = 'axis_' + (options.axis || 'default');
  }
};
var chart = {};
exports.chart = chart;
var polar = {};
exports.polar = polar;
chart['stackedline'] = (0, _extend2.extend)({}, _line_series.chart.line, baseStackedSeries, {});
chart['stackedspline'] = (0, _extend2.extend)({}, _line_series.chart['spline'], baseStackedSeries, {});
chart['fullstackedline'] = (0, _extend2.extend)({}, _line_series.chart.line, baseStackedSeries, {
  getValueRangeInitialValue: _area_series.chart.area.getValueRangeInitialValue
});
chart['fullstackedspline'] = (0, _extend2.extend)({}, _line_series.chart['spline'], baseStackedSeries, {
  getValueRangeInitialValue: _area_series.chart.area.getValueRangeInitialValue
});
var stackedBar = chart['stackedbar'] = (0, _extend2.extend)({}, chartBarSeries, baseStackedSeries, {
  _updateOptions: function _updateOptions(options) {
    baseStackedSeries._updateOptions.call(this, options);

    this._stackName = this._stackName + '_stack_' + (options.stack || 'default');
  }
});
chart['fullstackedbar'] = (0, _extend2.extend)({}, chartBarSeries, baseStackedSeries, {
  _updateOptions: stackedBar._updateOptions
});

function clonePoint(point, value, minValue, position) {
  point = (0, _object.clone)(point);
  point.value = value;
  point.minValue = minValue;
  point.translate();
  point.argument = point.argument + position;
  return point;
}

function preparePointsForStackedAreaSegment(points) {
  var i = 0;
  var p;
  var result = [];
  var array;
  var len = points.length;

  while (i < len) {
    p = points[i];
    array = [p];

    if (p.leftHole) {
      array = [clonePoint(p, p.leftHole, p.minLeftHole, 'left'), p];
    }

    if (p.rightHole) {
      array.push(clonePoint(p, p.rightHole, p.minRightHole, 'right'));
    }

    result.push(array);
    i++;
  }

  return [].concat.apply([], result);
}

chart['stackedarea'] = (0, _extend2.extend)({}, chartAreaSeries, baseStackedSeries, {
  _prepareSegment: function _prepareSegment(points, rotated) {
    return chartAreaSeries._prepareSegment.call(this, preparePointsForStackedAreaSegment(points), rotated);
  },
  _appendInGroup: function _appendInGroup() {
    this._group.append(this._extGroups.seriesGroup).toBackground();
  }
});

function getPointsByArgFromPrevSeries(prevSeries, argument) {
  var result;

  while (!result && prevSeries) {
    result = prevSeries._segmentByArg && prevSeries._segmentByArg[argument]; // T357324

    prevSeries = prevSeries._prevSeries;
  }

  return result;
}

chart['stackedsplinearea'] = (0, _extend2.extend)({}, _area_series.chart['splinearea'], baseStackedSeries, {
  _prepareSegment: function _prepareSegment(points, rotated) {
    var that = this;
    var areaSegment;
    points = preparePointsForStackedAreaSegment(points);

    if (!this._prevSeries || points.length === 1) {
      areaSegment = _area_series.chart['splinearea']._prepareSegment.call(this, points, rotated);
    } else {
      var forwardPoints = _line_series.chart.spline._calculateBezierPoints(points, rotated);

      var backwardPoints = (0, _utils.map)(points, function (p) {
        var point = p.getCoords(true);
        point.argument = p.argument;
        return point;
      });
      var prevSeriesForwardPoints = [];
      var pointByArg = {};
      var i = 0;
      var len = that._prevSeries._segments.length;

      while (i < len) {
        prevSeriesForwardPoints = prevSeriesForwardPoints.concat(that._prevSeries._segments[i].line);
        i++;
      }

      (0, _iterator.each)(prevSeriesForwardPoints, function (_, p) {
        if (p.argument !== null) {
          var argument = p.argument.valueOf();

          if (!pointByArg[argument]) {
            pointByArg[argument] = [p];
          } else {
            pointByArg[argument].push(p);
          }
        }
      });
      that._prevSeries._segmentByArg = pointByArg;
      backwardPoints = _line_series.chart.spline._calculateBezierPoints(backwardPoints, rotated);
      (0, _iterator.each)(backwardPoints, function (i, p) {
        var argument = p.argument.valueOf();
        var prevSeriesPoints;

        if (i % 3 === 0) {
          prevSeriesPoints = pointByArg[argument] || getPointsByArgFromPrevSeries(that._prevSeries, argument);

          if (prevSeriesPoints) {
            backwardPoints[i - 1] && prevSeriesPoints[0] && (backwardPoints[i - 1] = prevSeriesPoints[0]);
            backwardPoints[i + 1] && (backwardPoints[i + 1] = prevSeriesPoints[2] || p);
          }
        }
      });
      areaSegment = {
        line: forwardPoints,
        area: forwardPoints.concat(backwardPoints.reverse())
      };

      that._areaPointsToSplineAreaPoints(areaSegment.area);
    }

    return areaSegment;
  },
  _appendInGroup: chart['stackedarea']._appendInGroup
});
chart['fullstackedarea'] = (0, _extend2.extend)({}, chartAreaSeries, baseStackedSeries, {
  _prepareSegment: chart['stackedarea']._prepareSegment,
  _appendInGroup: chart['stackedarea']._appendInGroup
});
chart['fullstackedsplinearea'] = (0, _extend2.extend)({}, _area_series.chart['splinearea'], baseStackedSeries, {
  _prepareSegment: chart['stackedsplinearea']._prepareSegment,
  _appendInGroup: chart['stackedarea']._appendInGroup
});
polar['stackedbar'] = (0, _extend2.extend)({}, _bar_series.polar.bar, baseStackedSeries, {});

/***/ }),
/* 1054 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.PieTracker = exports.ChartTracker = void 0;

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _click = __webpack_require__(23);

var _extend = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _consts = _interopRequireDefault(__webpack_require__(161));

var _utils = __webpack_require__(14);

var _pointer = _interopRequireDefault(__webpack_require__(25));

var _index = __webpack_require__(8);

var _type = __webpack_require__(1);

var _common = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _floor = Math.floor;
var eventsConsts = _consts.default.events;
var statesConsts = _consts.default.states;
var HOVER_STATE = statesConsts.hoverMark;
var NORMAL_STATE = statesConsts.normalMark;
var EVENT_NS = 'dxChartTracker';
var DOT_EVENT_NS = '.' + EVENT_NS;
var POINTER_ACTION = (0, _index.addNamespace)([_pointer.default.down, _pointer.default.move], EVENT_NS);
var LEGEND_CLICK = 'legendClick';
var SERIES_CLICK = 'seriesClick';
var POINT_CLICK = 'pointClick';
var POINT_DATA = 'chart-data-point';
var SERIES_DATA = 'chart-data-series';
var ARG_DATA = 'chart-data-argument';
var DELAY = 100;
var HOLD_TIMEOUT = 300;
var NONE_MODE = 'none';
var ALL_ARGUMENT_POINTS_MODE = 'allargumentpoints';
var INCLUDE_POINTS_MODE = 'includepoints';
var EXLUDE_POINTS_MODE = 'excludepoints';
var LEGEND_HOVER_MODES = [INCLUDE_POINTS_MODE, EXLUDE_POINTS_MODE, NONE_MODE];

function getData(event, dataKey, tryCheckParent) {
  var target = event.target;

  if (target.tagName === 'tspan') {
    return target.parentNode[dataKey];
  }

  var data = target[dataKey];

  if (tryCheckParent && !(0, _type.isDefined)(data)) {
    var getParentData = function getParentData(node) {
      if (node.parentNode) {
        if ((0, _type.isDefined)(node.parentNode[dataKey])) {
          return node.parentNode[dataKey];
        } else {
          return getParentData(node.parentNode);
        }
      }

      return undefined;
    };

    return getParentData(target);
  }

  return data;
}

function eventCanceled(event, target) {
  return event.cancel || !target.getOptions();
}

function correctLegendHoverMode(mode) {
  if (LEGEND_HOVER_MODES.indexOf(mode) > -1) {
    return mode;
  } else {
    return INCLUDE_POINTS_MODE;
  }
}

function correctHoverMode(target) {
  var mode = target.getOptions().hoverMode;
  return mode === NONE_MODE ? mode : ALL_ARGUMENT_POINTS_MODE;
}

var baseTrackerPrototype = {
  ctor: function ctor(options) {
    var that = this;
    var data = {
      tracker: that
    };
    that._renderer = options.renderer;
    that._legend = options.legend;
    that._tooltip = options.tooltip;
    that._eventTrigger = options.eventTrigger;
    that._seriesGroup = options.seriesGroup;
    options.seriesGroup.off(DOT_EVENT_NS).on((0, _index.addNamespace)(eventsConsts.showPointTooltip, EVENT_NS), data, that._showPointTooltip).on((0, _index.addNamespace)(eventsConsts.hidePointTooltip, EVENT_NS), data, that._hidePointTooltip);

    that._renderer.root.off(DOT_EVENT_NS).on(POINTER_ACTION, data, that._pointerHandler).on((0, _index.addNamespace)(_pointer.default.up, EVENT_NS), function () {
      return clearTimeout(that._holdTimer);
    }).on((0, _index.addNamespace)(_click.name, EVENT_NS), data, that._clickHandler);
  },
  update: function update(options) {
    this._chart = options.chart;
  },
  updateSeries: function updateSeries(series, resetDecorations) {
    var that = this;
    var noHoveredSeries = !(series !== null && series !== void 0 && series.some(function (s) {
      return s === that.hoveredSeries;
    }) || that._hoveredPoint && that._hoveredPoint.series);

    if (that._storedSeries !== series) {
      that._storedSeries = series || [];
    }

    if (noHoveredSeries) {
      that._clean();

      that._renderer.initHatching();
    }

    if (resetDecorations) {
      that.clearSelection();

      if (!noHoveredSeries) {
        that._hideTooltip(that.pointAtShownTooltip);

        that.clearHover();
      }
    }
  },
  setCanvases: function setCanvases(mainCanvas, paneCanvases) {
    this._mainCanvas = mainCanvas;
    this._canvases = paneCanvases;
  },
  repairTooltip: function repairTooltip() {
    var point = this.pointAtShownTooltip;

    if (!point || !point.series || !point.isVisible()) {
      this._hideTooltip(point, true);
    } else {
      this._showTooltip(point);
    }
  },
  _setHoveredPoint: function _setHoveredPoint(point) {
    if (point === this._hoveredPoint) {
      return;
    }

    this._releaseHoveredPoint();

    point.hover();
    this._hoveredPoint = point;
  },
  _releaseHoveredPoint: function _releaseHoveredPoint() {
    if (this._hoveredPoint && this._hoveredPoint.getOptions()) {
      this._hoveredPoint.clearHover();

      this._hoveredPoint = null;

      if (this._tooltip.isEnabled()) {
        this._hideTooltip(this._hoveredPoint);
      }
    }
  },
  _setHoveredSeries: function _setHoveredSeries(series, mode) {
    this._releaseHoveredSeries();

    this._releaseHoveredPoint();

    series.hover(mode);
    this.hoveredSeries = series;
  },
  _releaseHoveredSeries: function _releaseHoveredSeries() {
    // hoveredPoint only for T273289
    if (this.hoveredSeries) {
      this.hoveredSeries.clearHover();
      this.hoveredSeries = null;
    }
  },
  clearSelection: function clearSelection() {
    this._storedSeries.forEach(function (series) {
      if (series) {
        series.clearSelection();
        series.getPoints().forEach(function (point) {
          return point.clearSelection();
        });
      }
    });
  },
  _clean: function _clean() {
    var that = this;
    that.hoveredPoint = that.hoveredSeries = that._hoveredArgumentPoints = null;

    that._hideTooltip(that.pointAtShownTooltip);
  },
  clearHover: function clearHover() {
    this._resetHoveredArgument();

    this._releaseHoveredSeries();

    this._releaseHoveredPoint();
  },
  _hideTooltip: function _hideTooltip(point, silent) {
    var that = this;

    if (!that._tooltip || point && that.pointAtShownTooltip !== point) {
      return;
    }

    if (!silent && that.pointAtShownTooltip) {
      that.pointAtShownTooltip = null;
    }

    that._tooltip.hide();
  },
  _showTooltip: function _showTooltip(point) {
    var that = this;
    var tooltipFormatObject;
    var eventData = {
      target: point
    };

    if (point !== null && point !== void 0 && point.getOptions()) {
      tooltipFormatObject = point.getTooltipFormatObject(that._tooltip, that._tooltip.isShared() && that._chart.getStackedPoints(point));

      if (!(0, _type.isDefined)(tooltipFormatObject.valueText) && !tooltipFormatObject.points || !point.isVisible()) {
        return;
      }

      var coords = point.getTooltipParams(that._tooltip.getLocation());

      var rootOffset = that._renderer.getRootOffset();

      coords.x += rootOffset.left;
      coords.y += rootOffset.top;

      var callback = function callback(result) {
        result && (that.pointAtShownTooltip = point);
      };

      callback(that._tooltip.show(tooltipFormatObject, coords, eventData, undefined, callback));
    }
  },
  _showPointTooltip: function _showPointTooltip(event, point) {
    var that = event.data.tracker;
    var pointWithTooltip = that.pointAtShownTooltip;

    if (pointWithTooltip && pointWithTooltip !== point) {
      that._hideTooltip(pointWithTooltip);
    }

    that._showTooltip(point);
  },
  _hidePointTooltip: function _hidePointTooltip(event, point) {
    event.data.tracker._hideTooltip(point);
  },
  _enableOutHandler: function _enableOutHandler() {
    if (this._outHandler) {
      return;
    }

    var that = this;

    var handler = function handler(e) {
      var rootOffset = that._renderer.getRootOffset();

      var x = _floor(e.pageX - rootOffset.left);

      var y = _floor(e.pageY - rootOffset.top);

      if (!(0, _utils.pointInCanvas)(that._mainCanvas, x, y) && !that._tooltip.isCursorOnTooltip(e.pageX, e.pageY)) {
        that._pointerOut();

        that._disableOutHandler();
      }
    };

    _events_engine.default.on(_dom_adapter.default.getDocument(), POINTER_ACTION, handler);

    this._outHandler = handler;
  },
  _disableOutHandler: function _disableOutHandler() {
    this._outHandler && _events_engine.default.off(_dom_adapter.default.getDocument(), POINTER_ACTION, this._outHandler);
    this._outHandler = null;
  },
  stopCurrentHandling: function stopCurrentHandling() {
    this._pointerOut(true);
  },
  _pointerOut: function _pointerOut(force) {
    this.clearHover();
    (force || this._tooltip.isEnabled()) && this._hideTooltip(this.pointAtShownTooltip);
  },
  _triggerLegendClick: function _triggerLegendClick(eventArgs, elementClick) {
    var eventTrigger = this._eventTrigger;
    eventTrigger(LEGEND_CLICK, eventArgs, function () {
      !eventCanceled(eventArgs.event, eventArgs.target) && eventTrigger(elementClick, eventArgs);
    });
  },
  _hoverLegendItem: function _hoverLegendItem(x, y) {
    var that = this;

    var item = that._legend.getItemByCoord(x, y);

    var series;
    var legendHoverMode = correctLegendHoverMode(that._legend.getOptions().hoverMode);

    if (item) {
      series = that._storedSeries[item.id];

      if (!series.isHovered() || series.lastHoverMode !== legendHoverMode) {
        that._setHoveredSeries(series, legendHoverMode);
      }

      that._tooltip.isEnabled() && that._hideTooltip(that.pointAtShownTooltip);
    } else {
      that.clearHover();
    }
  },
  _hoverArgument: function _hoverArgument(argument, argumentIndex) {
    var that = this;

    var hoverMode = that._getArgumentHoverMode();

    if ((0, _type.isDefined)(argument)) {
      that._releaseHoveredPoint();

      that._hoveredArgument = argument;
      that._argumentIndex = argumentIndex;

      that._notifySeries({
        action: 'pointHover',
        notifyLegend: that._notifyLegendOnHoverArgument,
        target: {
          argument: argument,
          fullState: HOVER_STATE,
          argumentIndex: argumentIndex,
          getOptions: function getOptions() {
            return {
              hoverMode: hoverMode
            };
          }
        }
      });
    }
  },
  _resetHoveredArgument: function _resetHoveredArgument() {
    var that = this;
    var hoverMode;

    if ((0, _type.isDefined)(that._hoveredArgument)) {
      hoverMode = that._getArgumentHoverMode();

      that._notifySeries({
        action: 'clearPointHover',
        notifyLegend: that._notifyLegendOnHoverArgument,
        target: {
          fullState: NORMAL_STATE,
          argumentIndex: that._argumentIndex,
          argument: that._hoveredArgument,
          getOptions: function getOptions() {
            return {
              hoverMode: hoverMode
            };
          }
        }
      });

      that._hoveredArgument = null;
    }
  },
  _notifySeries: function _notifySeries(data) {
    this._storedSeries.forEach(function (series) {
      series.notify(data);
    });
  },
  _pointerHandler: function _pointerHandler(e) {
    var _series;

    var that = e.data.tracker;

    var rootOffset = that._renderer.getRootOffset();

    var x = _floor(e.pageX - rootOffset.left);

    var y = _floor(e.pageY - rootOffset.top);

    var canvas = that._getCanvas(x, y);

    var series = getData(e, SERIES_DATA);
    var point = getData(e, POINT_DATA) || ((_series = series) === null || _series === void 0 ? void 0 : _series.getPointByCoord(x, y));
    that._isHolding = false;
    clearTimeout(that._holdTimer);

    if (e.type === _pointer.default.down) {
      that._holdTimer = setTimeout(function () {
        return that._isHolding = true;
      }, HOLD_TIMEOUT);
    }

    if (point && !point.getMarkerVisibility()) {
      point = undefined;
    }

    that._enableOutHandler();

    if (that._legend.coordsIn(x, y)) {
      that._hoverLegendItem(x, y);

      return;
    }

    if (that.hoveredSeries && that.hoveredSeries !== that._stuckSeries) {
      that._releaseHoveredSeries();
    }

    if (that._hoverArgumentAxis(x, y, e)) {
      return;
    }

    if (that._isPointerOut(canvas, point)) {
      that._pointerOut();
    }

    if (!canvas && !point) {
      return;
    }

    if (series && !point) {
      point = series.getNeighborPoint(x, y);

      if (!that._stickyHovering && point && !point.coordsIn(x, y)) {
        point = null;
      }

      if (series !== that.hoveredSeries) {
        that._setTimeout(function () {
          that._setHoveredSeries(series);

          that._setStuckSeries(e, series, x, y);

          that._pointerComplete(point, x, y);
        }, series);

        return;
      }
    } else if (point) {
      if (e.type !== _pointer.default.move && e.pointerType !== 'touch') {
        return;
      }

      if (that.hoveredSeries) {
        that._setTimeout(function () {
          return that._pointerOnPoint(point, x, y, e);
        }, point);
      } else {
        that._pointerOnPoint(point, x, y, e);
      }

      return;
    } else if (that._setStuckSeries(e, undefined, x, y) && that._stickyHovering) {
      var _point;

      series = that._stuckSeries;
      point = series.getNeighborPoint(x, y);

      that._releaseHoveredSeries();

      ((_point = point) === null || _point === void 0 ? void 0 : _point.getMarkerVisibility()) && that._setHoveredPoint(point);
    } else if (!that._stickyHovering) {
      that._pointerOut();
    }

    that._pointerComplete(point, x, y);
  },
  _pointerOnPoint: function _pointerOnPoint(point, x, y) {
    this._resetHoveredArgument();

    this._setHoveredPoint(point);

    this._pointerComplete(point, x, y);
  },
  _pointerComplete: function _pointerComplete(point) {
    this.pointAtShownTooltip !== point && this._tooltip.isEnabled() && this._showTooltip(point);
  },
  _clickHandler: function _clickHandler(e) {
    var _point2;

    var that = e.data.tracker;

    if (that._isHolding) {
      return;
    }

    var rootOffset = that._renderer.getRootOffset();

    var x = _floor(e.pageX - rootOffset.left);

    var y = _floor(e.pageY - rootOffset.top);

    var point = getData(e, POINT_DATA);
    var series = that._stuckSeries || getData(e, SERIES_DATA) || ((_point2 = point) === null || _point2 === void 0 ? void 0 : _point2.series);
    var axis = that._argumentAxis;

    if (that._legend.coordsIn(x, y)) {
      var item = that._legend.getItemByCoord(x, y);

      if (item) {
        that._legendClick(item, e);
      }
    } else if (axis !== null && axis !== void 0 && axis.coordsIn(x, y)) {
      var argument = getData(e, ARG_DATA, true);

      if ((0, _type.isDefined)(argument)) {
        that._eventTrigger('argumentAxisClick', {
          argument: argument,
          event: e
        });
      }
    } else if (series) {
      var _point3;

      point = point || series.getPointByCoord(x, y);

      if ((_point3 = point) !== null && _point3 !== void 0 && _point3.getMarkerVisibility()) {
        that._pointClick(point, e);
      } else {
        getData(e, SERIES_DATA) && that._eventTrigger(SERIES_CLICK, {
          target: series,
          event: e
        });
      }
    }
  },
  dispose: function dispose() {
    var that = this;

    that._disableOutHandler();

    that._renderer.root.off(DOT_EVENT_NS);

    that._seriesGroup.off(DOT_EVENT_NS);
  }
};

var ChartTracker = function ChartTracker(options) {
  this.ctor(options);
};

exports.ChartTracker = ChartTracker;
(0, _extend.extend)(ChartTracker.prototype, baseTrackerPrototype, {
  _pointClick: function _pointClick(point, event) {
    var that = this;
    var eventTrigger = that._eventTrigger;
    var series = point.series;
    eventTrigger(POINT_CLICK, {
      target: point,
      event: event
    }, function () {
      !eventCanceled(event, series) && eventTrigger(SERIES_CLICK, {
        target: series,
        event: event
      });
    });
  },
  update: function update(options) {
    var that = this;
    baseTrackerPrototype.update.call(this, options);
    that._argumentAxis = options.argumentAxis || {};
    that._axisHoverEnabled = that._argumentAxis && (0, _utils.normalizeEnum)(that._argumentAxis.getOptions().hoverMode) === ALL_ARGUMENT_POINTS_MODE;
    that._rotated = options.rotated;
    that._crosshair = options.crosshair;
    that._stickyHovering = options.stickyHovering;
  },
  _getCanvas: function _getCanvas(x, y) {
    var that = this;
    var canvases = that._canvases || [];

    for (var i = 0; i < canvases.length; i++) {
      var c = canvases[i];

      if ((0, _utils.pointInCanvas)(c, x, y)) {
        return c;
      }
    }

    return null;
  },
  _isPointerOut: function _isPointerOut(canvas) {
    return !canvas && this._stuckSeries;
  },
  _hideCrosshair: function _hideCrosshair() {
    var _this$_crosshair;

    (_this$_crosshair = this._crosshair) === null || _this$_crosshair === void 0 ? void 0 : _this$_crosshair.hide();
  },
  _moveCrosshair: function _moveCrosshair(point, x, y) {
    if (this._crosshair && point !== null && point !== void 0 && point.isVisible()) {
      this._crosshair.show({
        point: point,
        x: x,
        y: y
      });
    }
  },
  _clean: function _clean() {
    var that = this;

    baseTrackerPrototype._clean.call(that);

    that._resetTimer();

    that._stuckSeries = null;
  },
  _getSeriesForShared: function _getSeriesForShared(x, y) {
    var _point4;

    var that = this;
    var points = [];
    var point = null;
    var distance = Infinity;

    if (that._tooltip.isShared() && !that.hoveredSeries) {
      (0, _iterator.each)(that._storedSeries, function (_, series) {
        var point = series.getNeighborPoint(x, y);
        point && points.push(point);
      });
      (0, _iterator.each)(points, function (_, p) {
        var coords = p.getCrosshairData(x, y);
        var d = (0, _utils.getDistance)(x, y, coords.x, coords.y);

        if (d < distance) {
          point = p;
          distance = d;
        }
      });
    }

    return (_point4 = point) === null || _point4 === void 0 ? void 0 : _point4.series;
  },
  _setTimeout: function _setTimeout(callback, keeper) {
    var that = this;

    if (that._timeoutKeeper !== keeper) {
      that._resetTimer();

      that._hoverTimeout = setTimeout(function () {
        callback();
        that._timeoutKeeper = null;
      }, DELAY);
      that._timeoutKeeper = keeper;
    }
  },
  _resetTimer: function _resetTimer() {
    clearTimeout(this._hoverTimeout);
    this._timeoutKeeper = this._hoverTimeout = null;
  },
  _stopEvent: function _stopEvent(e) {
    if (!(0, _type.isDefined)(e.cancelable) || e.cancelable) {
      e.preventDefault();
      e.stopPropagation(); // T249548
    }
  },
  _setStuckSeries: function _setStuckSeries(e, series, x, y) {
    if (e.pointerType !== 'mouse') {
      this._stuckSeries = null;
    } else {
      this._stuckSeries = series || this._stuckSeries || this._getSeriesForShared(x, y);
    }

    return !!this._stuckSeries;
  },
  _pointerOut: function _pointerOut() {
    var that = this;
    that._stuckSeries = null;

    that._hideCrosshair();

    that._resetTimer();

    baseTrackerPrototype._pointerOut.apply(that, arguments);
  },
  _hoverArgumentAxis: function _hoverArgumentAxis(x, y, e) {
    var that = this;

    that._resetHoveredArgument();

    if (that._axisHoverEnabled && that._argumentAxis.coordsIn(x, y)) {
      that._hoverArgument(getData(e, ARG_DATA, true));

      return true;
    }
  },
  _pointerComplete: function _pointerComplete(point, x, y) {
    var that = this;
    that.hoveredSeries && that.hoveredSeries.updateHover(x, y);

    that._resetTimer();

    that._moveCrosshair(point, x, y);

    baseTrackerPrototype._pointerComplete.call(that, point);
  },
  _legendClick: function _legendClick(item, e) {
    var series = this._storedSeries[item.id];

    this._triggerLegendClick({
      target: series,
      event: e
    }, SERIES_CLICK);
  },
  _hoverLegendItem: function _hoverLegendItem(x, y) {
    this._stuckSeries = null;

    this._hideCrosshair();

    baseTrackerPrototype._hoverLegendItem.call(this, x, y);
  },
  _pointerOnPoint: function _pointerOnPoint(point, x, y, e) {
    this._setStuckSeries(e, point.series, x, y);

    this._releaseHoveredSeries();

    baseTrackerPrototype._pointerOnPoint.call(this, point, x, y, e);
  },
  _notifyLegendOnHoverArgument: false,
  _getArgumentHoverMode: function _getArgumentHoverMode() {
    return correctHoverMode(this._argumentAxis);
  },
  dispose: function dispose() {
    this._resetTimer();

    baseTrackerPrototype.dispose.call(this);
  }
});

var PieTracker = function PieTracker(options) {
  this.ctor(options);
};

exports.PieTracker = PieTracker;
(0, _extend.extend)(PieTracker.prototype, baseTrackerPrototype, {
  _isPointerOut: function _isPointerOut(_, point) {
    return !point;
  },
  _legendClick: function _legendClick(item, e) {
    var that = this;
    var points = [];

    that._storedSeries.forEach(function (s) {
      return points.push.apply(points, s.getPointsByKeys(item.argument, item.argumentIndex));
    });

    that._eventTrigger(LEGEND_CLICK, {
      target: item.argument,
      points: points,
      event: e
    });
  },
  _pointClick: function _pointClick(point, e) {
    this._eventTrigger(POINT_CLICK, {
      target: point,
      event: e
    });
  },
  _hoverLegendItem: function _hoverLegendItem(x, y) {
    var that = this;

    var item = that._legend.getItemByCoord(x, y);

    if (item && that._hoveredArgument !== item.argument) {
      that._resetHoveredArgument();

      that._hoverArgument(item.argument, item.argumentIndex);
    } else if (!item) {
      that.clearHover();
    }
  },
  _getArgumentHoverMode: function _getArgumentHoverMode() {
    return correctHoverMode(this._legend);
  },
  _hoverArgumentAxis: _common.noop,
  _setStuckSeries: _common.noop,
  _getCanvas: _common.noop,
  _notifyLegendOnHoverArgument: true
});

/***/ }),
/* 1055 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _console = __webpack_require__(111);

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

var _utils = __webpack_require__(14);

var _math2 = __webpack_require__(31);

var _math = Math;
var _floor = _math.floor;
var _max = _math.max;
var _abs = _math.abs;

function getValueAxesPerPanes(valueAxes) {
  var result = {};
  valueAxes.forEach(function (axis) {
    var pane = axis.pane;

    if (!result[pane]) {
      result[pane] = [];
    }

    result[pane].push(axis);
  });
  return result;
}

var linearConverter = {
  transform: function transform(v, b) {
    return (0, _math2.adjust)((0, _utils.getLog)(v, b));
  },
  addInterval: function addInterval(v, i) {
    return (0, _math2.adjust)(v + i);
  },
  getInterval: function getInterval(base, tickInterval) {
    return tickInterval;
  }
};
var logConverter = {
  transform: function transform(v, b) {
    return (0, _math2.adjust)((0, _utils.raiseTo)(v, b));
  },
  addInterval: function addInterval(v, i) {
    return (0, _math2.adjust)(v * i);
  },
  getInterval: function getInterval(base, tickInterval) {
    return _math.pow(base, tickInterval);
  }
};

function convertAxisInfo(axisInfo, converter) {
  if (!axisInfo.isLogarithmic) {
    return;
  }

  var base = axisInfo.logarithmicBase;
  var tickValues = axisInfo.tickValues;
  var tick;
  var ticks = [];
  axisInfo.minValue = converter.transform(axisInfo.minValue, base);
  axisInfo.oldMinValue = converter.transform(axisInfo.oldMinValue, base);
  axisInfo.maxValue = converter.transform(axisInfo.maxValue, base);
  axisInfo.oldMaxValue = converter.transform(axisInfo.oldMaxValue, base);
  axisInfo.tickInterval = _math.round(axisInfo.tickInterval);

  if (axisInfo.tickInterval < 1) {
    axisInfo.tickInterval = 1;
  }

  var interval = converter.getInterval(base, axisInfo.tickInterval);
  tick = converter.transform(tickValues[0], base);

  while (ticks.length < tickValues.length) {
    ticks.push(tick);
    tick = converter.addInterval(tick, interval);
  }

  ticks.tickInterval = axisInfo.tickInterval;
  axisInfo.tickValues = ticks;
}

function populateAxesInfo(axes) {
  return axes.reduce(function (result, axis) {
    var ticksValues = axis.getTicksValues();
    var majorTicks = ticksValues.majorTicksValues;
    var options = axis.getOptions();
    var businessRange = axis.getTranslator().getBusinessRange();
    var visibleArea = axis.getVisibleArea();
    var axisInfo;
    var tickInterval = axis._tickInterval;
    var synchronizedValue = options.synchronizedValue;
    var action = axis.getViewport().action;

    if (majorTicks && majorTicks.length > 0 && (0, _type.isNumeric)(majorTicks[0]) && options.type !== 'discrete' && !businessRange.isEmpty() && !(businessRange.breaks && businessRange.breaks.length) && action !== 'zoom' && action !== 'pan') {
      axis.applyMargins();
      var startValue = axis.getTranslator().from(visibleArea[0]);
      var endValue = axis.getTranslator().from(visibleArea[1]);
      var minValue = startValue < endValue ? startValue : endValue;
      var maxValue = startValue < endValue ? endValue : startValue;

      if (minValue === maxValue && (0, _type.isDefined)(synchronizedValue)) {
        tickInterval = _abs(majorTicks[0] - synchronizedValue) || 1;
        minValue = majorTicks[0] - tickInterval;
        maxValue = majorTicks[0] + tickInterval;
      }

      axisInfo = {
        axis: axis,
        isLogarithmic: options.type === 'logarithmic',
        logarithmicBase: businessRange.base,
        tickValues: majorTicks,
        minorValues: ticksValues.minorTicksValues,
        minorTickInterval: axis._minorTickInterval,
        minValue: minValue,
        oldMinValue: minValue,
        maxValue: maxValue,
        oldMaxValue: maxValue,
        inverted: businessRange.invert,
        tickInterval: tickInterval,
        synchronizedValue: synchronizedValue
      };
      convertAxisInfo(axisInfo, linearConverter);
      result.push(axisInfo);
    }

    return result;
  }, []);
}

function updateTickValues(axesInfo) {
  var maxTicksCount = axesInfo.reduce(function (max, axisInfo) {
    return _max(max, axisInfo.tickValues.length);
  }, 0);
  axesInfo.forEach(function (axisInfo) {
    var ticksMultiplier;
    var ticksCount;
    var additionalStartTicksCount = 0;
    var synchronizedValue = axisInfo.synchronizedValue;
    var tickValues = axisInfo.tickValues;
    var tickInterval = axisInfo.tickInterval;

    if ((0, _type.isDefined)(synchronizedValue)) {
      axisInfo.baseTickValue = axisInfo.invertedBaseTickValue = synchronizedValue;
      axisInfo.tickValues = [axisInfo.baseTickValue];
    } else {
      if (tickValues.length > 1 && tickInterval) {
        ticksMultiplier = _floor((maxTicksCount + 1) / tickValues.length);
        ticksCount = ticksMultiplier > 1 ? _floor((maxTicksCount + 1) / ticksMultiplier) : maxTicksCount;
        additionalStartTicksCount = _floor((ticksCount - tickValues.length) / 2);

        while (additionalStartTicksCount > 0 && tickValues[0] !== 0) {
          tickValues.unshift((0, _math2.adjust)(tickValues[0] - tickInterval));
          additionalStartTicksCount--;
        }

        while (tickValues.length < ticksCount) {
          tickValues.push((0, _math2.adjust)(tickValues[tickValues.length - 1] + tickInterval));
        }

        axisInfo.tickInterval = tickInterval / ticksMultiplier;
      }

      axisInfo.baseTickValue = tickValues[0];
      axisInfo.invertedBaseTickValue = tickValues[tickValues.length - 1];
    }
  });
}

function getAxisRange(axisInfo) {
  return axisInfo.maxValue - axisInfo.minValue || 1; // T153054
}

function getMainAxisInfo(axesInfo) {
  for (var i = 0; i < axesInfo.length; i++) {
    if (!axesInfo[i].stubData) {
      return axesInfo[i];
    }
  }

  return null;
}

function correctMinMaxValues(axesInfo) {
  var mainAxisInfo = getMainAxisInfo(axesInfo);
  var mainAxisInfoTickInterval = mainAxisInfo.tickInterval;
  axesInfo.forEach(function (axisInfo) {
    var scale;
    var move;
    var mainAxisBaseValueOffset;
    var valueFromAxisInfo;

    if (axisInfo !== mainAxisInfo) {
      if (mainAxisInfoTickInterval && axisInfo.tickInterval) {
        if (axisInfo.stubData && (0, _type.isDefined)(axisInfo.synchronizedValue)) {
          axisInfo.oldMinValue = axisInfo.minValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.minValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;
          axisInfo.oldMaxValue = axisInfo.maxValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.maxValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;
        }

        scale = mainAxisInfoTickInterval / getAxisRange(mainAxisInfo) / axisInfo.tickInterval * getAxisRange(axisInfo);
        axisInfo.maxValue = axisInfo.minValue + getAxisRange(axisInfo) / scale;
      }

      if (mainAxisInfo.inverted && !axisInfo.inverted || !mainAxisInfo.inverted && axisInfo.inverted) {
        mainAxisBaseValueOffset = mainAxisInfo.maxValue - mainAxisInfo.invertedBaseTickValue;
      } else {
        mainAxisBaseValueOffset = mainAxisInfo.baseTickValue - mainAxisInfo.minValue;
      }

      valueFromAxisInfo = getAxisRange(axisInfo);
      move = (mainAxisBaseValueOffset / getAxisRange(mainAxisInfo) - (axisInfo.baseTickValue - axisInfo.minValue) / valueFromAxisInfo) * valueFromAxisInfo;
      axisInfo.minValue -= move;
      axisInfo.maxValue -= move;
    }
  });
}

function calculatePaddings(axesInfo) {
  var minPadding;
  var maxPadding;
  var startPadding = 0;
  var endPadding = 0;
  axesInfo.forEach(function (axisInfo) {
    var inverted = axisInfo.inverted;
    minPadding = axisInfo.minValue > axisInfo.oldMinValue ? (axisInfo.minValue - axisInfo.oldMinValue) / getAxisRange(axisInfo) : 0;
    maxPadding = axisInfo.maxValue < axisInfo.oldMaxValue ? (axisInfo.oldMaxValue - axisInfo.maxValue) / getAxisRange(axisInfo) : 0;
    startPadding = _max(startPadding, inverted ? maxPadding : minPadding);
    endPadding = _max(endPadding, inverted ? minPadding : maxPadding);
  });
  return {
    start: startPadding,
    end: endPadding
  };
}

function correctMinMaxValuesByPaddings(axesInfo, paddings) {
  axesInfo.forEach(function (info) {
    var range = getAxisRange(info);
    var inverted = info.inverted;
    info.minValue = (0, _math2.adjust)(info.minValue - paddings[inverted ? 'end' : 'start'] * range);
    info.maxValue = (0, _math2.adjust)(info.maxValue + paddings[inverted ? 'start' : 'end'] * range);
  });
}

function updateTickValuesIfSynchronizedValueUsed(axesInfo) {
  var hasSynchronizedValue = false;
  axesInfo.forEach(function (info) {
    hasSynchronizedValue = hasSynchronizedValue || (0, _type.isDefined)(info.synchronizedValue);
  });
  axesInfo.forEach(function (info) {
    var tickInterval = info.tickInterval;
    var tickValues = info.tickValues;
    var maxValue = info.maxValue;
    var minValue = info.minValue;
    var tick;

    if (hasSynchronizedValue && tickInterval) {
      while ((tick = (0, _math2.adjust)(tickValues[0] - tickInterval)) >= minValue) {
        tickValues.unshift(tick);
      }

      tick = tickValues[tickValues.length - 1];

      while ((tick = (0, _math2.adjust)(tick + tickInterval)) <= maxValue) {
        tickValues.push(tick);
      }
    }

    while (tickValues[0] + tickInterval / 10 < minValue) {
      tickValues.shift();
    }

    while (tickValues[tickValues.length - 1] - tickInterval / 10 > maxValue) {
      tickValues.pop();
    }
  });
}

function applyMinMaxValues(axesInfo) {
  axesInfo.forEach(function (info) {
    var axis = info.axis;
    var range = axis.getTranslator().getBusinessRange();

    if (range.min === range.minVisible) {
      range.min = info.minValue;
    }

    if (range.max === range.maxVisible) {
      range.max = info.maxValue;
    }

    range.minVisible = info.minValue;
    range.maxVisible = info.maxValue;

    if (range.min > range.minVisible) {
      range.min = range.minVisible;
    }

    if (range.max < range.maxVisible) {
      range.max = range.maxVisible;
    }

    axis.getTranslator().updateBusinessRange(range);
    axis.setTicks({
      majorTicks: info.tickValues,
      minorTicks: info.minorValues
    });
  });
}

function correctAfterSynchronize(axesInfo) {
  var invalidAxisInfo = [];
  var correctValue;
  axesInfo.forEach(function (info) {
    if (info.oldMaxValue - info.oldMinValue === 0) {
      invalidAxisInfo.push(info);
    } else {
      if (!(0, _type.isDefined)(correctValue) && !(0, _type.isDefined)(info.synchronizedValue)) {
        correctValue = _abs((info.maxValue - info.minValue) / (info.tickValues[_floor(info.tickValues.length / 2)] - info.minValue || info.maxValue));
      }
    }
  });

  if (!(0, _type.isDefined)(correctValue)) {
    return;
  }

  invalidAxisInfo.forEach(function (info) {
    var firstTick = info.tickValues[0];
    var correctedTick = firstTick * correctValue;

    if (firstTick > 0) {
      info.maxValue = correctedTick;
      info.minValue = 0;
    } else if (firstTick < 0) {
      info.minValue = correctedTick;
      info.maxValue = 0;
    }
  });
}

function updateMinorTicks(axesInfo) {
  axesInfo.forEach(function (axisInfo) {
    if (!axisInfo.minorTickInterval) {
      return;
    }

    var ticks = [];
    var interval = axisInfo.minorTickInterval;
    var tickCount = axisInfo.tickInterval / interval - 1;

    for (var i = 1; i < axisInfo.tickValues.length; i++) {
      var tick = axisInfo.tickValues[i - 1];

      for (var j = 0; j < tickCount; j++) {
        tick += interval;
        ticks.push(tick);
      }
    }

    axisInfo.minorValues = ticks;
  });
}

function correctPaddings(axesInfo, paddings) {
  return axesInfo.reduce(function (prev, info) {
    var inverted = info.inverted;

    var _info$axis$getCorrect = info.axis.getCorrectedValuesToZero(info.minValue, info.maxValue),
        start = _info$axis$getCorrect.start,
        end = _info$axis$getCorrect.end;

    if ((0, _type.isDefined)(start) || (0, _type.isDefined)(end)) {
      return inverted ? {
        start: prev.start,
        end: Math.min(prev.end, end)
      } : {
        start: Math.min(prev.start, start),
        end: prev.end
      };
    }

    return prev;
  }, paddings);
}

var multiAxesSynchronizer = {
  synchronize: function synchronize(valueAxes) {
    (0, _iterator.each)(getValueAxesPerPanes(valueAxes), function (_, axes) {
      var axesInfo;
      var paddings;

      if (axes.length > 1) {
        axesInfo = populateAxesInfo(axes);
        if (axesInfo.length < 2 || !getMainAxisInfo(axesInfo)) return;
        updateTickValues(axesInfo);
        correctMinMaxValues(axesInfo);
        paddings = calculatePaddings(axesInfo);
        paddings = correctPaddings(axesInfo, paddings);
        correctMinMaxValuesByPaddings(axesInfo, paddings);
        correctAfterSynchronize(axesInfo);
        updateTickValuesIfSynchronizedValueUsed(axesInfo);
        updateMinorTicks(axesInfo);
        axesInfo.forEach(function (info) {
          convertAxisInfo(info, logConverter);
        });
        applyMinMaxValues(axesInfo);
      }
    });
  }
};
var _default = multiAxesSynchronizer;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1056 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _type = __webpack_require__(1);

var _math = __webpack_require__(31);

var round = Math.round;

function getValue(value) {
  return value;
}

var _default = {
  translate: function translate(category, directionOffset) {
    var that = this;
    var canvasOptions = that._canvasOptions;
    var categoryIndex = that._categoriesToPoints[category === null || category === void 0 ? void 0 : category.valueOf()];
    var specialValue = that.translateSpecialCase(category);
    var startPointIndex = canvasOptions.startPointIndex || 0;
    var stickInterval = that._options.stick ? 0 : 0.5;

    if ((0, _type.isDefined)(specialValue)) {
      return round(specialValue);
    } // Q522516


    if (!categoryIndex && categoryIndex !== 0) {
      return null;
    }

    directionOffset = directionOffset || 0;
    var stickDelta = categoryIndex + stickInterval - startPointIndex + directionOffset * 0.5;
    return round(that._calculateProjection(canvasOptions.interval * stickDelta));
  },
  getInterval: function getInterval() {
    return this._canvasOptions.interval;
  },
  getEventScale: function getEventScale(zoomEvent) {
    var scale = zoomEvent.deltaScale || 1;
    return 1 - (1 - scale) / (0.75 + this.visibleCategories.length / this._categories.length);
  },
  zoom: function zoom(translate, scale) {
    var that = this;
    var categories = that._categories;
    var canvasOptions = that._canvasOptions;
    var stick = that._options.stick;
    var invert = canvasOptions.invert;
    var interval = canvasOptions.interval * scale;
    var translateCategories = translate / interval;
    var visibleCount = (that.visibleCategories || []).length;
    var startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + translateCategories + 0.5);
    var categoriesLength = parseInt((0, _math.adjust)(canvasOptions.canvasLength / interval) + (stick ? 1 : 0)) || 1;
    var endCategoryIndex;

    if (invert) {
      startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + visibleCount - translateCategories + 0.5) - categoriesLength;
    }

    if (startCategoryIndex < 0) {
      startCategoryIndex = 0;
    }

    endCategoryIndex = startCategoryIndex + categoriesLength;

    if (endCategoryIndex > categories.length) {
      endCategoryIndex = categories.length;
      startCategoryIndex = endCategoryIndex - categoriesLength;

      if (startCategoryIndex < 0) {
        startCategoryIndex = 0;
      }
    }

    var newVisibleCategories = categories.slice(parseInt(startCategoryIndex), parseInt(endCategoryIndex));

    var newInterval = that._getDiscreteInterval(newVisibleCategories.length, canvasOptions);

    scale = newInterval / canvasOptions.interval;
    translate = that.translate(!invert ? newVisibleCategories[0] : newVisibleCategories[newVisibleCategories.length - 1]) * scale - (canvasOptions.startPoint + (stick ? 0 : newInterval / 2));
    return {
      min: newVisibleCategories[0],
      max: newVisibleCategories[newVisibleCategories.length - 1],
      translate: translate,
      scale: scale
    };
  },
  getMinScale: function getMinScale(zoom) {
    var that = this;
    var canvasOptions = that._canvasOptions;
    var categoriesLength = (that.visibleCategories || that._categories).length;
    categoriesLength += (parseInt(categoriesLength * 0.1) || 1) * (zoom ? -2 : 2);
    return canvasOptions.canvasLength / (Math.max(categoriesLength, 1) * canvasOptions.interval);
  },
  getScale: function getScale(min, max) {
    var that = this;
    var canvasOptions = that._canvasOptions;
    var visibleArea = that.getCanvasVisibleArea();
    var stickOffset = !that._options.stick && 1;
    var minPoint = (0, _type.isDefined)(min) ? that.translate(min, -stickOffset) : null;
    var maxPoint = (0, _type.isDefined)(max) ? that.translate(max, +stickOffset) : null;

    if (minPoint === null) {
      minPoint = canvasOptions.invert ? visibleArea.max : visibleArea.min;
    }

    if (maxPoint === null) {
      maxPoint = canvasOptions.invert ? visibleArea.min : visibleArea.max;
    }

    return that.canvasLength / Math.abs(maxPoint - minPoint);
  },
  // dxRangeSelector
  isValid: function isValid(value) {
    return (0, _type.isDefined)(value) ? this._categoriesToPoints[value.valueOf()] >= 0 : false;
  },
  getCorrectValue: getValue,
  to: function to(value, direction) {
    var canvasOptions = this._canvasOptions;
    var categoryIndex = this._categoriesToPoints[value === null || value === void 0 ? void 0 : value.valueOf()];
    var startPointIndex = canvasOptions.startPointIndex || 0;
    var stickDelta = categoryIndex + (this._options.stick ? 0 : 0.5) - startPointIndex + (this._businessRange.invert ? -1 : +1) * direction * 0.5;
    return round(this._calculateProjection(canvasOptions.interval * stickDelta));
  },
  from: function from(position) {
    var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var canvasOptions = this._canvasOptions;
    var startPoint = canvasOptions.startPoint;
    var categories = this.visibleCategories || this._categories;
    var categoriesLength = categories.length;
    var stickInterval = this._options.stick ? 0.5 : 0; // It is strange - while "businessRange.invert" check is required in "to" here it is not.
    // Check that translator.from(translator.to(x, -1), -1) equals x.
    // And check that translator.untranslate(translator.translate(x, -1), -1) does not equal x - is it really supposed to be so?

    var result = round((position - startPoint) / canvasOptions.interval + stickInterval - 0.5 -
    /* (businessRange.invert ? -1 : +1) * */
    direction * 0.5);

    if (result >= categoriesLength) {
      result = categoriesLength - 1;
    }

    if (result < 0) {
      result = 0;
    }

    if (canvasOptions.invert) {
      result = categoriesLength - result - 1;
    }

    return categories[result];
  },
  _add: function _add() {
    return NaN;
  },
  toValue: getValue,
  isValueProlonged: true,
  getRangeByMinZoomValue: function getRangeByMinZoomValue(minZoom, visualRange) {
    var categories = this._categories;
    var minVisibleIndex = categories.indexOf(visualRange.minVisible);
    var maxVisibleIndex = categories.indexOf(visualRange.maxVisible);
    var startIndex = minVisibleIndex + minZoom - 1;
    var endIndex = maxVisibleIndex - minZoom + 1;

    if (categories[startIndex]) {
      return [visualRange.minVisible, categories[startIndex]];
    } else {
      return [categories[endIndex], visualRange.maxVisible];
    }
  }
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1057 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _type = __webpack_require__(1);

var _date = _interopRequireDefault(__webpack_require__(18));

var _math = __webpack_require__(31);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var floor = Math.floor;
var _default = {
  _intervalize: function _intervalize(value, interval) {
    if (!(0, _type.isDefined)(value)) {
      return undefined;
    }

    if (this._businessRange.dataType === 'datetime') {
      if ((0, _type.isNumeric)(value)) {
        value = new Date(value);
      } else {
        value = new Date(value.getTime());
      }

      value = _date.default.correctDateWithUnitBeginning(value, interval, null, this._options.firstDayOfWeek);
    } else {
      value = (0, _math.adjust)(floor((0, _math.adjust)(value / interval)) * interval, interval);
    }

    return value;
  },
  translate: function translate(bp, direction, interval) {
    var that = this;
    var specialValue = that.translateSpecialCase(bp);

    if ((0, _type.isDefined)(specialValue)) {
      return Math.round(specialValue);
    }

    interval = interval || that._options.interval; // TODO B253861

    if (!that.isValid(bp, interval)) {
      return null;
    }

    return that.to(bp, direction, interval);
  },
  getInterval: function getInterval() {
    return Math.round(this._canvasOptions.ratioOfCanvasRange * (this._businessRange.interval || Math.abs(this._canvasOptions.rangeMax - this._canvasOptions.rangeMin)));
  },
  zoom: function zoom() {},
  getMinScale: function getMinScale() {},
  getScale: function getScale() {},
  _parse: function _parse(value) {
    return this._businessRange.dataType === 'datetime' ? new Date(value) : Number(value);
  },
  fromValue: function fromValue(value) {
    return this._parse(value);
  },
  toValue: function toValue(value) {
    return this._parse(value);
  },
  isValid: function isValid(value, interval) {
    var that = this;
    var co = that._canvasOptions;
    var rangeMin = co.rangeMin;
    var rangeMax = co.rangeMax;
    interval = interval || that._options.interval;

    if (value === null || isNaN(value)) {
      return false;
    }

    value = that._businessRange.dataType === 'datetime' && (0, _type.isNumeric)(value) ? new Date(value) : value;

    if (interval !== that._options.interval) {
      rangeMin = that._intervalize(rangeMin, interval);
      rangeMax = that._intervalize(rangeMax, interval);
    }

    if (value.valueOf() < rangeMin || value.valueOf() >= _date.default.addInterval(rangeMax, interval)) {
      return false;
    }

    return true;
  },
  to: function to(bp, direction, interval) {
    var that = this;
    interval = interval || that._options.interval;

    var v1 = that._intervalize(bp, interval);

    var v2 = _date.default.addInterval(v1, interval);

    var res = that._to(v1);

    var p2 = that._to(v2);

    if (!direction) {
      res = floor((res + p2) / 2);
    } else if (direction > 0) {
      res = p2;
    }

    return res;
  },
  _to: function _to(value) {
    var co = this._canvasOptions;
    var rMin = co.rangeMinVisible;
    var rMax = co.rangeMaxVisible;
    var offset = value - rMin;

    if (value < rMin) {
      offset = 0;
    } else if (value > rMax) {
      offset = _date.default.addInterval(rMax, this._options.interval) - rMin;
    }

    return this._conversionValue(this._calculateProjection(offset * this._canvasOptions.ratioOfCanvasRange));
  },
  from: function from(position, direction) {
    var that = this;
    var origInterval = that._options.interval;
    var interval = origInterval;
    var co = that._canvasOptions;
    var rMin = co.rangeMinVisible;
    var rMax = co.rangeMaxVisible;
    var value;

    if (that._businessRange.dataType === 'datetime') {
      interval = _date.default.dateToMilliseconds(origInterval);
    }

    value = that._calculateUnProjection((position - that._canvasOptions.startPoint) / that._canvasOptions.ratioOfCanvasRange);
    value = that._intervalize(_date.default.addInterval(value, interval / 2, direction > 0), origInterval);

    if (value < rMin) {
      value = rMin;
    } else if (value > rMax) {
      value = rMax;
    }

    return value;
  },
  _add: function _add() {
    return NaN;
  },
  isValueProlonged: true
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1058 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _date = _interopRequireDefault(__webpack_require__(18));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(value) {
  return value !== null ? new Date(value) : value;
}

var _default = {
  fromValue: parse,
  toValue: parse,
  _add: _date.default.addDateInterval,
  convert: _date.default.dateToMilliseconds
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1059 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _utils = __webpack_require__(14);

var _type = __webpack_require__(1);

var _default = {
  fromValue: function fromValue(value) {
    return value !== null ? (0, _utils.getLogExt)(value, this._canvasOptions.base, this._businessRange.allowNegatives, this._businessRange.linearThreshold) : value;
  },
  toValue: function toValue(value) {
    return value !== null ? (0, _utils.raiseToExt)(value, this._canvasOptions.base, this._businessRange.allowNegatives, this._businessRange.linearThreshold) : value;
  },
  getMinBarSize: function getMinBarSize(minBarSize) {
    var visibleArea = this.getCanvasVisibleArea();
    var minValue = this.from(visibleArea.min + minBarSize);
    var canvasOptions = this._canvasOptions;
    return Math.pow(canvasOptions.base, canvasOptions.rangeMinVisible + this.fromValue(this.from(visibleArea.min)) - this.fromValue(!(0, _type.isDefined)(minValue) ? this.from(visibleArea.max) : minValue));
  },
  checkMinBarSize: function checkMinBarSize(initialValue, minShownValue, stackValue) {
    var canvasOptions = this._canvasOptions;
    var prevValue = stackValue - initialValue;
    var baseMethod = this.constructor.prototype.checkMinBarSize;
    var minBarSize;
    var updateValue;

    if ((0, _type.isDefined)(minShownValue) && prevValue > 0) {
      minBarSize = baseMethod(this.fromValue(stackValue / prevValue), this.fromValue(minShownValue) - canvasOptions.rangeMinVisible);
      updateValue = Math.pow(canvasOptions.base, this.fromValue(prevValue) + minBarSize) - prevValue;
    } else {
      updateValue = baseMethod(initialValue, minShownValue);
    }

    return updateValue;
  }
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1060 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.generateDateBreaks = generateDateBreaks;

var _date = _interopRequireDefault(__webpack_require__(18));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var days = [0, 1, 2, 3, 4, 5, 6];

function getWeekendDays(workdays) {
  return days.filter(function (day) {
    return !workdays.some(function (workDay) {
      return workDay === day;
    });
  });
}

function getNextDayIndex(dayIndex) {
  return (dayIndex + 1) % 7;
}

function dayBetweenWeekend(weekend, day) {
  var start = weekend.start;
  var end = weekend.end;

  while (start !== end) {
    if (start === day) {
      return true;
    }

    start = getNextDayIndex(start);
  }

  return false;
}

function getDaysDistance(day, end) {
  var length = 0;

  while (day !== end) {
    day = getNextDayIndex(day);
    length++;
  }

  return length;
}

function separateBreak(scaleBreak, day) {
  var result = [];
  var dayEnd = new Date(day);
  dayEnd.setDate(day.getDate() + 1);

  if (day > scaleBreak.from) {
    result.push({
      from: scaleBreak.from,
      to: day
    });
  }

  if (dayEnd < scaleBreak.to) {
    result.push({
      from: dayEnd,
      to: scaleBreak.to
    });
  }

  return result;
}

function getWeekEndDayIndices(workDays) {
  var indices = getWeekendDays(workDays);

  if (indices.length < 7) {
    while (getNextDayIndex(indices[indices.length - 1]) === indices[0]) {
      indices.unshift(indices.pop());
    }
  }

  return indices;
}

function generateDateBreaksForWeekend(min, max, weekendDayIndices) {
  var day = min.getDate();
  var breaks = [];
  var weekends = weekendDayIndices.reduce(function (obj, day) {
    var currentWeekEnd = obj[1];

    if (currentWeekEnd.start === undefined) {
      currentWeekEnd = {
        start: day,
        end: getNextDayIndex(day)
      };
      obj[0].push(currentWeekEnd);
      return [obj[0], currentWeekEnd];
    } else if (currentWeekEnd.end === day) {
      currentWeekEnd.end = getNextDayIndex(day);
      return obj;
    }

    currentWeekEnd = {
      start: day,
      end: getNextDayIndex(day)
    };
    obj[0].push(currentWeekEnd);
    return [obj[0], currentWeekEnd];
  }, [[], {}]);
  weekends[0].forEach(function (weekend) {
    var currentDate = new Date(min);
    currentDate = _date.default.trimTime(currentDate);

    while (currentDate < max) {
      day = currentDate.getDay();
      var date = currentDate.getDate();

      if (dayBetweenWeekend(weekend, day)) {
        var from = new Date(currentDate);
        currentDate.setDate(date + getDaysDistance(day, weekend.end));
        var to = new Date(currentDate);
        breaks.push({
          from: from,
          to: to
        });
      }

      currentDate.setDate(currentDate.getDate() + 1);
    }
  });
  return breaks;
}

function excludeWorkDaysFromWeekEndBreaks(breaks, exactWorkDays) {
  var result = breaks.slice();
  var i;

  var processWorkDay = function processWorkDay(workday) {
    workday = _date.default.trimTime(new Date(workday));

    if (result[i].from <= workday && result[i].to > workday) {
      var separatedBreak = separateBreak(result[i], workday);

      if (separatedBreak.length === 2) {
        result.splice(i, 1, separatedBreak[0], separatedBreak[1]);
      } else if (separatedBreak.length === 1) {
        result.splice(i, 1, separatedBreak[0]);
      } else {
        result.splice(i, 1);
      }
    }
  };

  for (i = 0; i < result.length; i++) {
    exactWorkDays.forEach(processWorkDay);
  }

  return result;
}

function generateBreaksForHolidays(min, max, holidays, weekendDayIndices) {
  var day;

  var dayInWeekend = function dayInWeekend(dayIndex) {
    return dayIndex === day;
  };

  var adjustedMin = _date.default.trimTime(min);

  var adjustedMax = _date.default.trimTime(max);

  adjustedMax.setDate(max.getDate() + 1);
  return holidays.reduce(function (breaks, holiday) {
    var holidayStart;
    var holidayEnd;
    holiday = new Date(holiday);
    day = holiday.getDay();

    if (!weekendDayIndices.some(dayInWeekend) && holiday >= adjustedMin && holiday <= adjustedMax) {
      holidayStart = _date.default.trimTime(holiday);
      holidayEnd = new Date(holidayStart);
      holidayEnd.setDate(holidayStart.getDate() + 1);
      breaks.push({
        from: holidayStart,
        to: holidayEnd
      });
    }

    return breaks;
  }, []);
}

function calculateGaps(breaks) {
  return breaks.map(function (b) {
    return {
      from: b.from,
      to: b.to,
      gapSize: _date.default.convertMillisecondsToDateUnits(b.to - b.from)
    };
  });
}

function generateDateBreaks(min, max, workWeek, singleWorkdays, holidays) {
  var weekendDayIndices = getWeekEndDayIndices(workWeek);
  var breaks = generateDateBreaksForWeekend(min, max, weekendDayIndices);
  breaks.push.apply(breaks, generateBreaksForHolidays(min, max, holidays || [], weekendDayIndices));
  return calculateGaps(excludeWorkDaysFromWeekEndBreaks(breaks, singleWorkdays || []));
}

/***/ }),
/* 1061 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.linearSpider = exports.linear = exports.circularSpider = exports.circular = void 0;

var _utils = __webpack_require__(14);

var _type = __webpack_require__(1);

var _extend = __webpack_require__(0);

var _axes_constants = _interopRequireDefault(__webpack_require__(243));

var _xy_axes = _interopRequireDefault(__webpack_require__(597));

var _tick = __webpack_require__(596);

var _axes_utils = __webpack_require__(598);

var _common = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PI = Math.PI,
    abs = Math.abs,
    atan = Math.atan,
    round = Math.round;
var _min = Math.min;
var _max = Math.max;
var xyAxesLinear = _xy_axes.default.linear;
var HALF_PI_ANGLE = 90;

function getPolarQuarter(angle) {
  var quarter;
  angle = (0, _utils.normalizeAngle)(angle);

  if (angle >= 315 && angle <= 360 || angle < 45 && angle >= 0) {
    quarter = 1;
  } else if (angle >= 45 && angle < 135) {
    quarter = 2;
  } else if (angle >= 135 && angle < 225) {
    quarter = 3;
  } else if (angle >= 225 && angle < 315) {
    quarter = 4;
  }

  return quarter;
}

var circularAxes = {
  _calculateValueMargins: function _calculateValueMargins(ticks) {
    var _this$_getViewportRan = this._getViewportRange(),
        minVisible = _this$_getViewportRan.minVisible,
        maxVisible = _this$_getViewportRan.maxVisible;

    if (ticks && ticks.length > 1) {
      minVisible = minVisible < ticks[0].value ? minVisible : ticks[0].value;
      maxVisible = minVisible > ticks[ticks.length - 1].value ? maxVisible : ticks[ticks.length - 1].value;
    }

    return {
      minValue: minVisible,
      maxValue: maxVisible
    };
  },
  applyMargins: function applyMargins() {
    var margins = this._calculateValueMargins(this._majorTicks);

    var br = this._translator.getBusinessRange();

    br.addRange({
      minVisible: margins.minValue,
      maxVisible: margins.maxValue,
      interval: this._calculateRangeInterval(br.interval)
    });

    this._translator.updateBusinessRange(br);
  },
  _getTranslatorOptions: function _getTranslatorOptions() {
    return {
      isHorizontal: true,
      conversionValue: true,
      addSpiderCategory: this._getSpiderCategoryOption(),
      stick: this._getStick()
    };
  },
  getCenter: function getCenter() {
    return this._center;
  },
  getRadius: function getRadius() {
    return this._radius;
  },
  getAngles: function getAngles() {
    var options = this._options;
    return [options.startAngle, options.endAngle];
  },
  _updateRadius: function _updateRadius(canvas) {
    var rad = _min(canvas.width - canvas.left - canvas.right, canvas.height - canvas.top - canvas.bottom) / 2;
    this._radius = rad < 0 ? 0 : rad;
  },
  _updateCenter: function _updateCenter(canvas) {
    this._center = {
      x: canvas.left + (canvas.width - canvas.right - canvas.left) / 2,
      y: canvas.top + (canvas.height - canvas.top - canvas.bottom) / 2
    };
  },
  _processCanvas: function _processCanvas(canvas) {
    this._updateRadius(canvas);

    this._updateCenter(canvas);

    return {
      left: 0,
      right: 0,
      width: this._getScreenDelta()
    };
  },
  _createAxisElement: function _createAxisElement() {
    return this._renderer.circle();
  },
  _updateAxisElementPosition: function _updateAxisElementPosition() {
    var center = this.getCenter();

    this._axisElement.attr({
      cx: center.x,
      cy: center.y,
      r: this.getRadius()
    });
  },
  _boundaryTicksVisibility: {
    min: true
  },
  _getSpiderCategoryOption: function _getSpiderCategoryOption() {
    // TODO rename spider
    return this._options.firstPointOnStartAngle;
  },
  _validateOptions: function _validateOptions(options) {
    var that = this;
    var originValue = options.originValue;
    var wholeRange = options.wholeRange = {};
    var period = options.period;

    if ((0, _type.isDefined)(originValue)) {
      originValue = that.validateUnit(originValue);
    }

    if (period > 0 && options.argumentType === _axes_constants.default.numeric) {
      originValue = originValue || 0;
      wholeRange.endValue = originValue + period;
      that._viewport = (0, _utils.getVizRangeObject)([originValue, wholeRange.endValue]);
    }

    if ((0, _type.isDefined)(originValue)) {
      wholeRange.startValue = originValue;
    }
  },
  getMargins: function getMargins() {
    var tickOptions = this._options.tick;

    var tickOuterLength = _max(tickOptions.visible ? tickOptions.length / 2 + tickOptions.shift : 0, 0);

    var radius = this.getRadius();
    var _this$_center = this._center,
        x = _this$_center.x,
        y = _this$_center.y;

    var labelBoxes = this._majorTicks.map(function (t) {
      return t.label && t.label.getBBox();
    }).filter(function (b) {
      return b;
    });

    var canvas = (0, _extend.extend)({}, this._canvas, {
      left: x - radius,
      top: y - radius,
      right: this._canvas.width - (x + radius),
      bottom: this._canvas.height - (y + radius)
    });
    var margins = (0, _axes_utils.calculateCanvasMargins)(labelBoxes, canvas);
    Object.keys(margins).forEach(function (k) {
      return margins[k] = margins[k] < tickOuterLength ? tickOuterLength : margins[k];
    });
    return margins;
  },
  _updateLabelsPosition: function _updateLabelsPosition() {
    var that = this;
    (0, _axes_utils.measureLabels)(that._majorTicks);

    that._adjustLabelsCoord(0, 0, true);

    that._checkBoundedLabelsOverlapping(this._majorTicks, this._majorTicks.map(function (t) {
      return t.labelBBox;
    }));
  },
  _setVisualRange: _common.noop,
  applyVisualRangeSetter: _common.noop,
  _getStick: function _getStick() {
    return this._options.firstPointOnStartAngle || this._options.type !== _axes_constants.default.discrete;
  },
  _getTranslatedCoord: function _getTranslatedCoord(value, offset) {
    return this._translator.translate(value, offset) - HALF_PI_ANGLE;
  },
  _getCanvasStartEnd: function _getCanvasStartEnd() {
    return {
      start: 0 - HALF_PI_ANGLE,
      end: 360 - HALF_PI_ANGLE
    };
  },
  _getStripGraphicAttributes: function _getStripGraphicAttributes(fromAngle, toAngle) {
    var center = this.getCenter();
    var angle = this.getAngles()[0];
    var r = this.getRadius();
    return {
      x: center.x,
      y: center.y,
      innerRadius: 0,
      outerRadius: r,
      startAngle: -toAngle - angle,
      endAngle: -fromAngle - angle
    };
  },
  _createStrip: function _createStrip(coords) {
    return this._renderer.arc(coords.x, coords.y, coords.innerRadius, coords.outerRadius, coords.startAngle, coords.endAngle);
  },
  _getStripLabelCoords: function _getStripLabelCoords(from, to) {
    var that = this;

    var coords = that._getStripGraphicAttributes(from, to);

    var angle = coords.startAngle + (coords.endAngle - coords.startAngle) / 2;
    var cosSin = (0, _utils.getCosAndSin)(angle);
    var halfRad = that.getRadius() / 2;
    var center = that.getCenter();
    var x = round(center.x + halfRad * cosSin.cos);
    var y = round(center.y - halfRad * cosSin.sin);
    return {
      x: x,
      y: y,
      align: _axes_constants.default.center
    };
  },
  _getConstantLineGraphicAttributes: function _getConstantLineGraphicAttributes(value) {
    var center = this.getCenter();
    var r = this.getRadius();
    return {
      points: [center.x, center.y, center.x + r, center.y]
    };
  },
  _createConstantLine: function _createConstantLine(value, attr) {
    return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr);
  },
  _rotateConstantLine: function _rotateConstantLine(line, value) {
    var _this$getCenter = this.getCenter(),
        x = _this$getCenter.x,
        y = _this$getCenter.y;

    line.rotate(value + this.getAngles()[0], x, y);
  },
  _getConstantLineLabelsCoords: function _getConstantLineLabelsCoords(value) {
    var that = this;
    var cosSin = (0, _utils.getCosAndSin)(-value - that.getAngles()[0]);
    var halfRad = that.getRadius() / 2;
    var center = that.getCenter();
    var x = round(center.x + halfRad * cosSin.cos);
    var y = round(center.y - halfRad * cosSin.sin);
    return {
      x: x,
      y: y
    };
  },
  _checkAlignmentConstantLineLabels: _common.noop,
  _adjustDivisionFactor: function _adjustDivisionFactor(val) {
    return val * 180 / (this.getRadius() * PI);
  },
  _getScreenDelta: function _getScreenDelta() {
    var angles = this.getAngles();
    return abs(angles[0] - angles[1]);
  },
  _getTickMarkPoints: function _getTickMarkPoints(coords, length, _ref) {
    var _ref$shift = _ref.shift,
        shift = _ref$shift === void 0 ? 0 : _ref$shift;
    var center = this.getCenter();
    var corrections = {
      inside: -1,
      center: -0.5,
      outside: 0
    };
    var radiusWithTicks = this.getRadius() + length * corrections[this._options.tickOrientation || 'center'];
    return [center.x + radiusWithTicks + shift, center.y, center.x + radiusWithTicks + length + shift, center.y];
  },
  _getLabelAdjustedCoord: function _getLabelAdjustedCoord(tick, _offset, _maxWidth, checkCanvas) {
    var that = this;
    var labelCoords = tick.labelCoords;
    var labelY = labelCoords.y;
    var labelAngle = labelCoords.angle;
    var cosSin = (0, _utils.getCosAndSin)(labelAngle);
    var cos = cosSin.cos;
    var sin = cosSin.sin;
    var box = tick.labelBBox;
    var halfWidth = box.width / 2;
    var halfHeight = box.height / 2;
    var indentFromAxis = that._options.label.indentFromAxis || 0;
    var x = labelCoords.x + indentFromAxis * cos;
    var y = labelY + (labelY - box.y - halfHeight) + indentFromAxis * sin;
    var shiftX = 0;
    var shiftY = 0;

    switch (getPolarQuarter(labelAngle)) {
      case 1:
        shiftX = halfWidth;
        shiftY = halfHeight * sin;
        break;

      case 2:
        shiftX = halfWidth * cos;
        shiftY = halfHeight;
        break;

      case 3:
        shiftX = -halfWidth;
        shiftY = halfHeight * sin;
        break;

      case 4:
        shiftX = halfWidth * cos;
        shiftY = -halfHeight;
        break;
    }

    if (checkCanvas) {
      var canvas = that._canvas;
      var boxShiftX = x - labelCoords.x + shiftX;
      var boxShiftY = y - labelCoords.y + shiftY;

      if (box.x + boxShiftX < canvas.originalLeft) {
        shiftX -= box.x + boxShiftX - canvas.originalLeft;
      }

      if (box.x + box.width + boxShiftX > canvas.width - canvas.originalRight) {
        shiftX -= box.x + box.width + boxShiftX - (canvas.width - canvas.originalRight);
      }

      if (box.y + boxShiftY < canvas.originalTop) {
        shiftY -= box.y + boxShiftY - canvas.originalTop;
      }

      if (box.y + box.height + boxShiftY > canvas.height - canvas.originalBottom) {
        shiftY -= box.y + box.height + boxShiftY - (canvas.height - canvas.originalBottom);
      }
    }

    return {
      x: x + shiftX,
      y: y + shiftY
    };
  },
  _getGridLineDrawer: function _getGridLineDrawer() {
    var that = this;
    return function (tick, gridStyle) {
      var center = that.getCenter();
      return that._createPathElement(that._getGridPoints().points, gridStyle).rotate(tick.coords.angle, center.x, center.y);
    };
  },
  _getGridPoints: function _getGridPoints() {
    var r = this.getRadius();
    var center = this.getCenter();
    return {
      points: [center.x, center.y, center.x + r, center.y]
    };
  },
  _getTranslatedValue: function _getTranslatedValue(value, offset) {
    var startAngle = this.getAngles()[0];

    var angle = this._translator.translate(value, -offset);

    var coords = (0, _utils.convertPolarToXY)(this.getCenter(), startAngle, angle, this.getRadius());
    return {
      x: coords.x,
      y: coords.y,
      angle: this.getTranslatedAngle(angle)
    };
  },
  _getAdjustedStripLabelCoords: function _getAdjustedStripLabelCoords(strip) {
    var box = strip.labelBBox;
    return {
      translateY: strip.label.attr('y') - box.y - box.height / 2
    };
  },
  coordsIn: function coordsIn(x, y) {
    return (0, _utils.convertXYToPolar)(this.getCenter(), x, y).r > this.getRadius();
  },
  _rotateTick: function _rotateTick(element, coords) {
    var center = this.getCenter();
    element.rotate(coords.angle, center.x, center.y);
  },
  _validateOverlappingMode: function _validateOverlappingMode(mode) {
    return _axes_constants.default.validateOverlappingMode(mode);
  },
  _validateDisplayMode: function _validateDisplayMode() {
    return 'standard';
  },
  _getStep: function _getStep(boxes) {
    var that = this;
    var radius = that.getRadius() + (that._options.label.indentFromAxis || 0);
    var maxLabelBox = boxes.reduce(function (prevValue, box) {
      var curValue = prevValue;

      if (prevValue.width < box.width) {
        curValue.width = box.width;
      }

      if (prevValue.height < box.height) {
        curValue.height = box.height;
      }

      return curValue;
    }, {
      width: 0,
      height: 0
    });
    var angle1 = abs(2 * atan(maxLabelBox.height / (2 * radius - maxLabelBox.width)) * 180 / PI);
    var angle2 = abs(2 * atan(maxLabelBox.width / (2 * radius - maxLabelBox.height)) * 180 / PI);
    return _axes_constants.default.getTicksCountInRange(that._majorTicks, 'angle', _max(angle1, angle2));
  },
  _checkBoundedLabelsOverlapping: function _checkBoundedLabelsOverlapping(majorTicks, boxes, mode) {
    var labelOpt = this._options.label;
    mode = mode || this._validateOverlappingMode(labelOpt.overlappingBehavior);

    if (mode !== 'hide') {
      return;
    }

    var lastVisibleLabelIndex = majorTicks.reduce(function (lastVisibleLabelIndex, tick, index) {
      return tick.label ? index : lastVisibleLabelIndex;
    }, null);

    if (!lastVisibleLabelIndex) {
      return;
    }

    if (_axes_constants.default.areLabelsOverlap(boxes[0], boxes[lastVisibleLabelIndex], labelOpt.minSpacing, _axes_constants.default.center)) {
      labelOpt.hideFirstOrLast === 'first' ? majorTicks[0].removeLabel() : majorTicks[lastVisibleLabelIndex].removeLabel();
    }
  },
  shift: function shift(margins) {
    this._axisGroup.attr({
      translateX: margins.right,
      translateY: margins.bottom
    });

    this._axisElementsGroup.attr({
      translateX: margins.right,
      translateY: margins.bottom
    });
  },
  getTranslatedAngle: function getTranslatedAngle(angle) {
    var startAngle = this.getAngles()[0];
    return angle + startAngle - HALF_PI_ANGLE;
  }
};
var circular = circularAxes;
exports.circular = circular;
var circularSpider = (0, _extend.extend)({}, circularAxes, {
  _createAxisElement: function _createAxisElement() {
    return this._renderer.path([], 'area');
  },
  _updateAxisElementPosition: function _updateAxisElementPosition() {
    this._axisElement.attr({
      points: (0, _utils.map)(this.getSpiderTicks(), function (tick) {
        return {
          x: tick.coords.x,
          y: tick.coords.y
        };
      })
    });
  },
  _getStick: function _getStick() {
    return true;
  },
  _getSpiderCategoryOption: function _getSpiderCategoryOption() {
    return true;
  },
  getSpiderTicks: function getSpiderTicks() {
    var that = this;
    var ticks = that.getFullTicks();
    that._spiderTicks = ticks.map((0, _tick.tick)(that, that.renderer, {}, {}, that._getSkippedCategory(ticks), true));

    that._spiderTicks.forEach(function (tick) {
      tick.initCoords();
    });

    return that._spiderTicks;
  },
  _getStripGraphicAttributes: function _getStripGraphicAttributes(fromAngle, toAngle) {
    var center = this.getCenter();
    var spiderTicks = this.getSpiderTicks();
    var firstTick;
    var lastTick;
    var nextTick;
    var tick;
    var points = [];
    var i = 0;
    var len = spiderTicks.length;

    while (i < len) {
      tick = spiderTicks[i].coords;

      if (tick.angle >= fromAngle && tick.angle <= toAngle) {
        if (!firstTick) {
          firstTick = (spiderTicks[i - 1] || spiderTicks[spiderTicks.length - 1]).coords;
          points.push((tick.x + firstTick.x) / 2, (tick.y + firstTick.y) / 2);
        }

        points.push(tick.x, tick.y);
        nextTick = (spiderTicks[i + 1] || spiderTicks[0]).coords;
        lastTick = {
          x: (tick.x + nextTick.x) / 2,
          y: (tick.y + nextTick.y) / 2
        };
      }

      i++;
    }

    points.push(lastTick.x, lastTick.y);
    points.push(center.x, center.y);
    return {
      points: points
    };
  },
  _createStrip: function _createStrip(_ref2) {
    var points = _ref2.points;
    return this._renderer.path(points, 'area');
  },
  _getTranslatedCoord: function _getTranslatedCoord(value, offset) {
    return this._translator.translate(value, offset) - HALF_PI_ANGLE;
  },
  _setTickOffset: function _setTickOffset() {
    this._tickOffset = false;
  }
});
exports.circularSpider = circularSpider;
var linear = {
  _resetMargins: function _resetMargins() {
    this._reinitTranslator(this._getViewportRange());
  },
  _getStick: xyAxesLinear._getStick,
  _getSpiderCategoryOption: _common.noop,
  _getTranslatorOptions: function _getTranslatorOptions() {
    return {
      isHorizontal: true,
      stick: this._getStick()
    };
  },
  getRadius: circularAxes.getRadius,
  getCenter: circularAxes.getCenter,
  getAngles: circularAxes.getAngles,
  _updateRadius: circularAxes._updateRadius,
  _updateCenter: circularAxes._updateCenter,
  _processCanvas: function _processCanvas(canvas) {
    this._updateRadius(canvas);

    this._updateCenter(canvas);

    return {
      left: 0,
      right: 0,
      startPadding: canvas.startPadding,
      endPadding: canvas.endPadding,
      width: this.getRadius()
    };
  },
  _createAxisElement: xyAxesLinear._createAxisElement,
  _updateAxisElementPosition: function _updateAxisElementPosition() {
    var centerCoord = this.getCenter();

    this._axisElement.attr({
      points: [centerCoord.x, centerCoord.y, centerCoord.x + this.getRadius(), centerCoord.y]
    }).rotate(this.getAngles()[0] - HALF_PI_ANGLE, centerCoord.x, centerCoord.y);
  },
  _getScreenDelta: function _getScreenDelta() {
    return this.getRadius();
  },
  _getTickMarkPoints: function _getTickMarkPoints(coords, length) {
    return [coords.x - length / 2, coords.y, coords.x + length / 2, coords.y];
  },
  _getLabelAdjustedCoord: function _getLabelAdjustedCoord(tick) {
    var that = this;
    var labelCoords = tick.labelCoords;
    var labelY = labelCoords.y;
    var cosSin = (0, _utils.getCosAndSin)(labelCoords.angle);
    var indentFromAxis = that._options.label.indentFromAxis || 0;
    var box = tick.labelBBox;
    var x = labelCoords.x - abs(indentFromAxis * cosSin.sin) + abs(box.width / 2 * cosSin.cos) - box.width / 2;
    var y = labelY + (labelY - box.y) - abs(box.height / 2 * cosSin.sin) + abs(indentFromAxis * cosSin.cos);
    return {
      x: x,
      y: y
    };
  },
  _getGridLineDrawer: function _getGridLineDrawer() {
    var that = this;
    return function (tick, gridStyle) {
      var grid = that._getGridPoints(tick.coords);

      return that._renderer.circle(grid.cx, grid.cy, grid.r).attr(gridStyle).sharp();
    };
  },
  _getGridPoints: function _getGridPoints(coords) {
    var pos = this.getCenter();
    var radius = (0, _utils.getDistance)(pos.x, pos.y, coords.x, coords.y);

    if (radius > this.getRadius()) {
      return {
        cx: null,
        cy: null,
        r: null
      };
    }

    return {
      cx: pos.x,
      cy: pos.y,
      r: radius
    };
  },
  _getTranslatedValue: function _getTranslatedValue(value, offset) {
    var startAngle = this.getAngles()[0];
    var xy = (0, _utils.convertPolarToXY)(this.getCenter(), startAngle, 0, this._translator.translate(value, offset));
    return {
      x: xy.x,
      y: xy.y,
      angle: startAngle - HALF_PI_ANGLE
    };
  },
  _getTranslatedCoord: function _getTranslatedCoord(value, offset) {
    return this._translator.translate(value, offset);
  },
  _getCanvasStartEnd: function _getCanvasStartEnd() {
    var invert = this.getTranslator().getBusinessRange().invert;
    var coords = [0, this.getRadius()];
    invert && coords.reverse();
    return {
      start: coords[0],
      end: coords[1]
    };
  },
  _getStripGraphicAttributes: function _getStripGraphicAttributes(fromPoint, toPoint) {
    var center = this.getCenter();
    return {
      x: center.x,
      y: center.y,
      innerRadius: fromPoint,
      outerRadius: toPoint
    };
  },
  _createStrip: function _createStrip(attrs) {
    return this._renderer.arc(attrs.x, attrs.y, attrs.innerRadius, attrs.outerRadius, 0, 360);
  },
  _getAdjustedStripLabelCoords: circularAxes._getAdjustedStripLabelCoords,
  _getStripLabelCoords: function _getStripLabelCoords(from, to) {
    var that = this;
    var labelPos = from + (to - from) / 2;
    var center = that.getCenter();
    var y = round(center.y - labelPos);
    return {
      x: center.x,
      y: y,
      align: _axes_constants.default.center
    };
  },
  _getConstantLineGraphicAttributes: function _getConstantLineGraphicAttributes(value) {
    var center = this.getCenter();
    return {
      cx: center.x,
      cy: center.y,
      r: value
    };
  },
  _createConstantLine: function _createConstantLine(value, attr) {
    var attrs = this._getConstantLineGraphicAttributes(value);

    return this._renderer.circle(attrs.cx, attrs.cy, attrs.r).attr(attr).sharp();
  },
  _getConstantLineLabelsCoords: function _getConstantLineLabelsCoords(value) {
    var that = this;
    var center = that.getCenter();
    var y = round(center.y - value);
    return {
      x: center.x,
      y: y
    };
  },
  _checkAlignmentConstantLineLabels: _common.noop,
  _rotateTick: function _rotateTick(element, coords, isGridLine) {
    !isGridLine && element.rotate(coords.angle + HALF_PI_ANGLE, coords.x, coords.y);
  },
  _validateOverlappingMode: circularAxes._validateOverlappingMode,
  _validateDisplayMode: circularAxes._validateDisplayMode,
  _getStep: function _getStep(boxes) {
    var quarter = getPolarQuarter(this.getAngles()[0]);
    var spacing = this._options.label.minSpacing;
    var func = quarter === 2 || quarter === 4 ? function (box) {
      return box.width + spacing;
    } : function (box) {
      return box.height;
    };
    var maxLabelLength = boxes.reduce(function (prevValue, box) {
      return _max(prevValue, func(box));
    }, 0);
    return _axes_constants.default.getTicksCountInRange(this._majorTicks, quarter === 2 || quarter === 4 ? 'x' : 'y', maxLabelLength);
  }
};
exports.linear = linear;
var linearSpider = (0, _extend.extend)({}, linear, {
  _createPathElement: function _createPathElement(points, attr) {
    return this._renderer.path(points, 'area').attr(attr).sharp();
  },
  setSpiderTicks: function setSpiderTicks(ticks) {
    this._spiderTicks = ticks;
  },
  _getGridLineDrawer: function _getGridLineDrawer() {
    var that = this;
    return function (tick, gridStyle) {
      return that._createPathElement(that._getGridPoints(tick.coords).points, gridStyle);
    };
  },
  _getGridPoints: function _getGridPoints(coords) {
    var pos = this.getCenter();
    var radius = (0, _utils.getDistance)(pos.x, pos.y, coords.x, coords.y);
    return this._getGridPointsByRadius(radius);
  },
  _getGridPointsByRadius: function _getGridPointsByRadius(radius) {
    var pos = this.getCenter();

    if (radius > this.getRadius()) {
      return {
        points: null
      };
    }

    return {
      points: (0, _utils.map)(this._spiderTicks, function (tick) {
        var cosSin = (0, _utils.getCosAndSin)(tick.coords.angle);
        return {
          x: round(pos.x + radius * cosSin.cos),
          y: round(pos.y + radius * cosSin.sin)
        };
      })
    };
  },
  _getStripGraphicAttributes: function _getStripGraphicAttributes(fromPoint, toPoint) {
    var innerPoints = this._getGridPointsByRadius(toPoint).points;

    var outerPoints = this._getGridPointsByRadius(fromPoint).points;

    return {
      points: [outerPoints, innerPoints.reverse()]
    };
  },
  _createStrip: circularSpider._createStrip,
  _getConstantLineGraphicAttributes: function _getConstantLineGraphicAttributes(value) {
    return this._getGridPointsByRadius(value);
  },
  _createConstantLine: function _createConstantLine(value, attr) {
    return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr);
  }
});
exports.linearSpider = linearSpider;

/***/ }),
/* 1062 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = createConstantLine;

var _type = __webpack_require__(1);

function createConstantLine(axis, options) {
  var labelOptions = options.label || {};
  var labelPosition = labelOptions.position || 'inside';
  var parsedValue;
  var valueIsParsed = false;
  var lastStoredCoordinates;

  axis._checkAlignmentConstantLineLabels(labelOptions);

  var storedCoord;
  return {
    options: options,
    labelOptions: labelOptions,
    labelPosition: labelPosition,
    label: null,
    line: null,
    getParsedValue: function getParsedValue() {
      if (!valueIsParsed) {
        parsedValue = axis.validateUnit(options.value, 'E2105', 'constantLine');
        valueIsParsed = true;
        return parsedValue;
      }

      return parsedValue;
    },
    draw: function draw() {
      if (!(0, _type.isDefined)(options.value) || axis._translator.getBusinessRange().isEmpty()) {
        return this;
      }

      var canvas = axis._getCanvasStartEnd();

      var parsedValue = this.getParsedValue();
      this.coord = axis._getConstantLinePos(parsedValue, canvas.start, canvas.end);
      var rootGroup = options.displayBehindSeries ? axis._axisConstantLineGroups.under : axis._axisConstantLineGroups.above;
      var group = rootGroup[labelPosition];

      if (!group) {
        var side = axis._isHorizontal ? labelOptions.verticalAlignment : labelOptions.horizontalAlignment;
        group = rootGroup[side];
      }

      if (!(0, _type.isDefined)(this.coord)) {
        return this;
      }

      var path = axis._createConstantLine(this.coord, {
        stroke: options.color,
        'stroke-width': options.width,
        dashStyle: options.dashStyle
      });

      this.line = path.append(rootGroup.inside);
      this.label = labelOptions.visible ? axis._drawConstantLineLabels(parsedValue, labelOptions, this.coord, group) : null;
      this.updatePosition();
      return this;
    },
    getContentContainer: function getContentContainer() {
      return this.label;
    },
    removeLabel: function removeLabel() {
      this.label && this.label.remove();
    },
    updatePosition: function updatePosition(animate) {
      var canvas = axis._getCanvasStartEnd();

      var coord = axis._getConstantLinePos(this.getParsedValue(), canvas.start, canvas.end);

      if (!(0, _type.isDefined)(coord)) {
        return;
      }

      this.coord = coord;

      if (animate && storedCoord) {
        this.label && this.label.attr(axis._getConstantLineLabelsCoords(storedCoord, this.labelOptions));
        this.line && this.line.attr(axis._getConstantLineGraphicAttributes(storedCoord));
        this.label && this.label.animate(axis._getConstantLineLabelsCoords(this.coord, this.labelOptions));
        this.line && this.line.animate(axis._getConstantLineGraphicAttributes(this.coord));
      } else {
        this.label && this.label.attr(axis._getConstantLineLabelsCoords(this.coord, this.labelOptions));
        this.line && this.line.attr(axis._getConstantLineGraphicAttributes(this.coord));

        axis._rotateConstantLine(this.line, this.coord);
      }
    },
    saveCoords: function saveCoords() {
      lastStoredCoordinates = storedCoord;
      storedCoord = this.coord;
    },
    resetCoordinates: function resetCoordinates() {
      storedCoord = lastStoredCoordinates;
    }
  };
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1063 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = createStrip;

var _type = __webpack_require__(1);

var _utils = __webpack_require__(14);

var _extend = __webpack_require__(0);

function createStrip(axis, options) {
  var storedCoord;
  var lastStoredCoordinates;
  var labelOptions = options.label || {};
  return {
    options: options,
    label: null,
    rect: null,
    _getCoord: function _getCoord() {
      var canvas = axis._getCanvasStartEnd();

      var range = axis._translator.getBusinessRange();

      return axis._getStripPos(options.startValue, options.endValue, canvas.start, canvas.end, range);
    },
    _drawLabel: function _drawLabel(coords) {
      return axis._renderer.text(labelOptions.text, coords.x, coords.y).css((0, _utils.patchFontOptions)((0, _extend.extend)({}, axis.getOptions().label.font, labelOptions.font))).attr({
        align: 'center',
        'class': labelOptions.cssClass
      }).append(axis._axisStripLabelGroup);
    },
    draw: function draw() {
      if (axis._translator.getBusinessRange().isEmpty()) {
        return;
      }

      if (((0, _type.isDefined)(options.startValue) || (0, _type.isDefined)(options.endValue)) && (0, _type.isDefined)(options.color)) {
        var stripPos = this._getCoord();

        this.labelCoords = labelOptions.text ? axis._getStripLabelCoords(stripPos.from, stripPos.to, labelOptions) : null;

        if (stripPos.outOfCanvas || !(0, _type.isDefined)(stripPos.to) || !(0, _type.isDefined)(stripPos.from)) {
          return;
        }

        this.rect = axis._createStrip(axis._getStripGraphicAttributes(stripPos.from, stripPos.to)).attr({
          fill: options.color
        }).append(axis._axisStripGroup);
        this.label = labelOptions.text ? this._drawLabel(this.labelCoords) : null;
      }
    },
    getContentContainer: function getContentContainer() {
      return this.label;
    },
    removeLabel: function removeLabel() {},
    updatePosition: function updatePosition(animate) {
      var stripPos = this._getCoord();

      if (animate && storedCoord) {
        this.label && this.label.attr(axis._getStripLabelCoords(storedCoord.from, storedCoord.to, options.label));
        this.rect && this.rect.attr(axis._getStripGraphicAttributes(storedCoord.from, storedCoord.to));
        this.label && this.label.animate(axis._getStripLabelCoords(stripPos.from, stripPos.to, options.label));
        this.rect && this.rect.animate(axis._getStripGraphicAttributes(stripPos.from, stripPos.to));
      } else {
        this.label && this.label.attr(axis._getStripLabelCoords(stripPos.from, stripPos.to, options.label));
        this.rect && this.rect.attr(axis._getStripGraphicAttributes(stripPos.from, stripPos.to));
      }
    },
    saveCoords: function saveCoords() {
      lastStoredCoordinates = storedCoord;
      storedCoord = this._getCoord();
    },
    resetCoordinates: function resetCoordinates() {
      storedCoord = lastStoredCoordinates;
    }
  };
}

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1064 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.ScrollBar = void 0;

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _index = __webpack_require__(8);

var _extend = __webpack_require__(0);

var _translator2d = __webpack_require__(350);

var _type = __webpack_require__(1);

var _common = __webpack_require__(4);

var _drag = __webpack_require__(78);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _min = Math.min;
var _max = Math.max;
var MIN_SCROLL_BAR_SIZE = 2;

var ScrollBar = function ScrollBar(renderer, group) {
  this._translator = new _translator2d.Translator2D({}, {}, {});
  this._scroll = renderer.rect().append(group);

  this._addEvents();
};

exports.ScrollBar = ScrollBar;

function _getXCoord(canvas, pos, offset, width) {
  var x = 0;

  if (pos === 'right') {
    x = canvas.width - canvas.right + offset;
  } else if (pos === 'left') {
    x = canvas.left - offset - width;
  }

  return x;
}

function _getYCoord(canvas, pos, offset, width) {
  var y = 0;

  if (pos === 'top') {
    y = canvas.top - offset;
  } else if (pos === 'bottom') {
    y = canvas.height - canvas.bottom + width + offset;
  }

  return y;
}

ScrollBar.prototype = {
  _addEvents: function _addEvents() {
    var _this = this;

    var scrollElement = this._scroll.element;

    _events_engine.default.on(scrollElement, _drag.start, function (e) {
      (0, _index.fireEvent)({
        type: 'dxc-scroll-start',
        originalEvent: e,
        target: scrollElement
      });
    });

    _events_engine.default.on(scrollElement, _drag.move, function (e) {
      var dX = -e.offset.x * _this._scale;
      var dY = -e.offset.y * _this._scale;
      var lx = _this._offset - (_this._layoutOptions.vertical ? dY : dX) / _this._scale;

      _this._applyPosition(lx, lx + _this._translator.canvasLength / _this._scale);

      (0, _index.fireEvent)({
        type: 'dxc-scroll-move',
        originalEvent: e,
        target: scrollElement,
        offset: {
          x: dX,
          y: dY
        }
      });
    });

    _events_engine.default.on(scrollElement, _drag.end, function (e) {
      (0, _index.fireEvent)({
        type: 'dxc-scroll-end',
        originalEvent: e,
        target: scrollElement,
        offset: {
          x: -e.offset.x * _this._scale,
          y: -e.offset.y * _this._scale
        }
      });
    });
  },
  update: function update(options) {
    var that = this;
    var position = options.position;
    var isVertical = options.rotated;
    var defaultPosition = isVertical ? 'right' : 'top';
    var secondaryPosition = isVertical ? 'left' : 'bottom';

    if (position !== defaultPosition && position !== secondaryPosition) {
      position = defaultPosition;
    }

    that._scroll.attr({
      rotate: !options.rotated ? -90 : 0,
      rotateX: 0,
      rotateY: 0,
      fill: options.color,
      width: options.width,
      opacity: options.opacity
    });

    that._layoutOptions = {
      width: options.width,
      offset: options.offset,
      vertical: isVertical,
      position: position
    };
    return that;
  },
  init: function init(range, stick) {
    var that = this;
    var isDiscrete = range.axisType === 'discrete';
    that._translateWithOffset = isDiscrete && !stick && 1 || 0;

    that._translator.update((0, _extend.extend)({}, range, {
      minVisible: null,
      maxVisible: null,
      visibleCategories: null
    }, isDiscrete && {
      min: null,
      max: null
    } || {}), that._canvas, {
      isHorizontal: !that._layoutOptions.vertical,
      stick: stick
    });

    return that;
  },
  getOptions: function getOptions() {
    return this._layoutOptions;
  },
  setPane: function setPane(panes) {
    var position = this._layoutOptions.position;
    var pane;

    if (position === 'left' || position === 'top') {
      pane = panes[0];
    } else {
      pane = panes[panes.length - 1];
    }

    this.pane = pane.name;
    return this;
  },
  updateSize: function updateSize(canvas) {
    this._canvas = (0, _extend.extend)({}, canvas);
    var options = this._layoutOptions;
    var pos = options.position;
    var offset = options.offset;
    var width = options.width;

    this._scroll.attr({
      translateX: _getXCoord(canvas, pos, offset, width),
      translateY: _getYCoord(canvas, pos, offset, width)
    });
  },
  getMultipleAxesSpacing: function getMultipleAxesSpacing() {
    return 0;
  },
  estimateMargins: function estimateMargins() {
    return this.getMargins();
  },
  getMargins: function getMargins() {
    var options = this._layoutOptions;
    var margins = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    margins[options.position] = options.width + options.offset;
    return margins;
  },
  shift: function shift(margins) {
    var _that$_scroll$attr, _that$_scroll$attr2;

    var that = this;
    var options = that._layoutOptions;
    var side = options.position;
    var isVertical = options.vertical;
    var attr = {
      translateX: (_that$_scroll$attr = that._scroll.attr('translateX')) !== null && _that$_scroll$attr !== void 0 ? _that$_scroll$attr : 0,
      translateY: (_that$_scroll$attr2 = that._scroll.attr('translateY')) !== null && _that$_scroll$attr2 !== void 0 ? _that$_scroll$attr2 : 0
    };
    var shift = margins[side];
    attr[isVertical ? 'translateX' : 'translateY'] += (side === 'left' || side === 'top' ? -1 : 1) * shift;

    that._scroll.attr(attr);
  },
  // Axis like functions
  hideTitle: _common.noop,
  hideOuterElements: _common.noop,
  // Axis like functions
  setPosition: function setPosition(min, max) {
    var that = this;
    var translator = that._translator;
    var minPoint = (0, _type.isDefined)(min) ? translator.translate(min, -that._translateWithOffset) : translator.translate('canvas_position_start');
    var maxPoint = (0, _type.isDefined)(max) ? translator.translate(max, that._translateWithOffset) : translator.translate('canvas_position_end');
    that._offset = _min(minPoint, maxPoint);
    that._scale = translator.getScale(min, max);

    that._applyPosition(_min(minPoint, maxPoint), _max(minPoint, maxPoint));
  },
  customPositionIsAvailable: function customPositionIsAvailable() {
    return false;
  },
  dispose: function dispose() {
    this._scroll.dispose();

    this._scroll = this._translator = null;
  },
  _applyPosition: function _applyPosition(x1, x2) {
    var that = this;

    var visibleArea = that._translator.getCanvasVisibleArea();

    x1 = _max(x1, visibleArea.min);
    x1 = _min(x1, visibleArea.max);
    x2 = _min(x2, visibleArea.max);
    x2 = _max(x2, visibleArea.min);
    var height = Math.abs(x2 - x1);

    that._scroll.attr({
      y: x1,
      height: height < MIN_SCROLL_BAR_SIZE ? MIN_SCROLL_BAR_SIZE : height
    });
  }
};

/***/ }),
/* 1065 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _drag = __webpack_require__(78);

var SHUTTER_EVENTS_NS = '.shutter-zoom';
var DRAG_START_EVENT_NAME = _drag.start + SHUTTER_EVENTS_NS;
var DRAG_UPDATE_EVENT_NAME = _drag.move + SHUTTER_EVENTS_NS;
var DRAG_END_EVENT_NAME = _drag.end + SHUTTER_EVENTS_NS;

function getPointerCoord(rootOffset, canvas, rotated, e) {
  var coord = Math.floor(rotated ? e.pageY - rootOffset.top : e.pageX - rootOffset.left);
  var min = rotated ? canvas.y1 : canvas.x1;
  var max = rotated ? canvas.y2 : canvas.x2;

  if (coord < min) {
    coord = min;
  } else if (coord > max) {
    coord = max;
  }

  return coord;
}

function checkCoords(rootOffset, canvas, e) {
  var x = e.pageX - rootOffset.left;
  var y = e.pageY - rootOffset.top;
  return x >= canvas.x1 && x <= canvas.x2 && y >= canvas.y1 && y <= canvas.y2;
}

function dragStartHandler(ctx) {
  return function (e) {
    var offset = ctx.getRootOffset();
    var canvas = ctx.getCanvas();

    if (!checkCoords(offset, canvas, e)) {
      e.cancel = true;
      return;
    }

    ctx.rootOffset = offset;
    ctx.canvas = canvas;
    ctx.startCoord = getPointerCoord(offset, canvas, ctx.rotated, e);
    ctx.triggerStart();
    ctx.rect.attr({
      x: canvas.x1,
      y: canvas.y1,
      width: canvas.width,
      height: canvas.height
    }).append(ctx.root);
  };
}

function dragHandler(ctx) {
  return function (e) {
    var curCoord = getPointerCoord(ctx.rootOffset, ctx.canvas, ctx.rotated, e);
    var attr = {};
    ctx.curCoord = curCoord;
    attr[ctx.rotated ? 'y' : 'x'] = Math.min(ctx.startCoord, curCoord);
    attr[ctx.rotated ? 'height' : 'width'] = Math.abs(ctx.startCoord - curCoord);
    ctx.rect.attr(attr);
  };
}

function dragEndHandler(ctx) {
  return function (e) {
    ctx.triggerEnd();
    ctx.rect.remove();
  };
}

function shutterZoom(options) {
  var chart = options.chart;
  var renderer = options.renderer;
  var rotated = options.rotated;
  var rect = renderer.rect(0, 0, 0, 0).attr(options.shutterOptions);
  var shutter = {
    rect: rect,
    root: renderer.root,
    rotated: rotated,
    triggerStart: function triggerStart() {
      chart._eventTrigger('zoomStart');
    },
    triggerEnd: function triggerEnd() {
      var tr = chart._argumentAxes[0].getTranslator();

      var rangeStart = Math.min(this.startCoord, this.curCoord);
      var rangeEnd = Math.max(this.startCoord, this.curCoord);

      chart._eventTrigger('zoomEnd', {
        rangeStart: tr.from(rangeStart),
        rangeEnd: tr.from(rangeEnd)
      });
    },
    dispose: function dispose() {
      renderer.root.off(SHUTTER_EVENTS_NS);
      rect.dispose();
    },
    getRootOffset: function getRootOffset() {
      return renderer.getRootOffset();
    },
    getCanvas: function getCanvas() {
      var canvas = chart._canvas;
      var panes = chart.panes;
      var firstPane = panes[0].canvas;
      var lastPane = panes[panes.length - 1].canvas;
      return {
        x1: firstPane.left,
        y1: firstPane.top,
        x2: canvas.width - lastPane.right,
        y2: canvas.height - lastPane.bottom,
        width: canvas.width - firstPane.left - lastPane.right,
        height: canvas.height - firstPane.top - lastPane.bottom
      };
    }
  };
  renderer.root.off(SHUTTER_EVENTS_NS).on(DRAG_START_EVENT_NAME, {
    direction: rotated ? 'vertical' : 'horizontal',
    immediate: true
  }, dragStartHandler(shutter)).on(DRAG_UPDATE_EVENT_NAME, dragHandler(shutter)).on(DRAG_END_EVENT_NAME, dragEndHandler(shutter));
  return shutter;
}

var _default = {
  name: 'shutter_zoom',
  init: function init() {
    var options = this.option('shutterZoom') || {};

    if (!options.enabled) {
      return;
    }

    this._shutterZoom = shutterZoom({
      chart: this,
      renderer: this._renderer,
      rotated: this.option('rotated'),
      shutterOptions: options
    });
  },
  dispose: function dispose() {
    this._shutterZoom && this._shutterZoom.dispose();
  }
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1066 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.default = void 0;

var _type = __webpack_require__(1);

var _extend = __webpack_require__(0);

var _utils = __webpack_require__(14);

var _wheel = __webpack_require__(149);

var transformEvents = _interopRequireWildcard(__webpack_require__(286));

var _drag = __webpack_require__(78);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var EVENTS_NS = '.zoomAndPanNS';
var DRAG_START_EVENT_NAME = _drag.start + EVENTS_NS;
var DRAG_EVENT_NAME = _drag.move + EVENTS_NS;
var DRAG_END_EVENT_NAME = _drag.end + EVENTS_NS;
var PINCH_START_EVENT_NAME = transformEvents['pinchstart'] + EVENTS_NS;
var PINCH_EVENT_NAME = transformEvents['pinch'] + EVENTS_NS;
var PINCH_END_EVENT_NAME = transformEvents['pinchend'] + EVENTS_NS;
var SCROLL_BAR_START_EVENT_NAME = 'dxc-scroll-start' + EVENTS_NS;
var SCROLL_BAR_MOVE_EVENT_NAME = 'dxc-scroll-move' + EVENTS_NS;
var SCROLL_BAR_END_EVENT_NAME = 'dxc-scroll-end' + EVENTS_NS;
var GESTURE_TIMEOUT = 300;
var MIN_DRAG_DELTA = 5;
var _min = Math.min;
var _max = Math.max;
var _abs = Math.abs;

function canvasToRect(canvas) {
  return {
    x: canvas.left,
    y: canvas.top,
    width: canvas.width - canvas.left - canvas.right,
    height: canvas.height - canvas.top - canvas.bottom
  };
}

function checkCoords(rect, coords) {
  var x = coords.x;
  var y = coords.y;
  return x >= rect.x && x <= rect.width + rect.x && y >= rect.y && y <= rect.height + rect.y;
}

function sortAxes(axes, onlyAxisToNotify) {
  if (onlyAxisToNotify) {
    axes = axes.sort(function (a, b) {
      if (a === onlyAxisToNotify) {
        return -1;
      }

      if (b === onlyAxisToNotify) {
        return 1;
      }

      return 0;
    });
  }

  return axes;
}

function isNotEmptyAxisBusinessRange(axis) {
  return !axis.getTranslator().getBusinessRange().isEmpty();
}

function axisZoom(axis, onlyAxisToNotify, getRange, getParameters, actionField, scale, e) {
  var silent = onlyAxisToNotify && axis !== onlyAxisToNotify;
  var range = getRange(axis);

  var _axis$checkZoomingLow = axis.checkZoomingLowerLimitOvercome(actionField, scale, range),
      stopInteraction = _axis$checkZoomingLow.stopInteraction,
      correctedRange = _axis$checkZoomingLow.correctedRange;

  var result = axis.handleZooming(stopInteraction ? null : correctedRange, getParameters(silent), e, actionField);
  stopInteraction && axis.handleZoomEnd();
  return {
    stopInteraction: stopInteraction,
    result: result
  };
}

var _default = {
  name: 'zoom_and_pan',
  init: function init() {
    var chart = this;
    var renderer = this._renderer;

    function cancelEvent(e) {
      if (e.originalEvent) {
        cancelEvent(e.originalEvent);
      }

      if (e.cancelable !== false) {
        e.cancel = true;
      }
    }

    function startAxesViewportChanging(zoomAndPan, actionField, e) {
      var options = zoomAndPan.options;
      var actionData = zoomAndPan.actionData;
      var axes = [];

      if (options.argumentAxis[actionField]) {
        axes.push(chart.getArgumentAxis());
      }

      if (options.valueAxis[actionField]) {
        axes = axes.concat(actionData.valueAxes);
      }

      axes.reduce(function (isPrevented, axis) {
        if (isPrevented) {
          return isPrevented;
        }

        if (isNotEmptyAxisBusinessRange(axis)) {
          return axis.handleZooming(null, {
            end: true
          }, e, actionField).isPrevented;
        }

        return isPrevented;
      }, false) && cancelEvent(e);
    }

    function axesViewportChanging(zoomAndPan, actionField, e, offsetCalc, centerCalc) {
      function zoomAxes(axes, criteria, coordField, e, actionData) {
        var zoom = {
          zoomed: false
        };
        criteria && axes.filter(isNotEmptyAxisBusinessRange).forEach(function (axis) {
          var options = axis.getOptions();
          var viewport = axis.visualRange();
          var scale = axis.getTranslator().getEventScale(e);
          var translate = -offsetCalc(e, actionData, coordField, scale);
          zoom = (0, _extend.extend)(true, zoom, axis.getTranslator().zoom(translate, scale, axis.getZoomBounds()));
          var range = axis.adjustRange((0, _utils.getVizRangeObject)([zoom.min, zoom.max]));

          var _axis$checkZoomingLow2 = axis.checkZoomingLowerLimitOvercome(actionField, scale, range),
              stopInteraction = _axis$checkZoomingLow2.stopInteraction,
              correctedRange = _axis$checkZoomingLow2.correctedRange;

          if (!(0, _type.isDefined)(viewport) || viewport.startValue.valueOf() !== correctedRange.startValue.valueOf() || viewport.endValue.valueOf() !== correctedRange.endValue.valueOf()) {
            axis.handleZooming(stopInteraction ? null : correctedRange, {
              start: true,
              end: true
            }, e, actionField);

            if (!stopInteraction) {
              zoom.zoomed = true;
              zoom.deltaTranslate = translate - zoom.translate;
            }
          } else if (e.pointerType === 'touch' && options.type === 'discrete') {
            var isMinPosition = axis.isExtremePosition(false);
            var isMaxPosition = axis.isExtremePosition(true);
            var zoomInEnabled = scale > 1 && !stopInteraction;
            var zoomOutEnabled = scale < 1 && (!isMinPosition || !isMaxPosition);
            var panningEnabled = scale === 1 && !(isMinPosition && (translate < 0 && !options.inverted || translate > 0 && options.inverted) || isMaxPosition && (translate > 0 && !options.inverted || translate < 0 && options.inverted));
            zoom.enabled = zoomInEnabled || zoomOutEnabled || panningEnabled;
          }
        });
        return zoom;
      }

      function storeOffset(e, actionData, zoom, coordField) {
        if (zoom.zoomed) {
          actionData.offset[coordField] = (e.offset ? e.offset[coordField] : actionData.offset[coordField]) + zoom.deltaTranslate;
        }
      }

      function storeCenter(center, actionData, zoom, coordField) {
        if (zoom.zoomed) {
          actionData.center[coordField] = center[coordField] + zoom.deltaTranslate;
        }
      }

      var rotated = chart.option('rotated');
      var actionData = zoomAndPan.actionData;
      var options = zoomAndPan.options;
      var argZoom = {};
      var valZoom = {};

      if (!actionData.fallback) {
        argZoom = zoomAxes(chart._argumentAxes, options.argumentAxis[actionField], rotated ? 'y' : 'x', e, actionData);
        valZoom = zoomAxes(actionData.valueAxes, options.valueAxis[actionField], rotated ? 'x' : 'y', e, actionData);

        chart._requestChange(['VISUAL_RANGE']);

        storeOffset(e, actionData, argZoom, rotated ? 'y' : 'x');
        storeOffset(e, actionData, valZoom, rotated ? 'x' : 'y');
      }

      var center = centerCalc(e);
      storeCenter(center, actionData, argZoom, rotated ? 'y' : 'x');
      storeCenter(center, actionData, valZoom, rotated ? 'x' : 'y');

      if (!argZoom.zoomed && !valZoom.zoomed) {
        actionData.center = center;
      }

      return argZoom.zoomed || valZoom.zoomed || actionData.fallback || argZoom.enabled || valZoom.enabled;
    }

    function finishAxesViewportChanging(zoomAndPan, actionField, e, offsetCalc) {
      function zoomAxes(axes, criteria, coordField, actionData, onlyAxisToNotify) {
        var zoomStarted = false;
        var scale = e.scale || 1;

        var getRange = function getRange(axis) {
          var zoom = axis.getTranslator().zoom(-offsetCalc(e, actionData, coordField, scale), scale, axis.getZoomBounds());
          return {
            startValue: zoom.min,
            endValue: zoom.max
          };
        };

        var getParameters = function getParameters(silent) {
          return {
            start: true,
            end: silent
          };
        };

        criteria && axes.forEach(function (axis) {
          zoomStarted = !axisZoom(axis, onlyAxisToNotify, getRange, getParameters, actionField, scale, e).stopInteraction;
        });
        return zoomStarted;
      }

      var rotated = chart.option('rotated');
      var actionData = zoomAndPan.actionData;
      var options = zoomAndPan.options;
      var zoomStarted = true;

      if (actionData.fallback) {
        zoomStarted &= zoomAxes(chart._argumentAxes, options.argumentAxis[actionField], rotated ? 'y' : 'x', actionData, chart.getArgumentAxis());
        zoomStarted |= zoomAxes(actionData.valueAxes, options.valueAxis[actionField], rotated ? 'x' : 'y', actionData);
      } else {
        var axes = [];

        if (options.argumentAxis[actionField]) {
          axes.push(chart.getArgumentAxis());
        }

        if (options.valueAxis[actionField]) {
          axes = axes.concat(actionData.valueAxes);
        }

        axes.filter(isNotEmptyAxisBusinessRange).forEach(function (axis) {
          axis.handleZooming(null, {
            start: true
          }, e, actionField);
        });
        zoomStarted = axes.length;
      }

      zoomStarted && chart._requestChange(['VISUAL_RANGE']);
    }

    function prepareActionData(coords, action) {
      var axes = chart._argumentAxes.filter(function (axis) {
        return checkCoords(canvasToRect(axis.getCanvas()), coords);
      });

      return {
        fallback: chart._lastRenderingTime > GESTURE_TIMEOUT,
        cancel: !axes.length || !(0, _type.isDefined)(action),
        action: action,
        curAxisRect: axes.length && canvasToRect(axes[0].getCanvas()),
        valueAxes: axes.length && chart._valueAxes.filter(function (axis) {
          return checkCoords(canvasToRect(axis.getCanvas()), coords);
        }),
        offset: {
          x: 0,
          y: 0
        },
        center: coords,
        startCenter: coords
      };
    }

    function getPointerCoord(rect, e) {
      var rootOffset = renderer.getRootOffset();
      return {
        x: _min(_max(e.pageX - rootOffset.left, rect.x), rect.width + rect.x),
        y: _min(_max(e.pageY - rootOffset.top, rect.y), rect.height + rect.y)
      };
    }

    function calcCenterForPinch(e) {
      var rootOffset = renderer.getRootOffset();
      var x1 = e.pointers[0].pageX;
      var x2 = e.pointers[1].pageX;
      var y1 = e.pointers[0].pageY;
      var y2 = e.pointers[1].pageY;
      return {
        x: _min(x1, x2) + _abs(x2 - x1) / 2 - rootOffset.left,
        y: _min(y1, y2) + _abs(y2 - y1) / 2 - rootOffset.top
      };
    }

    function calcCenterForDrag(e) {
      var rootOffset = renderer.getRootOffset();
      return {
        x: e.pageX - rootOffset.left,
        y: e.pageY - rootOffset.top
      };
    }

    function calcOffsetForDrag(e, actionData, coordField) {
      return e.offset[coordField] - actionData.offset[coordField];
    }

    function preventDefaults(e) {
      if (e.cancelable !== false) {
        e.preventDefault();
        e.stopPropagation();
      }

      chart._stopCurrentHandling();
    }

    var zoomAndPan = {
      dragStartHandler: function dragStartHandler(e) {
        var options = zoomAndPan.options;
        var isTouch = e.pointerType === 'touch';
        var wantPan = options.argumentAxis.pan || options.valueAxis.pan;
        var wantZoom = options.argumentAxis.zoom || options.valueAxis.zoom;
        var panKeyPressed = (0, _type.isDefined)(options.panKey) && e[(0, _utils.normalizeEnum)(options.panKey) + 'Key'];
        var dragToZoom = options.dragToZoom;
        var action;
        e._cancelPreventDefault = true;

        if (isTouch) {
          if (options.allowTouchGestures && wantPan) {
            var cancelPanning = !zoomAndPan.panningVisualRangeEnabled() || zoomAndPan.skipEvent;
            action = cancelPanning ? null : 'pan';
          }
        } else {
          if (dragToZoom && wantPan && panKeyPressed) {
            action = 'pan';
          } else if (!dragToZoom && wantPan) {
            action = 'pan';
          } else if (dragToZoom && wantZoom) {
            action = 'zoom';
          }
        }

        var actionData = prepareActionData(calcCenterForDrag(e), action);

        if (actionData.cancel) {
          zoomAndPan.skipEvent = false;

          if (e.cancelable !== false) {
            e.cancel = true;
          }

          return;
        }

        zoomAndPan.actionData = actionData;

        if (action === 'zoom') {
          actionData.startCoords = getPointerCoord(actionData.curAxisRect, e);
          actionData.rect = renderer.rect(0, 0, 0, 0).attr(options.dragBoxStyle).append(renderer.root);
        } else {
          startAxesViewportChanging(zoomAndPan, 'pan', e);
        }
      },
      dragHandler: function dragHandler(e) {
        var rotated = chart.option('rotated');
        var options = zoomAndPan.options;
        var actionData = zoomAndPan.actionData;
        var isTouch = e.pointerType === 'touch';
        e._cancelPreventDefault = true;

        if (!actionData || isTouch && !zoomAndPan.panningVisualRangeEnabled()) {
          return;
        }

        if (actionData.action === 'zoom') {
          preventDefaults(e);
          var curCanvas = actionData.curAxisRect;
          var startCoords = actionData.startCoords;
          var curCoords = getPointerCoord(curCanvas, e);
          var zoomArg = options.argumentAxis.zoom;
          var zoomVal = options.valueAxis.zoom;
          var rect = {
            x: _min(startCoords.x, curCoords.x),
            y: _min(startCoords.y, curCoords.y),
            width: _abs(startCoords.x - curCoords.x),
            height: _abs(startCoords.y - curCoords.y)
          };

          if (!zoomArg || !zoomVal) {
            if (!zoomArg && !rotated || !zoomVal && rotated) {
              rect.x = curCanvas.x;
              rect.width = curCanvas.width;
            } else {
              rect.y = curCanvas.y;
              rect.height = curCanvas.height;
            }
          }

          actionData.rect.attr(rect);
        } else if (actionData.action === 'pan') {
          axesViewportChanging(zoomAndPan, 'pan', e, calcOffsetForDrag, function (e) {
            return e.offset;
          });
          var deltaOffsetY = Math.abs(e.offset.y - actionData.offset.y);
          var deltaOffsetX = Math.abs(e.offset.x - actionData.offset.x);

          if (isTouch && (deltaOffsetY > MIN_DRAG_DELTA && deltaOffsetY > Math.abs(actionData.offset.x) || deltaOffsetX > MIN_DRAG_DELTA && deltaOffsetX > Math.abs(actionData.offset.y))) {
            return;
          }

          preventDefaults(e);
        }
      },
      dragEndHandler: function dragEndHandler(e) {
        var rotated = chart.option('rotated');
        var options = zoomAndPan.options;
        var actionData = zoomAndPan.actionData;
        var isTouch = e.pointerType === 'touch';
        var panIsEmpty = actionData && actionData.action === 'pan' && !actionData.fallback && actionData.offset.x === 0 && actionData.offset.y === 0;

        if (!actionData || isTouch && !zoomAndPan.panningVisualRangeEnabled() || panIsEmpty) {
          return;
        }

        (!isTouch || !zoomAndPan.actionData.isNative) && preventDefaults(e);

        if (actionData.action === 'zoom') {
          var zoomAxes = function zoomAxes(axes, criteria, coordField, startCoords, curCoords, onlyAxisToNotify) {
            axes = sortAxes(axes, onlyAxisToNotify);
            var curCoord = curCoords[coordField];
            var startCoord = startCoords[coordField];
            var zoomStarted = false;

            var getParameters = function getParameters(silent) {
              return {
                start: !!silent,
                end: !!silent
              };
            };

            if (criteria && _abs(curCoord - startCoord) > MIN_DRAG_DELTA) {
              axes.some(function (axis) {
                var tr = axis.getTranslator();

                if (tr.getBusinessRange().isEmpty()) {
                  return;
                }

                var getRange = function getRange() {
                  return [tr.from(startCoord), tr.from(curCoord)];
                };

                var _axisZoom = axisZoom(axis, onlyAxisToNotify, getRange, getParameters, actionData.action, tr.getMinScale(true), e),
                    stopInteraction = _axisZoom.stopInteraction,
                    result = _axisZoom.result;

                zoomStarted = !stopInteraction;
                return onlyAxisToNotify && result.isPrevented;
              });
            }

            return zoomStarted;
          };

          var curCoords = getPointerCoord(actionData.curAxisRect, e);
          var argumentAxesZoomed = zoomAxes(chart._argumentAxes, options.argumentAxis.zoom, rotated ? 'y' : 'x', actionData.startCoords, curCoords, chart.getArgumentAxis());
          var valueAxesZoomed = zoomAxes(actionData.valueAxes, options.valueAxis.zoom, rotated ? 'x' : 'y', actionData.startCoords, curCoords);

          if (valueAxesZoomed || argumentAxesZoomed) {
            chart._requestChange(['VISUAL_RANGE']);
          }

          actionData.rect.dispose();
        } else if (actionData.action === 'pan') {
          finishAxesViewportChanging(zoomAndPan, 'pan', e, calcOffsetForDrag);
        }

        zoomAndPan.actionData = null;
      },
      pinchStartHandler: function pinchStartHandler(e) {
        var actionData = prepareActionData(calcCenterForPinch(e), 'zoom');
        actionData.isNative = !zoomAndPan.panningVisualRangeEnabled();

        if (actionData.cancel) {
          cancelEvent(e);
          return;
        }

        zoomAndPan.actionData = actionData;
        startAxesViewportChanging(zoomAndPan, 'zoom', e);
      },
      pinchHandler: function pinchHandler(e) {
        if (!zoomAndPan.actionData) {
          return;
        }

        var viewportChanged = axesViewportChanging(zoomAndPan, 'zoom', e, function (e, actionData, coordField, scale) {
          return calcCenterForPinch(e)[coordField] - actionData.center[coordField] + (actionData.center[coordField] - actionData.center[coordField] * scale);
        }, calcCenterForPinch);
        zoomAndPan.defineTouchBehavior(!viewportChanged, e);
        !viewportChanged && (zoomAndPan.actionData = null);
      },
      pinchEndHandler: function pinchEndHandler(e) {
        if (!zoomAndPan.actionData) {
          return;
        }

        finishAxesViewportChanging(zoomAndPan, 'zoom', e, function (e, actionData, coordField, scale) {
          return actionData.center[coordField] - actionData.startCenter[coordField] + (actionData.startCenter[coordField] - actionData.startCenter[coordField] * scale);
        });
        zoomAndPan.actionData = null;
      },
      cleanup: function cleanup() {
        renderer.root.off(EVENTS_NS);
        zoomAndPan.actionData && zoomAndPan.actionData.rect && zoomAndPan.actionData.rect.dispose();
        zoomAndPan.actionData = null;
        renderer.root.css({
          'touch-action': '',
          '-ms-touch-action': ''
        });
      },
      setup: function setup(options) {
        zoomAndPan.cleanup();

        if (!options.argumentAxis.pan) {
          renderer.root.on(SCROLL_BAR_START_EVENT_NAME, cancelEvent);
        }

        if (options.argumentAxis.none && options.valueAxis.none) {
          return;
        }

        zoomAndPan.options = options;
        var rotated = chart.option('rotated');

        if ((options.argumentAxis.zoom || options.valueAxis.zoom) && options.allowMouseWheel) {
          renderer.root.on(_wheel.name + EVENTS_NS, function (e) {
            function zoomAxes(axes, coord, delta, onlyAxisToNotify) {
              axes = sortAxes(axes, onlyAxisToNotify);
              var zoomStarted = false;

              var getParameters = function getParameters(silent) {
                return {
                  start: !!silent,
                  end: !!silent
                };
              };

              axes.some(function (axis) {
                var translator = axis.getTranslator();

                if (translator.getBusinessRange().isEmpty()) {
                  return;
                }

                var scale = translator.getMinScale(delta > 0);

                var getRange = function getRange() {
                  var zoom = translator.zoom(-(coord - coord * scale), scale, axis.getZoomBounds());
                  return {
                    startValue: zoom.min,
                    endValue: zoom.max
                  };
                };

                var _axisZoom2 = axisZoom(axis, onlyAxisToNotify, getRange, getParameters, 'zoom', scale, e),
                    stopInteraction = _axisZoom2.stopInteraction,
                    result = _axisZoom2.result;

                zoomStarted = !stopInteraction;
                return onlyAxisToNotify && result.isPrevented;
              });
              return zoomStarted;
            }

            var coords = calcCenterForDrag(e);
            var axesZoomed = false;
            var targetAxes;

            if (options.valueAxis.zoom) {
              targetAxes = chart._valueAxes.filter(function (axis) {
                return checkCoords(canvasToRect(axis.getCanvas()), coords);
              });

              if (targetAxes.length === 0) {
                var targetCanvas = chart._valueAxes.reduce(function (r, axis) {
                  if (!r && axis.coordsIn(coords.x, coords.y)) {
                    r = axis.getCanvas();
                  }

                  return r;
                }, null);

                if (targetCanvas) {
                  targetAxes = chart._valueAxes.filter(function (axis) {
                    return checkCoords(canvasToRect(axis.getCanvas()), {
                      x: targetCanvas.left,
                      y: targetCanvas.top
                    });
                  });
                }
              }

              axesZoomed |= zoomAxes(targetAxes, rotated ? coords.x : coords.y, e.delta);
            }

            if (options.argumentAxis.zoom) {
              var canZoom = chart._argumentAxes.some(function (axis) {
                if (checkCoords(canvasToRect(axis.getCanvas()), coords) || axis.coordsIn(coords.x, coords.y)) {
                  return true;
                }

                return false;
              });

              axesZoomed |= canZoom && zoomAxes(chart._argumentAxes, rotated ? coords.y : coords.x, e.delta, chart.getArgumentAxis());
            }

            if (axesZoomed) {
              chart._requestChange(['VISUAL_RANGE']);

              zoomAndPan.panningVisualRangeEnabled(targetAxes) && preventDefaults(e); // T249548
            }
          });
        }

        if (options.allowTouchGestures) {
          if (options.argumentAxis.zoom || options.valueAxis.zoom) {
            renderer.root.on(PINCH_START_EVENT_NAME, {
              passive: false
            }, zoomAndPan.pinchStartHandler).on(PINCH_EVENT_NAME, {
              passive: false
            }, zoomAndPan.pinchHandler).on(PINCH_END_EVENT_NAME, zoomAndPan.pinchEndHandler);
          }
        }

        renderer.root.on(DRAG_START_EVENT_NAME, {
          immediate: true,
          passive: false
        }, zoomAndPan.dragStartHandler).on(DRAG_EVENT_NAME, {
          immediate: true,
          passive: false
        }, zoomAndPan.dragHandler).on(DRAG_END_EVENT_NAME, zoomAndPan.dragEndHandler);

        if (options.argumentAxis.pan) {
          renderer.root.on(SCROLL_BAR_START_EVENT_NAME, function (e) {
            zoomAndPan.actionData = {
              valueAxes: [],
              offset: {
                x: 0,
                y: 0
              },
              center: {
                x: 0,
                y: 0
              }
            };
            preventDefaults(e);
            startAxesViewportChanging(zoomAndPan, 'pan', e);
          }).on(SCROLL_BAR_MOVE_EVENT_NAME, function (e) {
            preventDefaults(e);
            axesViewportChanging(zoomAndPan, 'pan', e, calcOffsetForDrag, function (e) {
              return e.offset;
            });
          }).on(SCROLL_BAR_END_EVENT_NAME, function (e) {
            preventDefaults(e);
            finishAxesViewportChanging(zoomAndPan, 'pan', e, calcOffsetForDrag);
            zoomAndPan.actionData = null;
          });
        }
      },
      defineTouchBehavior: function defineTouchBehavior(isDefault, e) {
        zoomAndPan.actionData && (zoomAndPan.actionData.isNative = isDefault);

        if (!isDefault) {
          preventDefaults(e);
        }
      },
      panningVisualRangeEnabled: function panningVisualRangeEnabled(targetAxes) {
        if (targetAxes !== null && targetAxes !== void 0 && targetAxes.length) {
          return targetAxes.some(function (axis) {
            return !axis.isExtremePosition(false) || !axis.isExtremePosition(true);
          });
        }

        var enablePanByValueAxis = chart._valueAxes.some(function (axis) {
          return !axis.isExtremePosition(false) || !axis.isExtremePosition(true);
        });

        var enablePanByArgumentAxis = chart._argumentAxes.some(function (axis) {
          return !axis.isExtremePosition(false) || !axis.isExtremePosition(true);
        });

        return enablePanByValueAxis || enablePanByArgumentAxis;
      }
    };
    this._zoomAndPan = zoomAndPan;
  },
  members: {
    _setupZoomAndPan: function _setupZoomAndPan() {
      this._zoomAndPan.setup(this._themeManager.getOptions('zoomAndPan'));
    }
  },
  dispose: function dispose() {
    this._zoomAndPan.cleanup();
  },
  customize: function customize(constructor) {
    constructor.addChange({
      code: 'ZOOM_AND_PAN',
      handler: function handler() {
        this._setupZoomAndPan();
      },
      isThemeDependent: true,
      isOptionChange: true,
      option: 'zoomAndPan'
    });
  }
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1067 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _consts = _interopRequireDefault(__webpack_require__(161));

var _utils = __webpack_require__(14);

var _extend2 = __webpack_require__(0);

var _type = __webpack_require__(1);

var _iterator = __webpack_require__(3);

var _range = __webpack_require__(141);

var _component_registrator = _interopRequireDefault(__webpack_require__(9));

var _base_chart = __webpack_require__(342);

var _common = __webpack_require__(4);

var _translator1d = __webpack_require__(601);

var _annotations = __webpack_require__(244);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var states = _consts.default.states;
var seriesSpacing = _consts.default.pieSeriesSpacing;
var OPTIONS_FOR_REFRESH_SERIES = ['startAngle', 'innerRadius', 'segmentsDirection', 'type'];
var NORMAL_STATE = states.normalMark;
var HOVER_STATE = states.hoverMark;
var SELECTED_STATE = states.selectedMark;
var MAX_RESOLVE_ITERATION_COUNT = 5;
var LEGEND_ACTIONS = [states.resetItem, states.applyHover, states.applySelected, states.applySelected];

function getLegendItemAction(points) {
  var state = NORMAL_STATE;
  points.forEach(function (point) {
    var _point$series;

    var seriesOptions = (_point$series = point.series) === null || _point$series === void 0 ? void 0 : _point$series.getOptions();
    var pointState = point.fullState;

    if ((seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.hoverMode) === 'none') {
      pointState &= ~HOVER_STATE;
    }

    if ((seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.selectionMode) === 'none') {
      pointState &= ~SELECTED_STATE;
    }

    state = state | pointState;
  });
  return LEGEND_ACTIONS[state];
}

function correctPercentValue(value) {
  if ((0, _type.isNumeric)(value)) {
    if (value > 1) {
      value = 1;
    } else if (value < 0) {
      value = 0;
    }
  } else {
    value = undefined;
  }

  return value;
}

var pieSizeEqualizer = function () {
  function equalize(group, allPies) {
    var pies = allPies.filter(function (p) {
      return p._isVisible() && p.getSizeGroup() === group;
    });
    var minRadius = Math.min.apply(null, pies.map(function (p) {
      return p.getSizeGroupLayout().radius;
    }));
    var minPie = pies.filter(function (p) {
      return p.getSizeGroupLayout().radius === minRadius;
    });
    pies.forEach(function (p) {
      return p.render({
        force: true,
        sizeGroupLayout: minPie.length ? minPie[0].getSizeGroupLayout() : {}
      });
    });
  }

  function removeFromList(list, item) {
    return list.filter(function (li) {
      return li !== item;
    });
  }

  function addToList(list, item) {
    return removeFromList(list, item).concat(item);
  }

  var pies = [];
  var timers = {};
  return {
    queue: function queue(pie) {
      var group = pie.getSizeGroup();
      pies = addToList(pies, pie);
      clearTimeout(timers[group]);
      timers[group] = setTimeout(function () {
        equalize(group, pies);
      });
    },
    remove: function remove(pie) {
      pies = removeFromList(pies, pie);

      if (!pies.length) {
        timers = {};
      }
    }
  };
}();

var dxPieChart = _base_chart.BaseChart.inherit({
  _themeSection: 'pie',
  _layoutManagerOptions: function _layoutManagerOptions() {
    return (0, _extend2.extend)(true, {}, this.callBase(), {
      piePercentage: correctPercentValue(this._themeManager.getOptions('diameter')),
      minPiePercentage: correctPercentValue(this._themeManager.getOptions('minDiameter'))
    });
  },
  _optionChangesOrder: ['CENTER_TEMPLATE'],
  _optionChangesMap: {
    diameter: 'REINIT',
    minDiameter: 'REINIT',
    sizeGroup: 'REINIT',
    centerTemplate: 'CENTER_TEMPLATE'
  },
  _change_CENTER_TEMPLATE: function _change_CENTER_TEMPLATE() {
    this._renderExtraElements();
  },
  _disposeCore: function _disposeCore() {
    pieSizeEqualizer.remove(this);
    this.callBase();

    this._centerTemplateGroup.linkOff().dispose();
  },
  _groupSeries: function _groupSeries() {
    var series = this.series;
    this._groupsData = {
      groups: [{
        series: series,
        valueOptions: {
          valueType: 'numeric'
        }
      }],
      argumentOptions: series[0] && series[0].getOptions()
    };
  },
  getArgumentAxis: function getArgumentAxis() {
    return null;
  },
  _getValueAxis: function _getValueAxis() {
    var translator = new _translator1d.Translator1D().setCodomain(360, 0);
    return {
      getTranslator: function getTranslator() {
        return translator;
      },
      setBusinessRange: function setBusinessRange(range) {
        translator.setDomain(range.min, range.max);
      }
    };
  },
  _populateBusinessRange: function _populateBusinessRange() {
    this.series.map(function (series) {
      var range = new _range.Range();
      range.addRange(series.getRangeData().val);
      series.getValueAxis().setBusinessRange(range);
      return range;
    });
  },
  _specialProcessSeries: function _specialProcessSeries() {
    (0, _iterator.each)(this.series, function (_, singleSeries) {
      singleSeries.arrangePoints();
    });
  },
  _checkPaneName: function _checkPaneName() {
    return true;
  },
  _processSingleSeries: function _processSingleSeries(singleSeries) {
    this.callBase(singleSeries);
    singleSeries.arrangePoints();
  },
  _handleSeriesDataUpdated: function _handleSeriesDataUpdated() {
    var maxPointCount = 0;
    this.series.forEach(function (s) {
      maxPointCount = Math.max(s.getPointsCount(), maxPointCount);
    });
    this.series.forEach(function (s) {
      s.setMaxPointsCount(maxPointCount);
    });
    this.callBase();
  },
  _getLegendOptions: function _getLegendOptions(item) {
    var legendItem = this.callBase(item);
    var legendData = legendItem.legendData;
    legendData.argument = item.argument;
    legendData.argumentIndex = item.argumentIndex;
    legendData.points = [item];
    return legendItem;
  },
  _getLegendTargets: function _getLegendTargets() {
    var that = this;
    var itemsByArgument = {};
    (that.series || []).forEach(function (series) {
      series.getPoints().forEach(function (point) {
        var argument = point.argument.valueOf();
        var index = series.getPointsByArg(argument).indexOf(point);
        var key = argument.valueOf().toString() + index;
        itemsByArgument[key] = itemsByArgument[key] || [];
        var argumentCount = itemsByArgument[key].push(point);
        point.index = itemsByArgument[key][argumentCount - 2] ? itemsByArgument[key][argumentCount - 2].index : Object.keys(itemsByArgument).length - 1;
        point.argumentIndex = index;
      });
    });
    var items = [];
    (0, _iterator.each)(itemsByArgument, function (_, points) {
      points.forEach(function (point, index) {
        if (index === 0) {
          items.push(that._getLegendOptions(point));
          return;
        }

        var item = items[items.length - 1];
        item.legendData.points.push(point);

        if (!item.visible) {
          item.visible = point.isVisible();
        }
      });
    });
    return items;
  },
  _getLayoutTargets: function _getLayoutTargets() {
    return [{
      canvas: this._canvas
    }];
  },
  _getLayoutSeries: function _getLayoutSeries(series, drawOptions) {
    var that = this;
    var layout;
    var canvas = that._canvas;
    var drawnLabels = false;
    layout = that.layoutManager.applyPieChartSeriesLayout(canvas, series, true);
    series.forEach(function (singleSeries) {
      singleSeries.correctPosition(layout, canvas);
      drawnLabels = singleSeries.drawLabelsWOPoints() || drawnLabels;
    });

    if (drawnLabels) {
      layout = that.layoutManager.applyPieChartSeriesLayout(canvas, series, drawOptions.hideLayoutLabels);
    }

    series.forEach(function (singleSeries) {
      singleSeries.hideLabels();
    });
    that._sizeGroupLayout = {
      x: layout.centerX,
      y: layout.centerY,
      radius: layout.radiusOuter,
      drawOptions: drawOptions
    };
    return layout;
  },
  _getLayoutSeriesForEqualPies: function _getLayoutSeriesForEqualPies(series, sizeGroupLayout) {
    var canvas = this._canvas;
    var layout = this.layoutManager.applyEqualPieChartLayout(series, sizeGroupLayout);
    series.forEach(function (s) {
      s.correctPosition(layout, canvas);
      s.drawLabelsWOPoints();
    });
    this.layoutManager.correctPieLabelRadius(series, layout, canvas);
    return layout;
  },
  _updateSeriesDimensions: function _updateSeriesDimensions(drawOptions) {
    var that = this;

    var visibleSeries = that._getVisibleSeries();

    var lengthVisibleSeries = visibleSeries.length;
    var innerRad;
    var delta;
    var layout;
    var sizeGroupLayout = drawOptions.sizeGroupLayout;

    if (lengthVisibleSeries) {
      layout = sizeGroupLayout ? that._getLayoutSeriesForEqualPies(visibleSeries, sizeGroupLayout) : that._getLayoutSeries(visibleSeries, drawOptions);
      delta = (layout.radiusOuter - layout.radiusInner - seriesSpacing * (lengthVisibleSeries - 1)) / lengthVisibleSeries;
      innerRad = layout.radiusInner;

      that._setGeometry(layout);

      visibleSeries.forEach(function (singleSeries) {
        singleSeries.correctRadius({
          radiusInner: innerRad,
          radiusOuter: innerRad + delta
        });
        innerRad += delta + seriesSpacing;
      });
    }
  },
  _renderSeries: function _renderSeries(drawOptions, isRotated, isLegendInside) {
    this._calculateSeriesLayout(drawOptions, isRotated);

    if (!drawOptions.sizeGroupLayout && this.getSizeGroup()) {
      pieSizeEqualizer.queue(this);

      this._clearCanvas();

      return;
    }

    this._renderSeriesElements(drawOptions, isLegendInside);
  },
  _createHtmlStructure: function _createHtmlStructure() {
    this.callBase();
    this._centerTemplateGroup = this._renderer.g().attr({
      class: 'dxc-hole-template'
    }).linkOn(this._renderer.root, 'center-template').css((0, _utils.patchFontOptions)(this._themeManager._font)).linkAppend();
  },
  _renderExtraElements: function _renderExtraElements() {
    var _this = this;

    var template = this.option('centerTemplate');

    var centerTemplateGroup = this._centerTemplateGroup.clear();

    if (!template) {
      return;
    }

    centerTemplateGroup.attr({
      visibility: 'hidden'
    });
    template = this._getTemplate(template);
    template.render({
      model: this,
      container: centerTemplateGroup.element,
      onRendered: function onRendered() {
        var group = centerTemplateGroup;
        var bBox = group.getBBox();
        group.move(_this._center.x - (bBox.x + bBox.width / 2), _this._center.y - (bBox.y + bBox.height / 2));
        group.attr({
          visibility: 'visible'
        });
      }
    });
  },
  getInnerRadius: function getInnerRadius() {
    return this._innerRadius;
  },
  _getLegendCallBack: function _getLegendCallBack() {
    var that = this;
    var legend = this._legend;

    var items = this._getLegendTargets().map(function (i) {
      return i.legendData;
    });

    return function (target) {
      items.forEach(function (data) {
        var points = [];
        var callback = legend.getActionCallback({
          index: data.id
        });
        that.series.forEach(function (series) {
          var seriesPoints = series.getPointsByKeys(data.argument, data.argumentIndex);
          points.push.apply(points, seriesPoints);
        });

        if (target && target.argument === data.argument && target.argumentIndex === data.argumentIndex) {
          points.push(target);
        }

        callback(getLegendItemAction(points));
      });
    };
  },
  _locateLabels: function _locateLabels(resolveLabelOverlapping) {
    var iterationCount = 0;
    var labelsWereOverlapped;
    var wordWrapApplied;

    do {
      wordWrapApplied = this._adjustSeriesLabels(resolveLabelOverlapping === 'shift');
      labelsWereOverlapped = this._resolveLabelOverlapping(resolveLabelOverlapping);
    } while ((labelsWereOverlapped || wordWrapApplied) && ++iterationCount < MAX_RESOLVE_ITERATION_COUNT);
  },
  _adjustSeriesLabels: function _adjustSeriesLabels(moveLabelsFromCenter) {
    return this.series.reduce(function (r, s) {
      return s.adjustLabels(moveLabelsFromCenter) || r;
    }, false);
  },
  _applyExtraSettings: _common.noop,
  _resolveLabelOverlappingShift: function _resolveLabelOverlappingShift() {
    var that = this;
    var inverseDirection = that.option('segmentsDirection') === 'anticlockwise';
    var seriesByPosition = that.series.reduce(function (r, s) {
      (r[s.getOptions().label.position] || r.outside).push(s);
      return r;
    }, {
      inside: [],
      columns: [],
      outside: []
    });
    var labelsOverlapped = false;

    if (seriesByPosition.inside.length > 0) {
      labelsOverlapped = resolve(seriesByPosition.inside.reduce(function (r, singleSeries) {
        return singleSeries.getVisiblePoints().reduce(function (r, point) {
          r.left.push(point);
          return r;
        }, r);
      }, {
        left: [],
        right: []
      }), shiftInColumnFunction) || labelsOverlapped;
    }

    labelsOverlapped = seriesByPosition.columns.reduce(function (r, singleSeries) {
      return resolve(dividePoints(singleSeries), shiftInColumnFunction) || r;
    }, labelsOverlapped);

    if (seriesByPosition.outside.length > 0) {
      labelsOverlapped = resolve(seriesByPosition.outside.reduce(function (r, singleSeries) {
        return dividePoints(singleSeries, r);
      }, null), shiftFunction) || labelsOverlapped;
    }

    return labelsOverlapped;

    function dividePoints(series, points) {
      return series.getVisiblePoints().reduce(function (r, point) {
        var angle = (0, _utils.normalizeAngle)(point.middleAngle);
        (angle <= 90 || angle >= 270 ? r.right : r.left).push(point);
        return r;
      }, points || {
        left: [],
        right: []
      });
    }

    function resolve(points, shiftCallback) {
      var overlapped = false;

      if (inverseDirection) {
        points.left.reverse();
        points.right.reverse();
      }

      overlapped = _base_chart.overlapping.resolveLabelOverlappingInOneDirection(points.left, that._canvas, false, shiftCallback);
      return _base_chart.overlapping.resolveLabelOverlappingInOneDirection(points.right, that._canvas, false, shiftCallback) || overlapped;
    }

    function shiftFunction(box, length) {
      return (0, _utils.getVerticallyShiftedAngularCoords)(box, -length, that._center);
    }

    function shiftInColumnFunction(box, length) {
      return {
        x: box.x,
        y: box.y - length
      };
    }
  },
  _setGeometry: function _setGeometry(_ref) {
    var x = _ref.centerX,
        y = _ref.centerY,
        radiusInner = _ref.radiusInner;
    this._center = {
      x: x,
      y: y
    };
    this._innerRadius = radiusInner;
  },
  _disposeSeries: function _disposeSeries(seriesIndex) {
    this.callBase.apply(this, arguments);
    this._abstractSeries = null;
  },
  _legendDataField: 'point',
  _legendItemTextField: 'argument',
  _applyPointMarkersAutoHiding: _common.noop,
  _renderTrackers: _common.noop,
  _trackerType: 'PieTracker',
  _createScrollBar: _common.noop,
  _updateAxesLayout: _common.noop,
  _applyClipRects: _common.noop,
  _appendAdditionalSeriesGroups: _common.noop,
  _prepareToRender: _common.noop,
  _isLegendInside: _common.noop,
  _renderAxes: _common.noop,
  _shrinkAxes: _common.noop,
  _isRotated: _common.noop,
  _seriesPopulatedHandlerCore: _common.noop,
  _reinitAxes: _common.noop,
  _correctAxes: _common.noop,
  _getExtraOptions: function _getExtraOptions() {
    var that = this;
    return {
      startAngle: that.option('startAngle'),
      innerRadius: that.option('innerRadius'),
      segmentsDirection: that.option('segmentsDirection'),
      type: that.option('type')
    };
  },
  getSizeGroup: function getSizeGroup() {
    return this._themeManager.getOptions('sizeGroup');
  },
  getSizeGroupLayout: function getSizeGroupLayout() {
    return this._sizeGroupLayout || {};
  }
});

(0, _iterator.each)(OPTIONS_FOR_REFRESH_SERIES, function (_, name) {
  dxPieChart.prototype._optionChangesMap[name] = 'REFRESH_SERIES_DATA_INIT';
});
dxPieChart.addPlugin(_annotations.plugins.core);
dxPieChart.addPlugin(_annotations.plugins.pieChart);
(0, _component_registrator.default)('dxPieChart', dxPieChart);
var _default = dxPieChart;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1068 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _common = __webpack_require__(4);

var _component_registrator = _interopRequireDefault(__webpack_require__(9));

var _extend = __webpack_require__(0);

var _utils = __webpack_require__(14);

var _advanced_chart = __webpack_require__(593);

var _type = __webpack_require__(1);

var _annotations = __webpack_require__(244);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_PANE_NAME = 'default';
var DOUBLE_PI_ANGLE = 360;

var dxPolarChart = _advanced_chart.AdvancedChart.inherit({
  _themeSection: 'polar',
  _createPanes: function _createPanes() {
    this.callBase();
    return [{
      name: DEFAULT_PANE_NAME
    }];
  },
  _checkPaneName: function _checkPaneName() {
    return true;
  },
  _getAxisRenderingOptions: function _getAxisRenderingOptions(typeSelector) {
    var isArgumentAxis = typeSelector === 'argumentAxis';
    var type = isArgumentAxis ? 'circular' : 'linear';
    var useSpiderWeb = this.option('useSpiderWeb');

    if (useSpiderWeb) {
      type += 'Spider';
    }

    return {
      axisType: 'polarAxes',
      drawingType: type
    };
  },
  _executeAppendBeforeSeries: function _executeAppendBeforeSeries(append) {
    append();
  },
  _prepareAxisOptions: function _prepareAxisOptions(typeSelector, axisOptions) {
    var isArgumentAxis = typeSelector === 'argumentAxis';
    var themeManager = this._themeManager;
    var axisUserOptions = this.option('argumentAxis');
    var argumentAxisOptions = themeManager.getOptions('argumentAxis', axisUserOptions) || {};
    var startAngle = isFinite(argumentAxisOptions.startAngle) ? (0, _utils.normalizeAngle)(argumentAxisOptions.startAngle) : 0;
    return {
      type: this.option('useSpiderWeb') && isArgumentAxis ? 'discrete' : axisOptions.type,
      isHorizontal: true,
      showCustomBoundaryTicks: isArgumentAxis,
      startAngle: startAngle,
      endAngle: startAngle + 360
    };
  },
  _optionChangesMap: {
    useSpiderWeb: 'AXES_AND_PANES'
  },
  _getExtraOptions: function _getExtraOptions() {
    return {
      spiderWidget: this.option('useSpiderWeb')
    };
  },
  _prepareToRender: function _prepareToRender() {
    this._appendAxesGroups();

    return {};
  },
  _calcCanvas: function _calcCanvas() {
    var canvas = (0, _extend.extend)({}, this._canvas);
    var argumentAxis = this.getArgumentAxis();
    var margins = argumentAxis.getMargins();
    Object.keys(margins).forEach(function (margin) {
      return canvas[margin] = canvas["original".concat(margin[0].toUpperCase()).concat(margin.slice(1))] + margins[margin];
    });
    return canvas;
  },
  _renderAxes: function _renderAxes(drawOptions) {
    var that = this;

    var valueAxis = that._getValueAxis();

    var argumentAxis = that.getArgumentAxis();
    argumentAxis.draw(that._canvas);
    valueAxis.setSpiderTicks(argumentAxis.getSpiderTicks());

    var canvas = that._calcCanvas();

    argumentAxis.updateSize(canvas);
    valueAxis.draw(canvas);
    return canvas;
  },
  _getValueAxis: function _getValueAxis() {
    return this._valueAxes[0];
  },
  _shrinkAxes: function _shrinkAxes(sizeStorage) {
    var valueAxis = this._getValueAxis();

    var argumentAxis = this.getArgumentAxis();

    if (sizeStorage && (sizeStorage.width || sizeStorage.height)) {
      argumentAxis.hideOuterElements();

      var canvas = this._calcCanvas();

      argumentAxis.updateSize(canvas);
      valueAxis.updateSize(canvas);
    }
  },
  checkForMoreSpaceForPanesCanvas: function checkForMoreSpaceForPanesCanvas() {
    return this.layoutManager.needMoreSpaceForPanesCanvas([{
      canvas: this.getArgumentAxis().getCanvas()
    }], this._isRotated());
  },
  _getLayoutTargets: function _getLayoutTargets() {
    return [{
      canvas: this._canvas
    }];
  },
  _getSeriesForPane: function _getSeriesForPane() {
    return this.series;
  },
  _applyClipRects: function _applyClipRects() {
    var canvasClipRectID = this._getCanvasClipRectID();

    this._createClipPathForPane();

    this.getArgumentAxis().applyClipRects(this._getElementsClipRectID(), canvasClipRectID);

    this._getValueAxis().applyClipRects(this._getElementsClipRectID(), canvasClipRectID);
  },
  _createClipPathForPane: function _createClipPathForPane() {
    var that = this;

    var valueAxis = that._getValueAxis();

    var center = valueAxis.getCenter();
    var radius = valueAxis.getRadius();
    var panesClipRects = that._panesClipRects;
    center = {
      x: Math.round(center.x),
      y: Math.round(center.y)
    };

    that._createClipCircle(panesClipRects.fixed, center.x, center.y, radius);

    that._createClipCircle(panesClipRects.base, center.x, center.y, radius);

    if (that.series.some(function (s) {
      return s.areErrorBarsVisible();
    })) {
      that._createClipCircle(panesClipRects.wide, center.x, center.y, radius);
    } else {
      panesClipRects.wide[0] = null;
    }
  },
  _createClipCircle: function _createClipCircle(clipArray, left, top, radius) {
    var that = this;
    var clipCircle = clipArray[0];

    if (!clipCircle) {
      clipCircle = that._renderer.clipCircle(left, top, radius);
      clipArray[0] = clipCircle;
    } else {
      clipCircle.attr({
        cx: left,
        cy: top,
        r: radius
      });
    }
  },
  _applyExtraSettings: function _applyExtraSettings(series) {
    var wideClipRect = this._panesClipRects.wide[0];
    series.setClippingParams(this._panesClipRects.base[0].id, wideClipRect && wideClipRect.id, false, false);
  },
  getActualAngle: function getActualAngle(angle) {
    return this.getArgumentAxis().getOptions().inverted ? DOUBLE_PI_ANGLE - angle : angle;
  },
  getXYFromPolar: function getXYFromPolar(angle, radius, argument, value) {
    var layoutInfo = {
      angle: undefined,
      radius: undefined,
      x: undefined,
      y: undefined
    };

    if (!(0, _type.isDefined)(angle) && !(0, _type.isDefined)(radius) && !(0, _type.isDefined)(argument) && !(0, _type.isDefined)(value)) {
      return layoutInfo;
    }

    var argAxis = this.getArgumentAxis();
    var startAngle = argAxis.getAngles()[0];
    var argAngle;
    var translatedRadius;

    if ((0, _type.isDefined)(argument)) {
      argAngle = argAxis.getTranslator().translate(argument);
    } else if (isFinite(angle)) {
      argAngle = this.getActualAngle(angle);
    } else if (!(0, _type.isDefined)(angle)) {
      argAngle = 0;
    }

    if ((0, _type.isDefined)(value)) {
      translatedRadius = this.getValueAxis().getTranslator().translate(value);
    } else if (isFinite(radius)) {
      translatedRadius = radius;
    } else if (!(0, _type.isDefined)(radius)) {
      translatedRadius = argAxis.getRadius();
    }

    if ((0, _type.isDefined)(argAngle) && (0, _type.isDefined)(translatedRadius)) {
      var coords = (0, _utils.convertPolarToXY)(argAxis.getCenter(), startAngle, argAngle, translatedRadius);
      (0, _extend.extend)(layoutInfo, coords, {
        angle: argAxis.getTranslatedAngle(argAngle),
        radius: translatedRadius
      });
    }

    return layoutInfo;
  },
  _applyPointMarkersAutoHiding: _common.noop,
  _createScrollBar: _common.noop,
  _isRotated: _common.noop,
  _getCrosshairOptions: _common.noop,
  _isLegendInside: _common.noop
});

dxPolarChart.addPlugin(_annotations.plugins.core);
dxPolarChart.addPlugin(_annotations.plugins.polarChart);
(0, _component_registrator.default)('dxPolarChart', dxPolarChart);
var _default = dxPolarChart;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1069 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _linear_gauge = _interopRequireDefault(__webpack_require__(1070));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = _linear_gauge.default;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1070 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports.default = void 0;

var _iterator = __webpack_require__(3);

var _component_registrator = _interopRequireDefault(__webpack_require__(9));

var _extend = __webpack_require__(0);

var _object = __webpack_require__(52);

var _base_gauge = __webpack_require__(210);

var _common = __webpack_require__(602);

var _utils = __webpack_require__(14);

var linearIndicators = _interopRequireWildcard(__webpack_require__(1073));

var _linear_range_container = _interopRequireDefault(__webpack_require__(1074));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _max = Math.max;
var _min = Math.min;
var _round = Math.round;

var dxLinearGauge = _common.dxGauge.inherit({
  _rootClass: 'dxg-linear-gauge',
  _factoryMethods: {
    rangeContainer: 'createLinearRangeContainer',
    indicator: 'createLinearIndicator'
  },
  _gridSpacingFactor: 25,
  _scaleTypes: {
    type: 'xyAxes',
    drawingType: 'linear'
  },
  _getTicksOrientation: function _getTicksOrientation(scaleOptions) {
    return scaleOptions.isHorizontal ? scaleOptions.verticalOrientation : scaleOptions.horizontalOrientation;
  },
  _getThemeManagerOptions: function _getThemeManagerOptions() {
    var options = this.callBase.apply(this, arguments);
    options.subTheme = '_linear';
    return options;
  },
  _getInvertedState: function _getInvertedState() {
    return !this._area.vertical && this.option('rtlEnabled');
  },
  _prepareScaleSettings: function _prepareScaleSettings() {
    var scaleOptions = this.callBase();
    scaleOptions.inverted = this._getInvertedState();
    return scaleOptions;
  },
  _updateScaleTickIndent: function _updateScaleTickIndent(scaleOptions) {
    var indentFromTick = scaleOptions.label.indentFromTick;
    var length = scaleOptions.tick.length;

    var textParams = this._scale.measureLabels((0, _extend.extend)({}, this._canvas));

    var verticalTextCorrection = scaleOptions.isHorizontal ? textParams.height + textParams.y : 0;
    var isIndentPositive = indentFromTick > 0;
    var orientation;
    var textCorrection;
    var tickCorrection;

    if (scaleOptions.isHorizontal) {
      orientation = isIndentPositive ? {
        center: 0.5,
        top: 0,
        bottom: 1
      } : {
        center: 0.5,
        top: 1,
        bottom: 0
      };
      tickCorrection = length * orientation[scaleOptions.verticalOrientation];
      textCorrection = textParams.y;
    } else {
      orientation = isIndentPositive ? {
        center: 0.5,
        left: 0,
        right: 1
      } : {
        center: 0.5,
        left: 1,
        right: 0
      };
      tickCorrection = length * orientation[scaleOptions.horizontalOrientation];
      textCorrection = -textParams.width;
    }

    scaleOptions.label.indentFromAxis = -indentFromTick + (isIndentPositive ? -tickCorrection + textCorrection : tickCorrection - verticalTextCorrection);

    this._scale.updateOptions(scaleOptions);
  },
  _shiftScale: function _shiftScale(layout, scaleOptions) {
    var that = this;
    var canvas = (0, _extend.extend)({}, that._canvas);
    var isHorizontal = scaleOptions.isHorizontal;
    var scale = that._scale;
    canvas[isHorizontal ? 'left' : 'top'] = that._area[isHorizontal ? 'startCoord' : 'endCoord'];
    canvas[isHorizontal ? 'right' : 'bottom'] = canvas[isHorizontal ? 'width' : 'height'] - that._area[isHorizontal ? 'endCoord' : 'startCoord'];
    scale.draw(canvas);
    scale.shift({
      left: -layout.x,
      top: -layout.y
    });
  },
  _setupCodomain: function _setupCodomain() {
    var that = this;
    var geometry = that.option('geometry') || {};
    var vertical = (0, _utils.normalizeEnum)(geometry.orientation) === 'vertical';
    var initialStartCoord = -100;
    var initialEndCoord = 100;
    that._area = {
      vertical: vertical,
      x: 0,
      y: 0,
      startCoord: initialStartCoord,
      endCoord: initialEndCoord
    };
    that._rangeContainer.vertical = vertical;

    that._translator.setInverted(that._getInvertedState());

    that._translator.setCodomain(initialStartCoord, initialEndCoord);
  },
  _getScaleLayoutValue: function _getScaleLayoutValue() {
    return this._area[this._area.vertical ? 'x' : 'y'];
  },
  _getTicksCoefficients: function _getTicksCoefficients(options) {
    var coefs = {
      inner: 0,
      outer: 1
    };

    if (this._area.vertical) {
      if (options.horizontalOrientation === 'left') {
        coefs.inner = 1;
        coefs.outer = 0;
      } else if (options.horizontalOrientation === 'center') {
        coefs.inner = coefs.outer = 0.5;
      }
    } else {
      if (options.verticalOrientation === 'top') {
        coefs.inner = 1;
        coefs.outer = 0;
      } else if (options.verticalOrientation === 'center') {
        coefs.inner = coefs.outer = 0.5;
      }
    }

    return coefs;
  },
  _correctScaleIndents: function _correctScaleIndents(result, indentFromTick, textParams) {
    var vertical = this._area.vertical;

    if (indentFromTick >= 0) {
      result.max += indentFromTick + textParams[vertical ? 'width' : 'height'];
    } else {
      result.min -= -indentFromTick + textParams[vertical ? 'width' : 'height'];
    }

    result.indent = textParams[vertical ? 'height' : 'width'] / 2;
  },
  _measureMainElements: function _measureMainElements(elements, scaleMeasurement) {
    var that = this;
    var x = that._area.x;
    var y = that._area.y;
    var minBound = 1000;
    var maxBound = 0;
    var indent = 0;
    var scale = that._scale;
    (0, _iterator.each)(elements.concat(scale), function (_, element) {
      var bounds = element.measure ? element.measure({
        x: x + element.getOffset(),
        y: y + element.getOffset()
      }) : scaleMeasurement;
      bounds.max !== undefined && (maxBound = _max(maxBound, bounds.max));
      bounds.min !== undefined && (minBound = _min(minBound, bounds.min));
      bounds.indent > 0 && (indent = _max(indent, bounds.indent));
    });
    return {
      minBound: minBound,
      maxBound: maxBound,
      indent: indent
    };
  },
  _applyMainLayout: function _applyMainLayout(elements, scaleMeasurement) {
    var that = this;

    var measurements = that._measureMainElements(elements, scaleMeasurement);

    var area = that._area;
    var rect;
    var offset;

    if (area.vertical) {
      rect = selectRectBySizes(that._innerRect, {
        width: measurements.maxBound - measurements.minBound
      });
      offset = (rect.left + rect.right) / 2 - (measurements.minBound + measurements.maxBound) / 2;
      area.startCoord = rect.bottom - measurements.indent;
      area.endCoord = rect.top + measurements.indent;
      area.x = _round(area.x + offset);
    } else {
      rect = selectRectBySizes(that._innerRect, {
        height: measurements.maxBound - measurements.minBound
      });
      offset = (rect.top + rect.bottom) / 2 - (measurements.minBound + measurements.maxBound) / 2;
      area.startCoord = rect.left + measurements.indent;
      area.endCoord = rect.right - measurements.indent;
      area.y = _round(area.y + offset);
    }

    that._translator.setCodomain(area.startCoord, area.endCoord);

    that._innerRect = rect;
  },
  _getElementLayout: function _getElementLayout(offset) {
    return {
      x: _round(this._area.x + offset),
      y: _round(this._area.y + offset)
    };
  },
  _getApproximateScreenRange: function _getApproximateScreenRange() {
    var that = this;
    var area = that._area;
    var s = area.vertical ? that._canvas.height : that._canvas.width;
    s > area.totalSize && (s = area.totalSize);
    s = s * 0.8;
    return s;
  },
  _getDefaultSize: function _getDefaultSize() {
    var geometry = this.option('geometry') || {};

    if (geometry.orientation === 'vertical') {
      return {
        width: 100,
        height: 300
      };
    } else {
      return {
        width: 300,
        height: 100
      };
    }
  },
  _factory: (0, _object.clone)(_base_gauge.BaseGauge.prototype._factory)
});

function selectRectBySizes(srcRect, sizes, margins) {
  var rect = (0, _extend.extend)({}, srcRect);
  var step;
  margins = margins || {};

  if (sizes) {
    rect.left += margins.left || 0;
    rect.right -= margins.right || 0;
    rect.top += margins.top || 0;
    rect.bottom -= margins.bottom || 0;

    if (sizes.width > 0) {
      step = (rect.right - rect.left - sizes.width) / 2;

      if (step > 0) {
        rect.left += step;
        rect.right -= step;
      }
    }

    if (sizes.height > 0) {
      step = (rect.bottom - rect.top - sizes.height) / 2;

      if (step > 0) {
        rect.top += step;
        rect.bottom -= step;
      }
    }
  }

  return rect;
}

var indicators = dxLinearGauge.prototype._factory.indicators = {};
dxLinearGauge.prototype._factory.createIndicator = (0, _common.createIndicatorCreator)(indicators);
indicators._default = linearIndicators._default;
indicators['rectangle'] = linearIndicators['rectangle'];
indicators['rhombus'] = linearIndicators['rhombus'];
indicators['circle'] = linearIndicators['circle'];
indicators['trianglemarker'] = linearIndicators['trianglemarker'];
indicators['textcloud'] = linearIndicators['textcloud'];
indicators['rangebar'] = linearIndicators['rangebar'];
dxLinearGauge.prototype._factory.RangeContainer = _linear_range_container.default;
(0, _component_registrator.default)('dxLinearGauge', dxLinearGauge);
var _default = dxLinearGauge;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1071 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _extend2 = __webpack_require__(0);

var _base_theme_manager = __webpack_require__(343);

var _extend = _extend2.extend;

var ThemeManager = _base_theme_manager.BaseThemeManager.inherit({
  ctor: function ctor(options) {
    this.callBase.apply(this, arguments);
    this._subTheme = options.subTheme;
  },
  _initializeTheme: function _initializeTheme() {
    var that = this;
    var subTheme;

    if (that._subTheme) {
      subTheme = _extend(true, {}, that._theme[that._subTheme], that._theme);

      _extend(true, that._theme, subTheme);
    }

    that.callBase.apply(that, arguments);
  }
});

var _default = {
  ThemeManager: ThemeManager
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1072 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _class = _interopRequireDefault(__webpack_require__(15));

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _wheel = __webpack_require__(149);

var _ready_callbacks = _interopRequireDefault(__webpack_require__(51));

var _index = __webpack_require__(8);

var _pointer = _interopRequireDefault(__webpack_require__(25));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EVENT_NS = 'gauge-tooltip';
var TOOLTIP_HIDE_DELAY = 100;
var ready = _ready_callbacks.default.add;

var Tracker = _class.default.inherit({
  ctor: function ctor(parameters) {
    var that = this;
    that._element = parameters.renderer.g().attr({
      'class': 'dxg-tracker',
      stroke: 'none',
      'stroke-width': 0,
      fill: '#000000',
      opacity: 0.0001
    }).linkOn(parameters.container, {
      name: 'tracker',
      after: 'peripheral'
    });

    that._showTooltipCallback = function () {
      var target = that._tooltipEvent.target;
      var data_target = target['gauge-data-target'];
      var data_info = target['gauge-data-info'];
      that._targetEvent = null; //  Internal state must be reset strictly BEFORE callback is invoked

      if (that._tooltipTarget !== target) {
        var callback = function callback(result) {
          result && (that._tooltipTarget = target);
        };

        callback(that._callbacks['tooltip-show'](data_target, data_info, callback));
      }
    };

    that._hideTooltipCallback = function () {
      that._hideTooltipTimeout = null;
      that._targetEvent = null;

      if (that._tooltipTarget) {
        that._callbacks['tooltip-hide']();

        that._tooltipTarget = null;
      }
    };

    that._dispose = function () {
      clearTimeout(that._hideTooltipTimeout);
      that._showTooltipCallback = that._hideTooltipCallback = that._dispose = null;
    };
  },
  dispose: function dispose() {
    var that = this;

    that._dispose();

    that.deactivate();

    that._element.off('.' + EVENT_NS);

    that._element.linkOff();

    that._element = that._context = that._callbacks = null;
    return that;
  },
  activate: function activate() {
    this._element.linkAppend();

    return this;
  },
  deactivate: function deactivate() {
    this._element.linkRemove().clear();

    return this;
  },
  attach: function attach(element, target, info) {
    element.data({
      'gauge-data-target': target,
      'gauge-data-info': info
    }).append(this._element);
    return this;
  },
  detach: function detach(element) {
    element.remove();
    return this;
  },
  setTooltipState: function setTooltipState(state) {
    var that = this;

    that._element.off('.' + EVENT_NS);

    if (state) {
      var data = {
        tracker: that
      };

      that._element.on((0, _index.addNamespace)([_pointer.default.move], EVENT_NS), data, handleTooltipMouseOver).on((0, _index.addNamespace)([_pointer.default.out], EVENT_NS), data, handleTooltipMouseOut).on((0, _index.addNamespace)([_pointer.default.down], EVENT_NS), data, handleTooltipTouchStart).on((0, _index.addNamespace)([_pointer.default.up], EVENT_NS), data, handleTooltipTouchEnd).on((0, _index.addNamespace)([_wheel.name], EVENT_NS), data, handleTooltipMouseWheel);
    }

    return that;
  },
  setCallbacks: function setCallbacks(callbacks) {
    this._callbacks = callbacks;
    return this;
  },
  _showTooltip: function _showTooltip(event) {
    var that = this;
    clearTimeout(that._hideTooltipTimeout);
    that._hideTooltipTimeout = null;

    if (that._tooltipTarget === event.target) {
      return;
    }

    that._tooltipEvent = event;

    that._showTooltipCallback();
  },
  _hideTooltip: function _hideTooltip(delay) {
    var that = this;
    clearTimeout(that._hideTooltipTimeout);

    if (delay) {
      that._hideTooltipTimeout = setTimeout(that._hideTooltipCallback, delay);
    } else {
      that._hideTooltipCallback();
    }
  }
});

var active_touch_tooltip_tracker = null;

function handleTooltipMouseOver(event) {
  var tracker = event.data.tracker;
  tracker._x = event.pageX;
  tracker._y = event.pageY;

  tracker._showTooltip(event);
}

function handleTooltipMouseOut(event) {
  event.data.tracker._hideTooltip(TOOLTIP_HIDE_DELAY);
}

function handleTooltipMouseWheel(event) {
  event.data.tracker._hideTooltip();
}

function handleTooltipTouchStart(event) {
  var tracker = active_touch_tooltip_tracker = event.data.tracker;
  tracker._touch = true;
  handleTooltipMouseOver(event);
}

function handleTooltipTouchEnd() {
  active_touch_tooltip_tracker._touch = false;
}

function handleDocumentTooltipTouchStart(event) {
  var tracker = active_touch_tooltip_tracker;

  if (tracker && !tracker._touch) {
    tracker._hideTooltip(TOOLTIP_HIDE_DELAY);

    active_touch_tooltip_tracker = null;
  }
}

ready(function () {
  _events_engine.default.subscribeGlobal(_dom_adapter.default.getDocument(), (0, _index.addNamespace)([_pointer.default.down], EVENT_NS), handleDocumentTooltipTouchStart);
});
var _default = Tracker;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1073 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.textcloud = exports.trianglemarker = exports.circle = exports.rhombus = exports.rectangle = exports.rangebar = exports._default = void 0;

var _base_indicators = __webpack_require__(351);

var _utils = __webpack_require__(14);

var _Number = Number;

var SimpleIndicator = _base_indicators.BaseIndicator.inherit({
  _move: function _move() {
    var that = this;
    var delta = that._actualPosition - that._zeroPosition;

    that._rootElement.move(that.vertical ? 0 : delta, that.vertical ? delta : 0);

    that._trackerElement && that._trackerElement.move(that.vertical ? 0 : delta, that.vertical ? delta : 0);
  },
  _isEnabled: function _isEnabled() {
    this.vertical = this._options.vertical;
    return this._options.length > 0 && this._options.width > 0;
  },
  _isVisible: function _isVisible() {
    return true;
  },
  _getTrackerSettings: function _getTrackerSettings() {
    var options = this._options;
    var x1;
    var x2;
    var y1;
    var y2;
    var width = options.width / 2;
    var length = options.length / 2;
    var p = this._zeroPosition;
    width > 10 || (width = 10);
    length > 10 || (length = 10);

    if (this.vertical) {
      x1 = options.x - length;
      x2 = options.x + length;
      y1 = p + width;
      y2 = p - width;
    } else {
      x1 = p - width;
      x2 = p + width;
      y1 = options.y + length;
      y2 = options.y - length;
    }

    return {
      points: [x1, y1, x1, y2, x2, y2, x2, y1]
    };
  },
  _render: function _render() {
    var that = this;
    that._zeroPosition = that._translator.getCodomainStart();
  },
  _clear: function _clear() {
    delete this._element;
  },
  measure: function measure(layout) {
    var p = this.vertical ? layout.x : layout.y;
    return {
      min: p - this._options.length / 2,
      max: p + this._options.length / 2
    };
  },
  getTooltipParameters: function getTooltipParameters() {
    var that = this;
    var options = that._options;
    var p = that._actualPosition;
    var parameters = {
      x: p,
      y: p,
      value: that._currentValue,
      color: options.color,
      offset: options.width / 2
    };
    that.vertical ? parameters.x = options.x : parameters.y = options.y;
    return parameters;
  }
});

var rectangle = SimpleIndicator.inherit({
  _render: function _render() {
    var that = this;
    var options = that._options;
    var x1;
    var x2;
    var y1;
    var y2;
    that.callBase();
    var p = that._zeroPosition;

    if (that.vertical) {
      x1 = options.x - options.length / 2;
      x2 = options.x + options.length / 2;
      y1 = p + options.width / 2;
      y2 = p - options.width / 2;
    } else {
      x1 = p - options.width / 2;
      x2 = p + options.width / 2;
      y1 = options.y + options.length / 2;
      y2 = options.y - options.length / 2;
    }

    that._element = that._element || that._renderer.path([], 'area').append(that._rootElement);

    that._element.attr({
      points: [x1, y1, x1, y2, x2, y2, x2, y1]
    });
  }
});
exports.rectangle = rectangle;
var rhombus = SimpleIndicator.inherit({
  _render: function _render() {
    var that = this;
    var options = that._options;
    var x;
    var y;
    var dx;
    var dy;
    that.callBase();

    if (that.vertical) {
      x = options.x;
      y = that._zeroPosition;
      dx = options.length / 2 || 0;
      dy = options.width / 2 || 0;
    } else {
      x = that._zeroPosition;
      y = options.y;
      dx = options.width / 2 || 0;
      dy = options.length / 2 || 0;
    }

    that._element = that._element || that._renderer.path([], 'area').append(that._rootElement);

    that._element.attr({
      points: [x - dx, y, x, y - dy, x + dx, y, x, y + dy]
    });
  }
});
exports.rhombus = rhombus;
var circle = SimpleIndicator.inherit({
  _render: function _render() {
    var that = this;
    var options = that._options;
    var x;
    var y;
    that.callBase();

    if (that.vertical) {
      x = options.x;
      y = that._zeroPosition;
    } else {
      x = that._zeroPosition;
      y = options.y;
    }

    var r = options.length / 2 || 0;
    that._element = that._element || that._renderer.circle().append(that._rootElement);

    that._element.attr({
      cx: x,
      cy: y,
      r: r
    });
  }
}); // The following is from linearMarker.js

exports.circle = circle;
var triangleMarker = SimpleIndicator.inherit({
  _isEnabled: function _isEnabled() {
    var that = this;
    that.vertical = that._options.vertical;
    that._inverted = that.vertical ? (0, _utils.normalizeEnum)(that._options.horizontalOrientation) === 'right' : (0, _utils.normalizeEnum)(that._options.verticalOrientation) === 'bottom';
    return that._options.length > 0 && that._options.width > 0;
  },
  _isVisible: function _isVisible() {
    return true;
  },
  _render: function _render() {
    var that = this;
    var options = that._options;
    var x1;
    var x2;
    var y1;
    var y2;
    var settings = {
      stroke: 'none',
      'stroke-width': 0,
      'stroke-linecap': 'square'
    };
    that.callBase();

    if (that.vertical) {
      x1 = options.x;
      y1 = that._zeroPosition;
      x2 = x1 + _Number(that._inverted ? options.length : -options.length);
      settings.points = [x1, y1, x2, y1 - options.width / 2, x2, y1 + options.width / 2];
    } else {
      y1 = options.y;
      x1 = that._zeroPosition;
      y2 = y1 + _Number(that._inverted ? options.length : -options.length);
      settings.points = [x1, y1, x1 - options.width / 2, y2, x1 + options.width / 2, y2];
    }

    if (options.space > 0) {
      settings['stroke-width'] = Math.min(options.space, options.width / 4) || 0;
      settings.stroke = settings['stroke-width'] > 0 ? options.containerBackgroundColor || 'none' : 'none';
    }

    that._element = that._element || that._renderer.path([], 'area').append(that._rootElement);

    that._element.attr(settings).sharp();
  },
  _getTrackerSettings: function _getTrackerSettings() {
    var that = this;
    var options = that._options;
    var width = options.width / 2;

    var length = _Number(options.length);

    var x1;
    var x2;
    var y1;
    var y2;
    var result;
    width > 10 || (width = 10);
    length > 20 || (length = 20);

    if (that.vertical) {
      x1 = options.x;
      x2 = x1 + (that._inverted ? length : -length);
      y1 = that._zeroPosition + width;
      y2 = that._zeroPosition - width;
      result = [x1, y1, x2, y1, x2, y2, x1, y2];
    } else {
      y1 = options.y;
      y2 = y1 + (that._inverted ? length : -length);
      x1 = that._zeroPosition - width;
      x2 = that._zeroPosition + width;
      result = [x1, y1, x1, y2, x2, y2, x2, y1];
    }

    return {
      points: result
    };
  },
  measure: function measure(layout) {
    var that = this;

    var length = _Number(that._options.length);

    var minBound;
    var maxBound;

    if (that.vertical) {
      minBound = maxBound = layout.x;

      if (that._inverted) {
        maxBound = minBound + length;
      } else {
        minBound = maxBound - length;
      }
    } else {
      minBound = maxBound = layout.y;

      if (that._inverted) {
        maxBound = minBound + length;
      } else {
        minBound = maxBound - length;
      }
    }

    return {
      min: minBound,
      max: maxBound,
      indent: that._options.width / 2
    };
  },
  getTooltipParameters: function getTooltipParameters() {
    var that = this;
    var options = that._options;
    var s = (that._inverted ? options.length : -options.length) / 2;
    var parameters = that.callBase();
    that.vertical ? parameters.x += s : parameters.y += s;
    parameters.offset = options.length / 2;
    return parameters;
  }
});
exports.trianglemarker = triangleMarker;

var textCloud = _base_indicators.BaseTextCloudMarker.inherit({
  _isEnabled: function _isEnabled() {
    var that = this;
    that.vertical = that._options.vertical;
    that._inverted = that.vertical ? (0, _utils.normalizeEnum)(that._options.horizontalOrientation) === 'right' : (0, _utils.normalizeEnum)(that._options.verticalOrientation) === 'bottom';
    return true;
  },
  _isVisible: function _isVisible() {
    return true;
  },
  _getTextCloudOptions: function _getTextCloudOptions() {
    var that = this;
    var x = that._actualPosition;
    var y = that._actualPosition;
    var type;

    if (that.vertical) {
      x = that._options.x;
      type = that._inverted ? 'top-left' : 'top-right';
    } else {
      y = that._options.y;
      type = that._inverted ? 'right-top' : 'right-bottom';
    }

    return {
      x: x,
      y: y,
      type: type
    };
  },
  measure: function measure(layout) {
    var that = this;
    var minBound;
    var maxBound;
    var arrowLength = _Number(that._options.arrowLength) || 0;

    that._measureText();

    if (that.vertical) {
      if (that._inverted) {
        minBound = layout.x;
        maxBound = layout.x + arrowLength + that._textFullWidth;
      } else {
        minBound = layout.x - arrowLength - that._textFullWidth;
        maxBound = layout.x;
      }
    } else {
      if (that._inverted) {
        minBound = layout.y;
        maxBound = layout.y + arrowLength + that._textFullHeight;
      } else {
        minBound = layout.y - arrowLength - that._textFullHeight;
        maxBound = layout.y;
      }
    }

    return {
      min: minBound,
      max: maxBound,
      indent: 0
    };
  },
  _correctCloudType: function _correctCloudType(type, _ref, _ref2) {
    var x = _ref.x,
        y = _ref.y;
    var width = _ref2.width,
        height = _ref2.height;

    if (type === 'right-top' || type === 'right-bottom') {
      if (x - width < this._translator.getCodomainStart()) {
        type = "left-".concat(type.split('-')[1]);
      }
    } else if (type === 'top-left' || type === 'top-right') {
      if (y + height > this._translator.getCodomainStart()) {
        type = "bottom-".concat(type.split('-')[1]);
      }
    }

    return type;
  }
}); // The following is from linearRangeBar.js


exports.textcloud = textCloud;

var rangeBar = _base_indicators.BaseRangeBar.inherit({
  _isEnabled: function _isEnabled() {
    var that = this;
    that.vertical = that._options.vertical;
    that._inverted = that.vertical ? (0, _utils.normalizeEnum)(that._options.horizontalOrientation) === 'right' : (0, _utils.normalizeEnum)(that._options.verticalOrientation) === 'bottom';
    return that._options.size > 0;
  },
  _isVisible: function _isVisible() {
    return true;
  },
  _createBarItem: function _createBarItem() {
    return this._renderer.path([], 'area').append(this._rootElement);
  },
  _createTracker: function _createTracker() {
    return this._renderer.path([], 'area');
  },
  _setBarSides: function _setBarSides() {
    var that = this;
    var options = that._options;

    var size = _Number(options.size);

    var minSide;
    var maxSide;

    if (that.vertical) {
      if (that._inverted) {
        minSide = options.x;
        maxSide = options.x + size;
      } else {
        minSide = options.x - size;
        maxSide = options.x;
      }
    } else {
      if (that._inverted) {
        minSide = options.y;
        maxSide = options.y + size;
      } else {
        minSide = options.y - size;
        maxSide = options.y;
      }
    }

    that._minSide = minSide;
    that._maxSide = maxSide;
    that._minBound = minSide;
    that._maxBound = maxSide;
  },
  _getSpace: function _getSpace() {
    var options = this._options;
    return options.space > 0 ? _Number(options.space) : 0;
  },
  _isTextVisible: function _isTextVisible() {
    var textOptions = this._options.text || {};
    return textOptions.indent > 0 || textOptions.indent < 0;
  },
  _getTextAlign: function _getTextAlign() {
    return this.vertical ? this._options.text.indent > 0 ? 'left' : 'right' : 'center';
  },
  _setTextItemsSides: function _setTextItemsSides() {
    var that = this;

    var indent = _Number(that._options.text.indent);

    if (indent > 0) {
      that._lineStart = that._maxSide;
      that._lineEnd = that._maxSide + indent;
      that._textPosition = that._lineEnd + (that.vertical ? 2 : that._textHeight / 2);
      that._maxBound = that._textPosition + (that.vertical ? that._textWidth : that._textHeight / 2);
    } else if (indent < 0) {
      that._lineStart = that._minSide;
      that._lineEnd = that._minSide + indent;
      that._textPosition = that._lineEnd - (that.vertical ? 2 : that._textHeight / 2);
      that._minBound = that._textPosition - (that.vertical ? that._textWidth : that._textHeight / 2);
    }
  },
  _getPositions: function _getPositions() {
    var that = this;
    var startPosition = that._startPosition;
    var endPosition = that._endPosition;
    var space = that._space;
    var basePosition = that._basePosition;
    var actualPosition = that._actualPosition;
    var mainPosition1;
    var mainPosition2;
    var backPosition1;
    var backPosition2;

    if (startPosition < endPosition) {
      if (basePosition < actualPosition) {
        mainPosition1 = basePosition;
        mainPosition2 = actualPosition;
      } else {
        mainPosition1 = actualPosition;
        mainPosition2 = basePosition;
      }

      backPosition1 = mainPosition1 - space;
      backPosition2 = mainPosition2 + space;
    } else {
      if (basePosition > actualPosition) {
        mainPosition1 = basePosition;
        mainPosition2 = actualPosition;
      } else {
        mainPosition1 = actualPosition;
        mainPosition2 = basePosition;
      }

      backPosition1 = mainPosition1 + space;
      backPosition2 = mainPosition2 - space;
    }

    return {
      start: startPosition,
      end: endPosition,
      main1: mainPosition1,
      main2: mainPosition2,
      back1: backPosition1,
      back2: backPosition2
    };
  },
  _buildItemSettings: function _buildItemSettings(from, to) {
    var that = this;
    var side1 = that._minSide;
    var side2 = that._maxSide;
    var points = that.vertical ? [side1, from, side1, to, side2, to, side2, from] : [from, side1, from, side2, to, side2, to, side1];
    return {
      points: points
    };
  },
  _updateTextPosition: function _updateTextPosition() {
    var that = this;

    that._text.attr(that.vertical ? {
      x: that._textPosition,
      y: that._actualPosition + that._textVerticalOffset
    } : {
      x: that._actualPosition,
      y: that._textPosition + that._textVerticalOffset
    });
  },
  _updateLinePosition: function _updateLinePosition() {
    var that = this;
    var actualPosition = that._actualPosition;
    var side1;
    var side2;
    var points;

    if (that.vertical) {
      if (that._basePosition >= actualPosition) {
        side1 = actualPosition;
        side2 = actualPosition + 2;
      } else {
        side1 = actualPosition - 2;
        side2 = actualPosition;
      }

      points = [that._lineStart, side1, that._lineStart, side2, that._lineEnd, side2, that._lineEnd, side1];
    } else {
      if (that._basePosition <= actualPosition) {
        side1 = actualPosition - 2;
        side2 = actualPosition;
      } else {
        side1 = actualPosition;
        side2 = actualPosition + 2;
      }

      points = [side1, that._lineStart, side1, that._lineEnd, side2, that._lineEnd, side2, that._lineStart];
    }

    that._line.attr({
      points: points
    }).sharp();
  },
  _getTooltipPosition: function _getTooltipPosition() {
    var that = this;
    var crossCenter = (that._minSide + that._maxSide) / 2;
    var alongCenter = (that._basePosition + that._actualPosition) / 2;
    return that.vertical ? {
      x: crossCenter,
      y: alongCenter
    } : {
      x: alongCenter,
      y: crossCenter
    };
  },
  measure: function measure(layout) {
    var that = this;

    var size = _Number(that._options.size);

    var textIndent = _Number(that._options.text.indent);

    var minBound;
    var maxBound;
    var indent;

    that._measureText();

    if (that.vertical) {
      minBound = maxBound = layout.x;

      if (that._inverted) {
        maxBound = maxBound + size;
      } else {
        minBound = minBound - size;
      }

      if (that._hasText) {
        indent = that._textHeight / 2;

        if (textIndent > 0) {
          maxBound += textIndent + that._textWidth;
        }

        if (textIndent < 0) {
          minBound += textIndent - that._textWidth;
        }
      }
    } else {
      minBound = maxBound = layout.y;

      if (that._inverted) {
        maxBound = maxBound + size;
      } else {
        minBound = minBound - size;
      }

      if (that._hasText) {
        indent = that._textWidth / 2;

        if (textIndent > 0) {
          maxBound += textIndent + that._textHeight;
        }

        if (textIndent < 0) {
          minBound += textIndent - that._textHeight;
        }
      }
    }

    return {
      min: minBound,
      max: maxBound,
      indent: indent
    };
  }
});
/* eslint-disable spellcheck/spell-checker */


exports.rangebar = exports._default = rangeBar;

/***/ }),
/* 1074 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _base_range_container = _interopRequireDefault(__webpack_require__(603));

var _utils = __webpack_require__(14);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _Number = Number;
var _max = Math.max;

var LinearRangeContainer = _base_range_container.default.inherit({
  _processOptions: function _processOptions() {
    var that = this;
    that.vertical = that._options.vertical;
    that._inner = that._outer = 0;

    if (that.vertical) {
      switch ((0, _utils.normalizeEnum)(that._options.horizontalOrientation)) {
        case 'left':
          that._inner = 1;
          break;

        case 'center':
          that._inner = that._outer = 0.5;
          break;

        default:
          that._outer = 1;
          break;
      }
    } else {
      switch ((0, _utils.normalizeEnum)(that._options.verticalOrientation)) {
        case 'top':
          that._inner = 1;
          break;

        case 'center':
          that._inner = that._outer = 0.5;
          break;

        default:
          that._outer = 1;
          break;
      }
    }
  },
  _isVisible: function _isVisible() {
    return true;
  },
  _createRange: function _createRange(range, layout) {
    var that = this;
    var inner = that._inner;
    var outer = that._outer;

    var startPosition = that._translator.translate(range.start);

    var endPosition = that._translator.translate(range.end);

    var points;
    var x = layout.x;
    var y = layout.y;
    var startWidth = range.startWidth;
    var endWidth = range.endWidth;

    if (that.vertical) {
      points = [x - startWidth * inner, startPosition, x - endWidth * inner, endPosition, x + endWidth * outer, endPosition, x + startWidth * outer, startPosition];
    } else {
      points = [startPosition, y + startWidth * outer, startPosition, y - startWidth * inner, endPosition, y - endWidth * inner, endPosition, y + endWidth * outer];
    }

    return that._renderer.path(points, 'area');
  },
  measure: function measure(layout) {
    var result = {};
    var width;
    result.min = result.max = layout[this.vertical ? 'x' : 'y'];
    width = this._options.width;
    width = _Number(width) || _max(_Number(width.start), _Number(width.end));
    result.min -= this._inner * width;
    result.max += this._outer * width;
    return result;
  }
});

var _default = LinearRangeContainer;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1075 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _circular_gauge = _interopRequireDefault(__webpack_require__(604));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = _circular_gauge.default;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1076 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.rangebar = exports.textcloud = exports.trianglemarker = exports.twocolorneedle = exports.triangleneedle = exports.rectangleneedle = exports._default = void 0;

var _base_indicators = __webpack_require__(351);

var _utils = __webpack_require__(14);

var _Number = Number;
var _getCosAndSin = _utils.getCosAndSin;
var _convertAngleToRendererSpace = _utils.convertAngleToRendererSpace;

var SimpleIndicator = _base_indicators.BaseIndicator.inherit({
  _move: function _move() {
    var that = this;
    var options = that._options;

    var angle = _convertAngleToRendererSpace(that._actualPosition);

    that._rootElement.rotate(angle, options.x, options.y);

    that._trackerElement && that._trackerElement.rotate(angle, options.x, options.y);
  },
  _isEnabled: function _isEnabled() {
    return this._options.width > 0;
  },
  _isVisible: function _isVisible(layout) {
    return layout.radius - _Number(this._options.indentFromCenter) > 0;
  },
  _getTrackerSettings: function _getTrackerSettings() {
    var options = this._options;

    var radius = this._getRadius();

    var indentFromCenter = this._getIndentFromCenter();

    var x = options.x;
    var y = options.y - (radius + indentFromCenter) / 2;
    var width = options.width / 2;
    var length = (radius - indentFromCenter) / 2;
    width > 10 || (width = 10);
    length > 10 || (length = 10);
    return {
      points: [x - width, y - length, x - width, y + length, x + width, y + length, x + width, y - length]
    };
  },
  _render: function _render() {
    var that = this;

    that._renderPointer();
  },
  _clearPointer: function _clearPointer() {
    delete this._element;
  },
  _clear: function _clear() {
    this._clearPointer();
  },
  _getIndentFromCenter: function _getIndentFromCenter(radius) {
    return Number(this._options.indentFromCenter) || 0;
  },
  _getRadius: function _getRadius() {
    return 0;
  },
  measure: function measure(layout) {
    var result = {
      max: layout.radius
    };

    if (this._options.indentFromCenter < 0) {
      result.inverseHorizontalOffset = result.inverseVerticalOffset = -_Number(this._options.indentFromCenter);
    }

    return result;
  },
  getTooltipParameters: function getTooltipParameters() {
    var options = this._options;

    var cosSin = _getCosAndSin(this._actualPosition);

    var r = (this._getRadius() + this._getIndentFromCenter()) / 2;
    return {
      x: options.x + cosSin.cos * r,
      y: options.y - cosSin.sin * r,
      value: this._currentValue,
      color: options.color,
      offset: options.width / 2
    };
  }
});

var NeedleIndicator = SimpleIndicator.inherit({
  _isVisible: function _isVisible(layout) {
    var indentFromCenter = this._adjustOffset(Number(this._options.indentFromCenter), layout.radius);

    var offset = this._adjustOffset(Number(this._options.offset), layout.radius);

    return layout.radius - indentFromCenter - offset > 0;
  },
  getOffset: function getOffset() {
    return 0;
  },
  _adjustOffset: function _adjustOffset(value, radius) {
    var minRadius = Number(this._options.beginAdaptingAtRadius);
    var diff = radius / minRadius;

    if (diff < 1) {
      value = Math.floor(value * diff);
    }

    return value || 0;
  },
  _getIndentFromCenter: function _getIndentFromCenter(radius) {
    return this._adjustOffset(Number(this._options.indentFromCenter), this._options.radius);
  },
  _getRadius: function _getRadius() {
    var options = this._options;
    return options.radius - this._adjustOffset(Number(options.offset), options.radius);
  },
  _renderSpindle: function _renderSpindle() {
    var that = this;
    var options = that._options;
    var radius = options.radius;
    var spindleSize = this._adjustOffset(_Number(options.spindleSize) / 2, radius) * 2;
    var gapSize = this._adjustOffset(_Number(options.spindleGapSize) / 2, radius) * 2 || 0;

    if (gapSize > 0) {
      gapSize = gapSize <= spindleSize ? gapSize : spindleSize;
    }

    if (spindleSize > 0) {
      that._spindleOuter = that._spindleOuter || that._renderer.circle().append(that._rootElement);
      that._spindleInner = that._spindleInner || that._renderer.circle().append(that._rootElement);

      that._spindleOuter.attr({
        'class': 'dxg-spindle-border',
        cx: options.x,
        cy: options.y,
        r: spindleSize / 2
      });

      that._spindleInner.attr({
        'class': 'dxg-spindle-hole',
        cx: options.x,
        cy: options.y,
        r: gapSize / 2,
        fill: options.containerBackgroundColor
      });
    }
  },
  _render: function _render() {
    var that = this;
    that.callBase();

    that._renderSpindle();
  },
  _clear: function _clear() {
    this.callBase();
    delete this._spindleOuter;
    delete this._spindleInner;
  }
});
var rectangleNeedle = NeedleIndicator.inherit({
  _renderPointer: function _renderPointer() {
    var that = this;
    var options = that._options;

    var y2 = options.y - this._getRadius();

    var y1 = options.y - this._getIndentFromCenter();

    var x1 = options.x - options.width / 2;

    var x2 = x1 + _Number(options.width);

    that._element = that._element || that._renderer.path([], 'area').append(that._rootElement);

    that._element.attr({
      points: [x1, y1, x1, y2, x2, y2, x2, y1]
    });
  }
});
exports.rectangleneedle = exports._default = rectangleNeedle;
var triangleNeedle = NeedleIndicator.inherit({
  _renderPointer: function _renderPointer() {
    var that = this;
    var options = that._options;

    var y2 = options.y - this._getRadius();

    var y1 = options.y - this._getIndentFromCenter();

    var x1 = options.x - options.width / 2;
    var x2 = options.x + options.width / 2;
    that._element = that._element || that._renderer.path([], 'area').append(that._rootElement);

    that._element.attr({
      points: [x1, y1, options.x, y2, x2, y1]
    });
  }
});
exports.triangleneedle = triangleNeedle;
var twoColorNeedle = NeedleIndicator.inherit({
  _renderPointer: function _renderPointer() {
    var that = this;
    var options = that._options;
    var x1 = options.x - options.width / 2;
    var x2 = options.x + options.width / 2;

    var y4 = options.y - this._getRadius();

    var y1 = options.y - this._getIndentFromCenter();

    var fraction = _Number(options.secondFraction) || 0;
    var y2;
    var y3; //  B253863

    if (fraction >= 1) {
      y2 = y3 = y1;
    } else if (fraction <= 0) {
      y2 = y3 = y4;
    } else {
      y3 = y4 + (y1 - y4) * fraction;
      y2 = y3 + _Number(options.space);
    }

    that._firstElement = that._firstElement || that._renderer.path([], 'area').append(that._rootElement);
    that._spaceElement = that._spaceElement || that._renderer.path([], 'area').append(that._rootElement);
    that._secondElement = that._secondElement || that._renderer.path([], 'area').append(that._rootElement);

    that._firstElement.attr({
      points: [x1, y1, x1, y2, x2, y2, x2, y1]
    });

    that._spaceElement.attr({
      points: [x1, y2, x1, y3, x2, y3, x2, y2],
      'class': 'dxg-hole',
      fill: options.containerBackgroundColor
    });

    that._secondElement.attr({
      points: [x1, y3, x1, y4, x2, y4, x2, y3],
      'class': 'dxg-part',
      fill: options.secondColor
    });
  },
  _clearPointer: function _clearPointer() {
    delete this._firstElement;
    delete this._secondElement;
    delete this._spaceElement;
  }
}); // The following is from circularMarker.js

exports.twocolorneedle = twoColorNeedle;
var triangleMarker = SimpleIndicator.inherit({
  _isEnabled: function _isEnabled() {
    return this._options.length > 0 && this._options.width > 0;
  },
  _isVisible: function _isVisible(layout) {
    return layout.radius > 0;
  },
  _render: function _render() {
    var that = this;
    var options = that._options;
    var x = options.x;
    var y1 = options.y - options.radius;
    var dx = options.width / 2 || 0;

    var y2 = y1 - _Number(options.length);

    that._element = that._element || that._renderer.path([], 'area').append(that._rootElement);
    var settings = {
      points: [x, y1, x - dx, y2, x + dx, y2],
      stroke: 'none',
      'stroke-width': 0,
      'stroke-linecap': 'square'
    };

    if (options.space > 0) {
      settings['stroke-width'] = Math.min(options.space, options.width / 4) || 0;
      settings.stroke = settings['stroke-width'] > 0 ? options.containerBackgroundColor || 'none' : 'none';
    }

    that._element.attr(settings).sharp();
  },
  _clear: function _clear() {
    delete this._element;
  },
  _getTrackerSettings: function _getTrackerSettings() {
    var options = this._options;
    var x = options.x;
    var y = options.y - options.radius - options.length / 2;
    var width = options.width / 2;
    var length = options.length / 2;
    width > 10 || (width = 10);
    length > 10 || (length = 10);
    return {
      points: [x - width, y - length, x - width, y + length, x + width, y + length, x + width, y - length]
    };
  },
  measure: function measure(layout) {
    return {
      min: layout.radius,
      max: layout.radius + _Number(this._options.length)
    };
  },
  getTooltipParameters: function getTooltipParameters() {
    var options = this._options;

    var cosSin = _getCosAndSin(this._actualPosition);

    var r = options.radius + options.length / 2;
    var parameters = this.callBase();
    parameters.x = options.x + cosSin.cos * r;
    parameters.y = options.y - cosSin.sin * r;
    parameters.offset = options.length / 2;
    return parameters;
  }
});
exports.trianglemarker = triangleMarker;

var textCloud = _base_indicators.BaseTextCloudMarker.inherit({
  _isEnabled: function _isEnabled() {
    return true;
  },
  _isVisible: function _isVisible(layout) {
    return layout.radius > 0;
  },
  _getTextCloudOptions: function _getTextCloudOptions() {
    var that = this;

    var cosSin = _getCosAndSin(that._actualPosition);

    var nAngle = (0, _utils.normalizeAngle)(that._actualPosition);
    return {
      x: that._options.x + cosSin.cos * that._options.radius,
      y: that._options.y - cosSin.sin * that._options.radius,
      type: nAngle > 270 ? 'left-top' : nAngle > 180 ? 'top-right' : nAngle > 90 ? 'right-bottom' : 'bottom-left'
    };
  },
  measure: function measure(layout) {
    var that = this;
    var arrowLength = _Number(that._options.arrowLength) || 0;

    that._measureText();

    var verticalOffset = that._textFullHeight + arrowLength;
    var horizontalOffset = that._textFullWidth + arrowLength;
    return {
      min: layout.radius,
      max: layout.radius,
      horizontalOffset: horizontalOffset,
      verticalOffset: verticalOffset,
      inverseHorizontalOffset: horizontalOffset,
      inverseVerticalOffset: verticalOffset
    };
  }
}); // The following is from circularRangeBar.js


exports.textcloud = textCloud;

var rangeBar = _base_indicators.BaseRangeBar.inherit({
  _isEnabled: function _isEnabled() {
    return this._options.size > 0;
  },
  _isVisible: function _isVisible(layout) {
    return layout.radius - _Number(this._options.size) > 0;
  },
  _createBarItem: function _createBarItem() {
    return this._renderer.arc().attr({
      'stroke-linejoin': 'round'
    }).append(this._rootElement);
  },
  _createTracker: function _createTracker() {
    return this._renderer.arc().attr({
      'stroke-linejoin': 'round'
    });
  },
  _setBarSides: function _setBarSides() {
    var that = this;
    that._maxSide = that._options.radius;
    that._minSide = that._maxSide - _Number(that._options.size);
  },
  _getSpace: function _getSpace() {
    var options = this._options;
    return options.space > 0 ? options.space * 180 / options.radius / Math.PI : 0;
  },
  _isTextVisible: function _isTextVisible() {
    var options = this._options.text || {};
    return options.indent > 0;
  },
  _setTextItemsSides: function _setTextItemsSides() {
    var that = this;
    var options = that._options;

    var indent = _Number(options.text.indent);

    that._lineFrom = options.y - options.radius;
    that._lineTo = that._lineFrom - indent;
    that._textRadius = options.radius + indent;
  },
  _getPositions: function _getPositions() {
    var that = this;
    var basePosition = that._basePosition;
    var actualPosition = that._actualPosition;
    var mainPosition1;
    var mainPosition2;

    if (basePosition >= actualPosition) {
      mainPosition1 = basePosition;
      mainPosition2 = actualPosition;
    } else {
      mainPosition1 = actualPosition;
      mainPosition2 = basePosition;
    }

    return {
      start: that._startPosition,
      end: that._endPosition,
      main1: mainPosition1,
      main2: mainPosition2,
      back1: Math.min(mainPosition1 + that._space, that._startPosition),
      back2: Math.max(mainPosition2 - that._space, that._endPosition)
    };
  },
  _buildItemSettings: function _buildItemSettings(from, to) {
    var that = this;
    return {
      x: that._options.x,
      y: that._options.y,
      innerRadius: that._minSide,
      outerRadius: that._maxSide,
      startAngle: to,
      endAngle: from
    };
  },
  _updateTextPosition: function _updateTextPosition() {
    var that = this;

    var cosSin = _getCosAndSin(that._actualPosition);

    var x = that._options.x + that._textRadius * cosSin.cos;
    var y = that._options.y - that._textRadius * cosSin.sin;
    x += cosSin.cos * that._textWidth * 0.6;
    y -= cosSin.sin * that._textHeight * 0.6;

    that._text.attr({
      x: x,
      y: y + that._textVerticalOffset
    });
  },
  _updateLinePosition: function _updateLinePosition() {
    var that = this;
    var x = that._options.x;
    var x1;
    var x2;

    if (that._basePosition > that._actualPosition) {
      x1 = x - 2;
      x2 = x;
    } else if (that._basePosition < that._actualPosition) {
      x1 = x;
      x2 = x + 2;
    } else {
      x1 = x - 1;
      x2 = x + 1;
    }

    that._line.attr({
      points: [x1, that._lineFrom, x1, that._lineTo, x2, that._lineTo, x2, that._lineFrom]
    }).rotate(_convertAngleToRendererSpace(that._actualPosition), x, that._options.y).sharp();
  },
  _getTooltipPosition: function _getTooltipPosition() {
    var that = this;

    var cosSin = _getCosAndSin((that._basePosition + that._actualPosition) / 2);

    var r = (that._minSide + that._maxSide) / 2;
    return {
      x: that._options.x + cosSin.cos * r,
      y: that._options.y - cosSin.sin * r
    };
  },
  measure: function measure(layout) {
    var that = this;
    var result = {
      min: layout.radius - _Number(that._options.size),
      max: layout.radius
    };

    that._measureText();

    if (that._hasText) {
      result.max += _Number(that._options.text.indent);
      result.horizontalOffset = that._textWidth;
      result.verticalOffset = that._textHeight;
    }

    return result;
  }
});
/* eslint-disable spellcheck/spell-checker */


exports.rangebar = rangeBar;

/***/ }),
/* 1077 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _base_range_container = _interopRequireDefault(__webpack_require__(603));

var _utils = __webpack_require__(14);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _Number = Number;
var _max = Math.max;

var CircularRangeContainer = _base_range_container.default.inherit({
  _processOptions: function _processOptions() {
    var that = this;
    that._inner = that._outer = 0;

    switch ((0, _utils.normalizeEnum)(that._options.orientation)) {
      case 'inside':
        that._inner = 1;
        break;

      case 'center':
        that._inner = that._outer = 0.5;
        break;

      default:
        that._outer = 1;
        break;
    }
  },
  _isVisible: function _isVisible(layout) {
    var width = this._options.width;
    width = _Number(width) || _max(_Number(width.start), _Number(width.end));
    return layout.radius - this._inner * width > 0;
  },
  _createRange: function _createRange(range, layout) {
    var that = this;
    var width = (range.startWidth + range.endWidth) / 2;
    return that._renderer.arc(layout.x, layout.y, layout.radius - that._inner * width, layout.radius + that._outer * width, that._translator.translate(range.end), that._translator.translate(range.start)).attr({
      'stroke-linejoin': 'round'
    });
  },
  measure: function measure(layout) {
    var width = this._options.width;
    width = _Number(width) || _max(_Number(width.start), _Number(width.end));
    return {
      min: layout.radius - this._inner * width,
      max: layout.radius + this._outer * width
    };
  }
});

var _default = CircularRangeContainer;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1078 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _bar_gauge = __webpack_require__(1079);

var _default = _bar_gauge.dxBarGauge;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1079 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.dxBarGauge = void 0;

var _component_registrator = _interopRequireDefault(__webpack_require__(9));

var _object = __webpack_require__(52);

var _common = __webpack_require__(4);

var _extend2 = __webpack_require__(0);

var _utils = __webpack_require__(14);

var _base_gauge = __webpack_require__(210);

var _circular_gauge = _interopRequireDefault(__webpack_require__(604));

var _legend = __webpack_require__(239);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PI_DIV_180 = Math.PI / 180;
var _abs = Math.abs;
var _round = Math.round;
var _floor = Math.floor;
var _min = Math.min;
var _max = Math.max;
var _getSampleText = _base_gauge.getSampleText;
var _formatValue = _base_gauge.formatValue;
var _compareArrays = _base_gauge.compareArrays;
var _isArray = Array.isArray;
var _convertAngleToRendererSpace = _utils.convertAngleToRendererSpace;
var _getCosAndSin = _utils.getCosAndSin;
var _patchFontOptions = _utils.patchFontOptions;
var _Number = Number;
var _isFinite = isFinite;
var _noop = _common.noop;
var _extend = _extend2.extend;
var OPTION_VALUES = 'values';
var BarWrapper;

var dxBarGauge = _base_gauge.BaseGauge.inherit({
  _rootClass: 'dxbg-bar-gauge',
  _themeSection: 'barGauge',
  _fontFields: ['label.font', 'legend.font', 'legend.title.font', 'legend.title.subtitle.font'],
  _initCore: function _initCore() {
    var that = this;
    that.callBase.apply(that, arguments);
    that._barsGroup = that._renderer.g().attr({
      'class': 'dxbg-bars'
    }).linkOn(that._renderer.root, 'bars');
    that._values = [];
    that._context = {
      renderer: that._renderer,
      translator: that._translator,
      tracker: that._tracker,
      group: that._barsGroup
    };

    that._animateStep = function (pos) {
      var bars = that._bars;
      var i;
      var ii;

      for (i = 0, ii = bars.length; i < ii; ++i) {
        bars[i].animate(pos);
      }
    };

    that._animateComplete = function () {
      that._bars.forEach(function (bar) {
        return bar.endAnimation();
      });

      that._checkOverlap();
    };
  },
  _disposeCore: function _disposeCore() {
    var that = this;

    that._barsGroup.linkOff();

    that._barsGroup = that._values = that._context = that._animateStep = that._animateComplete = null;
    that.callBase.apply(that, arguments);
  },
  _setupDomainCore: function _setupDomainCore() {
    var that = this;
    var startValue = that.option('startValue');
    var endValue = that.option('endValue');
    _isFinite(startValue) || (startValue = 0);
    _isFinite(endValue) || (endValue = 100);

    that._translator.setDomain(startValue, endValue);

    that._baseValue = that._translator.adjust(that.option('baseValue'));
    _isFinite(that._baseValue) || (that._baseValue = startValue < endValue ? startValue : endValue);
  },
  _getDefaultSize: function _getDefaultSize() {
    return {
      width: 300,
      height: 300
    };
  },
  _setupCodomain: _circular_gauge.default.prototype._setupCodomain,
  _getApproximateScreenRange: function _getApproximateScreenRange() {
    var that = this;
    var sides = that._area.sides;
    var width = that._canvas.width / (sides.right - sides.left);
    var height = that._canvas.height / (sides.down - sides.up);
    var r = width < height ? width : height;
    return -that._translator.getCodomainRange() * r * PI_DIV_180;
  },
  _setupAnimationSettings: function _setupAnimationSettings() {
    var that = this;
    that.callBase.apply(that, arguments);

    if (that._animationSettings) {
      that._animationSettings.step = that._animateStep;
      that._animationSettings.complete = that._animateComplete;
    }
  },
  _cleanContent: function _cleanContent() {
    var that = this;

    that._barsGroup.linkRemove();

    that._animationSettings && that._barsGroup.stopAnimation();

    that._barsGroup.clear();
  },
  _renderContent: function _renderContent() {
    var that = this;
    var labelOptions = that.option('label');
    var text;
    var bBox;
    var context = that._context;

    that._barsGroup.linkAppend();

    context.textEnabled = labelOptions === undefined || labelOptions && (!('visible' in labelOptions) || labelOptions.visible);

    if (context.textEnabled) {
      context.textColor = labelOptions && labelOptions.font && labelOptions.font.color || null;
      labelOptions = _extend(true, {}, that._themeManager.theme().label, labelOptions);
      context.formatOptions = {
        format: labelOptions.format !== undefined ? labelOptions.format : that._defaultFormatOptions,
        customizeText: labelOptions.customizeText
      };
      context.textOptions = {
        align: 'center'
      };
      context.fontStyles = _patchFontOptions(_extend({}, that._themeManager.theme().label.font, labelOptions.font, {
        color: null
      }));
      that._textIndent = labelOptions.indent > 0 ? _Number(labelOptions.indent) : 0;
      context.lineWidth = labelOptions.connectorWidth > 0 ? _Number(labelOptions.connectorWidth) : 0;
      context.lineColor = labelOptions.connectorColor || null;
      text = that._renderer.text(_getSampleText(that._translator, context.formatOptions), 0, 0).attr(context.textOptions).css(context.fontStyles).append(that._barsGroup);
      bBox = text.getBBox();
      text.remove();
      context.textY = bBox.y;
      context.textWidth = bBox.width;
      context.textHeight = bBox.height;
    }

    _circular_gauge.default.prototype._applyMainLayout.call(that);

    that._renderBars();
  },
  _measureMainElements: function _measureMainElements() {
    var result = {
      maxRadius: this._area.radius
    };

    if (this._context.textEnabled) {
      result.horizontalMargin = this._context.textWidth;
      result.verticalMargin = this._context.textHeight;
      result.inverseHorizontalMargin = this._context.textWidth / 2;
      result.inverseVerticalMargin = this._context.textHeight / 2;
    }

    return result;
  },
  _renderBars: function _renderBars() {
    var that = this;

    var options = _extend({}, that._themeManager.theme(), that.option());

    var radius;
    var area = that._area;
    var relativeInnerRadius = options.relativeInnerRadius > 0 && options.relativeInnerRadius < 1 ? _Number(options.relativeInnerRadius) : 0.1;
    radius = area.radius;

    if (that._context.textEnabled) {
      //  B253614
      that._textIndent = _round(_min(that._textIndent, radius / 2));
      radius -= that._textIndent;
    }

    that._outerRadius = _floor(radius);
    that._innerRadius = _floor(radius * relativeInnerRadius);
    that._barSpacing = options.barSpacing > 0 ? _Number(options.barSpacing) : 0;

    _extend(that._context, {
      backgroundColor: options.backgroundColor,
      x: area.x,
      y: area.y,
      startAngle: area.startCoord,
      endAngle: area.endCoord,
      baseAngle: that._translator.translate(that._baseValue)
    });

    that._arrangeBars();
  },
  _arrangeBars: function _arrangeBars() {
    var that = this;
    var radius = that._outerRadius - that._innerRadius;
    var context = that._context;
    var i;
    var count = that._bars.length;

    that._beginValueChanging();

    context.barSize = count > 0 ? _max((radius - (count - 1) * that._barSpacing) / count, 1) : 0;
    var spacing = count > 1 ? _max(_min((radius - count * context.barSize) / (count - 1), that._barSpacing), 0) : 0;

    var _count = _min(_floor((radius + spacing) / context.barSize), count);

    that._setBarsCount(count);

    radius = that._outerRadius;
    context.textRadius = radius;
    context.textIndent = that._textIndent;

    that._palette.reset();

    var unitOffset = context.barSize + spacing;

    var colors = that._palette.generateColors(_count);

    for (i = 0; i < _count; ++i, radius -= unitOffset) {
      that._bars[i].arrange({
        radius: radius,
        color: colors[i]
      });
    }

    for (var _i = _count; _i < count; _i++) {
      that._bars[_i].hide();
    }

    if (that._animationSettings && !that._noAnimation) {
      that._animateBars();
    } else {
      that._updateBars();
    }

    that._endValueChanging();
  },
  _setBarsCount: function _setBarsCount() {
    var that = this;

    if (that._bars.length > 0) {
      if (that._dummyBackground) {
        that._dummyBackground.dispose();

        that._dummyBackground = null;
      }
    } else {
      if (!that._dummyBackground) {
        that._dummyBackground = that._renderer.arc().attr({
          'stroke-linejoin': 'round'
        });
      }

      that._dummyBackground.attr({
        //  Because of vizMocks
        x: that._context.x,
        y: that._context.y,
        outerRadius: that._outerRadius,
        innerRadius: that._innerRadius,
        startAngle: that._context.endAngle,
        endAngle: that._context.startAngle,
        fill: that._context.backgroundColor
      }).append(that._barsGroup);
    }
  },
  _updateBars: function _updateBars() {
    this._bars.forEach(function (bar) {
      return bar.applyValue();
    });

    this._checkOverlap();
  },
  _checkOverlap: function _checkOverlap() {
    var that = this;
    var bars = that._bars;
    var overlapStrategy = (0, _utils.normalizeEnum)(that._getOption('resolveLabelOverlapping', true));

    if (overlapStrategy === 'none') {
      return;
    }

    var sortedBars = bars.concat().sort(function (a, b) {
      return a.getValue() - b.getValue();
    });
    var currentIndex = 0;
    var nextIndex = 1;

    while (currentIndex < sortedBars.length && nextIndex < sortedBars.length) {
      var current = sortedBars[currentIndex];
      var next = sortedBars[nextIndex];

      if (current.checkIntersect(next)) {
        next.hideLabel();
        nextIndex++;
      } else {
        currentIndex = nextIndex;
        nextIndex = currentIndex + 1;
      }
    }
  },
  _animateBars: function _animateBars() {
    var that = this;
    var i;
    var ii = that._bars.length;

    if (ii > 0) {
      for (i = 0; i < ii; ++i) {
        that._bars[i].beginAnimation();
      }

      that._barsGroup.animate({
        _: 0
      }, that._animationSettings);
    }
  },
  _buildNodes: function _buildNodes() {
    var that = this;

    var options = that._options.silent();

    that._palette = that._themeManager.createPalette(options.palette, {
      useHighlight: true,
      extensionMode: options.paletteExtensionMode
    });

    that._palette.reset();

    that._bars = that._bars || [];
    that._animationSettings && that._barsGroup.stopAnimation();

    var barValues = that._values.filter(_isFinite);

    var count = barValues.length;

    if (that._bars.length > count) {
      var ii = that._bars.length;

      for (var i = count; i < ii; ++i) {
        that._bars[i].dispose();
      }

      that._bars.splice(count, ii - count);
    } else if (that._bars.length < count) {
      for (var _i2 = that._bars.length; _i2 < count; ++_i2) {
        that._bars.push(new BarWrapper(_i2, that._context));
      }
    }

    that._bars.forEach(function (bar, index) {
      bar.update({
        color: that._palette.getNextColor(count),
        value: barValues[index]
      });
    });
  },
  _updateValues: function _updateValues(values) {
    var that = this;
    var list = _isArray(values) && values || _isFinite(values) && [values] || [];
    var i;
    var ii = list.length;
    var value;
    that._values.length = ii;

    for (i = 0; i < ii; ++i) {
      value = list[i];
      that._values[i] = _Number(_isFinite(value) ? value : that._values[i]);
    }

    if (!that._resizing) {
      if (!_compareArrays(that._values, that.option(OPTION_VALUES))) {
        that.option(OPTION_VALUES, that._values.slice());
      }
    }

    this._change(['NODES']);
  },
  values: function values(arg) {
    if (arg !== undefined) {
      this._updateValues(arg);

      return this;
    } else {
      return this._values.slice(0);
    }
  },
  _optionChangesMap: {
    backgroundColor: 'MOSTLY_TOTAL',
    relativeInnerRadius: 'MOSTLY_TOTAL',
    barSpacing: 'MOSTLY_TOTAL',
    label: 'MOSTLY_TOTAL',
    resolveLabelOverlapping: 'MOSTLY_TOTAL',
    palette: 'MOSTLY_TOTAL',
    paletteExtensionMode: 'MOSTLY_TOTAL',
    values: 'VALUES'
  },
  _change_VALUES: function _change_VALUES() {
    this._updateValues(this.option(OPTION_VALUES));
  },
  _factory: (0, _object.clone)(_base_gauge.BaseGauge.prototype._factory),
  _optionChangesOrder: ['VALUES', 'NODES'],
  _initialChanges: ['VALUES'],
  _change_NODES: function _change_NODES() {
    this._buildNodes();
  },
  _change_MOSTLY_TOTAL: function _change_MOSTLY_TOTAL() {
    this._change(['NODES']);

    this.callBase();
  },
  _proxyData: [],
  _getLegendData: function _getLegendData() {
    var that = this;
    var formatOptions = {};

    var options = that._options.silent();

    var labelFormatOptions = (options.label || {}).format;
    var legendFormatOptions = (options.legend || {}).itemTextFormat;

    if (legendFormatOptions) {
      formatOptions.format = legendFormatOptions;
    } else {
      formatOptions.format = labelFormatOptions || that._defaultFormatOptions;
    }

    return (this._bars || []).map(function (b) {
      return {
        id: b.index,
        item: {
          value: b.getValue(),
          color: b.getColor(),
          index: b.index
        },
        text: _formatValue(b.getValue(), formatOptions),
        visible: true,
        states: {
          normal: {
            fill: b.getColor()
          }
        }
      };
    });
  }
});

exports.dxBarGauge = dxBarGauge;

BarWrapper = function BarWrapper(index, context) {
  var that = this;
  that._context = context;
  that._tracker = context.renderer.arc().attr({
    'stroke-linejoin': 'round'
  });
  that.index = index;
};

_extend(BarWrapper.prototype, {
  dispose: function dispose() {
    var that = this;

    that._background.dispose();

    that._bar.dispose();

    if (that._context.textEnabled) {
      that._line.dispose();

      that._text.dispose();
    }

    that._context.tracker.detach(that._tracker);

    that._context = that._settings = that._background = that._bar = that._line = that._text = that._tracker = null;
    return that;
  },
  arrange: function arrange(options) {
    var that = this;
    var context = that._context;
    this._visible = true;
    context.tracker.attach(that._tracker, that, {
      index: that.index
    });
    that._background = context.renderer.arc().attr({
      'stroke-linejoin': 'round',
      fill: context.backgroundColor
    }).append(context.group);
    that._settings = that._settings || {
      x: context.x,
      y: context.y,
      startAngle: context.baseAngle,
      endAngle: context.baseAngle
    };
    that._bar = context.renderer.arc().attr(_extend({
      'stroke-linejoin': 'round'
    }, that._settings)).append(context.group);

    if (context.textEnabled) {
      that._line = context.renderer.path([], 'line').attr({
        'stroke-width': context.lineWidth
      }).append(context.group);
      that._text = context.renderer.text().css(context.fontStyles).attr(context.textOptions).append(context.group);
    }

    that._angle = isFinite(that._angle) ? that._angle : context.baseAngle;
    that._settings.outerRadius = options.radius;
    that._settings.innerRadius = options.radius - context.barSize;
    that._settings.x = context.x;
    that._settings.y = context.y;

    that._background.attr(_extend({}, that._settings, {
      startAngle: context.endAngle,
      endAngle: context.startAngle,
      fill: that._context.backgroundColor
    }));

    that._bar.attr({
      x: context.x,
      y: context.y,
      outerRadius: that._settings.outerRadius,
      innerRadius: that._settings.innerRadius,
      fill: that._color
    });

    that._tracker.attr(that._settings);

    if (context.textEnabled) {
      that._line.attr({
        points: [context.x, context.y - that._settings.innerRadius, context.x, context.y - context.textRadius - context.textIndent],
        stroke: context.lineColor || that._color
      }).sharp();

      that._text.css({
        fill: context.textColor || that._color
      });
    }

    return that;
  },
  getTooltipParameters: function getTooltipParameters() {
    var that = this;

    var cosSin = _getCosAndSin((that._angle + that._context.baseAngle) / 2);

    return {
      x: _round(that._context.x + (that._settings.outerRadius + that._settings.innerRadius) / 2 * cosSin.cos),
      y: _round(that._context.y - (that._settings.outerRadius + that._settings.innerRadius) / 2 * cosSin.sin),
      offset: 0,
      color: that._color,
      value: that._value
    };
  },
  setAngle: function setAngle(angle) {
    var that = this;
    var context = that._context;
    var settings = that._settings;
    var cosSin;
    that._angle = angle;
    setAngles(settings, context.baseAngle, angle);

    that._bar.attr(settings);

    that._tracker.attr(settings);

    if (context.textEnabled) {
      cosSin = _getCosAndSin(angle);
      var indent = context.textIndent;
      var radius = context.textRadius + indent;
      var x = context.x + radius * cosSin.cos;
      var y = context.y - radius * cosSin.sin;
      var halfWidth = context.textWidth * 0.5;
      var textHeight = context.textHeight;
      var textY = context.textY;

      if (_abs(x - context.x) > indent) {
        x += x < context.x ? -halfWidth : halfWidth;
      }

      if (_abs(y - context.y) <= indent) {
        y -= textY + textHeight * 0.5;
      } else {
        y -= y < context.y ? textY + textHeight : textY;
      }

      var text = _formatValue(that._value, context.formatOptions, {
        index: that.index
      });

      var visibility = text === '' ? 'hidden' : null;

      that._text.attr({
        text: text,
        x: x,
        y: y,
        visibility: visibility
      });

      that._line.attr({
        visibility: visibility
      });

      that._line.rotate(_convertAngleToRendererSpace(angle), context.x, context.y);
    }

    return that;
  },
  hideLabel: function hideLabel() {
    this._text.attr({
      visibility: 'hidden'
    });

    this._line.attr({
      visibility: 'hidden'
    });
  },
  checkIntersect: function checkIntersect(anotherBar) {
    var coords = this.calculateLabelCoords();
    var anotherCoords = anotherBar.calculateLabelCoords();

    if (!coords || !anotherCoords) {
      return false;
    }

    var width = Math.max(0, Math.min(coords.bottomRight.x, anotherCoords.bottomRight.x) - Math.max(coords.topLeft.x, anotherCoords.topLeft.x));
    var height = Math.max(0, Math.min(coords.bottomRight.y, anotherCoords.bottomRight.y) - Math.max(coords.topLeft.y, anotherCoords.topLeft.y));
    return width * height !== 0;
  },
  calculateLabelCoords: function calculateLabelCoords() {
    if (!this._text) {
      return;
    }

    var box = this._text.getBBox();

    return {
      topLeft: {
        x: box.x,
        y: box.y
      },
      bottomRight: {
        x: box.x + box.width,
        y: box.y + box.height
      }
    };
  },
  _processValue: function _processValue(value) {
    return this._context.translator.translate(this._context.translator.adjust(value));
  },
  applyValue: function applyValue() {
    if (!this._visible) {
      return this;
    }

    return this.setAngle(this._processValue(this.getValue()));
  },
  update: function update(_ref) {
    var color = _ref.color,
        value = _ref.value;
    this._color = color;
    this._value = value;
  },
  hide: function hide() {
    this._visible = false;
  },
  getColor: function getColor() {
    return this._color;
  },
  getValue: function getValue() {
    return this._value;
  },
  beginAnimation: function beginAnimation() {
    if (!this._visible) {
      return this;
    }

    var that = this;

    var angle = this._processValue(this.getValue());

    if (!compareFloats(that._angle, angle)) {
      that._start = that._angle;
      that._delta = angle - that._angle;

      that._tracker.attr({
        visibility: 'hidden'
      });

      if (that._context.textEnabled) {
        that._line.attr({
          visibility: 'hidden'
        });

        that._text.attr({
          visibility: 'hidden'
        });
      }
    } else {
      that.animate = _noop;
      that.setAngle(that._angle);
    }
  },
  animate: function animate(pos) {
    if (!this._visible) {
      return this;
    }

    var that = this;
    that._angle = that._start + that._delta * pos;
    setAngles(that._settings, that._context.baseAngle, that._angle);

    that._bar.attr(that._settings);
  },
  endAnimation: function endAnimation() {
    var that = this;

    if (that._delta !== undefined) {
      if (compareFloats(that._angle, that._start + that._delta)) {
        that._tracker.attr({
          visibility: null
        });

        that.setAngle(that._angle);
      }
    } else {
      delete that.animate;
    }

    delete that._start;
    delete that._delta;
  }
});

function setAngles(target, angle1, angle2) {
  target.startAngle = angle1 < angle2 ? angle1 : angle2;
  target.endAngle = angle1 < angle2 ? angle2 : angle1;
}

function compareFloats(value1, value2) {
  return _abs(value1 - value2) < 0.0001;
}

(0, _component_registrator.default)('dxBarGauge', dxBarGauge);
dxBarGauge.addPlugin(_legend.plugin);

/***/ }),
/* 1080 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _range_selector = _interopRequireDefault(__webpack_require__(1081));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = _range_selector.default;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1081 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _component_registrator = _interopRequireDefault(__webpack_require__(9));

var _type2 = __webpack_require__(1);

var _extend = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _utils = __webpack_require__(14);

var _date = _interopRequireDefault(__webpack_require__(18));

var _math = __webpack_require__(31);

var _range = __webpack_require__(141);

var _base_axis = __webpack_require__(349);

var _parse_utils = __webpack_require__(346);

var _format_helper = _interopRequireDefault(__webpack_require__(82));

var _common = __webpack_require__(245);

var _sliders_controller = __webpack_require__(1082);

var _tracker = __webpack_require__(1085);

var _range_view = __webpack_require__(1086);

var _series_data_source = __webpack_require__(1087);

var _tick_generator = __webpack_require__(595);

var _axes_constants = _interopRequireDefault(__webpack_require__(243));

var _base_widget = _interopRequireDefault(__webpack_require__(119));

var _export = __webpack_require__(118);

var _title = __webpack_require__(138);

var _loading_indicator = __webpack_require__(163);

var _data_source = __webpack_require__(186);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _max = Math.max;
var _ceil = Math.ceil;
var _floor = Math.floor;
var START_VALUE = 'startValue';
var END_VALUE = 'endValue';
var DATETIME = 'datetime';
var VALUE = 'value';
var DISCRETE = 'discrete';
var SEMIDISCRETE = 'semidiscrete';
var STRING = 'string';
var VALUE_CHANGED = VALUE + 'Changed';
var CONTAINER_BACKGROUND_COLOR = 'containerBackgroundColor';
var SLIDER_MARKER = 'sliderMarker';
var OPTION_BACKGROUND = 'background';
var LOGARITHMIC = 'logarithmic';
var KEEP = 'keep';
var SHIFT = 'shift';
var RESET = 'reset';
var INVISIBLE_POS = -1000;
var SEMIDISCRETE_GRID_SPACING_FACTOR = 50;
var DEFAULT_AXIS_DIVISION_FACTOR = 30;
var DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 15;
var logarithmBase = 10;

function calculateMarkerHeight(renderer, value, sliderMarkerOptions) {
  var formattedText = value === undefined ? _common.consts.emptySliderMarkerText : (0, _common.formatValue)(value, sliderMarkerOptions);
  var textBBox = getTextBBox(renderer, formattedText, sliderMarkerOptions.font);
  return _ceil(textBBox.height) + 2 * sliderMarkerOptions.paddingTopBottom + _common.consts.pointerSize;
}

function calculateScaleLabelHalfWidth(renderer, value, scaleOptions, tickIntervalsInfo) {
  var formattedText = (0, _common.formatValue)(value, scaleOptions.label, tickIntervalsInfo, scaleOptions.valueType, scaleOptions.type, scaleOptions.logarithmBase);
  var textBBox = getTextBBox(renderer, formattedText, scaleOptions.label.font);
  return _ceil(textBBox.width / 2);
}

function calculateIndents(renderer, scale, sliderMarkerOptions, indentOptions, tickIntervalsInfo) {
  var leftMarkerHeight;
  var leftScaleLabelWidth = 0;
  var rightScaleLabelWidth = 0;
  var rightMarkerHeight;
  var placeholderWidthLeft;
  var placeholderWidthRight;
  var placeholderHeight;
  var ticks = scale.type === 'semidiscrete' ? scale.customTicks : tickIntervalsInfo.ticks;
  var startTickValue;
  var endTickValue;
  indentOptions = indentOptions || {};
  placeholderWidthLeft = indentOptions.left;
  placeholderWidthRight = indentOptions.right;
  placeholderHeight = sliderMarkerOptions.placeholderHeight;

  if (sliderMarkerOptions.visible) {
    leftMarkerHeight = calculateMarkerHeight(renderer, scale.startValue, sliderMarkerOptions);
    rightMarkerHeight = calculateMarkerHeight(renderer, scale.endValue, sliderMarkerOptions);

    if (placeholderHeight === undefined) {
      placeholderHeight = _max(leftMarkerHeight, rightMarkerHeight);
    }
  }

  if (scale.label.visible) {
    startTickValue = (0, _type2.isDefined)(scale.startValue) ? ticks[0] : undefined;
    endTickValue = (0, _type2.isDefined)(scale.endValue) ? ticks[ticks.length - 1] : undefined;
    leftScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, startTickValue, scale, tickIntervalsInfo);
    rightScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, endTickValue, scale, tickIntervalsInfo);
  }

  placeholderWidthLeft = placeholderWidthLeft !== undefined ? placeholderWidthLeft : leftScaleLabelWidth;
  placeholderWidthRight = (placeholderWidthRight !== undefined ? placeholderWidthRight : rightScaleLabelWidth) || 1; // T240698

  return {
    left: placeholderWidthLeft,
    right: placeholderWidthRight,
    top: placeholderHeight || 0,
    bottom: 0
  };
}

function calculateValueType(firstValue, secondValue) {
  var typeFirstValue = (0, _type2.type)(firstValue);
  var typeSecondValue = (0, _type2.type)(secondValue);

  var validType = function validType(type) {
    return typeFirstValue === type || typeSecondValue === type;
  };

  return validType('date') ? DATETIME : validType('number') ? 'numeric' : validType(STRING) ? STRING : '';
}

function showScaleMarkers(scaleOptions) {
  return scaleOptions.valueType === DATETIME && scaleOptions.marker.visible;
}

function updateTranslatorRangeInterval(translatorRange, scaleOptions) {
  var intervalX = scaleOptions.minorTickInterval || scaleOptions.tickInterval;

  if (scaleOptions.valueType === 'datetime') {
    intervalX = _date.default.dateToMilliseconds(intervalX);
  }

  translatorRange.addRange({
    interval: intervalX
  });
}

function checkLogarithmicOptions(options, defaultLogarithmBase, incidentOccurred) {
  if (!options) {
    return;
  }

  var logarithmBase = options.logarithmBase;

  if (options.type === LOGARITHMIC && logarithmBase <= 0 || logarithmBase && !(0, _type2.isNumeric)(logarithmBase)) {
    options.logarithmBase = defaultLogarithmBase;
    incidentOccurred('E2104');
  } else if (options.type !== LOGARITHMIC) {
    options.logarithmBase = undefined;
  }
}

function calculateScaleAreaHeight(renderer, scaleOptions, visibleMarkers, tickIntervalsInfo) {
  var labelScaleOptions = scaleOptions.label;
  var markerScaleOptions = scaleOptions.marker;
  var placeholderHeight = scaleOptions.placeholderHeight;
  var ticks = scaleOptions.type === 'semidiscrete' ? scaleOptions.customTicks : tickIntervalsInfo.ticks;
  var text = (0, _common.formatValue)(ticks[0], labelScaleOptions);

  if (placeholderHeight) {
    return placeholderHeight;
  } else {
    return (labelScaleOptions.visible ? labelScaleOptions.topIndent + getTextBBox(renderer, text, labelScaleOptions.font).height : 0) + (visibleMarkers ? markerScaleOptions.topIndent + markerScaleOptions.separatorHeight : 0);
  }
}

function getMinorTickIntervalUnit(tickInterval, minorTickInterval, withCorrection) {
  var interval = _date.default.getDateUnitInterval(minorTickInterval);

  var majorUnit = _date.default.getDateUnitInterval(tickInterval);

  var idx = _date.default.dateUnitIntervals.indexOf(interval);

  if (withCorrection && interval === majorUnit && idx > 0) {
    interval = _date.default.dateUnitIntervals[idx - 1];
  }

  return interval;
}

function getNextTickInterval(tickInterval, minorTickInterval, isDateType) {
  if (!tickInterval) {
    tickInterval = minorTickInterval;
  } else {
    if (isDateType) {
      tickInterval = _date.default.getNextDateUnit(tickInterval);
    } else {
      tickInterval += minorTickInterval;
    }
  }

  return tickInterval;
}

function calculateTickIntervalsForSemidiscreteScale(scaleOptions, min, max, screenDelta) {
  var minorTickInterval = scaleOptions.minorTickInterval;
  var tickInterval = scaleOptions.tickInterval;
  var interval;
  var isDateType = scaleOptions.valueType === 'datetime';
  var gridSpacingFactor = scaleOptions.axisDivisionFactor || {};
  var tickCountByInterval;
  var tickCountByScreen;

  if (!tickInterval) {
    do {
      interval = getNextTickInterval(tickInterval, minorTickInterval, isDateType);

      if (tickInterval !== interval) {
        tickInterval = interval;
      } else {
        break;
      }

      if (isDateType) {
        interval = _date.default.dateToMilliseconds(tickInterval);
      }

      tickCountByInterval = _ceil((max - min) / interval);
      tickCountByScreen = _floor(screenDelta / (gridSpacingFactor[tickInterval] || SEMIDISCRETE_GRID_SPACING_FACTOR)) || 1;
    } while (interval && tickCountByInterval > tickCountByScreen);
  }

  return {
    tickInterval: tickInterval,
    minorTickInterval: minorTickInterval,
    bounds: {
      minVisible: min,
      maxVisible: max
    },
    ticks: []
  };
}

function updateTickIntervals(scaleOptions, screenDelta, incidentOccurred, range) {
  var result;
  var min = (0, _type2.isDefined)(range.minVisible) ? range.minVisible : range.min;
  var max = (0, _type2.isDefined)(range.maxVisible) ? range.maxVisible : range.max;
  var categoriesInfo = scaleOptions._categoriesInfo;
  var ticksInfo;
  var length;
  var bounds = {};

  if (scaleOptions.type === SEMIDISCRETE) {
    result = calculateTickIntervalsForSemidiscreteScale(scaleOptions, min, max, screenDelta);
  } else {
    ticksInfo = (0, _tick_generator.tickGenerator)({
      axisType: scaleOptions.type,
      dataType: scaleOptions.valueType,
      logBase: scaleOptions.logarithmBase,
      allowNegatives: true,
      linearThreshold: Math.abs(scaleOptions.linearThreshold || 0),
      axisDivisionFactor: scaleOptions.axisDivisionFactor,
      minorAxisDivisionFactor: scaleOptions.minorAxisDivisionFactor,
      calculateMinors: true,
      allowDecimals: scaleOptions.allowDecimals,
      endOnTick: scaleOptions.endOnTick,
      incidentOccurred: incidentOccurred,
      rangeIsEmpty: range.isEmpty()
    })({
      min: min,
      max: max,
      categories: (0, _type2.isDefined)(categoriesInfo) ? categoriesInfo.categories : []
    }, screenDelta, scaleOptions.tickInterval, scaleOptions.forceUserTickInterval, undefined, scaleOptions.minorTickInterval, scaleOptions.minorTickCount);
    length = ticksInfo.ticks.length;
    bounds.minVisible = ticksInfo.ticks[0] < min ? ticksInfo.ticks[0] : min;
    bounds.maxVisible = ticksInfo.ticks[length - 1] > max ? ticksInfo.ticks[length - 1] : max;
    result = {
      tickInterval: ticksInfo.tickInterval,
      minorTickInterval: scaleOptions.minorTickInterval === 0 ? 0 : ticksInfo.minorTickInterval,
      bounds: bounds,
      ticks: ticksInfo.ticks
    };
  }

  return result;
}

function getFirstDayOfWeek(options) {
  var _options$workWeek;

  return (_options$workWeek = options.workWeek) === null || _options$workWeek === void 0 ? void 0 : _options$workWeek[0];
}

function calculateTranslatorRange(seriesDataSource, scaleOptions) {
  var minValue;
  var maxValue;
  var inverted = false;
  var startValue = scaleOptions.startValue;
  var endValue = scaleOptions.endValue;
  var categories;
  var categoriesInfo; // TODO: There should be something like "seriesDataSource.getArgumentRange()"

  var translatorRange = seriesDataSource ? seriesDataSource.getBoundRange().arg : new _range.Range();
  var rangeForCategories;
  var isDate = scaleOptions.valueType === 'datetime';
  var firstDayOfWeek = getFirstDayOfWeek(scaleOptions);
  var minRange = scaleOptions.minRange;

  if (scaleOptions.type === DISCRETE) {
    rangeForCategories = new _range.Range({
      minVisible: startValue,
      maxVisible: endValue
    });
    rangeForCategories.addRange(translatorRange);
    translatorRange = rangeForCategories;
    categories = seriesDataSource ? seriesDataSource.argCategories : scaleOptions.categories || startValue && endValue && [startValue, endValue];
    categories = categories || [];
    scaleOptions._categoriesInfo = categoriesInfo = (0, _utils.getCategoriesInfo)(categories, startValue, endValue);
  }

  if (scaleOptions.type === SEMIDISCRETE) {
    startValue = scaleOptions.startValue = correctValueByInterval(scaleOptions.startValue, isDate, minRange, firstDayOfWeek);
    endValue = scaleOptions.endValue = correctValueByInterval(scaleOptions.endValue, isDate, minRange, firstDayOfWeek);
    translatorRange.minVisible = correctValueByInterval(translatorRange.minVisible, isDate, minRange, firstDayOfWeek);
    translatorRange.maxVisible = correctValueByInterval(translatorRange.maxVisible, isDate, minRange, firstDayOfWeek);
    translatorRange.min = correctValueByInterval(translatorRange.min, isDate, minRange, firstDayOfWeek);
    translatorRange.max = correctValueByInterval(translatorRange.max, isDate, minRange, firstDayOfWeek);
  }

  if ((0, _type2.isDefined)(startValue) && (0, _type2.isDefined)(endValue)) {
    inverted = categoriesInfo ? categoriesInfo.inverted : startValue > endValue;
    minValue = categoriesInfo ? categoriesInfo.start : inverted ? endValue : startValue;
    maxValue = categoriesInfo ? categoriesInfo.end : inverted ? startValue : endValue;
  } else if ((0, _type2.isDefined)(startValue) || (0, _type2.isDefined)(endValue)) {
    minValue = startValue;
    maxValue = endValue;
  } else if (categoriesInfo) {
    minValue = categoriesInfo.start;
    maxValue = categoriesInfo.end;
  }

  translatorRange.addRange({
    invert: inverted,
    min: minValue,
    max: maxValue,
    minVisible: minValue,
    maxVisible: maxValue,
    dataType: scaleOptions.valueType
  });
  translatorRange.addRange({
    categories: !seriesDataSource ? categories : undefined,
    base: scaleOptions.logarithmBase,
    axisType: scaleOptions.type,
    dataType: scaleOptions.valueType
  });
  seriesDataSource && translatorRange.sortCategories(categories);
  return translatorRange;
}

function startEndNotDefined(start, end) {
  return !(0, _type2.isDefined)(start) || !(0, _type2.isDefined)(end);
}

function getTextBBox(renderer, text, fontOptions) {
  var textElement = renderer.text(text, INVISIBLE_POS, INVISIBLE_POS).css((0, _utils.patchFontOptions)(fontOptions)).append(renderer.root);
  var textBBox = textElement.getBBox();
  textElement.remove();
  return textBBox;
}

function getDateMarkerVisibilityChecker(screenDelta) {
  return function (isDateScale, isMarkerVisible, min, max, tickInterval) {
    if (isMarkerVisible && isDateScale) {
      if (!(0, _type2.isDefined)(tickInterval) || tickInterval.years || tickInterval.months >= 6 || screenDelta / SEMIDISCRETE_GRID_SPACING_FACTOR < _ceil((max - min) / _date.default.dateToMilliseconds('year')) + 1) {
        isMarkerVisible = false;
      }
    }

    return isMarkerVisible;
  };
}

function updateScaleOptions(scaleOptions, seriesDataSource, translatorRange, tickIntervalsInfo, checkDateMarkerVisibility) {
  var bounds;
  var isEmptyInterval;
  var categoriesInfo = scaleOptions._categoriesInfo;
  var intervals;
  var isDateTime = scaleOptions.valueType === DATETIME;

  if (seriesDataSource && !seriesDataSource.isEmpty() && !translatorRange.isEmpty()) {
    bounds = tickIntervalsInfo.bounds;
    translatorRange.addRange(bounds);
    scaleOptions.startValue = translatorRange.invert ? bounds.maxVisible : bounds.minVisible;
    scaleOptions.endValue = translatorRange.invert ? bounds.minVisible : bounds.maxVisible;
  }

  scaleOptions.marker.visible = checkDateMarkerVisibility(isDateTime && scaleOptions.type.indexOf(DISCRETE) === -1, scaleOptions.marker.visible, scaleOptions.startValue, scaleOptions.endValue, tickIntervalsInfo.tickInterval);

  if (categoriesInfo) {
    scaleOptions.startValue = categoriesInfo.start;
    scaleOptions.endValue = categoriesInfo.end;
  }

  if (scaleOptions.type.indexOf(DISCRETE) === -1) {
    isEmptyInterval = (0, _type2.isDate)(scaleOptions.startValue) && (0, _type2.isDate)(scaleOptions.endValue) && scaleOptions.startValue.getTime() === scaleOptions.endValue.getTime() || scaleOptions.startValue === scaleOptions.endValue;
  }

  scaleOptions.isEmpty = startEndNotDefined(scaleOptions.startValue, scaleOptions.endValue) || isEmptyInterval;

  if (scaleOptions.isEmpty) {
    scaleOptions.startValue = scaleOptions.endValue = undefined;
  } else {
    scaleOptions.minorTickInterval = tickIntervalsInfo.minorTickInterval;
    scaleOptions.tickInterval = tickIntervalsInfo.tickInterval;

    if (isDateTime && (!(0, _type2.isDefined)(scaleOptions.label.format) || scaleOptions.type === SEMIDISCRETE && scaleOptions.minorTickInterval !== scaleOptions.tickInterval)) {
      if (scaleOptions.type === DISCRETE) {
        scaleOptions.label.format = _format_helper.default.getDateFormatByTicks(tickIntervalsInfo.ticks);
      } else {
        if (!scaleOptions.marker.visible) {
          scaleOptions.label.format = _format_helper.default.getDateFormatByTickInterval(scaleOptions.startValue, scaleOptions.endValue, scaleOptions.tickInterval);
        } else {
          scaleOptions.label.format = _date.default.getDateFormatByTickInterval(scaleOptions.tickInterval);
        }
      }
    }
  }

  if (scaleOptions.type === SEMIDISCRETE) {
    intervals = getIntervalCustomTicks(scaleOptions);
    scaleOptions.customMinorTicks = intervals.altIntervals;
    scaleOptions.customTicks = intervals.intervals;
    scaleOptions.customBoundTicks = [scaleOptions.customTicks[0]];
  }
}

function prepareScaleOptions(scaleOption, calculatedValueType, incidentOccurred, containerColor) {
  var parsedValue = 0;
  var valueType = (0, _parse_utils.correctValueType)((0, _utils.normalizeEnum)(scaleOption.valueType));

  var validateStartEndValues = function validateStartEndValues(field, parser) {
    var messageToIncidentOccurred = field === START_VALUE ? 'start' : 'end';

    if ((0, _type2.isDefined)(scaleOption[field])) {
      parsedValue = parser(scaleOption[field]);

      if ((0, _type2.isDefined)(parsedValue)) {
        scaleOption[field] = parsedValue;
      } else {
        scaleOption[field] = undefined;
        incidentOccurred('E2202', [messageToIncidentOccurred]);
      }
    }
  };

  valueType = calculatedValueType || valueType;

  if (!valueType) {
    valueType = calculateValueType(scaleOption.startValue, scaleOption.endValue) || 'numeric';
  }

  if (valueType === STRING || scaleOption.categories) {
    scaleOption.type = DISCRETE;
    valueType = STRING;
  }

  scaleOption.containerColor = containerColor;
  scaleOption.valueType = valueType;
  scaleOption.dataType = valueType;
  var parser = (0, _parse_utils.getParser)(valueType);
  validateStartEndValues(START_VALUE, parser);
  validateStartEndValues(END_VALUE, parser);
  checkLogarithmicOptions(scaleOption, logarithmBase, incidentOccurred);

  if (!scaleOption.type) {
    scaleOption.type = 'continuous';
  }

  scaleOption.parser = parser;

  if (scaleOption.type === SEMIDISCRETE) {
    scaleOption.minorTick.visible = false;
    scaleOption.minorTickInterval = scaleOption.minRange;
    scaleOption.marker.visible = false;
    scaleOption.maxRange = undefined;
  }

  scaleOption.forceUserTickInterval |= (0, _type2.isDefined)(scaleOption.tickInterval) && !(0, _type2.isDefined)(scaleOption.axisDivisionFactor);
  scaleOption.axisDivisionFactor = (0, _type2.isDefined)(scaleOption.axisDivisionFactor) ? scaleOption.axisDivisionFactor : DEFAULT_AXIS_DIVISION_FACTOR;
  scaleOption.minorAxisDivisionFactor = (0, _type2.isDefined)(scaleOption.minorAxisDivisionFactor) ? scaleOption.minorAxisDivisionFactor : DEFAULT_MINOR_AXIS_DIVISION_FACTOR;
  return scaleOption;
}

function correctValueByInterval(value, isDate, interval, firstDayOfWeek) {
  if ((0, _type2.isDefined)(value)) {
    value = isDate ? _date.default.correctDateWithUnitBeginning(new Date(value), interval, null, firstDayOfWeek) : (0, _math.adjust)(_floor((0, _math.adjust)(value / interval)) * interval);
  }

  return value;
}

function getIntervalCustomTicks(options) {
  var min = options.startValue;
  var max = options.endValue;
  var isDate = options.valueType === 'datetime';
  var firstDayOfWeek = getFirstDayOfWeek(options);
  var tickInterval = options.tickInterval;
  var res = {
    intervals: []
  };

  if (!(0, _type2.isDefined)(min) || !(0, _type2.isDefined)(max)) {
    return res;
  }

  res.intervals = _date.default.getSequenceByInterval(min, max, options.minorTickInterval);

  if (tickInterval !== options.minorTickInterval) {
    res.altIntervals = res.intervals;
    min = correctValueByInterval(min, isDate, tickInterval, firstDayOfWeek);
    max = correctValueByInterval(max, isDate, tickInterval, firstDayOfWeek);
    res.intervals = _date.default.getSequenceByInterval(min, max, tickInterval);
    res.intervals[0] = res.altIntervals[0];
  }

  return res;
}

function getPrecisionForSlider(startValue, endValue, screenDelta) {
  var d = Math.abs(endValue - startValue) / screenDelta;

  var tail = d - _floor(d);

  return tail > 0 ? _ceil(Math.abs((0, _math.adjust)((0, _utils.getLog)(tail, 10)))) : 0;
}

var dxRangeSelector = _base_widget.default.inherit({
  _toggleParentsScrollSubscription: function _toggleParentsScrollSubscription() {},
  _eventsMap: {
    'onValueChanged': {
      name: VALUE_CHANGED
    }
  },
  _rootClassPrefix: 'dxrs',
  _rootClass: 'dxrs-range-selector',
  _dataIsReady: function _dataIsReady() {
    return this._dataIsLoaded();
  },
  _initialChanges: ['DATA_SOURCE', 'VALUE'],
  _themeDependentChanges: ['MOSTLY_TOTAL'],
  _themeSection: 'rangeSelector',
  _fontFields: ['scale.label.font', 'sliderMarker.font'],
  _initCore: function _initCore() {
    var that = this;
    var renderer = that._renderer;
    var root = renderer.root; // TODO: Move it to the SlidersEventManager

    root.css({
      'touch-action': 'pan-y'
    }); // RangeContainer

    that._clipRect = renderer.clipRect(); // TODO: Try to remove it
    // TODO: Groups could be created by the corresponding components

    var rangeViewGroup = renderer.g().attr({
      'class': 'dxrs-view'
    }).append(root);
    var slidersGroup = renderer.g().attr({
      'class': 'dxrs-slidersContainer',
      'clip-path': that._clipRect.id
    }).append(root);
    var scaleGroup = renderer.g().attr({
      'class': 'dxrs-scale',
      'clip-path': that._clipRect.id
    }).append(root);
    var labelsAxesGroup = renderer.g().attr({
      'class': 'dxrs-scale-elements',
      'clip-path': that._clipRect.id
    }).append(root);
    var scaleBreaksGroup = renderer.g().attr({
      'class': 'dxrs-scale-breaks'
    }).append(root);
    var trackersGroup = renderer.g().attr({
      'class': 'dxrs-trackers'
    }).append(root);
    that._axis = new AxisWrapper({
      renderer: renderer,
      root: scaleGroup,
      scaleBreaksGroup: scaleBreaksGroup,
      labelsAxesGroup: labelsAxesGroup,
      updateSelectedRange: function updateSelectedRange(range, e) {
        that.setValue((0, _utils.convertVisualRangeObject)(range), e);
      },
      incidentOccurred: that._incidentOccurred
    });
    that._rangeView = new _range_view.RangeView({
      renderer: renderer,
      root: rangeViewGroup,
      translator: that._axis.getTranslator()
    });
    that._slidersController = new _sliders_controller.SlidersController({
      renderer: renderer,
      root: slidersGroup,
      trackersGroup: trackersGroup,
      updateSelectedRange: function updateSelectedRange(range, lastSelectedRange, e) {
        if (!that._rangeOption) {
          that.option(VALUE, (0, _utils.convertVisualRangeObject)(range, (0, _type2.isPlainObject)(that._options.silent(VALUE))));
        }

        that._eventTrigger(VALUE_CHANGED, {
          value: (0, _utils.convertVisualRangeObject)(range),
          previousValue: (0, _utils.convertVisualRangeObject)(lastSelectedRange),
          event: e
        });
      },
      axis: that._axis,
      translator: that._axis.getTranslator()
    });
    that._tracker = new _tracker.Tracker({
      renderer: renderer,
      controller: that._slidersController
    });
  },
  _getDefaultSize: function _getDefaultSize() {
    return {
      width: 400,
      height: 160
    };
  },
  _disposeCore: function _disposeCore() {
    this._axis.dispose();

    this._slidersController.dispose();

    this._tracker.dispose();
  },
  _applySize: function _applySize(rect) {
    this._clientRect = rect.slice();

    this._change(['MOSTLY_TOTAL']);
  },
  _optionChangesMap: {
    scale: 'SCALE',
    value: 'VALUE',
    dataSource: 'DATA_SOURCE'
  },
  _optionChangesOrder: ['SCALE', 'DATA_SOURCE'],
  _change_SCALE: function _change_SCALE() {
    this._change(['MOSTLY_TOTAL']);
  },
  _setValueByDataSource: function _setValueByDataSource() {
    var that = this;

    var options = that._options.silent();

    var axis = that._axis;

    if (options.dataSource) {
      var selectedRangeUpdateMode = that.option('selectedRangeUpdateMode');
      var value = that.getValue();
      var valueIsReady = (0, _type2.isDefined)(value[0]) && (0, _type2.isDefined)(value[1]);

      if ((0, _type2.isDefined)(selectedRangeUpdateMode)) {
        selectedRangeUpdateMode = (0, _utils.normalizeEnum)(selectedRangeUpdateMode);
        that.__skipAnimation = true;
      } else if (valueIsReady && !that._dataSourceIsAsync) {
        // T696409 T930471
        selectedRangeUpdateMode = RESET;
      }

      if (selectedRangeUpdateMode === 'auto' && valueIsReady) {
        var rangesInfo = axis.allScaleSelected(value);

        if (rangesInfo.startValue && rangesInfo.endValue) {
          selectedRangeUpdateMode = RESET;
        } else if (rangesInfo.endValue) {
          selectedRangeUpdateMode = SHIFT;
        } else {
          selectedRangeUpdateMode = KEEP;
        }
      }

      if (selectedRangeUpdateMode === RESET) {
        options[VALUE] = null;
      } else if (selectedRangeUpdateMode === SHIFT && valueIsReady) {
        var _value = that.getValue();

        that.__skipAnimation = true;
        options[VALUE] = {
          length: axis.getVisualRangeLength({
            minVisible: _value[0],
            maxVisible: _value[1]
          })
        };
      } else if (selectedRangeUpdateMode === KEEP) {
        that.__skipAnimation = true;
      }
    }

    that._dataSourceIsAsync = undefined;
  },
  _change_DATA_SOURCE: function _change_DATA_SOURCE() {
    if (this._options.silent('dataSource')) {
      this._updateDataSource();
    }
  },
  _customChangesOrder: ['MOSTLY_TOTAL', 'VALUE', 'SLIDER_SELECTION'],
  _change_MOSTLY_TOTAL: function _change_MOSTLY_TOTAL() {
    this._applyMostlyTotalChange();
  },
  _change_SLIDER_SELECTION: function _change_SLIDER_SELECTION() {
    var that = this;

    var value = that._options.silent(VALUE);

    that._slidersController.setSelectedRange(value && (0, _utils.getVizRangeObject)(value));
  },
  _change_VALUE: function _change_VALUE() {
    var that = this;
    var option = that._rangeOption;
    that._dataSourceIsAsync = !that._dataIsReady();

    if (option) {
      that._options.silent(VALUE, option);

      that.setValue(option);
    }
  },
  _validateRange: function _validateRange(start, end) {
    var that = this;

    var translator = that._axis.getTranslator();

    if ((0, _type2.isDefined)(start) && !translator.isValid(start) || (0, _type2.isDefined)(end) && !translator.isValid(end)) {
      that._incidentOccurred('E2203');
    }
  },
  _applyChanges: function _applyChanges() {
    var that = this;

    var value = that._options.silent(VALUE);

    if (that._changes.has('VALUE') && value) {
      that._rangeOption = value;
    }

    that.callBase.apply(that, arguments);
    that._rangeOption = null;
    that.__isResizing = that.__skipAnimation = false;
  },
  _applyMostlyTotalChange: function _applyMostlyTotalChange() {
    var that = this;
    var renderer = that._renderer;
    var rect = that._clientRect;
    var currentAnimationEnabled;
    var canvas = {
      left: rect[0],
      top: rect[1],
      width: rect[2] - rect[0],
      height: rect[3] - rect[1]
    };

    if (that.__isResizing || that.__skipAnimation) {
      currentAnimationEnabled = renderer.animationEnabled();
      renderer.updateAnimationOptions({
        enabled: false
      });
    }

    that._clipRect.attr({
      x: rect[0],
      y: rect[1],
      width: rect[2] - rect[0],
      height: rect[3] - rect[1]
    });

    that._axis.getTranslator().update(new _range.Range(), canvas, {
      isHorizontal: true
    });

    that._updateContent({
      left: rect[0],
      top: rect[1],
      width: rect[2] - rect[0],
      height: rect[3] - rect[1]
    });

    if (that.__isResizing || that.__skipAnimation) {
      renderer.updateAnimationOptions({
        enabled: currentAnimationEnabled
      });
    }

    that._drawn();
  },
  _dataSourceChangedHandler: function _dataSourceChangedHandler() {
    this._setValueByDataSource();

    this._requestChange(['MOSTLY_TOTAL']);
  },
  // It seems that we REALLY like to translate option structures from one form to another.
  // TODO: The more appropriate way is the following:
  // that._rangeView.update([
  //     that._getOption("background"),
  //     that._getOption("chart"),
  //     that.option("dataSource")
  // ]);
  // that._slidersController.update([
  //     that._getOption("sliderHandle"),
  //     that._getOption("sliderMarker"),
  //     that._getOption("shutter"),
  //     that._getOption("behavior")
  // ]);
  // that._axis.update(that._getOption("scale"));
  _completeSeriesDataSourceCreation: function _completeSeriesDataSourceCreation(scaleOptions, seriesDataSource) {
    var rect = this._clientRect;
    var canvas = {
      left: rect[0],
      top: rect[1],
      width: rect[2] - rect[0],
      height: rect[3] - rect[1]
    };

    this._axis.updateOptions((0, _extend.extend)({}, scaleOptions, {
      isHorizontal: true,
      label: {}
    }));

    seriesDataSource.isShowChart() && this._axis.setMarginOptions(seriesDataSource.getMarginOptions(canvas));

    this._axis.updateCanvas(canvas);

    seriesDataSource.createPoints();
  },
  _updateContent: function _updateContent(canvas) {
    var that = this;
    var chartOptions = that.option('chart');

    var seriesDataSource = that._createSeriesDataSource(chartOptions);

    var isCompactMode = !(seriesDataSource && seriesDataSource.isShowChart() || that.option('background.image.url'));
    var scaleOptions = prepareScaleOptions(that._getOption('scale'), seriesDataSource && seriesDataSource.getCalculatedValueType(), that._incidentOccurred, this._getOption('containerBackgroundColor', true));
    seriesDataSource && that._completeSeriesDataSourceCreation(scaleOptions, seriesDataSource);
    var argTranslatorRange = calculateTranslatorRange(seriesDataSource, scaleOptions);
    var tickIntervalsInfo = updateTickIntervals(scaleOptions, canvas.width, that._incidentOccurred, argTranslatorRange);
    var chartThemeManager = seriesDataSource && seriesDataSource.isShowChart() && seriesDataSource.getThemeManager();

    if (chartThemeManager) {
      // TODO: Looks like usage of "chartThemeManager" can be replaced with "that._getOption("chart").valueAxis.logarithmBase - check it
      checkLogarithmicOptions(chartOptions && chartOptions.valueAxis, chartThemeManager.getOptions('valueAxis').logarithmBase, that._incidentOccurred);
    }

    updateScaleOptions(scaleOptions, seriesDataSource, argTranslatorRange, tickIntervalsInfo, getDateMarkerVisibilityChecker(canvas.width));
    updateTranslatorRangeInterval(argTranslatorRange, scaleOptions);

    var sliderMarkerOptions = that._prepareSliderMarkersOptions(scaleOptions, canvas.width, tickIntervalsInfo, argTranslatorRange);

    var indents = calculateIndents(that._renderer, scaleOptions, sliderMarkerOptions, that.option('indent'), tickIntervalsInfo);
    var rangeContainerCanvas = {
      left: canvas.left + indents.left,
      top: canvas.top + indents.top,
      width: canvas.left + indents.left + _max(canvas.width - indents.left - indents.right, 1),
      height: _max(!isCompactMode ? canvas.height - indents.top - indents.bottom - calculateScaleAreaHeight(that._renderer, scaleOptions, showScaleMarkers(scaleOptions), tickIntervalsInfo) : _common.HEIGHT_COMPACT_MODE, 0),
      right: 0,
      bottom: 0
    }; // TODO: There should be one call to some axis method (not 4 methods)

    that._axis.update(scaleOptions, isCompactMode, rangeContainerCanvas, argTranslatorRange, seriesDataSource);

    scaleOptions.minorTickInterval = scaleOptions.isEmpty ? 0 : scaleOptions.minorTickInterval; // RangeContainer

    that._updateElements(scaleOptions, sliderMarkerOptions, isCompactMode, rangeContainerCanvas, seriesDataSource);

    if (chartThemeManager) {
      chartThemeManager.dispose(); // TODO: Move it inside "SeriesDataSource"
    }
  },
  _updateElements: function _updateElements(scaleOptions, sliderMarkerOptions, isCompactMode, canvas, seriesDataSource) {
    var that = this;

    var behavior = that._getOption('behavior');

    var shutterOptions = that._getOption('shutter');

    var isNotSemiDiscrete = scaleOptions.type !== SEMIDISCRETE;
    shutterOptions.color = shutterOptions.color || that._getOption(CONTAINER_BACKGROUND_COLOR, true);

    that._rangeView.update(that.option('background'), that._themeManager.theme('background'), canvas, isCompactMode, behavior.animationEnabled && that._renderer.animationEnabled(), seriesDataSource); // TODO: Is entire options bag really needed for SlidersContainer?


    that._isUpdating = true;

    that._slidersController.update([canvas.top, canvas.top + canvas.height], behavior, isCompactMode, that._getOption('sliderHandle'), sliderMarkerOptions, shutterOptions, {
      minRange: isNotSemiDiscrete ? that.option('scale.minRange') : undefined,
      maxRange: isNotSemiDiscrete ? that.option('scale.maxRange') : undefined
    }, that._axis.getFullTicks(), that._getOption('selectedRangeColor', true));

    that._requestChange(['SLIDER_SELECTION']);

    that._isUpdating = false;

    that._tracker.update(!that._axis.getTranslator().getBusinessRange().isEmpty(), behavior);
  },
  _createSeriesDataSource: function _createSeriesDataSource(chartOptions) {
    var that = this;
    var seriesDataSource;

    var dataSource = that._dataSourceItems(); // TODO: This code can be executed when data source is not loaded (it is an error)!


    var scaleOptions = that._getOption('scale');

    var valueType = scaleOptions.valueType || calculateValueType(scaleOptions.startValue, scaleOptions.endValue);
    var valueAxis = new _base_axis.Axis({
      renderer: that._renderer,
      axisType: 'xyAxes',
      drawingType: 'linear'
    });
    valueAxis.updateOptions({
      isHorizontal: false,
      label: {},
      categoriesSortingMethod: that._getOption('chart').valueAxis.categoriesSortingMethod
    });

    if (dataSource || chartOptions && chartOptions.series) {
      chartOptions = (0, _extend.extend)({}, chartOptions, {
        theme: that.option('theme')
      });
      seriesDataSource = new _series_data_source.SeriesDataSource({
        renderer: that._renderer,
        dataSource: dataSource,
        valueType: (0, _utils.normalizeEnum)(valueType),
        axisType: scaleOptions.type,
        chart: chartOptions,
        dataSourceField: that.option('dataSourceField'),
        incidentOccurred: that._incidentOccurred,
        categories: scaleOptions.categories,
        argumentAxis: that._axis,
        valueAxis: valueAxis
      });
    }

    return seriesDataSource;
  },
  _prepareSliderMarkersOptions: function _prepareSliderMarkersOptions(scaleOptions, screenDelta, tickIntervalsInfo, argRange) {
    var that = this;
    var minorTickInterval = tickIntervalsInfo.minorTickInterval;
    var tickInterval = tickIntervalsInfo.tickInterval;
    var interval = tickInterval;
    var endValue = scaleOptions.endValue;
    var startValue = scaleOptions.startValue;

    var sliderMarkerOptions = that._getOption(SLIDER_MARKER);

    var doNotSnap = !that._getOption('behavior').snapToTicks;
    var isTypeDiscrete = scaleOptions.type === DISCRETE;
    var isValueTypeDatetime = scaleOptions.valueType === DATETIME;
    sliderMarkerOptions.borderColor = that._getOption(CONTAINER_BACKGROUND_COLOR, true);

    if (!sliderMarkerOptions.format && !argRange.isEmpty()) {
      if (doNotSnap && (0, _type2.isNumeric)(scaleOptions.startValue)) {
        sliderMarkerOptions.format = {
          type: 'fixedPoint',
          precision: getPrecisionForSlider(startValue, endValue, screenDelta)
        };
      }

      if (isValueTypeDatetime && !isTypeDiscrete) {
        if ((0, _type2.isDefined)(minorTickInterval) && minorTickInterval !== 0) {
          interval = getMinorTickIntervalUnit(tickInterval, minorTickInterval, doNotSnap);
        }

        if (!scaleOptions.marker.visible) {
          if ((0, _type2.isDefined)(startValue) && (0, _type2.isDefined)(endValue)) {
            sliderMarkerOptions.format = _format_helper.default.getDateFormatByTickInterval(startValue, endValue, interval);
          }
        } else {
          sliderMarkerOptions.format = _date.default.getDateFormatByTickInterval(interval);
        }
      } // T347293


      if (isValueTypeDatetime && isTypeDiscrete && tickIntervalsInfo.ticks.length) {
        sliderMarkerOptions.format = _format_helper.default.getDateFormatByTicks(tickIntervalsInfo.ticks);
      }
    }

    return sliderMarkerOptions;
  },
  getValue: function getValue() {
    return (0, _utils.convertVisualRangeObject)(this._slidersController.getSelectedRange());
  },
  setValue: function setValue(value, e) {
    var visualRange = (0, _utils.getVizRangeObject)(value);

    if (!this._isUpdating && value) {
      this._validateRange(visualRange.startValue, visualRange.endValue);

      !(0, _utils.rangesAreEqual)(visualRange, this._slidersController.getSelectedRange()) && this._slidersController.setSelectedRange(visualRange, e);
    }
  },
  _setContentSize: function _setContentSize() {
    this.__isResizing = this._changes.count() === 2;
    this.callBase.apply(this, arguments);
  }
});

(0, _iterator.each)(['selectedRangeColor', 'containerBackgroundColor', 'sliderMarker', 'sliderHandle', 'shutter', OPTION_BACKGROUND, 'behavior', 'chart', 'indent'], function (_, name) {
  dxRangeSelector.prototype._optionChangesMap[name] = 'MOSTLY_TOTAL';
}); // AxisWrapper

function prepareAxisOptions(scaleOptions, isCompactMode, height, axisPosition) {
  scaleOptions.marker.label.font = scaleOptions.label.font;
  scaleOptions.color = scaleOptions.marker.color = scaleOptions.tick.color;
  scaleOptions.opacity = scaleOptions.marker.opacity = scaleOptions.tick.opacity;
  scaleOptions.width = scaleOptions.marker.width = scaleOptions.tick.width;
  scaleOptions.placeholderSize = (scaleOptions.placeholderHeight || 0) + axisPosition;
  scaleOptions.argumentType = scaleOptions.valueType;
  scaleOptions.visible = isCompactMode;
  scaleOptions.isHorizontal = true;
  scaleOptions.calculateMinors = true;
  scaleOptions.semiDiscreteInterval = scaleOptions.minRange;

  if (!isCompactMode) {
    scaleOptions.minorTick.length = scaleOptions.tick.length = height;
  }

  scaleOptions.label.indentFromAxis = scaleOptions.label.topIndent + axisPosition;
  return scaleOptions;
}

function createDateMarkersEvent(scaleOptions, markerTrackers, setSelectedRange) {
  (0, _iterator.each)(markerTrackers, function (_, value) {
    value.on('dxpointerdown', onPointerDown);
  });

  function onPointerDown(e) {
    var range = e.target.range;
    var minRange = scaleOptions.minRange ? _date.default.addInterval(range.startValue, scaleOptions.minRange) : undefined;
    var maxRange = scaleOptions.maxRange ? _date.default.addInterval(range.startValue, scaleOptions.maxRange) : undefined;

    if (!(minRange && minRange > range.endValue || maxRange && maxRange < range.endValue)) {
      setSelectedRange(range, e);
    }
  }
}

function getShiftDirection() {
  return 1;
}

function getTickStartPositionShift(length) {
  return length % 2 === 1 ? -_floor(length / 2) : -length / 2;
}

function checkShiftedLabels(majorTicks, boxes, minSpacing, alignment) {
  function checkLabelsOverlapping(nearestLabelsIndexes) {
    if (nearestLabelsIndexes.length === 2 && _axes_constants.default.areLabelsOverlap(boxes[nearestLabelsIndexes[0]], boxes[nearestLabelsIndexes[1]], minSpacing, alignment)) {
      majorTicks[nearestLabelsIndexes[0]].removeLabel();
    }
  }

  function getTwoVisibleLabels(startIndex) {
    var labels = [];

    for (var i = startIndex; labels.length < 2 && i < majorTicks.length; i++) {
      majorTicks[i].label && labels.push(i);
    }

    return labels;
  }

  if (majorTicks.length < 3) {
    return;
  }

  checkLabelsOverlapping(getTwoVisibleLabels(0));
  checkLabelsOverlapping(getTwoVisibleLabels(majorTicks.length - 2).reverse());
}

function AxisWrapper(params) {
  var that = this;
  that._axis = new _base_axis.Axis({
    renderer: params.renderer,
    axesContainerGroup: params.root,
    scaleBreaksGroup: params.scaleBreaksGroup,
    labelsAxesGroup: params.labelsAxesGroup,
    incidentOccurred: params.incidentOccurred,
    // TODO: These dependencies should be statically resolved (not for every new instance)
    axisType: 'xyAxes',
    drawingType: 'linear',
    widgetClass: 'dxrs',
    axisClass: 'range-selector',
    isArgumentAxis: true,
    getTemplate: function getTemplate() {}
  });
  that._updateSelectedRangeCallback = params.updateSelectedRange;
  that._axis.getAxisSharpDirection = that._axis.getSharpDirectionByCoords = getShiftDirection;
  that._axis.getTickStartPositionShift = getTickStartPositionShift;
  that._axis._checkShiftedLabels = checkShiftedLabels;
}

AxisWrapper.prototype = {
  constructor: AxisWrapper,
  dispose: function dispose() {
    this._axis.dispose();
  },
  calculateInterval: function calculateInterval(value, prevValue) {
    return this._axis.calculateInterval(value, prevValue);
  },
  update: function update(options, isCompactMode, canvas, businessRange, seriesDataSource) {
    var axis = this._axis;
    axis.updateOptions(prepareAxisOptions(options, isCompactMode, canvas.height, canvas.height / 2 - _ceil(options.width / 2)));
    axis.validate();
    axis.setBusinessRange(businessRange, true);

    if (seriesDataSource !== undefined && seriesDataSource.isShowChart()) {
      axis.setMarginOptions(seriesDataSource.getMarginOptions(canvas));
    }

    axis.draw(canvas);
    axis.shift({
      left: 0,
      bottom: -canvas.height / 2 + canvas.top
    });

    if (axis.getMarkerTrackers()) {
      // TODO: Check who is responsible for destroying events
      createDateMarkersEvent(options, axis.getMarkerTrackers(), this._updateSelectedRangeCallback);
    }

    axis.drawScaleBreaks({
      start: canvas.top,
      end: canvas.top + canvas.height
    });
  },
  visualRange: function visualRange() {},
  getViewport: function getViewport() {
    return {};
  },
  allScaleSelected: function allScaleSelected(value) {
    var _this$_axis$visualRan = this._axis.visualRange(),
        startValue = _this$_axis$visualRan.startValue,
        endValue = _this$_axis$visualRan.endValue;

    return {
      startValue: value[0].valueOf() === startValue.valueOf(),
      endValue: value[1].valueOf() === endValue.valueOf()
    };
  },
  getOptions: function getOptions() {
    return this._axis.getOptions() || {};
  }
};
['setMarginOptions', 'getFullTicks', 'updateCanvas', 'updateOptions', 'getAggregationInfo', 'getTranslator', 'getVisualRangeLength', 'getVisibleArea', 'getMarginOptions', 'getVisualRangeCenter'].forEach(function (methodName) {
  AxisWrapper.prototype[methodName] = function () {
    var axis = this._axis;
    return axis[methodName].apply(axis, arguments);
  };
});
(0, _component_registrator.default)('dxRangeSelector', dxRangeSelector);
var _default = dxRangeSelector; // PLUGINS_SECTION

exports.default = _default;
dxRangeSelector.addPlugin(_export.plugin);
dxRangeSelector.addPlugin(_title.plugin);
dxRangeSelector.addPlugin(_loading_indicator.plugin);
dxRangeSelector.addPlugin(_data_source.plugin);
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1082 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.SlidersController = SlidersController;

var _common = __webpack_require__(4);

var _common2 = __webpack_require__(245);

var _slider = _interopRequireDefault(__webpack_require__(1083));

var _utils = __webpack_require__(14);

var _type = __webpack_require__(1);

var _math = __webpack_require__(31);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var animationSettings = _common2.utils.animationSettings;
var emptySliderMarkerText = _common2.consts.emptySliderMarkerText;

function buildRectPoints(left, top, right, bottom) {
  return [left, top, right, top, right, bottom, left, bottom];
}

function isLess(a, b) {
  return a < b;
}

function isGreater(a, b) {
  return a > b;
}

function selectClosestValue(target, values) {
  var start = 0;
  var end = values ? values.length - 1 : 0;
  var middle;
  var val = target;

  while (end - start > 1) {
    middle = start + end >> 1;
    val = values[middle];

    if (val === target) {
      return target;
    } else if (target < val) {
      end = middle;
    } else {
      start = middle;
    }
  }

  if (values) {
    val = values[target - values[start] <= values[end] - target ? start : end];
  }

  return val;
}

function dummyProcessSelectionChanged() {
  this._lastSelectedRange = this.getSelectedRange();
  delete this._processSelectionChanged;
} // See tests in "rangeSelectorWithAssertion.html", "'onSelectedRangeChanged' event" module


function suppressSetSelectedRange(controller) {
  controller.setSelectedRange = _common.noop;

  if (controller._processSelectionChanged === dummyProcessSelectionChanged) {
    controller._processSelectionChanged();
  }
}

function restoreSetSelectedRange(controller) {
  delete controller.setSelectedRange;
}

function SlidersController(params) {
  var that = this;
  var sliderParams = {
    renderer: params.renderer,
    root: params.root,
    trackersGroup: params.trackersGroup,
    translator: params.translator
  };
  that._params = params;
  that._areaTracker = params.renderer.path(null, 'area').attr({
    'class': 'area-tracker',
    fill: '#000000',
    opacity: 0.0001
  }).append(params.trackersGroup);
  that._selectedAreaTracker = params.renderer.path(null, 'area').attr({
    'class': 'selected-area-tracker',
    fill: '#000000',
    opacity: 0.0001
  }).append(params.trackersGroup); // Shutter is appended before sliders because later (when they will be foregrounded) it will be at any case located before them.

  that._shutter = params.renderer.path(null, 'area').append(params.root);
  that._sliders = [new _slider.default(sliderParams, 0), new _slider.default(sliderParams, 1)]; // It seems that there is no special reasons to suppress first event - it was accidentally suppressed.
  // Let it stay so for now.

  that._processSelectionChanged = dummyProcessSelectionChanged;
}

SlidersController.prototype = {
  constructor: SlidersController,
  dispose: function dispose() {
    this._sliders[0].dispose();

    this._sliders[1].dispose();
  },
  getTrackerTargets: function getTrackerTargets() {
    return {
      area: this._areaTracker,
      selectedArea: this._selectedAreaTracker,
      sliders: this._sliders
    };
  },
  _processSelectionChanged: function _processSelectionChanged(e) {
    var that = this;
    var selectedRange = that.getSelectedRange();

    if (!(0, _utils.rangesAreEqual)(selectedRange, that._lastSelectedRange)) {
      that._params.updateSelectedRange(selectedRange, that._lastSelectedRange, e);

      that._lastSelectedRange = selectedRange;
    }
  },
  update: function update(verticalRange, behavior, isCompactMode, sliderHandleOptions, sliderMarkerOptions, shutterOptions, rangeBounds, fullTicks, selectedRangeColor) {
    var that = this;

    var screenRange = that._params.translator.getScreenRange();

    that._verticalRange = verticalRange;
    that._minRange = rangeBounds.minRange;
    that._maxRange = rangeBounds.maxRange; // TODO: Investigate reasons of "renderer.animationEnabled" usage - it seems to be useless (if only for vml somehow)

    that._animationEnabled = behavior.animationEnabled && that._params.renderer.animationEnabled();
    that._allowSlidersSwap = behavior.allowSlidersSwap;

    that._sliders[0].update(verticalRange, sliderHandleOptions, sliderMarkerOptions);

    that._sliders[1].update(verticalRange, sliderHandleOptions, sliderMarkerOptions); // This is required for placing sliders and shutter into initial position from which initial animation will be going.


    that._sliders[0]._position = that._sliders[1]._position = screenRange[0];
    that._values = !that._params.translator.isValueProlonged && behavior.snapToTicks ? fullTicks : null;

    that._areaTracker.attr({
      points: buildRectPoints(screenRange[0], verticalRange[0], screenRange[1], verticalRange[1])
    }); // SlidersContainer


    that._isCompactMode = isCompactMode;
    that._shutterOffset = sliderHandleOptions.width / 2;

    that._updateSelectedView(shutterOptions, selectedRangeColor);

    that._isOnMoving = (0, _utils.normalizeEnum)(behavior.callValueChanged) === 'onmoving';

    that._updateSelectedRange(); // This is placing sliders and shutter into initial position. They all will be animated from that position when "setSelectedRange" is called.


    that._applyTotalPosition(false);
  },
  _updateSelectedView: function _updateSelectedView(shutterOptions, selectedRangeColor) {
    var settings = {
      fill: null,
      'fill-opacity': null,
      stroke: null,
      'stroke-width': null
    };

    if (this._isCompactMode) {
      settings.stroke = selectedRangeColor;
      settings['stroke-width'] = 3;
      settings.sharp = 'v';
    } else {
      settings.fill = shutterOptions.color;
      settings['fill-opacity'] = shutterOptions.opacity;
    }

    this._shutter.attr(settings);
  },
  _updateSelectedRange: function _updateSelectedRange() {
    var that = this;
    var sliders = that._sliders;
    sliders[0].cancelAnimation();
    sliders[1].cancelAnimation();

    that._shutter.stopAnimation();

    if (that._params.translator.getBusinessRange().isEmpty()) {
      sliders[0]._setText(emptySliderMarkerText);

      sliders[1]._setText(emptySliderMarkerText);

      sliders[0]._value = sliders[1]._value = undefined;
      sliders[0]._position = that._params.translator.getScreenRange()[0];
      sliders[1]._position = that._params.translator.getScreenRange()[1];

      that._applyTotalPosition(false);

      suppressSetSelectedRange(that);
    } else {
      restoreSetSelectedRange(that);
    }
  },
  _applyTotalPosition: function _applyTotalPosition(isAnimated) {
    var sliders = this._sliders;
    isAnimated = this._animationEnabled && isAnimated;
    sliders[0].applyPosition(isAnimated);
    sliders[1].applyPosition(isAnimated);
    var areOverlapped = sliders[0].getCloudBorder() > sliders[1].getCloudBorder();
    sliders[0].setOverlapped(areOverlapped);
    sliders[1].setOverlapped(areOverlapped);

    this._applyAreaTrackersPosition();

    this._applySelectedRangePosition(isAnimated);
  },
  _applyAreaTrackersPosition: function _applyAreaTrackersPosition() {
    var that = this;

    var position1 = that._sliders[0].getPosition();

    var position2 = that._sliders[1].getPosition();

    that._selectedAreaTracker.attr({
      points: buildRectPoints(position1, that._verticalRange[0], position2, that._verticalRange[1])
    }).css({
      cursor: Math.abs(that._params.translator.getScreenRange()[1] - that._params.translator.getScreenRange()[0] - position2 + position1) < 0.001 ? 'default' : 'pointer'
    });
  },
  _applySelectedRangePosition: function _applySelectedRangePosition(isAnimated) {
    var that = this;
    var verticalRange = that._verticalRange;

    var pos1 = that._sliders[0].getPosition();

    var pos2 = that._sliders[1].getPosition();

    var screenRange;
    var points;

    if (that._isCompactMode) {
      points = [pos1 + Math.ceil(that._shutterOffset), (verticalRange[0] + verticalRange[1]) / 2, pos2 - Math.floor(that._shutterOffset), (verticalRange[0] + verticalRange[1]) / 2];
    } else {
      screenRange = that._params.axis.getVisibleArea();
      points = [buildRectPoints(screenRange[0], verticalRange[0], Math.max(pos1 - Math.floor(that._shutterOffset), screenRange[0]), verticalRange[1]), buildRectPoints(screenRange[1], verticalRange[0], Math.min(pos2 + Math.ceil(that._shutterOffset), screenRange[1]), verticalRange[1])];
    }

    if (isAnimated) {
      that._shutter.animate({
        points: points
      }, animationSettings);
    } else {
      that._shutter.attr({
        points: points
      });
    }
  },
  getSelectedRange: function getSelectedRange() {
    return {
      startValue: this._sliders[0].getValue(),
      endValue: this._sliders[1].getValue()
    };
  },
  setSelectedRange: function setSelectedRange(visualRange, e) {
    visualRange = visualRange || {};
    var that = this;
    var translator = that._params.translator;
    var businessRange = translator.getBusinessRange();
    var compare = businessRange.axisType === 'discrete' ? function (a, b) {
      return a < b;
    } : function (a, b) {
      return a <= b;
    };

    var _adjustVisualRange = (0, _utils.adjustVisualRange)({
      dataType: businessRange.dataType,
      axisType: businessRange.axisType,
      base: businessRange.base
    }, {
      startValue: translator.isValid(visualRange.startValue) ? translator.getCorrectValue(visualRange.startValue, +1) : undefined,
      endValue: translator.isValid(visualRange.endValue) ? translator.getCorrectValue(visualRange.endValue, -1) : undefined,
      length: visualRange.length
    }, {
      min: businessRange.minVisible,
      max: businessRange.maxVisible,
      categories: businessRange.categories
    }),
        startValue = _adjustVisualRange.startValue,
        endValue = _adjustVisualRange.endValue;

    startValue = (0, _type.isNumeric)(startValue) ? (0, _math.adjust)(startValue) : startValue;
    endValue = (0, _type.isNumeric)(endValue) ? (0, _math.adjust)(endValue) : endValue;
    var values = compare(translator.to(startValue, -1), translator.to(endValue, +1)) ? [startValue, endValue] : [endValue, startValue];

    that._sliders[0].setDisplayValue(values[0]);

    that._sliders[1].setDisplayValue(values[1]);

    that._sliders[0]._position = translator.to(values[0], -1);
    that._sliders[1]._position = translator.to(values[1], +1);

    that._applyTotalPosition(true);

    that._processSelectionChanged(e);
  },
  beginSelectedAreaMoving: function beginSelectedAreaMoving(initialPosition) {
    var that = this;
    var sliders = that._sliders;
    var offset = (sliders[0].getPosition() + sliders[1].getPosition()) / 2 - initialPosition;
    var currentPosition = initialPosition;

    move.complete = function (e) {
      that._dockSelectedArea(e);
    };

    return move;

    function move(position, e) {
      if (position !== currentPosition && position > currentPosition === position > (sliders[0].getPosition() + sliders[1].getPosition()) / 2 - offset) {
        that._moveSelectedArea(position + offset, false, e);
      }

      currentPosition = position;
    }
  },
  _dockSelectedArea: function _dockSelectedArea(e) {
    var translator = this._params.translator;
    var sliders = this._sliders;
    sliders[0]._position = translator.to(sliders[0].getValue(), -1);
    sliders[1]._position = translator.to(sliders[1].getValue(), +1);

    this._applyTotalPosition(true);

    this._processSelectionChanged(e);
  },
  moveSelectedArea: function moveSelectedArea(screenPosition, e) {
    this._moveSelectedArea(screenPosition, true, e);

    this._dockSelectedArea(e);
  },
  _moveSelectedArea: function _moveSelectedArea(screenPosition, isAnimated, e) {
    var that = this;
    var translator = that._params.translator;
    var sliders = that._sliders;
    var interval = sliders[1].getPosition() - sliders[0].getPosition();
    var startPosition = screenPosition - interval / 2;
    var endPosition = screenPosition + interval / 2;

    if (startPosition < translator.getScreenRange()[0]) {
      startPosition = translator.getScreenRange()[0];
      endPosition = startPosition + interval;
    }

    if (endPosition > translator.getScreenRange()[1]) {
      endPosition = translator.getScreenRange()[1];
      startPosition = endPosition - interval;
    } // Check for "minRange" and "maxRange" is not performed because it was not performed in the previous code, though I find it strange.


    var startValue = selectClosestValue(translator.from(startPosition, -1), that._values);
    sliders[0].setDisplayValue(startValue);
    sliders[1].setDisplayValue(selectClosestValue(translator.from(translator.to(startValue, -1) + interval, +1), that._values));
    sliders[0]._position = startPosition;
    sliders[1]._position = endPosition;

    that._applyTotalPosition(isAnimated);

    if (that._isOnMoving) {
      that._processSelectionChanged(e);
    }
  },
  placeSliderAndBeginMoving: function placeSliderAndBeginMoving(firstPosition, secondPosition, e) {
    var that = this;
    var translator = that._params.translator;
    var sliders = that._sliders;
    var index = firstPosition < secondPosition ? 0 : 1;
    var dir = index > 0 ? +1 : -1;
    var compare = index > 0 ? isGreater : isLess;
    var antiCompare = index > 0 ? isLess : isGreater;
    var thresholdPosition;
    var positions = [];
    var values = [];
    values[index] = translator.from(firstPosition, dir);
    values[1 - index] = translator.from(secondPosition, -dir);
    positions[1 - index] = secondPosition;

    if (translator.isValueProlonged) {
      // Ensure that first value is strictly to the outer side from the "firstPosition".
      if (compare(firstPosition, translator.to(values[index], dir))) {
        values[index] = translator.from(firstPosition, -dir);
      } // Check - if "secondPosition" is closer to "firstPosition" than a span of a single category.


      if (compare(secondPosition, translator.to(values[index], -dir))) {
        values[1 - index] = values[index];
      }
    }

    if (that._minRange) {
      thresholdPosition = translator.to(translator.add(selectClosestValue(values[index], that._values), that._minRange, -dir), -dir); // Check - if "secondPosition" is closer to "firstPosition" than it is allowed by "minRange".

      if (compare(secondPosition, thresholdPosition)) {
        values[1 - index] = translator.add(values[index], that._minRange, -dir);
      }

      thresholdPosition = translator.to(translator.add(translator.getRange()[1 - index], that._minRange, dir), -dir); // Check - if "firstPosition" is closer to an end than it is allowed by "minRange".
      // So there is definitely not enough space for both sliders - the first  (as the one which is farther from the end) has to be moved away by "minRange".

      if (antiCompare(firstPosition, thresholdPosition)) {
        values[1 - index] = translator.getRange()[1 - index];
        values[index] = translator.add(values[1 - index], that._minRange, dir);
        positions[1 - index] = firstPosition;
      }
    }

    values[0] = selectClosestValue(values[0], that._values);
    values[1] = selectClosestValue(values[1], that._values);
    positions[index] = translator.to(values[index], dir);
    sliders[0].setDisplayValue(values[0]);
    sliders[1].setDisplayValue(values[1]);
    sliders[0]._position = positions[0];
    sliders[1]._position = positions[1];

    that._applyTotalPosition(true);

    if (that._isOnMoving) {
      that._processSelectionChanged(e);
    }

    var handler = that.beginSliderMoving(1 - index, secondPosition);

    sliders[1 - index]._sliderGroup.stopAnimation();

    that._shutter.stopAnimation();

    handler(secondPosition);
    return handler;
  },
  beginSliderMoving: function beginSliderMoving(initialIndex, initialPosition) {
    var that = this;
    var translator = that._params.translator;
    var sliders = that._sliders;
    var minPosition = translator.getScreenRange()[0];
    var maxPosition = translator.getScreenRange()[1];
    var index = initialIndex;
    var staticPosition = sliders[1 - index].getPosition();
    var currentPosition = initialPosition;
    var dir = index > 0 ? +1 : -1;
    var compareMin = index > 0 ? isLess : isGreater;
    var compareMax = index > 0 ? isGreater : isLess;
    var moveOffset = sliders[index].getPosition() - initialPosition;
    var swapOffset = compareMin(sliders[index].getPosition(), initialPosition) ? -moveOffset : moveOffset;

    move.complete = function (e) {
      sliders[index]._setValid(true);

      that._dockSelectedArea(e);
    };

    return move;

    function move(position, e) {
      var isValid;
      var temp;
      var pos;
      var slider;
      var value;

      if (position !== currentPosition) {
        if (compareMin(position + swapOffset, staticPosition)) {
          isValid = that._allowSlidersSwap; // TODO: Validate "_minRange" so that for discrete translator it is always null - that will allow to split "isValueProlonged" and "_minRange" checks

          if (isValid && !translator.isValueProlonged && that._minRange) {
            isValid = translator.isValid(translator.add(sliders[1 - index].getValue(), that._minRange, -dir));
          }

          if (isValid) {
            that._changeMovingSlider(index);

            index = 1 - index;
            dir = -dir;
            temp = compareMin;
            compareMin = compareMax;
            compareMax = temp;
            moveOffset = -dir * Math.abs(moveOffset);
            swapOffset = -moveOffset;
          }
        }

        if (compareMax(position + moveOffset, staticPosition)) {
          slider = sliders[index];
          value = sliders[1 - index].getValue();
          pos = Math.max(Math.min(position + moveOffset, maxPosition), minPosition); // TODO: Write it as single operation (isValid = ... && ... && ...) when code is stable.
          // Check - if moving slider is closer to static slider than a span of a single category.

          isValid = translator.isValueProlonged ? !compareMin(pos, translator.to(value, dir)) : true;
          var invalidStateValue; // Check - if moving slider is closer to static slider than it is allowed "minRange".

          if (isValid && that._minRange) {
            isValid = !compareMin(pos, translator.to(translator.add(value, that._minRange, dir), dir));

            if (!isValid) {
              invalidStateValue = translator.add(value, that._minRange, dir);
            }
          } // Check - if moving slider is farther from static slider than it is allowed by "maxRange"


          if (isValid && that._maxRange) {
            isValid = !compareMax(pos, translator.to(translator.add(value, that._maxRange, dir), dir));

            if (!isValid) {
              invalidStateValue = translator.add(value, that._maxRange, dir);
            }
          }

          slider._setValid(isValid);

          slider.setDisplayValue(isValid ? selectClosestValue(translator.from(pos, dir), that._values) : (0, _type.isDefined)(invalidStateValue) ? invalidStateValue : slider.getValue());
          slider._position = pos;

          that._applyTotalPosition(false);

          slider.toForeground();

          if (that._isOnMoving) {
            that._processSelectionChanged(e);
          }
        }
      }

      currentPosition = position;
    }
  },
  _changeMovingSlider: function _changeMovingSlider(index) {
    var that = this;
    var translator = that._params.translator;
    var sliders = that._sliders;
    var position = sliders[1 - index].getPosition();
    var dir = index > 0 ? +1 : -1;
    var newValue;
    sliders[index].setDisplayValue(selectClosestValue(translator.from(position, dir), that._values));
    newValue = translator.from(position, -dir);

    if (translator.isValueProlonged) {
      newValue = translator.from(position, dir);
    } else if (that._minRange) {
      // TODO: Consider adding "translator.isValid" check - that will allow to split "if-else" into two "if"
      newValue = translator.add(newValue, that._minRange, -dir);
    }

    sliders[1 - index].setDisplayValue(selectClosestValue(newValue, that._values));

    sliders[index]._setValid(true);

    sliders[index]._marker._update(); // This is to update "text" element


    sliders[0]._position = sliders[1]._position = position;
  },
  foregroundSlider: function foregroundSlider(index) {
    this._sliders[index].toForeground();
  }
};

/***/ }),
/* 1083 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _common = __webpack_require__(245);

var _slider_marker = _interopRequireDefault(__webpack_require__(1084));

var _support = __webpack_require__(48);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var animationSettings = _common.utils.animationSettings;
var SPLITTER_WIDTH = 8;
var TOUCH_SPLITTER_WIDTH = 20;

function getSliderTrackerWidth(sliderHandleWidth) {
  return _support.touchEvents || _support.pointerEvents ? TOUCH_SPLITTER_WIDTH : SPLITTER_WIDTH < sliderHandleWidth ? sliderHandleWidth : SPLITTER_WIDTH;
}

function Slider(params, index) {
  var that = this;
  that._translator = params.translator;
  that._sliderGroup = params.renderer.g().attr({
    'class': 'slider'
  }).append(params.root);
  that._line = params.renderer.path(null, 'line').append(that._sliderGroup);
  that._marker = new _slider_marker.default(params.renderer, that._sliderGroup, index === 1);
  that._tracker = params.renderer.rect().attr({
    'class': 'slider-tracker',
    fill: '#000000',
    opacity: 0.0001
  }).css({
    cursor: 'w-resize'
  }).append(params.trackersGroup);
}

Slider.prototype = {
  constructor: Slider,
  cancelAnimation: function cancelAnimation() {
    this._sliderGroup.stopAnimation();

    this._tracker.stopAnimation();
  },
  applyPosition: function applyPosition(isAnimated) {
    var that = this;
    var slider = that._sliderGroup;
    var tracker = that._tracker;
    var attrs = {
      translateX: that._position
    };

    that._marker.setPosition(that._position);

    if (isAnimated) {
      slider.animate(attrs, animationSettings);
      tracker.animate(attrs, animationSettings);
    } else {
      slider.attr(attrs);
      tracker.attr(attrs);
    }
  },
  _setValid: function _setValid(isValid) {
    this._marker.setValid(isValid);

    this._line.attr({
      stroke: this._colors[Number(isValid)]
    });
  },
  _setText: function _setText(text) {
    this._marker.setText(text);
  },
  update: function update(verticalRange, sliderHandleOptions, sliderMarkerOptions) {
    var that = this;
    that._formatOptions = {
      format: sliderMarkerOptions.format,
      customizeText: sliderMarkerOptions.customizeText
    };

    that._marker.applyOptions(sliderMarkerOptions, that._translator.getScreenRange());

    that._colors = [sliderMarkerOptions.invalidRangeColor, sliderHandleOptions.color];

    that._sliderGroup.attr({
      translateY: verticalRange[0]
    });

    that._line.attr({
      'stroke-width': sliderHandleOptions.width,
      stroke: sliderHandleOptions.color,
      'stroke-opacity': sliderHandleOptions.opacity,
      sharp: 'h',
      points: [0, 0, 0, verticalRange[1] - verticalRange[0]]
    });

    var trackerWidth = getSliderTrackerWidth(sliderHandleOptions.width);

    that._tracker.attr({
      x: -trackerWidth / 2,
      y: 0,
      width: trackerWidth,
      height: verticalRange[1] - verticalRange[0],
      translateY: verticalRange[0]
    });
  },
  toForeground: function toForeground() {
    this._sliderGroup.toForeground();
  },
  getSliderTracker: function getSliderTracker() {
    return this._tracker;
  },
  getPosition: function getPosition() {
    return this._position;
  },
  setDisplayValue: function setDisplayValue(value) {
    this._value = value;

    this._setText((0, _common.formatValue)(value, this._formatOptions));
  },
  setOverlapped: function setOverlapped(isOverlapped) {
    this._marker.setOverlapped(isOverlapped);
  },
  getValue: function getValue() {
    return this._value;
  },
  on: function on(event, handler) {
    this._tracker.on(event, handler);

    this._marker.getTracker().on(event, handler);
  },
  getCloudBorder: function getCloudBorder() {
    return this._marker.getBorderPosition();
  },
  dispose: function dispose() {
    this._marker.dispose();
  }
};
var _default = Slider;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1084 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _utils = __webpack_require__(14);

var _common = __webpack_require__(245);

var POINTER_SIZE = _common.consts.pointerSize;
var SLIDER_MARKER_UPDATE_DELAY = 75;

function SliderMarker(renderer, root, isLeftPointer) {
  var that = this;
  that._isLeftPointer = isLeftPointer;
  that._isOverlapped = false;
  that._group = renderer.g().attr({
    'class': 'slider-marker'
  }).append(root);
  that._area = renderer.path(null, 'area').append(that._group);
  that._label = renderer.text().attr({
    align: 'left'
  }).append(that._group);
  that._tracker = renderer.rect().attr({
    'class': 'slider-marker-tracker',
    fill: '#000000',
    opacity: 0.0001
  }).css({
    cursor: 'pointer'
  }).append(that._group);
  that._border = renderer.rect(0, 0, 1, 0);
}

SliderMarker.prototype = {
  constructor: SliderMarker,
  _getRectSize: function _getRectSize(textSize) {
    return {
      width: Math.round(2 * this._paddingLeftRight + textSize.width),
      height: Math.round(2 * this._paddingTopBottom + textSize.height)
    };
  },
  _getTextSize: function _getTextSize() {
    var textSize = this._label.getBBox();

    if (!this._textHeight && isFinite(textSize.height)) {
      this._textHeight = textSize.height;
    }

    return {
      width: textSize.width,
      height: this._textHeight,
      y: textSize.y
    };
  },
  _getAreaPointsInfo: function _getAreaPointsInfo(textSize) {
    var that = this;

    var rectSize = that._getRectSize(textSize);

    var rectWidth = rectSize.width;
    var rectHeight = rectSize.height;
    var rectLeftBorder = -rectWidth;
    var rectRightBorder = 0;
    var pointerRightPoint = POINTER_SIZE;
    var pointerCenterPoint = 0;
    var pointerLeftPoint = -POINTER_SIZE;
    var position = that._position;
    var isLeft = that._isLeftPointer;

    var correctCloudBorders = function correctCloudBorders() {
      rectLeftBorder++;
      rectRightBorder++;
      pointerRightPoint++;
      pointerCenterPoint++;
      pointerLeftPoint++;
    };

    var checkPointerBorders = function checkPointerBorders() {
      if (pointerRightPoint > rectRightBorder) {
        pointerRightPoint = rectRightBorder;
      } else {
        if (pointerLeftPoint < rectLeftBorder) {
          pointerLeftPoint = rectLeftBorder;
        }
      }

      isLeft && correctCloudBorders();
    };

    var borderPosition = position;

    if (isLeft) {
      if (position > that._range[1] - rectWidth) {
        rectRightBorder = -position + that._range[1];
        rectLeftBorder = rectRightBorder - rectWidth;
        checkPointerBorders();
        borderPosition += rectLeftBorder;
      } else {
        rectLeftBorder = pointerLeftPoint = 0;
        rectRightBorder = rectWidth;
      }
    } else {
      if (position - that._range[0] < rectWidth) {
        rectLeftBorder = -(position - that._range[0]);
        rectRightBorder = rectLeftBorder + rectWidth;
        checkPointerBorders();
        borderPosition += rectRightBorder;
      } else {
        pointerRightPoint = 0;
        correctCloudBorders();
      }
    }

    that._borderPosition = borderPosition;
    return {
      offset: rectLeftBorder,
      isCut: (!isLeft || pointerCenterPoint !== pointerLeftPoint) && (isLeft || pointerCenterPoint !== pointerRightPoint),
      points: [rectLeftBorder, 0, rectRightBorder, 0, rectRightBorder, rectHeight, pointerRightPoint, rectHeight, pointerCenterPoint, rectHeight + POINTER_SIZE, pointerLeftPoint, rectHeight, rectLeftBorder, rectHeight]
    };
  },
  _update: function _update() {
    var that = this;
    var textSize;
    clearTimeout(that._timeout);

    that._label.attr({
      text: that._text || ''
    });

    var currentTextSize = that._getTextSize();

    var rectSize = that._getRectSize(currentTextSize);

    textSize = that._textSize || currentTextSize;
    textSize = that._textSize = currentTextSize.width > textSize.width || currentTextSize.height > textSize.height ? currentTextSize : textSize;
    that._timeout = setTimeout(function () {
      updateSliderMarker(currentTextSize, rectSize);
      that._textSize = currentTextSize;
    }, SLIDER_MARKER_UPDATE_DELAY);

    function updateSliderMarker(size, rectSize) {
      rectSize = rectSize || that._getRectSize(size);

      that._group.attr({
        translateY: -(rectSize.height + POINTER_SIZE)
      });

      var pointsData = that._getAreaPointsInfo(size);

      var points = pointsData.points;
      var offset = pointsData.offset;

      that._area.attr({
        points: points
      });

      that._border.attr({
        x: that._isLeftPointer ? points[0] - 1 : points[2],
        height: pointsData.isCut ? rectSize.height : rectSize.height + POINTER_SIZE
      });

      that._tracker.attr({
        translateX: offset,
        width: rectSize.width,
        height: rectSize.height + POINTER_SIZE
      });

      that._label.attr({
        translateX: that._paddingLeftRight + offset,
        translateY: rectSize.height / 2 - (size.y + size.height / 2)
      });
    }

    updateSliderMarker(textSize);
  },
  setText: function setText(value) {
    this._text = value;
  },
  setPosition: function setPosition(position) {
    this._position = position;

    this._update();
  },
  applyOptions: function applyOptions(options, screenRange) {
    var that = this;
    that._range = screenRange;
    that._paddingLeftRight = options.paddingLeftRight;
    that._paddingTopBottom = options.paddingTopBottom;
    that._textHeight = null;
    that._colors = [options.invalidRangeColor, options.color];

    that._area.attr({
      fill: options.color
    });

    that._border.attr({
      fill: options.borderColor
    });

    that._label.css((0, _utils.patchFontOptions)(options.font));

    that._update();
  },
  getTracker: function getTracker() {
    return this._tracker;
  },
  setValid: function setValid(isValid) {
    this._area.attr({
      fill: this._colors[Number(isValid)]
    });
  },
  setColor: function setColor(color) {
    this._area.attr({
      fill: color
    });
  },
  dispose: function dispose() {
    clearTimeout(this._timeout);
  },
  setOverlapped: function setOverlapped(isOverlapped) {
    var that = this;

    if (that._isOverlapped !== isOverlapped) {
      if (isOverlapped) {
        that._border.append(that._group);
      } else {
        that._isOverlapped && that._border.remove();
      }

      that._isOverlapped = isOverlapped;
    }
  },
  getBorderPosition: function getBorderPosition() {
    return this._borderPosition;
  }
};
var _default = SliderMarker;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1085 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Tracker = Tracker;

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _pointer = _interopRequireDefault(__webpack_require__(25));

var _window = __webpack_require__(7);

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _iterator = __webpack_require__(3);

var _support = __webpack_require__(48);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var MIN_MANUAL_SELECTING_WIDTH = 10;
var window = (0, _window.getWindow)();

function isLeftButtonPressed(event) {
  var e = event || window.event;
  var originalEvent = e.originalEvent;
  var touches = e.touches;
  var pointerType = originalEvent ? originalEvent.pointerType : false;
  var eventTouches = originalEvent ? originalEvent.touches : false;
  var isMSPointerLeftClick = originalEvent && pointerType !== undefined && (pointerType === (originalEvent.MSPOINTER_TYPE_TOUCH || 'touch') || pointerType === (originalEvent.MSPOINTER_TYPE_MOUSE || 'mouse') && originalEvent.buttons === 1);
  var isTouches = touches && touches.length > 0 || eventTouches && eventTouches.length > 0;
  return e.which === 1 || isMSPointerLeftClick || isTouches;
}

function isMultiTouches(event) {
  var originalEvent = event.originalEvent;
  var touches = event.touches;
  var eventTouches = originalEvent && originalEvent.touches;
  return touches && touches.length > 1 || eventTouches && eventTouches.length > 1 || null;
}

function preventDefault(e) {
  if (!isMultiTouches(e)) {
    e.preventDefault();
  }
}

function stopPropagationAndPreventDefault(e) {
  if (!isMultiTouches(e)) {
    e.stopPropagation();
    e.preventDefault();
  }
} // Q375042


function isTouchEventArgs(e) {
  return e && e.type && e.type.indexOf('touch') === 0;
}

function getEventPageX(event) {
  var originalEvent = event.originalEvent;
  var result = 0;

  if (event.pageX) {
    result = event.pageX;
  } else if (originalEvent && originalEvent.pageX) {
    result = originalEvent.pageX;
  }

  if (originalEvent && originalEvent.touches) {
    if (originalEvent.touches.length > 0) {
      result = originalEvent.touches[0].pageX;
    } else if (originalEvent.changedTouches.length > 0) {
      result = originalEvent.changedTouches[0].pageX;
    }
  }

  return result;
}

function initializeAreaEvents(controller, area, state, getRootOffsetLeft) {
  var _docEvents;

  var isTouchEvent;
  var isActive = false;
  var initialPosition;
  var movingHandler = null;
  var docEvents = (_docEvents = {}, _defineProperty(_docEvents, _pointer.default.move, function (e) {
    var position;
    var offset;
    if (isTouchEvent !== isTouchEventArgs(e)) return;

    if (!isLeftButtonPressed(e)) {
      cancel(e);
    }

    if (isActive) {
      position = getEventPageX(e);
      offset = getRootOffsetLeft();

      if (movingHandler) {
        movingHandler(position - offset, e);
      } else {
        if (state.manualRangeSelectionEnabled && Math.abs(initialPosition - position) >= MIN_MANUAL_SELECTING_WIDTH) {
          movingHandler = controller.placeSliderAndBeginMoving(initialPosition - offset, position - offset, e);
        }
      }
    }
  }), _defineProperty(_docEvents, _pointer.default.up, function (e) {
    var position;

    if (isActive) {
      position = getEventPageX(e);

      if (!movingHandler && state.moveSelectedRangeByClick && Math.abs(initialPosition - position) < MIN_MANUAL_SELECTING_WIDTH) {
        controller.moveSelectedArea(position - getRootOffsetLeft(), e);
      }

      cancel(e);
    }
  }), _docEvents);

  function cancel(e) {
    if (isActive) {
      isActive = false;

      if (movingHandler) {
        movingHandler.complete(e);
        movingHandler = null;
      }
    }
  }

  area.on(_pointer.default.down, function (e) {
    if (!state.enabled || !isLeftButtonPressed(e) || isActive) return;
    isActive = true;
    isTouchEvent = isTouchEventArgs(e);
    initialPosition = getEventPageX(e);
  });
  return docEvents;
}

function initializeSelectedAreaEvents(controller, area, state, getRootOffsetLeft) {
  var _docEvents2;

  var isTouchEvent;
  var isActive = false;
  var movingHandler = null;
  var docEvents = (_docEvents2 = {}, _defineProperty(_docEvents2, _pointer.default.move, function (e) {
    if (isTouchEvent !== isTouchEventArgs(e)) return;

    if (!isLeftButtonPressed(e)) {
      cancel(e);
    }

    if (isActive) {
      preventDefault(e);
      movingHandler(getEventPageX(e) - getRootOffsetLeft(), e);
    }
  }), _defineProperty(_docEvents2, _pointer.default.up, cancel), _docEvents2);

  function cancel(e) {
    if (isActive) {
      isActive = false;
      movingHandler.complete(e);
      movingHandler = null;
    }
  }

  area.on(_pointer.default.down, function (e) {
    if (!state.enabled || !isLeftButtonPressed(e) || isActive) return;
    isActive = true;
    isTouchEvent = isTouchEventArgs(e);
    movingHandler = controller.beginSelectedAreaMoving(getEventPageX(e) - getRootOffsetLeft());
    stopPropagationAndPreventDefault(e);
  });
  return docEvents;
}

function initializeSliderEvents(controller, sliders, state, getRootOffsetLeft) {
  var _docEvents3;

  var isTouchEvent;
  var isActive = false;
  var movingHandler = null;
  var docEvents = (_docEvents3 = {}, _defineProperty(_docEvents3, _pointer.default.move, function (e) {
    if (isTouchEvent !== isTouchEventArgs(e)) return;

    if (!isLeftButtonPressed(e)) {
      cancel(e);
    }

    if (isActive) {
      preventDefault(e);
      movingHandler(getEventPageX(e) - getRootOffsetLeft(), e);
    }
  }), _defineProperty(_docEvents3, _pointer.default.up, cancel), _docEvents3);
  (0, _iterator.each)(sliders, function (i, slider) {
    var _slider$on;

    slider.on((_slider$on = {}, _defineProperty(_slider$on, _pointer.default.down, function (e) {
      if (!state.enabled || !isLeftButtonPressed(e) || isActive) return;
      isActive = true;
      isTouchEvent = isTouchEventArgs(e);
      movingHandler = controller.beginSliderMoving(i, getEventPageX(e) - getRootOffsetLeft());
      stopPropagationAndPreventDefault(e);
    }), _defineProperty(_slider$on, _pointer.default.move, function () {
      if (!movingHandler) {
        controller.foregroundSlider(i);
      }
    }), _slider$on));
  });

  function cancel(e) {
    if (isActive) {
      isActive = false;
      movingHandler.complete(e);
      movingHandler = null;
    }
  }

  return docEvents;
}

function Tracker(params) {
  var state = this._state = {};
  var targets = params.controller.getTrackerTargets();

  if (_support.pointerEvents) {
    params.renderer.root.css({
      'msTouchAction': 'pinch-zoom'
    });
  }

  this._docEvents = [initializeSelectedAreaEvents(params.controller, targets.selectedArea, state, getRootOffsetLeft), initializeAreaEvents(params.controller, targets.area, state, getRootOffsetLeft), initializeSliderEvents(params.controller, targets.sliders, state, getRootOffsetLeft)]; // TODO: 3 "move" and 3 "end" events - do we really need that much?

  (0, _iterator.each)(this._docEvents, function (_, events) {
    _events_engine.default.on(_dom_adapter.default.getDocument(), events);
  });

  function getRootOffsetLeft() {
    return params.renderer.getRootOffset().left;
  }
}

Tracker.prototype = {
  constructor: Tracker,
  dispose: function dispose() {
    (0, _iterator.each)(this._docEvents, function (_, events) {
      _events_engine.default.off(_dom_adapter.default.getDocument(), events);
    });
  },
  update: function update(enabled, behavior) {
    var state = this._state;
    state.enabled = enabled;
    state.moveSelectedRangeByClick = behavior.moveSelectedRangeByClick;
    state.manualRangeSelectionEnabled = behavior.manualRangeSelectionEnabled;
  }
};

/***/ }),
/* 1086 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.RangeView = RangeView;

// TODO: Move it inside the "SeriesDataSource"
function drawSeriesView(root, seriesDataSource, canvas, isAnimationEnabled) {
  var seriesList = seriesDataSource.getSeries();

  if (!seriesList.length) {
    return;
  }

  var valueAxis = seriesList[0].getValueAxis();
  valueAxis.updateCanvas({
    top: canvas.top,
    bottom: 0,
    height: canvas.height + canvas.top
  });
  seriesDataSource.adjustSeriesDimensions();
  var valueRange = seriesDataSource.getBoundRange().val;
  valueRange.sortCategories(valueAxis.getCategoriesSorter());
  valueAxis.setBusinessRange(valueRange);
  seriesList.forEach(function (series) {
    series._extGroups.seriesGroup = series._extGroups.labelsGroup = root;
    series.draw(isAnimationEnabled);
  });
}

function merge(a, b) {
  return a !== undefined ? a : b;
}

function RangeView(params) {
  this._params = params;
  this._clipRect = params.renderer.clipRect();
  params.root.attr({
    'clip-path': this._clipRect.id
  });
}

RangeView.prototype = {
  constructor: RangeView,
  update: function update(backgroundOption, backgroundTheme, canvas, isCompactMode, isAnimationEnabled, seriesDataSource) {
    var renderer = this._params.renderer;
    var root = this._params.root;
    var canvasWidth = canvas.width - canvas.left;
    var seriesGroup;
    backgroundOption = backgroundOption || {};
    root.clear();

    this._clipRect.attr({
      x: canvas.left,
      y: canvas.top,
      width: canvasWidth,
      height: canvas.height
    });

    if (!isCompactMode) {
      if (merge(backgroundOption.visible, backgroundTheme.visible)) {
        if (backgroundOption.color) {
          renderer.rect(canvas.left, canvas.top, canvasWidth + 1, canvas.height).attr({
            // Seems that "backgroundTheme.color" is never used and so can be removed both from here and from themes
            // TODO: Check it (special attention to WidgetsGallery) and remove the option
            fill: merge(backgroundOption.color, backgroundTheme.color),
            'class': 'dx-range-selector-background'
          }).append(root);
        }

        if (backgroundOption.image && backgroundOption.image.url) {
          renderer.image(canvas.left, canvas.top, canvasWidth + 1, canvas.height, backgroundOption.image.url, merge(backgroundOption.image.location, backgroundTheme.image.location)).append(root);
        }
      }

      if (seriesDataSource && seriesDataSource.isShowChart()) {
        seriesGroup = renderer.g().attr({
          'class': 'dxrs-series-group'
        }).append(root);
        drawSeriesView(seriesGroup, seriesDataSource, canvas, isAnimationEnabled);
      }
    }
  }
};

/***/ }),
/* 1087 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.SeriesDataSource = void 0;

var _base_series = __webpack_require__(347);

var _series_family = __webpack_require__(599);

var _type = __webpack_require__(1);

var _extend = __webpack_require__(0);

var _array = __webpack_require__(12);

var _iterator = __webpack_require__(3);

var _utils = __webpack_require__(14);

var _range = __webpack_require__(141);

var _data_validator = __webpack_require__(345);

var _chart_theme_manager = __webpack_require__(590);

var createThemeManager = function createThemeManager(chartOptions) {
  return new _chart_theme_manager.ThemeManager({
    options: chartOptions,
    themeSection: 'rangeSelector.chart',
    fontFields: ['commonSeriesSettings.label.font']
  });
};

var processSeriesFamilies = function processSeriesFamilies(series, minBubbleSize, maxBubbleSize, barOptions, negativesAsZeroes) {
  var families = [];
  var types = [];
  (0, _iterator.each)(series, function (i, item) {
    if ((0, _array.inArray)(item.type, types) === -1) {
      types.push(item.type);
    }
  });
  (0, _iterator.each)(types, function (_, type) {
    var family = new _series_family.SeriesFamily({
      type: type,
      minBubbleSize: minBubbleSize,
      maxBubbleSize: maxBubbleSize,
      barGroupPadding: barOptions.barGroupPadding,
      barGroupWidth: barOptions.barGroupWidth,
      negativesAsZeroes: negativesAsZeroes
    });
    family.add(series);
    family.adjustSeriesValues();
    families.push(family);
  });
  return families;
};

var SeriesDataSource = function SeriesDataSource(options) {
  var that = this;
  var themeManager = that._themeManager = createThemeManager(options.chart);
  themeManager.setTheme(options.chart.theme);
  var topIndent = themeManager.getOptions('topIndent');
  var bottomIndent = themeManager.getOptions('bottomIndent');
  that._indent = {
    top: topIndent >= 0 && topIndent < 1 ? topIndent : 0,
    bottom: bottomIndent >= 0 && bottomIndent < 1 ? bottomIndent : 0
  };
  that._valueAxis = themeManager.getOptions('valueAxisRangeSelector') || {};
  that._hideChart = false;
  that._series = that._calculateSeries(options);
  that._seriesFamilies = [];
};

exports.SeriesDataSource = SeriesDataSource;
SeriesDataSource.prototype = {
  constructor: SeriesDataSource,
  _calculateSeries: function _calculateSeries(options) {
    var that = this;
    var series = [];
    var particularSeriesOptions;
    var seriesTheme;
    var data = options.dataSource || [];
    var parsedData;
    var chartThemeManager = that._themeManager;
    var seriesTemplate = chartThemeManager.getOptions('seriesTemplate');
    var allSeriesOptions = seriesTemplate ? (0, _utils.processSeriesTemplate)(seriesTemplate, data) : options.chart.series;
    var dataSourceField;
    var valueAxis = that._valueAxis;
    var i;
    var newSeries;
    var groupsData;

    if (options.dataSource && !allSeriesOptions) {
      dataSourceField = options.dataSourceField || 'arg';
      allSeriesOptions = {
        argumentField: dataSourceField,
        valueField: dataSourceField
      };
      that._hideChart = true;
    }

    allSeriesOptions = Array.isArray(allSeriesOptions) ? allSeriesOptions : allSeriesOptions ? [allSeriesOptions] : [];

    for (i = 0; i < allSeriesOptions.length; i++) {
      particularSeriesOptions = (0, _extend.extend)(true, {}, allSeriesOptions[i]);
      particularSeriesOptions.rotated = false;
      seriesTheme = chartThemeManager.getOptions('series', particularSeriesOptions, allSeriesOptions.length);
      seriesTheme.argumentField = seriesTheme.argumentField || options.dataSourceField; // B253068

      if (!seriesTheme.name) {
        seriesTheme.name = 'Series ' + (i + 1).toString();
      }

      if (data && data.length > 0) {
        // TODO
        newSeries = new _base_series.Series({
          renderer: options.renderer,
          argumentAxis: options.argumentAxis,
          valueAxis: options.valueAxis,
          incidentOccurred: options.incidentOccurred
        }, seriesTheme);
        series.push(newSeries);
      }
    }

    if (series.length) {
      groupsData = {
        groups: [{
          series: series,
          valueAxis: options.valueAxis,
          valueOptions: {
            type: valueAxis.type,
            valueType: dataSourceField ? options.valueType : valueAxis.valueType
          }
        }],
        argumentOptions: {
          categories: options.categories,
          argumentType: options.valueType,
          type: options.axisType
        }
      };
      parsedData = (0, _data_validator.validateData)(data, groupsData, options.incidentOccurred, chartThemeManager.getOptions('dataPrepareSettings'));
      that.argCategories = groupsData.categories;

      for (i = 0; i < series.length; i++) {
        series[i].updateData(parsedData[series[i].getArgumentField()]);
      }
    }

    return series;
  },
  createPoints: function createPoints() {
    if (this._series.length === 0) {
      return;
    }

    var series = this._series;
    var viewport = new _range.Range();
    var axis = series[0].getArgumentAxis();
    var themeManager = this._themeManager;
    var negativesAsZeroes = themeManager.getOptions('negativesAsZeroes');
    var negativesAsZeros = themeManager.getOptions('negativesAsZeros'); // misspelling case

    series.forEach(function (s) {
      viewport.addRange(s.getArgumentRange());
    });
    axis.getTranslator().updateBusinessRange(viewport);
    series.forEach(function (s) {
      s.createPoints();
    });
    this._seriesFamilies = processSeriesFamilies(series, themeManager.getOptions('minBubbleSize'), themeManager.getOptions('maxBubbleSize'), {
      barGroupPadding: themeManager.getOptions('barGroupPadding'),
      barGroupWidth: themeManager.getOptions('barGroupWidth')
    }, (0, _type.isDefined)(negativesAsZeroes) ? negativesAsZeroes : negativesAsZeros);
  },
  adjustSeriesDimensions: function adjustSeriesDimensions() {
    (0, _iterator.each)(this._seriesFamilies, function (_, family) {
      family.adjustSeriesDimensions();
    });
  },
  getBoundRange: function getBoundRange() {
    var that = this;
    var rangeData;
    var valueAxis = that._valueAxis;
    var valRange = new _range.Range({
      min: valueAxis.min,
      minVisible: valueAxis.min,
      max: valueAxis.max,
      maxVisible: valueAxis.max,
      axisType: valueAxis.type,
      base: valueAxis.logarithmBase
    });
    var argRange = new _range.Range({});
    var rangeYSize;
    var rangeVisibleSizeY;
    var minIndent;
    var maxIndent;
    (0, _iterator.each)(that._series, function (_, series) {
      rangeData = series.getRangeData();
      valRange.addRange(rangeData.val);
      argRange.addRange(rangeData.arg);
    });

    if (!valRange.isEmpty() && !argRange.isEmpty()) {
      minIndent = valueAxis.inverted ? that._indent.top : that._indent.bottom;
      maxIndent = valueAxis.inverted ? that._indent.bottom : that._indent.top;
      rangeYSize = valRange.max - valRange.min;
      rangeVisibleSizeY = ((0, _type.isNumeric)(valRange.maxVisible) ? valRange.maxVisible : valRange.max) - ((0, _type.isNumeric)(valRange.minVisible) ? valRange.minVisible : valRange.min); // B253717

      if ((0, _type.isDate)(valRange.min)) {
        valRange.min = new Date(valRange.min.valueOf() - rangeYSize * minIndent);
      } else {
        valRange.min -= rangeYSize * minIndent;
      }

      if ((0, _type.isDate)(valRange.max)) {
        valRange.max = new Date(valRange.max.valueOf() + rangeYSize * maxIndent);
      } else {
        valRange.max += rangeYSize * maxIndent;
      }

      if ((0, _type.isNumeric)(rangeVisibleSizeY)) {
        valRange.maxVisible = valRange.maxVisible ? valRange.maxVisible + rangeVisibleSizeY * maxIndent : undefined;
        valRange.minVisible = valRange.minVisible ? valRange.minVisible - rangeVisibleSizeY * minIndent : undefined;
      }

      valRange.invert = valueAxis.inverted;
    }

    return {
      arg: argRange,
      val: valRange
    };
  },
  getMarginOptions: function getMarginOptions(canvas) {
    var bubbleSize = Math.min(canvas.width, canvas.height) * this._themeManager.getOptions('maxBubbleSize');

    return this._series.reduce(function (marginOptions, series) {
      var seriesOptions = series.getMarginOptions();

      if (seriesOptions.processBubbleSize === true) {
        seriesOptions.size = bubbleSize;
      }

      return (0, _utils.mergeMarginOptions)(marginOptions, seriesOptions);
    }, {});
  },
  getSeries: function getSeries() {
    return this._series;
  },
  isEmpty: function isEmpty() {
    return this.getSeries().length === 0;
  },
  isShowChart: function isShowChart() {
    return !this._hideChart;
  },
  getCalculatedValueType: function getCalculatedValueType() {
    var series = this._series[0];
    return series === null || series === void 0 ? void 0 : series.argumentType;
  },
  getThemeManager: function getThemeManager() {
    return this._themeManager;
  }
};

/***/ }),
/* 1088 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _vector_map = _interopRequireDefault(__webpack_require__(1089));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = _vector_map.default;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1089 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _utils = __webpack_require__(14);

var _projection = __webpack_require__(605);

var _control_bar = __webpack_require__(1090);

var _gesture_handler = __webpack_require__(1091);

var _tracker = __webpack_require__(1092);

var _data_exchanger = __webpack_require__(1093);

var _legend = __webpack_require__(1094);

var _layout = __webpack_require__(1095);

var _map_layer = __webpack_require__(1096);

var _tooltip_viewer = __webpack_require__(1097);

var _vector_map = __webpack_require__(1098);

__webpack_require__(607);

var _base_widget = _interopRequireDefault(__webpack_require__(119));

var _component_registrator = _interopRequireDefault(__webpack_require__(9));

var _export = __webpack_require__(118);

var _title = __webpack_require__(138);

var _tooltip = __webpack_require__(140);

var _loading_indicator = __webpack_require__(163);

var _annotations = __webpack_require__(244);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_WIDTH = 800;
var DEFAULT_HEIGHT = 400;
var RE_STARTS_LAYERS = /^layers/;
var RE_ENDS_DATA_SOURCE = /\.dataSource$/;

function mergeBounds(sumBounds, dataBounds) {
  return dataBounds ? [Math.min(dataBounds[0], dataBounds[2], sumBounds[0]), Math.min(dataBounds[1], dataBounds[3], sumBounds[3]), Math.max(dataBounds[0], dataBounds[2], sumBounds[2]), Math.max(dataBounds[1], dataBounds[3], sumBounds[1])] : sumBounds;
}

var dxVectorMap = _base_widget.default.inherit({
  _eventsMap: {
    'onClick': {
      name: 'click'
    },
    'onCenterChanged': {
      name: 'centerChanged'
    },
    'onZoomFactorChanged': {
      name: 'zoomFactorChanged'
    },
    'onHoverChanged': {
      name: 'hoverChanged'
    },
    'onSelectionChanged': {
      name: 'selectionChanged'
    }
  },
  _rootClassPrefix: 'dxm',
  _rootClass: 'dxm-vector-map',
  _themeSection: 'map',
  _fontFields: ['layer:area.label.font', 'layer:marker:dot.label.font', 'layer:marker:bubble.label.font', 'layer:marker:pie.label.font', 'layer:marker:image.label.font', 'legend.font', 'legend.title.font', 'legend.title.subtitle.font'],
  _initLayerCollection: function _initLayerCollection(dataKey) {
    var that = this;
    that._layerCollection = new _map_layer.MapLayerCollection({
      renderer: that._renderer,
      projection: that._projection,
      themeManager: that._themeManager,
      tracker: that._tracker,
      dataKey: dataKey,
      eventTrigger: that._eventTrigger,
      dataExchanger: that._dataExchanger,
      tooltip: that._tooltip,
      notifyDirty: that._notifyDirty,
      notifyReady: that._notifyReady,
      dataReady: function dataReady() {
        var bounds;

        if (that.option('getBoundsFromData') && !that.option('bounds')) {
          that._preventProjectionEvents();

          bounds = that._getBoundsFromData();

          that._projection.setBounds(bounds);

          that._allowProjectionEvents();
        }

        if (!that.option('projection')) {
          bounds = bounds || that._getBoundsFromData();

          if (Math.ceil(bounds[0]) < -180 || Math.ceil(bounds[3]) < -90 || Math.floor(bounds[2]) > 180 || Math.floor(bounds[1]) > 90) {
            var longitudeLength = bounds[2] - bounds[0];
            var latitudeLength = bounds[1] - bounds[3];

            that._projection.setEngine({
              to: function to(coordinates) {
                return [(coordinates[0] - bounds[0]) * 2 / longitudeLength - 1, (coordinates[1] - bounds[3]) * 2 / latitudeLength - 1];
              },
              from: function from(coordinates) {
                return [(coordinates[0] + 1) * longitudeLength / 2 + bounds[0], (coordinates[1] + 1) * latitudeLength / 2 + bounds[3]];
              }
            });
          }
        }
      }
    });
  },
  _getBoundsFromData: function _getBoundsFromData() {
    var bounds = this._getBoundingBoxFromDataSource();

    if (!bounds) {
      var boundsByData = (0, _map_layer.getMaxBound)(this.getLayers().map(function (l) {
        return l.getBounds();
      }));

      if (boundsByData) {
        bounds = boundsByData;
      }
    }

    bounds = bounds || [];
    bounds = [bounds[0], bounds[3], bounds[2], bounds[1]];
    return bounds;
  },
  _initLegendsControl: function _initLegendsControl() {
    var that = this;
    that._legendsControl = new _legend.LegendsControl({
      renderer: that._renderer,
      container: that._root,
      widget: that,
      layoutControl: that._layoutControl,
      themeManager: that._themeManager,
      dataExchanger: that._dataExchanger,
      notifyDirty: that._notifyDirty,
      notifyReady: that._notifyReady
    });
  },
  _initControlBar: function _initControlBar(dataKey) {
    var that = this;
    that._controlBar = new _control_bar.ControlBar({
      renderer: that._renderer,
      container: that._root,
      layoutControl: that._layoutControl,
      projection: that._projection,
      tracker: that._tracker,
      dataKey: dataKey
    });
  },
  _initElements: function _initElements() {
    var that = this;
    var dataKey = (0, _vector_map.generateDataKey)();
    var notifyCounter = 0;
    var preventProjectionEvents;

    that._preventProjectionEvents = function () {
      preventProjectionEvents = true;
    };

    that._allowProjectionEvents = function () {
      preventProjectionEvents = false;
    };

    that._notifyDirty = function () {
      that._resetIsReady();

      ++notifyCounter;
    };

    that._notifyReady = function () {
      that._allowProjectionEvents();

      if (--notifyCounter === 0) {
        that._drawn();
      }
    };

    that._preventProjectionEvents();

    that._dataExchanger = new _data_exchanger.DataExchanger(); // The `{ eventTrigger: that._eventTrigger }` object cannot be passed to the Projection because later backward option updating is going to be added.

    that._projection = new _projection.Projection({
      centerChanged: function centerChanged(value) {
        if (!preventProjectionEvents) {
          that._eventTrigger('centerChanged', {
            center: value
          });
        }
      },
      zoomChanged: function zoomChanged(value) {
        if (!preventProjectionEvents) {
          that._eventTrigger('zoomFactorChanged', {
            zoomFactor: value
          });
        }
      }
    });
    that._tracker = new _tracker.Tracker({
      root: that._root,
      projection: that._projection,
      dataKey: dataKey
    });
    that._gestureHandler = new _gesture_handler.GestureHandler({
      projection: that._projection,
      renderer: that._renderer,
      tracker: that._tracker
    });
    that._layoutControl = new _layout.LayoutControl(that);

    that._layoutControl.suspend();

    that._initLayerCollection(dataKey);

    that._createHtmlStructure();

    that._initControlBar(dataKey);

    that._initLegendsControl();

    that._prepareExtraElements();

    that._tooltipViewer = new _tooltip_viewer.TooltipViewer({
      tracker: that._tracker,
      tooltip: that._tooltip,
      layerCollection: that._layerCollection
    });
  },
  _change_RESUME_LAYOUT: function _change_RESUME_LAYOUT() {
    this._layoutControl.resume();
  },
  _initialChanges: ['PROJECTION', 'RESUME_LAYOUT', 'LAYOUT_INIT', 'BOUNDS', 'MAX_ZOOM_FACTOR', 'ZOOM_FACTOR', 'CENTER'],
  _layoutChangesOrder: ['RESUME_LAYOUT', 'LAYERS'],
  _customChangesOrder: ['EXTRA_ELEMENTS'],
  _initCore: function _initCore() {
    this._root = this._renderer.root.attr({
      align: 'center',
      cursor: 'default'
    });

    this._initElements();
  },
  _disposeCore: function _disposeCore() {
    var that = this;

    that._controlBar.dispose();

    that._gestureHandler.dispose();

    that._tracker.dispose();

    that._legendsControl.dispose();

    that._layerCollection.dispose();

    that._layoutControl.dispose();

    that._tooltipViewer.dispose();

    that._dataExchanger.dispose();

    that._projection.dispose();

    that._dataExchanger = that._gestureHandler = that._projection = that._tracker = that._layoutControl = that._root = that._layerCollection = that._controlBar = that._legendsControl = null;
  },
  _setupInteraction: function _setupInteraction() {
    var options = {
      centeringEnabled: !!(0, _utils.parseScalar)(this._getOption('panningEnabled', true), true),
      zoomingEnabled: !!(0, _utils.parseScalar)(this._getOption('zoomingEnabled', true), true)
    };

    this._gestureHandler.setInteraction(options);

    this._controlBar.setInteraction(options);
  },
  _getDefaultSize: function _getDefaultSize() {
    return {
      width: DEFAULT_WIDTH,
      height: DEFAULT_HEIGHT
    };
  },
  _applySize: function _applySize(rect) {
    var layout = {
      left: rect[0],
      top: rect[1],
      width: rect[2] - rect[0],
      height: rect[3] - rect[1],
      right: 0,
      bottom: 0
    };

    this._projection.setSize(layout);

    this._layoutControl.setSize(layout);

    this._layerCollection.setRect([layout.left, layout.top, layout.width, layout.height]);

    this._requestChange(['EXTRA_ELEMENTS']);
  },
  // The "layers_data", "mapData", "markers" options must never be merged (because of their meaning)
  // For "layers_data" there are special cases: "layers", "layers.data", "layers[i]", "layers[i].data"
  // Because of the cases (1) and (3) "option by reference" mechanism cannot be used -
  // so separate (for dxVectorMap only by now) mechanism is introduced - it handles all cases (including "option by reference")
  // T318992
  // Previously mechanism used the "_optionValuesEqual" method but after T318992 usage of "_optionValuesEqual" was stopped
  // and new (more meaningful) method was added - "_optionChanging"
  _optionChanging: function _optionChanging(name, currentValue, nextValue) {
    if (currentValue && nextValue) {
      if (RE_STARTS_LAYERS.test(name)) {
        if (currentValue.dataSource && nextValue.dataSource && currentValue !== nextValue) {
          currentValue.dataSource = null;
        } else if (RE_ENDS_DATA_SOURCE.test(name)) {
          this.option(name, null);
        }
      }
    }
  },
  _applyChanges: function _applyChanges() {
    this._notifyDirty();

    this.callBase.apply(this, arguments);

    this._notifyReady();
  },
  _optionChangesMap: {
    background: 'BACKGROUND',
    layers: 'LAYERS',
    extraElements: 'EXTRA_ELEMENTS',
    controlBar: 'CONTROL_BAR',
    legends: 'LEGENDS',
    touchEnabled: 'TRACKER',
    wheelEnabled: 'TRACKER',
    panningEnabled: 'INTERACTION',
    zoomingEnabled: 'INTERACTION',
    projection: 'PROJECTION',
    bounds: 'BOUNDS',
    maxZoomFactor: 'MAX_ZOOM_FACTOR',
    zoomFactor: 'ZOOM_FACTOR',
    center: 'CENTER'
  },
  _optionChangesOrder: ['PROJECTION', 'BOUNDS', 'MAX_ZOOM_FACTOR', 'ZOOM_FACTOR', 'CENTER', 'BACKGROUND', 'CONTROL_BAR', 'LEGENDS', 'TRACKER', 'INTERACTION'],
  _change_PROJECTION: function _change_PROJECTION() {
    this._setProjection();
  },
  _change_BOUNDS: function _change_BOUNDS() {
    this._setBounds();
  },
  _change_MAX_ZOOM_FACTOR: function _change_MAX_ZOOM_FACTOR() {
    this._setMaxZoom();
  },
  _change_ZOOM_FACTOR: function _change_ZOOM_FACTOR() {
    this._setZoom();
  },
  _change_CENTER: function _change_CENTER() {
    this._setCenter();
  },
  _change_BACKGROUND: function _change_BACKGROUND() {
    this._setBackgroundOptions();
  },
  _change_LAYERS: function _change_LAYERS() {
    this._setLayerCollectionOptions();
  },
  _change_CONTROL_BAR: function _change_CONTROL_BAR() {
    this._setControlBarOptions();
  },
  _change_EXTRA_ELEMENTS: function _change_EXTRA_ELEMENTS() {
    this._renderExtraElements();
  },
  _change_LEGENDS: function _change_LEGENDS() {
    this._setLegendsOptions();
  },
  _change_TRACKER: function _change_TRACKER() {
    this._setTrackerOptions();
  },
  _change_INTERACTION: function _change_INTERACTION() {
    this._setupInteraction();
  },
  _themeDependentChanges: ['BACKGROUND', 'LAYERS', 'CONTROL_BAR', 'LEGENDS', 'TRACKER', 'INTERACTION'],
  _setProjection: function _setProjection() {
    this._projection.setEngine(this.option('projection'));
  },
  _setBounds: function _setBounds() {
    this._projection.setBounds(this.option('bounds'));
  },
  _setMaxZoom: function _setMaxZoom() {
    this._projection.setMaxZoom(this.option('maxZoomFactor'));
  },
  _setZoom: function _setZoom() {
    this._projection.setZoom(this.option('zoomFactor'));
  },
  _setCenter: function _setCenter() {
    this._projection.setCenter(this.option('center'));
  },
  _setBackgroundOptions: function _setBackgroundOptions() {
    this._layerCollection.setBackgroundOptions(this._getOption('background'));
  },
  _setLayerCollectionOptions: function _setLayerCollectionOptions() {
    this._layerCollection.setOptions(this.option('layers'));
  },
  _getBoundingBoxFromDataSource: function _getBoundingBoxFromDataSource() {
    var that = this;

    var layers = that._layerCollection.items();

    var infinityBounds = [Infinity, -Infinity, -Infinity, Infinity];
    var resultBBox = layers && layers.length ? layers.reduce(function (sumBBox, l) {
      var layerData = l.getData();
      var itemCount = layerData.count();

      if (itemCount > 0) {
        var rootBBox = layerData.getBBox();

        if (rootBBox) {
          sumBBox = mergeBounds(sumBBox, rootBBox);
        } else {
          for (var i = 0; i < itemCount; i++) {
            sumBBox = mergeBounds(sumBBox, layerData.getBBox(i));
          }
        }
      }

      return sumBBox;
    }, infinityBounds) : undefined;
    return resultBBox === infinityBounds ? undefined : resultBBox;
  },
  _setControlBarOptions: function _setControlBarOptions() {
    this._controlBar.setOptions(this._getOption('controlBar'));
  },
  _setLegendsOptions: function _setLegendsOptions() {
    this._legendsControl.setOptions(this.option('legends'));
  },
  _setTrackerOptions: function _setTrackerOptions() {
    this._tracker.setOptions({
      touchEnabled: this._getOption('touchEnabled', true),
      wheelEnabled: this._getOption('wheelEnabled', true)
    });
  },
  getLayers: function getLayers() {
    return this._layerCollection.items().map(function (l) {
      return l.proxy;
    });
  },
  getLayerByIndex: function getLayerByIndex(index) {
    var layer = this._layerCollection.byIndex(index);

    return layer ? layer.proxy : null;
  },
  getLayerByName: function getLayerByName(name) {
    var layer = this._layerCollection.byName(name);

    return layer ? layer.proxy : null;
  },
  clearSelection: function clearSelection(_noEvent) {
    var layers = this._layerCollection.items();

    var i;
    var ii = layers.length;

    for (i = 0; i < ii; ++i) {
      layers[i].clearSelection(_noEvent);
    }

    return this;
  },
  center: function center(value) {
    var that = this;

    if (value === undefined) {
      return that._projection.getCenter();
    } else {
      that._projection.setCenter(value);

      return that;
    }
  },
  zoomFactor: function zoomFactor(value) {
    var that = this;

    if (value === undefined) {
      return that._projection.getZoom();
    } else {
      that._projection.setZoom(value);

      return that;
    }
  },
  viewport: function viewport(value) {
    var that = this;

    if (value === undefined) {
      return that._projection.getViewport();
    } else {
      that._projection.setViewport(value);

      return that;
    }
  },
  convertCoordinates: function convertCoordinates(coordinates) {
    coordinates = coordinates && coordinates.length ? coordinates : [arguments[0], arguments[1]];
    return this.convertToGeo(coordinates[0], coordinates[1]);
  },
  convertToGeo: function convertToGeo(x, y) {
    return this._projection.fromScreenPoint([x, y]);
  },
  convertToXY: function convertToXY(longitude, latitude) {
    return this._projection.toScreenPoint([longitude, latitude]);
  }
});

(0, _component_registrator.default)('dxVectorMap', dxVectorMap);
var _default = dxVectorMap; // PLUGINS_SECTION

exports.default = _default;
dxVectorMap.addPlugin(_export.plugin);
dxVectorMap.addPlugin(_title.plugin);
dxVectorMap.addPlugin(_tooltip.plugin);
dxVectorMap.addPlugin(_loading_indicator.plugin);
dxVectorMap.addPlugin(_annotations.plugins.core);
dxVectorMap.addPlugin(_annotations.plugins.vectorMap);
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1090 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.ControlBar = ControlBar;

var _utils = __webpack_require__(14);

var _math = Math;
var _min = _math.min;
var _max = _math.max;
var _round = _math.round;
var _floor = _math.floor;
var _sqrt = _math.sqrt;
var parseHorizontalAlignment = (0, _utils.enumParser)(['left', 'center', 'right']);
var parseVerticalAlignment = (0, _utils.enumParser)(['top', 'bottom']);
var COMMAND_RESET = 'command-reset';
var COMMAND_MOVE_UP = 'command-move-up';
var COMMAND_MOVE_RIGHT = 'command-move-right';
var COMMAND_MOVE_DOWN = 'command-move-down';
var COMMAND_MOVE_LEFT = 'command-move-left';
var COMMAND_ZOOM_IN = 'command-zoom-in';
var COMMAND_ZOOM_OUT = 'command-zoom-out';
var COMMAND_ZOOM_DRAG_LINE = 'command-zoom-drag-line';
var COMMAND_ZOOM_DRAG = 'command-zoom-drag';
var EVENT_TARGET_TYPE = 'control-bar';
var FLAG_CENTERING = 1;
var FLAG_ZOOMING = 2; // TODO: This should be specified in options - seems like everything can be calculated from "buttonSize" and "zoomSliderLength"

var SIZE_OPTIONS = {
  bigCircleSize: 58,
  smallCircleSize: 28,
  buttonSize: 10,
  arrowButtonOffset: 20,
  incDecButtonSize: 11,
  incButtonOffset: 66,
  decButtonOffset: 227,
  sliderLineStartOffset: 88.5,
  sliderLineEndOffset: 205.5,
  sliderLength: 20,
  sliderWidth: 8,
  trackerGap: 4
};
var OFFSET_X = 30.5;
var OFFSET_Y = 30.5;
var TOTAL_WIDTH = 61;
var TOTAL_HEIGHT = 274;
var COMMAND_TO_TYPE_MAP = {};
COMMAND_TO_TYPE_MAP[COMMAND_RESET] = ResetCommand;
COMMAND_TO_TYPE_MAP[COMMAND_MOVE_UP] = COMMAND_TO_TYPE_MAP[COMMAND_MOVE_RIGHT] = COMMAND_TO_TYPE_MAP[COMMAND_MOVE_DOWN] = COMMAND_TO_TYPE_MAP[COMMAND_MOVE_LEFT] = MoveCommand;
COMMAND_TO_TYPE_MAP[COMMAND_ZOOM_IN] = COMMAND_TO_TYPE_MAP[COMMAND_ZOOM_OUT] = ZoomCommand;
COMMAND_TO_TYPE_MAP[COMMAND_ZOOM_DRAG] = ZoomDragCommand;

function ControlBar(parameters) {
  var that = this;
  that._params = parameters;

  that._createElements(parameters.renderer, parameters.container, parameters.dataKey);

  parameters.layoutControl.addItem(that);

  that._subscribeToProjection(parameters.projection);

  that._subscribeToTracker(parameters.tracker);

  that._createCallbacks(parameters.projection);
}

ControlBar.prototype = {
  constructor: ControlBar,
  _flags: 0,
  dispose: function dispose() {
    var that = this;

    that._params.layoutControl.removeItem(that);

    that._root.linkRemove().linkOff();

    that._offProjection();

    that._offTracker();

    that._params = that._root = that._offProjection = that._offTracker = that._callbacks = null;
  },
  _subscribeToProjection: function _subscribeToProjection(projection) {
    var that = this;
    that._offProjection = projection.on({
      'engine': function engine() {
        that._update();
      },
      'zoom': updateZoom,
      'max-zoom': function maxZoom() {
        that._zoomPartition = projection.getZoomScalePartition();
        that._sliderUnitLength = that._sliderLineLength / that._zoomPartition;
        updateZoom();
      }
    });

    function updateZoom() {
      that._adjustZoom(projection.getScaledZoom());
    }
  },
  _subscribeToTracker: function _subscribeToTracker(tracker) {
    var that = this;
    var isActive = false;
    that._offTracker = tracker.on({
      'start': function start(arg) {
        isActive = arg.data.name === EVENT_TARGET_TYPE;

        if (isActive) {
          that._processStart(arg.data.index, arg);
        }
      },
      'move': function move(arg) {
        if (isActive) {
          that._processMove(arg.data.index, arg);
        }
      },
      'end': function end() {
        if (isActive) {
          that._processEnd();

          isActive = false;
        }
      }
    });
  },
  _createCallbacks: function _createCallbacks(projection) {
    var that = this;
    that._callbacks = {
      reset: function reset(isCenter, isZoom) {
        if (isCenter) {
          projection.setCenter(null);
        }

        if (isZoom) {
          projection.setZoom(null);
        }
      },
      beginMove: function beginMove() {
        projection.beginMoveCenter();
      },
      endMove: function endMove() {
        projection.endMoveCenter();
      },
      move: function move(shift) {
        projection.moveCenter(shift);
      },
      zoom: function zoom(_zoom) {
        projection.setScaledZoom(_zoom);
      }
    };
  },
  _createElements: function _createElements(renderer, container, dataKey) {
    var that = this;
    that._root = renderer.g().attr({
      'class': 'dxm-control-bar'
    }).linkOn(container, 'control-bar');
    var buttonsGroups = that._buttonsGroup = renderer.g().attr({
      'class': 'dxm-control-buttons'
    }).append(that._root);
    var trackersGroup = renderer.g().attr({
      stroke: 'none',
      'stroke-width': 0,
      fill: '#000000',
      opacity: 0.0001
    }).css({
      cursor: 'pointer'
    }).append(that._root);

    that._createButtons(renderer, dataKey, buttonsGroups);

    that._createTrackers(renderer, dataKey, trackersGroup);
  },
  _createButtons: function _createButtons(renderer, dataKey, group) {
    var that = this;
    var options = SIZE_OPTIONS;
    var size = options.buttonSize / 2;
    var offset1 = options.arrowButtonOffset - size;
    var offset2 = options.arrowButtonOffset;
    var incDecButtonSize = options.incDecButtonSize / 2;
    var directionOptions = {
      'stroke-linecap': 'square',
      fill: 'none'
    };
    var line = 'line';
    renderer.circle(0, 0, options.bigCircleSize / 2).append(group);
    renderer.circle(0, 0, size).attr({
      fill: 'none'
    }).append(group);
    renderer.path([-size, -offset1, 0, -offset2, size, -offset1], line).attr(directionOptions).append(group);
    renderer.path([offset1, -size, offset2, 0, offset1, size], line).attr(directionOptions).append(group);
    renderer.path([size, offset1, 0, offset2, -size, offset1], line).attr(directionOptions).append(group);
    renderer.path([-offset1, size, -offset2, 0, -offset1, -size], line).attr(directionOptions).append(group);
    renderer.circle(0, options.incButtonOffset, options.smallCircleSize / 2).append(group);
    renderer.path([[-incDecButtonSize, options.incButtonOffset, incDecButtonSize, options.incButtonOffset], [0, options.incButtonOffset - incDecButtonSize, 0, options.incButtonOffset + incDecButtonSize]], 'area').append(group);
    renderer.circle(0, options.decButtonOffset, options.smallCircleSize / 2).append(group);
    renderer.path([-incDecButtonSize, options.decButtonOffset, incDecButtonSize, options.decButtonOffset], 'area').append(group);
    that._zoomLine = renderer.path([], 'line').append(group);
    that._zoomDrag = renderer.rect(_floor(-options.sliderLength / 2), _floor(options.sliderLineEndOffset - options.sliderWidth / 2), options.sliderLength, options.sliderWidth).append(group);
    that._sliderLineLength = options.sliderLineEndOffset - options.sliderLineStartOffset;
  },
  _createTrackers: function _createTrackers(renderer, dataKey, group) {
    var options = SIZE_OPTIONS;

    var size = _round((options.arrowButtonOffset - options.trackerGap) / 2);

    var offset1 = options.arrowButtonOffset - size;

    var offset2 = _round(_sqrt(options.bigCircleSize * options.bigCircleSize / 4 - size * size));

    var size2 = offset2 - offset1;
    renderer.rect(-size, -size, size * 2, size * 2).data(dataKey, {
      index: COMMAND_RESET,
      name: EVENT_TARGET_TYPE
    }).append(group);
    renderer.rect(-size, -offset2, size * 2, size2).data(dataKey, {
      index: COMMAND_MOVE_UP,
      name: EVENT_TARGET_TYPE
    }).append(group);
    renderer.rect(offset1, -size, size2, size * 2).data(dataKey, {
      index: COMMAND_MOVE_RIGHT,
      name: EVENT_TARGET_TYPE
    }).append(group);
    renderer.rect(-size, offset1, size * 2, size2).data(dataKey, {
      index: COMMAND_MOVE_DOWN,
      name: EVENT_TARGET_TYPE
    }).append(group);
    renderer.rect(-offset2, -size, size2, size * 2).data(dataKey, {
      index: COMMAND_MOVE_LEFT,
      name: EVENT_TARGET_TYPE
    }).append(group);
    renderer.circle(0, options.incButtonOffset, options.smallCircleSize / 2).data(dataKey, {
      index: COMMAND_ZOOM_IN,
      name: EVENT_TARGET_TYPE
    }).append(group);
    renderer.circle(0, options.decButtonOffset, options.smallCircleSize / 2).data(dataKey, {
      index: COMMAND_ZOOM_OUT,
      name: EVENT_TARGET_TYPE
    }).append(group);
    renderer.rect(-2, options.sliderLineStartOffset - 2, 4, options.sliderLineEndOffset - options.sliderLineStartOffset + 4).css({
      cursor: 'default'
    }).data(dataKey, {
      index: COMMAND_ZOOM_DRAG_LINE,
      name: EVENT_TARGET_TYPE
    }).append(group);
    this._zoomDragTracker = renderer.rect(-options.sliderLength / 2, options.sliderLineEndOffset - options.sliderWidth / 2, options.sliderLength, options.sliderWidth).data(dataKey, {
      index: COMMAND_ZOOM_DRAG,
      name: EVENT_TARGET_TYPE
    }).append(group);
  },
  // BEGIN: Implementation of LayoutTarget interface
  resize: function resize(size) {
    if (this._isActive) {
      this._root.attr({
        visibility: size !== null ? null : 'hidden'
      });
    }
  },
  getLayoutOptions: function getLayoutOptions() {
    return this._isActive ? this._layoutOptions : null;
  },
  locate: function locate(x, y) {
    this._root.attr({
      translateX: x + this._margin + OFFSET_X,
      translateY: y + this._margin + OFFSET_Y
    });
  },
  // END: Implementation of LayoutTarget interface
  _update: function _update() {
    var that = this;
    that._isActive = that._isEnabled && that._flags && that._params.projection.isInvertible();

    if (that._isActive) {
      that._root.linkAppend();
    } else {
      that._root.linkRemove();
    }

    that._processEnd();

    that.updateLayout();
  },
  setInteraction: function setInteraction(interaction) {
    var that = this;

    if ((0, _utils.parseScalar)(interaction.centeringEnabled, true)) {
      that._flags |= FLAG_CENTERING;
    } else {
      that._flags &= ~FLAG_CENTERING;
    }

    if ((0, _utils.parseScalar)(interaction.zoomingEnabled, true)) {
      that._flags |= FLAG_ZOOMING;
    } else {
      that._flags &= ~FLAG_ZOOMING;
    }

    that._update();
  },
  setOptions: function setOptions(options) {
    var that = this;
    that._isEnabled = !!(0, _utils.parseScalar)(options.enabled, true);
    that._margin = options.margin || 0;
    that._layoutOptions = {
      width: 2 * that._margin + TOTAL_WIDTH,
      height: 2 * that._margin + TOTAL_HEIGHT,
      horizontalAlignment: parseHorizontalAlignment(options.horizontalAlignment, 'left'),
      verticalAlignment: parseVerticalAlignment(options.verticalAlignment, 'top')
    };

    that._buttonsGroup.attr({
      'stroke-width': options.borderWidth,
      stroke: options.borderColor,
      fill: options.color,
      'fill-opacity': options.opacity
    });

    that._update();
  },
  _adjustZoom: function _adjustZoom(zoom) {
    var that = this;
    var start = SIZE_OPTIONS.sliderLineStartOffset;
    var end = SIZE_OPTIONS.sliderLineEndOffset;
    var h = SIZE_OPTIONS.sliderWidth;
    that._zoomFactor = _max(_min(_round(zoom), that._zoomPartition), 0);
    var transform = {
      translateY: -_round(that._zoomFactor * that._sliderUnitLength)
    };
    var y = end - h / 2 + transform.translateY;

    that._zoomLine.attr({
      points: [[0, start, 0, _max(start, y)], [0, _min(end, y + h), 0, end]]
    });

    that._zoomDrag.attr(transform);

    that._zoomDragTracker.attr(transform);
  },
  _applyZoom: function _applyZoom() {
    this._callbacks.zoom(this._zoomFactor);
  },
  _processStart: function _processStart(command, arg) {
    var commandType;

    if (this._isActive) {
      commandType = COMMAND_TO_TYPE_MAP[command];
      this._command = commandType && commandType.flags & this._flags ? new commandType(this, command, arg) : null;
    }
  },
  _processMove: function _processMove(command, arg) {
    this._command && this._command.update(command, arg);
  },
  _processEnd: function _processEnd() {
    this._command && this._command.finish();
    this._command = null;
  }
};

function disposeCommand(command) {
  delete command._owner;

  command.update = function () {};

  command.finish = function () {};
}

function ResetCommand(owner, command) {
  this._owner = owner;
  this._command = command;
}

ResetCommand.flags = FLAG_CENTERING | FLAG_ZOOMING;

ResetCommand.prototype.update = function (command) {
  command !== this._command && disposeCommand(this);
};

ResetCommand.prototype.finish = function () {
  var flags = this._owner._flags;

  this._owner._callbacks.reset(!!(flags & FLAG_CENTERING), !!(flags & FLAG_ZOOMING));

  disposeCommand(this);
};

function MoveCommand(owner, command, arg) {
  this._command = command;
  var timeout = null;
  var interval = 100;
  var dx = 0;
  var dy = 0;

  switch (this._command) {
    case COMMAND_MOVE_UP:
      dy = -10;
      break;

    case COMMAND_MOVE_RIGHT:
      dx = 10;
      break;

    case COMMAND_MOVE_DOWN:
      dy = 10;
      break;

    case COMMAND_MOVE_LEFT:
      dx = -10;
      break;
  }

  function callback() {
    owner._callbacks.move([dx, dy]);

    timeout = setTimeout(callback, interval);
  }

  this._stop = function () {
    clearTimeout(timeout);

    owner._callbacks.endMove();

    this._stop = owner = null;
    return this;
  };

  arg = null;

  owner._callbacks.beginMove();

  callback();
}

MoveCommand.flags = FLAG_CENTERING;

MoveCommand.prototype.update = function (command) {
  this._command !== command && this.finish();
};

MoveCommand.prototype.finish = function () {
  disposeCommand(this._stop());
};

function ZoomCommand(owner, command) {
  this._owner = owner;
  this._command = command;
  var timeout = null;
  var interval = 150;
  var dZoom = this._command === COMMAND_ZOOM_IN ? 1 : -1;

  function callback() {
    owner._adjustZoom(owner._zoomFactor + dZoom);

    timeout = setTimeout(callback, interval);
  }

  this._stop = function () {
    clearTimeout(timeout);
    this._stop = owner = null;
    return this;
  };

  callback();
}

ZoomCommand.flags = FLAG_ZOOMING;

ZoomCommand.prototype.update = function (command) {
  this._command !== command && this.finish();
};

ZoomCommand.prototype.finish = function () {
  this._owner._applyZoom();

  disposeCommand(this._stop());
};

function ZoomDragCommand(owner, command, arg) {
  this._owner = owner;
  this._zoomFactor = owner._zoomFactor;
  this._pos = arg.y;
}

ZoomDragCommand.flags = FLAG_ZOOMING;

ZoomDragCommand.prototype.update = function (command, arg) {
  var owner = this._owner;

  owner._adjustZoom(this._zoomFactor + owner._zoomPartition * (this._pos - arg.y) / owner._sliderLineLength);
};

ZoomDragCommand.prototype.finish = function () {
  this._owner._applyZoom();

  disposeCommand(this);
};

/***/ }),
/* 1091 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.GestureHandler = GestureHandler;
var _ln = Math.log;
var _LN2 = Math.LN2;

function GestureHandler(params) {
  var that = this;
  that._projection = params.projection;
  that._renderer = params.renderer;
  that._x = that._y = 0;

  that._subscribeToTracker(params.tracker);
}

GestureHandler.prototype = {
  constructor: GestureHandler,
  dispose: function dispose() {
    this._offTracker();

    this._offTracker = null;
  },
  _subscribeToTracker: function _subscribeToTracker(tracker) {
    var that = this;
    var isActive = false;
    that._offTracker = tracker.on({
      'start': function start(arg) {
        // TODO: This is an implicit dependency on the ControlBar which must be removed
        isActive = arg.data.name !== 'control-bar';

        if (isActive) {
          that._processStart(arg);
        }
      },
      'move': function move(arg) {
        if (isActive) {
          that._processMove(arg);
        }
      },
      'end': function end() {
        if (isActive) {
          that._processEnd();
        }
      },
      'zoom': function zoom(arg) {
        that._processZoom(arg);
      }
    });
  },
  setInteraction: function setInteraction(options) {
    this._processEnd();

    this._centeringEnabled = options.centeringEnabled;
    this._zoomingEnabled = options.zoomingEnabled;
  },
  _processStart: function _processStart(arg) {
    if (this._centeringEnabled) {
      this._x = arg.x;
      this._y = arg.y;

      this._projection.beginMoveCenter();
    }
  },
  _processMove: function _processMove(arg) {
    var that = this;

    if (that._centeringEnabled) {
      that._renderer.root.attr({
        cursor: 'move'
      });

      that._projection.moveCenter([that._x - arg.x, that._y - arg.y]);

      that._x = arg.x;
      that._y = arg.y;
    }
  },
  _processEnd: function _processEnd() {
    if (this._centeringEnabled) {
      this._renderer.root.attr({
        cursor: 'default'
      });

      this._projection.endMoveCenter();
    }
  },
  _processZoom: function _processZoom(arg) {
    var that = this;
    var delta;
    var screenPosition;
    var coords;

    if (that._zoomingEnabled) {
      if (arg.delta) {
        delta = arg.delta;
      } else if (arg.ratio) {
        delta = _ln(arg.ratio) / _LN2;
      }

      if (that._centeringEnabled) {
        screenPosition = that._renderer.getRootOffset();
        screenPosition = [arg.x - screenPosition.left, arg.y - screenPosition.top];
        coords = that._projection.fromScreenPoint(screenPosition);
      }

      that._projection.changeScaledZoom(delta);

      if (that._centeringEnabled) {
        that._projection.setCenterByPoint(coords, screenPosition);
      }
    }
  }
};

/***/ }),
/* 1092 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Tracker = Tracker;

var _events_engine = _interopRequireDefault(__webpack_require__(5));

var _window = __webpack_require__(7);

var _dom_adapter = _interopRequireDefault(__webpack_require__(11));

var _event_emitter = __webpack_require__(606);

var _index = __webpack_require__(8);

var _wheel = __webpack_require__(149);

var _utils = __webpack_require__(14);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var navigator = (0, _window.getNavigator)();
var _math = Math;
var _abs = _math.abs;
var _sqrt = _math.sqrt;
var _round = _math.round;
var _addNamespace = _index.addNamespace;
var _NAME = 'dxVectorMap';
var EVENT_START = 'start';
var EVENT_MOVE = 'move';
var EVENT_END = 'end';
var EVENT_ZOOM = 'zoom';
var EVENT_HOVER_ON = 'hover-on';
var EVENT_HOVER_OFF = 'hover-off';
var EVENT_CLICK = 'click';
var EVENT_FOCUS_ON = 'focus-on';
var EVENT_FOCUS_MOVE = 'focus-move';
var EVENT_FOCUS_OFF = 'focus-off';
var CLICK_TIME_THRESHOLD = 500;
var CLICK_COORD_THRESHOLD_MOUSE = 5;
var CLICK_COORD_THRESHOLD_TOUCH = 20;
var DRAG_COORD_THRESHOLD_MOUSE = 5;
var DRAG_COORD_THRESHOLD_TOUCH = 10;
var FOCUS_OFF_DELAY = 100;
var WHEEL_COOLDOWN = 50;
var WHEEL_DIRECTION_COOLDOWN = 300;
var EVENTS;
var Focus;
setupEvents();

function Tracker(parameters) {
  var that = this;
  that._root = parameters.root;

  that._createEventHandlers(parameters.dataKey);

  that._createProjectionHandlers(parameters.projection);

  that._initEvents();

  that._focus = new Focus(function (name, arg) {
    that._fire(name, arg);
  });

  that._attachHandlers();
}

Tracker.prototype = {
  constructor: Tracker,
  dispose: function dispose() {
    var that = this;

    that._detachHandlers();

    that._disposeEvents();

    that._focus.dispose();

    that._root = that._focus = that._docHandlers = that._rootHandlers = null;
  },
  _eventNames: [EVENT_START, EVENT_MOVE, EVENT_END, EVENT_ZOOM, EVENT_CLICK, EVENT_HOVER_ON, EVENT_HOVER_OFF, EVENT_FOCUS_ON, EVENT_FOCUS_OFF, EVENT_FOCUS_MOVE],
  _startClick: function _startClick(event, data) {
    if (!data) {
      return;
    }

    var coords = getEventCoords(event);
    this._clickState = {
      x: coords.x,
      y: coords.y,
      threshold: isTouchEvent(event) ? CLICK_COORD_THRESHOLD_TOUCH : CLICK_COORD_THRESHOLD_MOUSE,
      time: Date.now()
    };
  },
  _endClick: function _endClick(event, data) {
    var state = this._clickState;
    var threshold;
    var coords;

    if (!state) {
      return;
    }

    if (data && Date.now() - state.time <= CLICK_TIME_THRESHOLD) {
      threshold = state.threshold;
      coords = getEventCoords(event);

      if (_abs(coords.x - state.x) <= threshold && _abs(coords.y - state.y) <= threshold) {
        this._fire(EVENT_CLICK, {
          data: data,
          x: coords.x,
          y: coords.y,
          $event: event
        });
      }
    }

    this._clickState = null;
  },
  _startDrag: function _startDrag(event, data) {
    if (!data) {
      return;
    }

    var coords = getEventCoords(event);
    var state = this._dragState = {
      x: coords.x,
      y: coords.y,
      data: data
    };

    this._fire(EVENT_START, {
      x: state.x,
      y: state.y,
      data: state.data
    });
  },
  _moveDrag: function _moveDrag(event, data) {
    var state = this._dragState;

    if (!state) {
      return;
    }

    var coords = getEventCoords(event);
    var threshold = isTouchEvent(event) ? DRAG_COORD_THRESHOLD_TOUCH : DRAG_COORD_THRESHOLD_MOUSE;

    if (state.active || _abs(coords.x - state.x) > threshold || _abs(coords.y - state.y) > threshold) {
      state.x = coords.x;
      state.y = coords.y;
      state.active = true;
      state.data = data || {};

      this._fire(EVENT_MOVE, {
        x: state.x,
        y: state.y,
        data: state.data
      });
    }
  },
  _endDrag: function _endDrag() {
    var state = this._dragState;

    if (!state) {
      return;
    }

    this._dragState = null;

    this._fire(EVENT_END, {
      x: state.x,
      y: state.y,
      data: state.data
    });
  },
  _wheelZoom: function _wheelZoom(event, data) {
    if (!data) {
      return;
    }

    var that = this;
    var lock = that._wheelLock;
    var time = Date.now();

    if (time - lock.time <= WHEEL_COOLDOWN) {
      return;
    } // T136650


    if (time - lock.dirTime > WHEEL_DIRECTION_COOLDOWN) {
      lock.dir = 0;
    } // T107589, T136650


    var delta = adjustWheelDelta(event.delta / 120 || 0, lock);

    if (delta === 0) {
      return;
    }

    var coords = getEventCoords(event);

    that._fire(EVENT_ZOOM, {
      delta: delta,
      x: coords.x,
      y: coords.y
    });

    lock.time = lock.dirTime = time;
  },
  _startZoom: function _startZoom(event, data) {
    if (!isTouchEvent(event) || !data) {
      return;
    }

    var state = this._zoomState = this._zoomState || {};
    var coords;
    var pointer2;

    if (state.pointer1 && state.pointer2) {
      return;
    }

    if (state.pointer1 === undefined) {
      state.pointer1 = getPointerId(event) || 0;
      coords = getMultitouchEventCoords(event, state.pointer1);
      state.x1 = state.x1_0 = coords.x;
      state.y1 = state.y1_0 = coords.y;
    }

    if (state.pointer2 === undefined) {
      pointer2 = getPointerId(event) || 1;

      if (pointer2 !== state.pointer1) {
        coords = getMultitouchEventCoords(event, pointer2);

        if (coords) {
          state.x2 = state.x2_0 = coords.x;
          state.y2 = state.y2_0 = coords.y;
          state.pointer2 = pointer2;
          state.ready = true;

          this._endDrag();
        }
      }
    }
  },
  _moveZoom: function _moveZoom(event) {
    var state = this._zoomState;
    var coords;

    if (!state || !isTouchEvent(event)) {
      return;
    }

    if (state.pointer1 !== undefined) {
      coords = getMultitouchEventCoords(event, state.pointer1);

      if (coords) {
        state.x1 = coords.x;
        state.y1 = coords.y;
      }
    }

    if (state.pointer2 !== undefined) {
      coords = getMultitouchEventCoords(event, state.pointer2);

      if (coords) {
        state.x2 = coords.x;
        state.y2 = coords.y;
      }
    }
  },
  _endZoom: function _endZoom(event) {
    var state = this._zoomState;
    var startDistance;
    var currentDistance;

    if (!state || !isTouchEvent(event)) {
      return;
    }

    if (state.ready) {
      startDistance = getDistance(state.x1_0, state.y1_0, state.x2_0, state.y2_0);
      currentDistance = getDistance(state.x1, state.y1, state.x2, state.y2);

      this._fire(EVENT_ZOOM, {
        ratio: currentDistance / startDistance,
        x: (state.x1_0 + state.x2_0) / 2,
        y: (state.y1_0 + state.y2_0) / 2
      });
    }

    this._zoomState = null;
  },
  _startHover: function _startHover(event, data) {
    this._doHover(event, data, true);
  },
  _moveHover: function _moveHover(event, data) {
    this._doHover(event, data, false);
  },
  _doHover: function _doHover(event, data, isTouch) {
    var that = this;

    if (that._dragState && that._dragState.active || that._zoomState && that._zoomState.ready) {
      that._cancelHover();

      return;
    }

    if (isTouchEvent(event) !== isTouch || that._hoverTarget === event.target || that._hoverState && that._hoverState.data === data) {
      return;
    }

    that._cancelHover();

    if (data) {
      that._hoverState = {
        data: data
      };

      that._fire(EVENT_HOVER_ON, {
        data: data
      });
    }

    that._hoverTarget = event.target;
  },
  _cancelHover: function _cancelHover() {
    var state = this._hoverState;
    this._hoverState = this._hoverTarget = null;

    if (state) {
      this._fire(EVENT_HOVER_OFF, {
        data: state.data
      });
    }
  },
  _startFocus: function _startFocus(event, data) {
    this._doFocus(event, data, true);
  },
  _moveFocus: function _moveFocus(event, data) {
    this._doFocus(event, data, false);
  },
  _doFocus: function _doFocus(event, data, isTouch) {
    var that = this;

    if (that._dragState && that._dragState.active || that._zoomState && that._zoomState.ready) {
      that._cancelFocus();

      return;
    }

    if (isTouchEvent(event) !== isTouch) {
      return;
    }

    that._focus.turnOff();

    data && that._focus.turnOn(data, getEventCoords(event));
  },
  _cancelFocus: function _cancelFocus() {
    this._focus.cancel();
  },
  _createEventHandlers: function _createEventHandlers(DATA_KEY) {
    var that = this;
    that._docHandlers = {};
    that._rootHandlers = {}; // Because of "stopPropagation" at any time only one of two handlers will be fully executed

    that._rootHandlers[EVENTS.start]
    /* T322560 */
    = that._docHandlers[EVENTS.start] = function (event) {
      var isTouch = isTouchEvent(event);
      var data = getData(event);

      if (isTouch && !that._isTouchEnabled) {
        return;
      }

      if (data) {
        event.preventDefault();
        event.stopPropagation(); // T322560
      }

      that._startClick(event, data);

      that._startDrag(event, data);

      that._startZoom(event, data);

      that._startHover(event, data);

      that._startFocus(event, data);
    };

    that._docHandlers[EVENTS.move] = function (event) {
      var isTouch = isTouchEvent(event);
      var data = getData(event);

      if (isTouch && !that._isTouchEnabled) {
        return;
      }

      that._moveDrag(event, data);

      that._moveZoom(event, data);

      that._moveHover(event, data);

      that._moveFocus(event, data);
    };

    that._docHandlers[EVENTS.end] = function (event) {
      var isTouch = isTouchEvent(event);
      var data = getData(event);

      if (isTouch && !that._isTouchEnabled) {
        return;
      }

      that._endClick(event, data);

      that._endDrag(event, data);

      that._endZoom(event, data);
    };

    that._rootHandlers[EVENTS.wheel] = function (event) {
      that._cancelFocus();

      if (!that._isWheelEnabled) {
        return;
      }

      var data = getData(event);

      if (data) {
        event.preventDefault();
        event.stopPropagation(); // T249548

        that._wheelZoom(event, data);
      }
    };

    that._wheelLock = {
      dir: 0
    }; // Actually it is responsibility of the text element wrapper to handle "data" to its span elements (if there are any).
    // Now to avoid not so necessary complication of renderer text-span issue is handled on the side of the tracker.

    function getData(event) {
      var target = event.target;
      return (target.tagName === 'tspan' ? target.parentNode : target)[DATA_KEY];
    }
  },
  _createProjectionHandlers: function _createProjectionHandlers(projection) {
    var that = this;
    projection.on({
      'center': handler,
      'zoom': handler
    }); // T247841

    function handler() {
      // `_cancelHover` probably should also be called here but for now let it not be so
      that._cancelFocus();
    }
  },
  reset: function reset() {
    var that = this;
    that._clickState = null;

    that._endDrag();

    that._cancelHover();

    that._cancelFocus();
  },
  setOptions: function setOptions(options) {
    var that = this;
    that.reset();

    that._detachHandlers();

    that._isTouchEnabled = !!(0, _utils.parseScalar)(options.touchEnabled, true);
    that._isWheelEnabled = !!(0, _utils.parseScalar)(options.wheelEnabled, true);

    that._attachHandlers();
  },
  _detachHandlers: function _detachHandlers() {
    var that = this;

    if (that._isTouchEnabled) {
      that._root.css({
        'touch-action': '',
        '-webkit-user-select': ''
      }).off(_addNamespace('MSHoldVisual', _NAME)).off(_addNamespace('contextmenu', _NAME));
    }

    _events_engine.default.off(_dom_adapter.default.getDocument(), that._docHandlers);

    that._root.off(that._rootHandlers);
  },
  _attachHandlers: function _attachHandlers() {
    var that = this;

    if (that._isTouchEnabled) {
      that._root.css({
        'touch-action': 'none',
        '-webkit-user-select': 'none'
      }).on(_addNamespace('MSHoldVisual', _NAME), function (event) {
        event.preventDefault();
      }).on(_addNamespace('contextmenu', _NAME), function (event) {
        isTouchEvent(event) && event.preventDefault();
      });
    }

    _events_engine.default.on(_dom_adapter.default.getDocument(), that._docHandlers);

    that._root.on(that._rootHandlers);
  }
};

Focus = function Focus(fire) {
  var that = this;
  var _activeData = null;
  var _data = null;
  var _disabled = false;
  var _offTimer = null;

  var _x;

  var _y;

  that.dispose = function () {
    clearTimeout(_offTimer);
    that.turnOn = that.turnOff = that.cancel = that.dispose = that = fire = _activeData = _data = _offTimer = null;
  };

  that.turnOn = function (data, coords) {
    if (data === _data && _disabled) {
      return;
    }

    _disabled = false;
    _data = data;

    if (_activeData) {
      _x = coords.x;
      _y = coords.y;

      if (_data === _activeData) {
        fire(EVENT_FOCUS_MOVE, {
          data: _data,
          x: _x,
          y: _y
        });
        onCheck(true);
      } else {
        fire(EVENT_FOCUS_ON, {
          data: _data,
          x: _x,
          y: _y,
          done: onCheck
        });
      }
    } else {
      _x = coords.x;
      _y = coords.y;
      fire(EVENT_FOCUS_ON, {
        data: _data,
        x: _x,
        y: _y,
        done: onCheck
      });
    }

    function onCheck(result) {
      _disabled = !result;

      if (result) {
        _activeData = _data;
        clearTimeout(_offTimer);
        _offTimer = null;
      }
    }
  };

  that.turnOff = function () {
    _data = null;

    if (_activeData && !_disabled) {
      _offTimer = _offTimer || setTimeout(function () {
        _offTimer = null;
        fire(EVENT_FOCUS_OFF, {
          data: _activeData
        });
        _activeData = null;
      }, FOCUS_OFF_DELAY);
    }
  };

  that.cancel = function () {
    clearTimeout(_offTimer);

    if (_activeData) {
      fire(EVENT_FOCUS_OFF, {
        data: _activeData
      });
    }

    _activeData = _data = _offTimer = null;
  };
};

(0, _event_emitter.makeEventEmitter)(Tracker);

function getDistance(x1, y1, x2, y2) {
  return _sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

function isTouchEvent(event) {
  var type = event.originalEvent.type;
  var pointerType = event.originalEvent.pointerType;
  return /^touch/.test(type) || /^MSPointer/.test(type) && pointerType !== 4 || /^pointer/.test(type) && pointerType !== 'mouse';
}

function selectItem(flags, items) {
  var i = 0;
  var ii = flags.length;
  var item;

  for (; i < ii; ++i) {
    if (flags[i]) {
      item = items[i];
      break;
    }
  }

  return _addNamespace(item || items[i], _NAME);
}

function setupEvents() {
  var flags = [navigator.pointerEnabled, navigator.msPointerEnabled, (0, _window.hasProperty)('ontouchstart')];
  EVENTS = {
    start: selectItem(flags, ['pointerdown', 'MSPointerDown', 'touchstart mousedown', 'mousedown']),
    move: selectItem(flags, ['pointermove', 'MSPointerMove', 'touchmove mousemove', 'mousemove']),
    end: selectItem(flags, ['pointerup', 'MSPointerUp', 'touchend mouseup', 'mouseup']),
    wheel: _addNamespace(_wheel.name, _NAME)
  };
}

function getEventCoords(event) {
  var originalEvent = event.originalEvent;
  var touch = originalEvent.touches && originalEvent.touches[0] || {};
  return {
    x: touch.pageX || originalEvent.pageX || event.pageX,
    y: touch.pageY || originalEvent.pageY || event.pageY
  };
}

function getPointerId(event) {
  return event.originalEvent.pointerId;
}

function getMultitouchEventCoords(event, pointerId) {
  var originalEvent = event.originalEvent;

  if (originalEvent.pointerId !== undefined) {
    originalEvent = originalEvent.pointerId === pointerId ? originalEvent : null;
  } else {
    originalEvent = originalEvent.touches[pointerId];
  }

  return originalEvent ? {
    x: originalEvent.pageX || event.pageX,
    y: originalEvent.pageY || event.pageY
  } : null;
}

function adjustWheelDelta(delta, lock) {
  if (delta === 0) {
    return 0;
  }

  var _delta = _abs(delta);

  var sign = _round(delta / _delta);

  if (lock.dir && sign !== lock.dir) {
    return 0;
  }

  lock.dir = sign;

  if (_delta < 0.1) {
    _delta = 0;
  } else if (_delta < 1) {
    _delta = 1;
  } else if (_delta > 4) {
    _delta = 4;
  } else {
    _delta = _round(_delta);
  }

  return sign * _delta;
}

/***/ }),
/* 1093 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.DataExchanger = DataExchanger;

var _callbacks = _interopRequireDefault(__webpack_require__(28));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function DataExchanger() {
  this._store = {};
}

DataExchanger.prototype = {
  constructor: DataExchanger,
  dispose: function dispose() {
    this._store = null;
    return this;
  },
  _get: function _get(category, name) {
    var store = this._store[category] || (this._store[category] = {});
    return store[name] || (store[name] = {
      callbacks: (0, _callbacks.default)()
    });
  },
  set: function set(category, name, data) {
    var item = this._get(category, name);

    item.data = data;
    item.callbacks.fire(data);
    return this;
  },
  bind: function bind(category, name, callback) {
    var item = this._get(category, name);

    item.callbacks.add(callback);
    item.data && callback(item.data);
    return this;
  },
  unbind: function unbind(category, name, callback) {
    var item = this._get(category, name);

    item.callbacks.remove(callback);
    return this;
  }
};

/***/ }),
/* 1094 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.LegendsControl = LegendsControl;

var _extend2 = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _object = __webpack_require__(52);

var _legend = __webpack_require__(239);

var _extend = _extend2.extend;
var _each = _iterator.each;
var unknownSource = {
  category: 'UNKNOWN',
  name: 'UNKNOWN'
};

function buildData(partition, values, field) {
  var i;
  var ii = values.length;
  var list = [];
  var item;

  for (i = 0; i < ii; ++i) {
    list[i] = item = {
      start: partition[i],
      end: partition[i + 1],
      index: i
    };
    item[field] = values[i];
    item.states = {
      normal: {
        fill: item.color
      }
    };
    item.visible = true;
  }

  return list;
} // 'var' because JSHint throws W021 error


var Legend = function Legend(parameters) {
  var that = this;
  that._params = parameters;
  that._root = parameters.renderer.g().attr({
    'class': 'dxm-legend'
  }).linkOn(parameters.container, {
    name: 'legend',
    after: 'legend-base'
  }).enableLinks().linkAppend();
  parameters.layoutControl.addItem(that);

  _legend.Legend.call(that, {
    renderer: parameters.renderer,
    widget: parameters.widget,
    group: that._root,
    backgroundClass: null,
    itemsGroupClass: null,
    textField: 'text',
    getFormatObject: function getFormatObject(data) {
      return data;
    }
  });

  that._onDataChanged = function (data) {
    that._updateData(data);
  };
};

Legend.prototype = _extend((0, _object.clone)(_legend.Legend.prototype), {
  constructor: Legend,
  dispose: function dispose() {
    var that = this;

    that._params.layoutControl.removeItem(that);

    that._unbindData();

    that._root.linkRemove().linkOff();

    that._params = that._root = that._onDataChanged = null;
    return _legend.Legend.prototype.dispose.apply(that, arguments);
  },
  // This method is called only by the layout
  resize: function resize(size) {
    this._params.notifyDirty();

    if (size === null) {
      this.erase();
    } else {
      this.draw(size.width, size.height);
    }

    this._params.notifyReady();
  },
  locate: _legend.Legend.prototype.shift,
  _updateData: function _updateData(data) {
    this._options.defaultColor = data && data.defaultColor;
    this.update(data ? buildData(data.partition, data.values, this._dataName) : [], this._options, this._params.themeManager.theme('legend').title);
    this.updateLayout();
  },
  _unbindData: function _unbindData() {
    if (this._dataCategory) {
      this._params.dataExchanger.unbind(this._dataCategory, this._dataName, this._onDataChanged);
    }
  },
  _bindData: function _bindData(arg) {
    this._params.dataExchanger.bind(this._dataCategory = arg.category, this._dataName = arg.name, this._onDataChanged);
  },
  // The `_root` should be appended or removed here but there is no way to check if core.Legend is actually enabled or not
  setOptions: function setOptions(options) {
    var that = this;
    that.update(that._data, options, this._params.themeManager.theme('legend').title);

    that._unbindData();

    var source = options.source;

    that._bindData(source ? {
      category: source.layer,
      name: source.grouping
    } : unknownSource);

    that.updateLayout();
    return that;
  }
});

function LegendsControl(parameters) {
  this._params = parameters;
  this._items = [];
  parameters.container.virtualLink('legend-base');
}

LegendsControl.prototype = {
  constructor: LegendsControl,
  dispose: function dispose() {
    _each(this._items, function (_, item) {
      item.dispose();
    });

    this._params = this._items = null;
  },
  setOptions: function setOptions(options) {
    var optionList = options && options.length ? options : [];
    var items = this._items;
    var i;
    var ii = optionList.length;
    var params = this._params;
    var theme = params.themeManager.theme('legend');

    for (i = items.length; i < ii; ++i) {
      items[i] = new Legend(params);
    }

    for (i = items.length - 1; i >= ii; --i) {
      items[i].dispose();
      items.splice(i, 1);
    }

    params.layoutControl.suspend();

    for (i = 0; i < ii; ++i) {
      items[i].setOptions(_extend(true, {}, theme, optionList[i]));
    }

    params.layoutControl.resume();
  }
};

/***/ }),
/* 1095 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.LayoutControl = LayoutControl;

var _array = __webpack_require__(12);

var _iterator = __webpack_require__(3);

var _round = Math.round;
var _min = Math.min;
var _max = Math.max;
var _each = _iterator.each;
var _inArray = _array.inArray;
var horizontalAlignmentMap = {
  'left': 0,
  'center': 1,
  'right': 2
};
var verticalAlignmentMap = {
  'top': 0,
  'bottom': 1
};

function getCellIndex(options) {
  return verticalAlignmentMap[options.verticalAlignment] * 3 + horizontalAlignmentMap[options.horizontalAlignment];
}

function createCells(canvas, items) {
  var hStep = (canvas.right - canvas.left) / 3;
  var vStep = (canvas.bottom - canvas.top) / 2;
  var h1 = canvas.left;

  var h2 = _round(h1 + hStep);

  var h3 = _round(h1 + hStep + hStep);

  var h4 = canvas.right;
  var v1 = canvas.top;

  var v2 = _round(v1 + vStep);

  var v3 = canvas.bottom;
  var cells = [{
    rect: [h1, v1, h2, v2]
  }, {
    rect: [h2, v1, h3, v2],
    center: true
  }, {
    rect: [h3, v1, h4, v2],
    horInversion: true
  }, {
    rect: [h1, v2, h2, v3],
    verInversion: true
  }, {
    rect: [h2, v2, h3, v3],
    center: true,
    verInversion: true
  }, {
    rect: [h3, v2, h4, v3],
    horInversion: true,
    verInversion: true
  }];
  var itemsList = [[], [], [], [], [], []];

  _each(items, function (_, item) {
    var options = item.getLayoutOptions();

    if (options) {
      itemsList[getCellIndex(options)].push({
        item: item,
        width: options.width,
        height: options.height
      });
    }
  });

  _each(cells, function (i, cell) {
    if (itemsList[i].length) {
      cell.items = itemsList[i];
    } else {
      if (cell.center) {
        cell.rect[0] = cell.rect[2] = (cell.rect[0] + cell.rect[2]) / 2;
      } else {
        cell.rect[cell.horInversion ? 0 : 2] = cell.rect[cell.horInversion ? 2 : 0];
      }

      cell.rect[cell.verInversion ? 1 : 3] = cell.rect[cell.verInversion ? 3 : 1];
    }
  });

  return cells;
}

function adjustCellSizes(cells) {
  _each([0, 1, 2, 3, 4, 5], function (_, index) {
    var cell = cells[index];
    var otherCell = cells[(index + 3) % 6];

    if (cell.items) {
      if (!otherCell.items) {
        cell.rect[1] = _min(cell.rect[1], otherCell.rect[3]);
        cell.rect[3] = _max(cell.rect[3], otherCell.rect[1]);
      }
    }
  });

  _each([1, 4], function (_, index) {
    var cell = cells[index];
    var otherCell1 = cells[index - 1];
    var otherCell2 = cells[index + 1];
    var size1;
    var size2;

    if (cell.items) {
      if (!otherCell1.items && !otherCell2.items) {
        size1 = cell.rect[0] - otherCell1.rect[2];
        size2 = otherCell2.rect[0] - cell.rect[2];

        if (size1 > size2) {
          if (size1 / size2 >= 2) {
            cell.rect[0] -= size1;
            cell.right = true;
          } else {
            cell.rect[0] -= size2;
            cell.rect[2] += size2;
          }
        } else {
          if (size2 / size1 >= 2) {
            cell.rect[2] += size2;
            cell.center = null;
          } else {
            cell.rect[0] -= size1;
            cell.rect[2] += size1;
          }
        }
      }
    } else {
      if (otherCell1.items) {
        otherCell1.rect[2] = (cell.rect[0] + cell.rect[2]) / 2;
      }

      if (otherCell2.items) {
        otherCell2.rect[0] = (cell.rect[0] + cell.rect[2]) / 2;
      }
    }
  });
}

function adjustCellsAndApplyLayout(cells, forceMode) {
  var hasHiddenItems = false;
  adjustCellSizes(cells);

  _each(cells, function (_, cell) {
    if (cell.items) {
      hasHiddenItems = applyCellLayout(cell, forceMode) || hasHiddenItems;
    }
  });

  return hasHiddenItems;
}

function applyCellLayout(cell, forceMode) {
  var cellRect = cell.rect;
  var cellWidth = cellRect[2] - cellRect[0];
  var cellHeight = cellRect[3] - cellRect[1];
  var xOffset = 0;
  var yOffset = 0;
  var currentHeight = 0;
  var totalL = cellRect[2];
  var totalT = cellRect[3];
  var totalR = cellRect[0];
  var totalB = cellRect[1];
  var moves = [];
  var hasHiddenItems = false;

  _each(cell.items, function (_, item) {
    if (item.width > cellWidth || item.height > cellHeight) {
      moves.push(null);
      hasHiddenItems = true;
      return forceMode || false;
    }

    if (xOffset + item.width > cellWidth) {
      yOffset += currentHeight;
      xOffset = currentHeight = 0;
    }

    if (yOffset + item.height > cellHeight) {
      moves.push(null);
      hasHiddenItems = true;
      return forceMode || false;
    }

    currentHeight = _max(currentHeight, item.height);
    var dx = cell.horInversion ? cellRect[2] - item.width - xOffset : cellRect[0] + xOffset;
    var dy = cell.verInversion ? cellRect[3] - item.height - yOffset : cellRect[1] + yOffset;
    xOffset += item.width;
    totalL = _min(totalL, dx);
    totalT = _min(totalT, dy);
    totalR = _max(totalR, dx + item.width);
    totalB = _max(totalB, dy + item.height);
    moves.push([dx, dy]);
  });

  if (forceMode || !hasHiddenItems) {
    xOffset = 0;

    if (cell.right) {
      xOffset = cellRect[2] - cellRect[0] - totalR + totalL;
    } else if (cell.center) {
      xOffset = _round((cellRect[2] - cellRect[0] - totalR + totalL) / 2);
    }

    _each(cell.items, function (i, item) {
      var move = moves[i];

      if (move) {
        item.item.locate(move[0] + xOffset, move[1]);
      } else {
        item.item.resize(null);
      }
    });

    cell.rect = [totalL, totalT, totalR, totalB];
    cell.items = null;
  }

  return hasHiddenItems;
}

function applyLayout(canvas, items) {
  var cells = createCells(canvas, items);

  if (adjustCellsAndApplyLayout(cells)) {
    adjustCellsAndApplyLayout(cells, true);
  }
}

function LayoutControl(widget) {
  var that = this;
  that._items = [];
  that._suspended = 0;
  that._widget = widget;

  that._updateLayout = function () {
    that._update();
  };
}

LayoutControl.prototype = {
  constructor: LayoutControl,
  dispose: function dispose() {
    this._items = this._updateLayout = null;
  },
  setSize: function setSize(canvas) {
    this._canvas = canvas;

    this._update();
  },
  suspend: function suspend() {
    ++this._suspended;
  },
  resume: function resume() {
    if (--this._suspended === 0) {
      this._update();
    }
  },
  // It should return callback (update trigger) instead of injecting the argument
  addItem: function addItem(item) {
    this._items.push(item);

    item.updateLayout = this._updateLayout;
  },
  removeItem: function removeItem(item) {
    this._items.splice(_inArray(item, this._items), 1);

    item.updateLayout = null;
  },
  _update: function _update() {
    var canvas;

    if (this._suspended === 0) {
      canvas = this._canvas;

      _each(this._items, function (_, item) {
        item.resize(canvas);
      });

      this._widget.resolveItemsDeferred(this._items.filter(function (el) {
        return el.getTemplatesGroups && el.getTemplatesDef;
      }));

      applyLayout({
        left: canvas.left,
        top: canvas.top,
        right: canvas.width + canvas.left,
        bottom: canvas.height + canvas.top
      }, this._items);
    }
  }
};

/***/ }),
/* 1096 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getMaxBound = getMaxBound;
exports.MapLayerCollection = MapLayerCollection;

var _common = __webpack_require__(4);

var _extend2 = __webpack_require__(0);

var _iterator = __webpack_require__(3);

var _data_helper = _interopRequireDefault(__webpack_require__(97));

var _type = __webpack_require__(1);

var _deferred = __webpack_require__(6);

var _utils = __webpack_require__(14);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _noop = _common.noop;
var _extend = _extend2.extend;
var _each = _iterator.each;
var _concat = Array.prototype.concat;
var TYPE_AREA = 'area';
var TYPE_LINE = 'line';
var TYPE_MARKER = 'marker';
var STATE_DEFAULT = 0;
var STATE_HOVERED = 1;
var STATE_SELECTED = 2;
var STATE_TO_INDEX = [0, 1, 2, 2];
var TOLERANCE = 1;
var SELECTIONS = {
  'none': null,
  'single': -1,
  'multiple': NaN
};
var _isArray = Array.isArray;
var _Number = Number;
var _String = String;
var _abs = Math.abs;
var _round = Math.round;
var _min = Math.min;
var _max = Math.max;
var _sqrt = Math.sqrt;

function getMaxBound(arr) {
  return arr.reduce(function (a, c) {
    return c ? [_min(a[0], c[0]), _min(a[1], c[1]), _max(a[2], c[2]), _max(a[3], c[3])] : a;
  }, arr[0]);
}

function getSelection(selectionMode) {
  var selection = (0, _utils.normalizeEnum)(selectionMode);
  selection = selection in SELECTIONS ? SELECTIONS[selection] : SELECTIONS.single;

  if (selection !== null) {
    selection = {
      state: {},
      single: selection
    };
  }

  return selection;
}

function getName(opt, index) {
  return (opt[index] || {}).name;
}

function EmptySource() {}

EmptySource.prototype.count = function () {
  return 0;
};

function ArraySource(raw) {
  this.raw = raw;
}

ArraySource.prototype = {
  constructor: ArraySource,
  count: function count() {
    return this.raw.length;
  },
  item: function item(index) {
    return this.raw[index];
  },
  geometry: function geometry(item) {
    return {
      coordinates: item.coordinates
    };
  },
  attributes: function attributes(item) {
    return item.attributes;
  },
  getBBox: function getBBox(index) {
    return arguments.length === 0 ? undefined : this.raw[index]['bbox'];
  }
};

function GeoJsonSource(raw) {
  this.raw = raw;
}

GeoJsonSource.prototype = {
  constructor: GeoJsonSource,
  count: function count() {
    return this.raw.features.length;
  },
  item: function item(index) {
    return this.raw.features[index];
  },
  geometry: function geometry(item) {
    return item.geometry;
  },
  attributes: function attributes(item) {
    return item.properties;
  },
  getBBox: function getBBox(index) {
    return arguments.length === 0 ? this.raw['bbox'] : this.raw.features[index]['bbox'];
  }
};

function isGeoJsonObject(obj) {
  return _isArray(obj.features);
} // The problem is that when remote source returns an object (not an array) the data.DataSource internally wraps it into array (of one element)
// So specific `if` clause is required to recognize GeoJson object in the returned `items`


function unwrapFromDataSource(source) {
  var sourceType;

  if (source) {
    if (isGeoJsonObject(source)) {
      sourceType = GeoJsonSource;
    } else if (source.length === 1 && source[0] && isGeoJsonObject(source[0])) {
      sourceType = GeoJsonSource;
      source = source[0];
    } else if (_isArray(source)) {
      sourceType = ArraySource;
    }
  }

  sourceType = sourceType || EmptySource;
  return new sourceType(source);
} // The first problem is that when our DataSource is updated with an object (not an array) it considers such object a bunch of options.
// So single object has to be wrapped into array in order to be passed to the data.DataSource as is.
// The second problem is that when our DataSource is updated with `null` or `undefined` it does nothing - callback is not triggered (it is because of charts).
// So `null` or `undefined` is changed to empty array.


function wrapToDataSource(option) {
  return option ? isGeoJsonObject(option) ? [option] : option : [];
}

function customizeHandles(proxies, callback, widget) {
  callback.call(widget, proxies);
} // TODO: Consider moving it inside a strategy


function setAreaLabelVisibility(label) {
  label.text.attr({
    visibility: label.size[0] / label.spaceSize[0] < TOLERANCE && label.size[1] / label.spaceSize[1] < TOLERANCE ? null : 'hidden'
  });
} // TODO: Consider moving it inside a strategy


function setLineLabelVisibility(label) {
  label.text.attr({
    visibility: label.size[0] / label.spaceSize[0] < TOLERANCE || label.size[1] / label.spaceSize[1] < TOLERANCE ? null : 'hidden'
  });
}

function getDataValue(proxy, dataField) {
  return proxy.attribute(dataField);
}

var TYPE_TO_TYPE_MAP = {
  Point: TYPE_MARKER,
  MultiPoint: TYPE_LINE,
  LineString: TYPE_LINE,
  MultiLineString: TYPE_LINE,
  Polygon: TYPE_AREA,
  MultiPolygon: TYPE_AREA
};

function pick(a, b) {
  return a !== undefined ? a : b;
}

function guessTypeByData(sample) {
  var type = TYPE_TO_TYPE_MAP[sample.type];
  var coordinates = sample.coordinates;

  if (!type) {
    if (typeof coordinates[0] === 'number') {
      type = TYPE_MARKER;
    } else if (typeof coordinates[0][0] === 'number') {
      type = TYPE_LINE;
    } else {
      type = TYPE_AREA;
    }
  }

  return type;
}

var emptyStrategy = {
  setup: _noop,
  reset: _noop,
  arrange: _noop,
  updateGrouping: _noop,
  getDefaultColor: _noop
};
var strategiesByType = {};
var strategiesByGeometry = {};
var strategiesByElementType = {};
var groupByColor;
var groupBySize;

var selectStrategy = function selectStrategy(options, data) {
  var type = (0, _utils.normalizeEnum)(options.type);
  var elementType = (0, _utils.normalizeEnum)(options.elementType);
  var sample;

  var strategy = _extend({}, emptyStrategy);

  if (data.count() > 0) {
    sample = data.geometry(data.item(0));
    type = strategiesByType[type] ? type : guessTypeByData(sample);

    _extend(strategy, strategiesByType[type]);

    strategy.fullType = strategy.type = type;

    if (strategiesByGeometry[type]) {
      _extend(strategy, strategiesByGeometry[type](sample));
    }

    if (strategiesByElementType[type]) {
      elementType = strategiesByElementType[type][elementType] ? elementType : strategiesByElementType[type]._default;

      _extend(strategy, strategiesByElementType[type][elementType]);

      strategy.elementType = elementType;
      strategy.fullType += ':' + elementType;
    }
  }

  return strategy;
};

function applyElementState(figure, styles, state, field) {
  figure[field].attr(styles[field][state]);
}

strategiesByType[TYPE_AREA] = {
  projectLabel: projectAreaLabel,
  transform: transformPointList,
  transformLabel: transformAreaLabel,
  draw: function draw(context, figure, data) {
    figure.root = context.renderer.path([], 'area').data(context.dataKey, data);
  },
  refresh: _noop,
  getLabelOffset: function getLabelOffset(label) {
    setAreaLabelVisibility(label);
    return [0, 0];
  },
  getStyles: function getStyles(settings) {
    var color = settings.color || null;
    var borderColor = settings.borderColor || null;
    var borderWidth = pick(settings.borderWidth, null);
    var opacity = pick(settings.opacity, null);
    return {
      root: [{
        'class': 'dxm-area',
        stroke: borderColor,
        'stroke-width': borderWidth,
        fill: color,
        opacity: opacity
      }, {
        'class': 'dxm-area dxm-area-hovered',
        stroke: settings.hoveredBorderColor || borderColor,
        'stroke-width': pick(settings.hoveredBorderWidth, borderWidth),
        fill: settings.hoveredColor || color,
        opacity: pick(settings.hoveredOpacity, opacity)
      }, {
        'class': 'dxm-area dxm-area-selected',
        stroke: settings.selectedBorderColor || borderColor,
        'stroke-width': pick(settings.selectedBorderWidth, borderWidth),
        fill: settings.selectedColor || color,
        opacity: pick(settings.selectedOpacity, opacity)
      }]
    };
  },
  setState: function setState(figure, styles, state) {
    applyElementState(figure, styles, state, 'root');
  },
  hasLabelsGroup: true,
  updateGrouping: function updateGrouping(context) {
    groupByColor(context);
  },
  getDefaultColor: _noop
};
strategiesByType[TYPE_LINE] = {
  projectLabel: projectLineLabel,
  transform: transformPointList,
  transformLabel: transformLineLabel,
  draw: function draw(context, figure, data) {
    figure.root = context.renderer.path([], 'line').data(context.dataKey, data);
  },
  refresh: _noop,
  getLabelOffset: function getLabelOffset(label) {
    setLineLabelVisibility(label);
    return [0, 0];
  },
  getStyles: function getStyles(settings) {
    var color = settings.color || settings.borderColor || null;
    var width = pick(settings.borderWidth, null);
    var opacity = pick(settings.opacity, null);
    return {
      root: [{
        'class': 'dxm-line',
        stroke: color,
        'stroke-width': width,
        opacity: opacity
      }, {
        'class': 'dxm-line dxm-line-hovered',
        stroke: settings.hoveredColor || settings.hoveredBorderColor || color,
        'stroke-width': pick(settings.hoveredBorderWidth, width),
        opacity: pick(settings.hoveredOpacity, opacity)
      }, {
        'class': 'dxm-line dxm-line-selected',
        stroke: settings.selectedColor || settings.selectedBorderColor || color,
        'stroke-width': pick(settings.selectedBorderWidth, width),
        opacity: pick(settings.selectedOpacity, opacity)
      }]
    };
  },
  setState: function setState(figure, styles, state) {
    applyElementState(figure, styles, state, 'root');
  },
  hasLabelsGroup: true,
  updateGrouping: function updateGrouping(context) {
    groupByColor(context);
  },
  getDefaultColor: _noop
};
strategiesByType[TYPE_MARKER] = {
  project: projectPoint,
  transform: transformPoint,
  draw: function draw(context, figure, data) {
    figure.root = context.renderer.g();

    this._draw(context, figure, data);
  },
  refresh: _noop,
  hasLabelsGroup: false,
  getLabelOffset: function getLabelOffset(label, settings) {
    return [_round((label.size[0] + _max(settings.size || 0, 0)) / 2) + 2, 0];
  },
  getStyles: function getStyles(settings) {
    var styles = {
      root: [{
        'class': 'dxm-marker'
      }, {
        'class': 'dxm-marker dxm-marker-hovered'
      }, {
        'class': 'dxm-marker dxm-marker-selected'
      }]
    };

    this._getStyles(styles, settings);

    return styles;
  },
  setState: function setState(figure, styles, state) {
    applyElementState(figure, styles, state, 'root');

    this._setState(figure, styles, state);
  },
  updateGrouping: function updateGrouping(context) {
    groupByColor(context);
    groupBySize(context);
  },
  getDefaultColor: function getDefaultColor(ctx, palette) {
    return ctx.params.themeManager.getAccentColor(palette);
  }
};

strategiesByGeometry[TYPE_AREA] = function (sample) {
  return {
    project: function project(projection, coordinates) {
      return coordinates[0] && coordinates[0][0] && coordinates[0][0][0] && typeof coordinates[0][0][0][0] === 'number' ? projectMultiPolygon(projection, coordinates) : projectPolygon(projection, coordinates);
    }
  };
};

strategiesByGeometry[TYPE_LINE] = function (sample) {
  var coordinates = sample.coordinates;
  return {
    project: coordinates[0] && coordinates[0][0] && typeof coordinates[0][0][0] === 'number' ? projectPolygon : projectLineString
  };
};

strategiesByElementType[TYPE_MARKER] = {
  _default: 'dot',
  dot: {
    setup: function setup(context) {
      context.filter = context.renderer.shadowFilter('-40%', '-40%', '180%', '200%', 0, 1, 1, '#000000', 0.2);
    },
    reset: function reset(context) {
      context.filter.dispose();
      context.filter = null;
    },
    _draw: function _draw(ctx, figure, data) {
      figure.back = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root);
      figure.dot = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root);
    },
    refresh: function refresh(ctx, figure, data, proxy, settings) {
      figure.dot.attr({
        filter: settings.shadow ? ctx.filter.id : null
      });
    },
    _getStyles: function _getStyles(styles, style) {
      var size = style.size > 0 ? _Number(style.size) : 0;
      var hoveredSize = size;
      var selectedSize = size + (style.selectedStep > 0 ? _Number(style.selectedStep) : 0);
      var hoveredBackSize = hoveredSize + (style.backStep > 0 ? _Number(style.backStep) : 0);
      var selectedBackSize = selectedSize + (style.backStep > 0 ? _Number(style.backStep) : 0);
      var color = style.color || null;
      var borderColor = style.borderColor || null;
      var borderWidth = pick(style.borderWidth, null);
      var opacity = pick(style.opacity, null);
      var backColor = style.backColor || null;
      var backOpacity = pick(style.backOpacity, null);
      styles.dot = [{
        r: size / 2,
        stroke: borderColor,
        'stroke-width': borderWidth,
        fill: color,
        opacity: opacity
      }, {
        r: hoveredSize / 2,
        stroke: style.hoveredBorderColor || borderColor,
        'stroke-width': pick(style.hoveredBorderWidth, borderWidth),
        fill: style.hoveredColor || color,
        opacity: pick(style.hoveredOpacity, opacity)
      }, {
        r: selectedSize / 2,
        stroke: style.selectedBorderColor || borderColor,
        'stroke-width': pick(style.selectedBorderWidth, borderWidth),
        fill: style.selectedColor || color,
        opacity: pick(style.selectedOpacity, opacity)
      }];
      styles.back = [{
        r: size / 2,
        stroke: 'none',
        'stroke-width': 0,
        fill: backColor,
        opacity: backOpacity
      }, {
        r: hoveredBackSize / 2,
        stroke: 'none',
        'stroke-width': 0,
        fill: backColor,
        opacity: backOpacity
      }, {
        r: selectedBackSize / 2,
        stroke: 'none',
        'stroke-width': 0,
        fill: backColor,
        opacity: backOpacity
      }];
    },
    _setState: function _setState(figure, styles, state) {
      applyElementState(figure, styles, state, 'dot');
      applyElementState(figure, styles, state, 'back');
    }
  },
  bubble: {
    _draw: function _draw(ctx, figure, data) {
      figure.bubble = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root);
    },
    refresh: function refresh(ctx, figure, data, proxy, settings) {
      figure.bubble.attr({
        r: settings.size / 2
      });
    },
    _getStyles: function _getStyles(styles, style) {
      var color = style.color || null;
      var borderColor = style.borderColor || null;
      var borderWidth = pick(style.borderWidth, null);
      var opacity = pick(style.opacity, null);
      styles.bubble = [{
        stroke: borderColor,
        'stroke-width': borderWidth,
        fill: color,
        opacity: opacity
      }, {
        stroke: style.hoveredBorderColor || borderColor,
        'stroke-width': pick(style.hoveredBorderWidth, borderWidth),
        fill: style.hoveredColor || style.color,
        opacity: pick(style.hoveredOpacity, opacity)
      }, {
        stroke: style.selectedBorderColor || borderColor,
        'stroke-width': pick(style.selectedBorderWidth, borderWidth),
        fill: style.selectedColor || style.color,
        opacity: pick(style.selectedOpacity, opacity)
      }];
    },
    _setState: function _setState(figure, styles, state) {
      applyElementState(figure, styles, state, 'bubble');
    },
    arrange: function arrange(context, handles) {
      var values = [];
      var i;
      var ii = values.length = handles.length;
      var settings = context.settings;
      var dataField = settings.dataField;
      var minSize = settings.minSize > 0 ? _Number(settings.minSize) : 0;
      var maxSize = settings.maxSize > minSize ? _Number(settings.maxSize) : minSize;

      if (settings.sizeGroups) {
        return;
      }

      for (i = 0; i < ii; ++i) {
        values[i] = _max(getDataValue(handles[i].proxy, dataField) || 0, 0);
      }

      var minValue = _min.apply(null, values);

      var maxValue = _max.apply(null, values);

      var deltaValue = maxValue - minValue || 1;
      var deltaSize = maxSize - minSize;

      for (i = 0; i < ii; ++i) {
        handles[i]._settings.size = minSize + deltaSize * (values[i] - minValue) / deltaValue;
      }
    },
    updateGrouping: function updateGrouping(context) {
      var dataField = context.settings.dataField;
      strategiesByType[TYPE_MARKER].updateGrouping(context);
      groupBySize(context, function (proxy) {
        return getDataValue(proxy, dataField);
      });
    }
  },
  pie: {
    _draw: function _draw(ctx, figure, data) {
      figure.pie = ctx.renderer.g().append(figure.root);
      figure.border = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root);
    },
    refresh: function refresh(ctx, figure, data, proxy, settings) {
      var values = getDataValue(proxy, ctx.settings.dataField) || [];
      var colors = settings._colors;
      var sum = 0;
      var pie = figure.pie;
      var renderer = ctx.renderer;
      var dataKey = ctx.dataKey;
      var r = (settings.size > 0 ? _Number(settings.size) : 0) / 2;
      var start = 90;
      var end = start;
      var zeroSum = false;
      sum = values.reduce(function (total, item) {
        return total + (item || 0);
      }, 0);

      if (sum === 0) {
        zeroSum = true;
        sum = 360 / values.length;
      }

      values.forEach(function (item, i) {
        start = end;
        end += zeroSum ? sum : (item || 0) / sum * 360;
        renderer.arc(0, 0, 0, r, start, end).attr({
          'stroke-linejoin': 'round',
          fill: colors[i]
        }).data(dataKey, data).append(pie);
      });
      figure.border.attr({
        r: r
      });
    },
    _getStyles: function _getStyles(styles, style) {
      var opacity = pick(style.opacity, null);
      var borderColor = style.borderColor || null;
      var borderWidth = pick(style.borderWidth, null);
      styles.pie = [{
        opacity: opacity
      }, {
        opacity: pick(style.hoveredOpacity, opacity)
      }, {
        opacity: pick(style.selectedOpacity, opacity)
      }];
      styles.border = [{
        stroke: borderColor,
        'stroke-width': borderWidth
      }, {
        stroke: style.hoveredBorderColor || borderColor,
        'stroke-width': pick(style.hoveredBorderWidth, borderWidth)
      }, {
        stroke: style.selectedBorderColor || borderColor,
        'stroke-width': pick(style.selectedBorderWidth, borderWidth)
      }];
    },
    _setState: function _setState(figure, styles, state) {
      applyElementState(figure, styles, state, 'pie');
      applyElementState(figure, styles, state, 'border');
    },
    arrange: function arrange(context, handles) {
      var i;
      var ii = handles.length;
      var dataField = context.settings.dataField;
      var values;
      var count = 0;
      var palette;

      for (i = 0; i < ii; ++i) {
        values = getDataValue(handles[i].proxy, dataField);

        if (values && values.length > count) {
          count = values.length;
        }
      }

      if (count > 0) {
        palette = context.params.themeManager.createPalette(context.settings.palette, {
          useHighlight: true,
          extensionMode: 'alternate'
        });
        values = palette.generateColors(count);
        context.settings._colors = values;
        context.grouping.color = {
          callback: _noop,
          field: '',
          partition: [],
          values: []
        };
        context.params.dataExchanger.set(context.name, 'color', {
          partition: [],
          values: values
        });
      }
    }
  },
  image: {
    _draw: function _draw(ctx, figure, data) {
      figure.image = ctx.renderer.image(null, null, null, null, null, 'center').attr({
        'pointer-events': 'visible'
      }) // T567545
      .data(ctx.dataKey, data).append(figure.root);
    },
    refresh: function refresh(ctx, figure, data, proxy) {
      figure.image.attr({
        href: getDataValue(proxy, ctx.settings.dataField)
      });
    },
    _getStyles: function _getStyles(styles, style) {
      var size = style.size > 0 ? _Number(style.size) : 0;
      var hoveredSize = size + (style.hoveredStep > 0 ? _Number(style.hoveredStep) : 0);
      var selectedSize = size + (style.selectedStep > 0 ? _Number(style.selectedStep) : 0);
      var opacity = pick(style.opacity, null);
      styles.image = [{
        x: -size / 2,
        y: -size / 2,
        width: size,
        height: size,
        opacity: opacity
      }, {
        x: -hoveredSize / 2,
        y: -hoveredSize / 2,
        width: hoveredSize,
        height: hoveredSize,
        opacity: pick(style.hoveredOpacity, opacity)
      }, {
        x: -selectedSize / 2,
        y: -selectedSize / 2,
        width: selectedSize,
        height: selectedSize,
        opacity: pick(style.selectedOpacity, opacity)
      }];
    },
    _setState: function _setState(figure, styles, state) {
      applyElementState(figure, styles, state, 'image');
    }
  }
};

function projectPoint(projection, coordinates) {
  return projection.project(coordinates);
}

function projectPointList(projection, coordinates) {
  var output = [];
  var i;
  var ii = output.length = coordinates.length;

  for (i = 0; i < ii; ++i) {
    output[i] = projection.project(coordinates[i]);
  }

  return output;
}

function projectLineString(projection, coordinates) {
  return [projectPointList(projection, coordinates)];
}

function projectPolygon(projection, coordinates) {
  var output = [];
  var i;
  var ii = output.length = coordinates.length;

  for (i = 0; i < ii; ++i) {
    output[i] = projectPointList(projection, coordinates[i]);
  }

  return output;
}

function projectMultiPolygon(projection, coordinates) {
  var output = [];
  var i;
  var ii = output.length = coordinates.length;

  for (i = 0; i < ii; ++i) {
    output[i] = projectPolygon(projection, coordinates[i]);
  }

  return _concat.apply([], output);
}

function transformPoint(content, projection, coordinates) {
  var data = projection.transform(coordinates);
  content.root.attr({
    translateX: data[0],
    translateY: data[1]
  });
}

function transformList(projection, coordinates) {
  var output = [];
  var i;
  var ii = coordinates.length;
  var item;
  var k = 0;
  output.length = 2 * ii;

  for (i = 0; i < ii; ++i) {
    item = projection.transform(coordinates[i]);
    output[k++] = item[0];
    output[k++] = item[1];
  }

  return output;
}

function transformPointList(content, projection, coordinates) {
  var output = [];
  var i;
  var ii = output.length = coordinates.length;

  for (i = 0; i < ii; ++i) {
    output[i] = transformList(projection, coordinates[i]);
  }

  content.root.attr({
    points: output
  });
}

function transformAreaLabel(label, projection, coordinates) {
  var data = projection.transform(coordinates[0]);
  label.spaceSize = projection.getSquareSize(coordinates[1]);
  label.text.attr({
    translateX: data[0],
    translateY: data[1]
  });
  setAreaLabelVisibility(label);
}

function transformLineLabel(label, projection, coordinates) {
  var data = projection.transform(coordinates[0]);
  label.spaceSize = projection.getSquareSize(coordinates[1]);
  label.text.attr({
    translateX: data[0],
    translateY: data[1]
  });
  setLineLabelVisibility(label);
}

function getItemSettings(context, proxy, settings) {
  var result = combineSettings(context.settings, settings);
  applyGrouping(context.grouping, proxy, result);

  if (settings.color === undefined && settings.paletteIndex >= 0) {
    result.color = result._colors[settings.paletteIndex];
  }

  return result;
}

function applyGrouping(grouping, proxy, settings) {
  _each(grouping, function (name, data) {
    var index = findGroupingIndex(data.callback(proxy, data.field), data.partition);

    if (index >= 0) {
      settings[name] = data.values[index];
    }
  });
}

function findGroupingIndex(value, partition) {
  var start = 0;
  var end = partition.length - 1;
  var index = -1;
  var middle;

  if (partition[start] <= value && value <= partition[end]) {
    if (value === partition[end]) {
      index = end - 1;
    } else {
      while (end - start > 1) {
        middle = start + end >> 1;

        if (value < partition[middle]) {
          end = middle;
        } else {
          start = middle;
        }
      }

      index = start;
    }
  }

  return index;
}

function raiseChanged(context, handle, state, name) {
  context.params.eventTrigger(name, {
    target: handle.proxy,
    state: state
  });
} // This is required because `$.extend` cannot be used - because of the `options.data` which is commonly a very large array
// TODO: Try to use our simple `extend` instead of `$.extend`


function combineSettings(common, partial) {
  var obj = _extend({}, common, partial);

  obj.label = _extend({}, common.label, obj.label);
  obj.label.font = _extend({}, common.label.font, obj.label.font);
  return obj;
}

function processCommonSettings(context, options) {
  var themeManager = context.params.themeManager;
  var strategy = context.str;
  var settings = combineSettings(_extend({
    label: {},
    color: strategy.getDefaultColor(context, options.palette)
  }, themeManager.theme('layer:' + strategy.fullType)), options);
  var colors;
  var i;
  var palette;

  if (settings.paletteSize > 0) {
    palette = themeManager.createDiscretePalette(settings.palette, settings.paletteSize);

    for (i = 0, colors = []; i < settings.paletteSize; ++i) {
      colors.push(palette.getColor(i));
    }

    settings._colors = colors;
  }

  return settings;
}

function valueCallback(proxy, dataField) {
  return proxy.attribute(dataField);
}

var performGrouping = function performGrouping(context, partition, settingField, dataField, valuesCallback) {
  var values;

  if (dataField && partition && partition.length > 1) {
    values = valuesCallback(partition.length - 1);
    context.grouping[settingField] = {
      callback: (0, _type.isFunction)(dataField) ? dataField : valueCallback,
      field: dataField,
      partition: partition,
      values: values
    };
    context.params.dataExchanger.set(context.name, settingField, {
      partition: partition,
      values: values,
      defaultColor: context.settings.color
    });
  }
};

function dropGrouping(context) {
  var name = context.name;
  var dataExchanger = context.params.dataExchanger;

  _each(context.grouping, function (field) {
    dataExchanger.set(name, field, null);
  });

  context.grouping = {};
}

groupByColor = function groupByColor(context) {
  performGrouping(context, context.settings.colorGroups, 'color', context.settings.colorGroupingField, function (count) {
    var _palette = context.params.themeManager.createDiscretePalette(context.settings.palette, count);

    var i;
    var list = [];

    for (i = 0; i < count; ++i) {
      list.push(_palette.getColor(i));
    }

    return list;
  });
};

groupBySize = function groupBySize(context, valueCallback) {
  var settings = context.settings;
  performGrouping(context, settings.sizeGroups, 'size', valueCallback || settings.sizeGroupingField, function (count) {
    var minSize = settings.minSize > 0 ? _Number(settings.minSize) : 0;
    var maxSize = settings.maxSize >= minSize ? _Number(settings.maxSize) : 0;
    var i = 0;
    var sizes = [];

    if (count > 1) {
      for (i = 0; i < count; ++i) {
        sizes.push((minSize * (count - i - 1) + maxSize * i) / (count - 1));
      }
    } else if (count === 1) {
      sizes.push((minSize + maxSize) / 2);
    }

    return sizes;
  });
};

function setFlag(flags, flag, state) {
  if (state) {
    flags |= flag;
  } else {
    flags &= ~flag;
  }

  return flags;
}

function hasFlag(flags, flag) {
  return !!(flags & flag);
}

function createLayerProxy(layer, name, index) {
  var proxy = {
    index: index,
    name: name,
    getElements: function getElements() {
      return layer.getProxies();
    },
    clearSelection: function clearSelection(_noEvent) {
      layer.clearSelection(_noEvent);
      return proxy;
    },
    getDataSource: function getDataSource() {
      return layer.getDataSource();
    },
    getBounds: function getBounds() {
      return layer.getBounds();
    }
  };
  return proxy;
}

var MapLayerElement;

var MapLayer = function MapLayer(params, container, name, index) {
  var that = this;
  that._params = params;

  that._onProjection();

  that.proxy = createLayerProxy(that, name, index);
  that._context = {
    name: name,
    layer: that.proxy,
    renderer: params.renderer,
    projection: params.projection,
    params: params,
    dataKey: params.dataKey,
    str: emptyStrategy,
    hover: false,
    selection: null,
    grouping: {},
    // TODO: Link name should be built upon layer index rather than name
    root: params.renderer.g().attr({
      'class': 'dxm-layer'
    }).linkOn(container, name).linkAppend()
  };
  that._container = container;
  that._options = {}; // Though the `_handles` field is set in the `_createHandles` it is required here because projection events are fired before data is set

  that._handles = []; // The `_data` field may be accessed in the `setOptions` when data is not set

  that._data = new EmptySource();
  that._dataSourceLoaded = null;
};

MapLayer.prototype = _extend({
  constructor: MapLayer,
  getDataReadyCallback: function getDataReadyCallback() {
    return this._dataSourceLoaded;
  },
  _onProjection: function _onProjection() {
    var that = this;
    that._removeHandlers = that._params.projection.on({
      'engine': function engine() {
        that._project();
      },
      'screen': function screen() {
        that._transform();
      },
      'center': function center() {
        that._transformCore();
      },
      'zoom': function zoom() {
        that._transform();
      }
    });
  },
  getData: function getData() {
    return this._data;
  },
  _dataSourceLoadErrorHandler: function _dataSourceLoadErrorHandler() {
    this._dataSourceChangedHandler();
  },
  _dataSourceChangedHandler: function _dataSourceChangedHandler() {
    var that = this;
    that._data = unwrapFromDataSource(that._dataSource && that._dataSource.items());

    that._update(true);
  },
  _dataSourceOptions: function _dataSourceOptions() {
    return {
      paginate: false
    };
  },
  _getSpecificDataSourceOption: function _getSpecificDataSourceOption() {
    return this._specificDataSourceOption;
  },
  _normalizeDataSource: function _normalizeDataSource(dataSource) {
    var store = dataSource.store();

    if (store._loadMode === 'raw') {
      store._loadMode = undefined;
    }

    return dataSource;
  },
  _offProjection: function _offProjection() {
    this._removeHandlers();

    this._removeHandlers = null;
  },
  dispose: function dispose() {
    var that = this;

    that._disposeDataSource();

    that._destroyHandles();

    dropGrouping(that._context);

    that._context.root.linkRemove().linkOff();

    that._context.labelRoot && that._context.labelRoot.linkRemove().linkOff();

    that._context.str.reset(that._context);

    that._offProjection();

    that._params = that._container = that._context = that.proxy = null;
    return that;
  },
  setOptions: function setOptions(options) {
    var that = this;
    options = that._options = options || {};
    that._dataSourceLoaded = new _deferred.Deferred();

    if ('dataSource' in options && options.dataSource !== that._options_dataSource) {
      that._options_dataSource = options.dataSource;

      that._params.notifyDirty();

      that._specificDataSourceOption = wrapToDataSource(options.dataSource);

      that._refreshDataSource();
    } else if (that._data.count() > 0) {
      that._params.notifyDirty();

      that._update(options.type !== undefined && options.type !== that._context.str.type || options.elementType !== undefined && options.elementType !== that._context.str.elementType);
    }

    that._transformCore();
  },
  _update: function _update(isContextChanged) {
    var that = this;
    var context = that._context;

    if (isContextChanged) {
      context.str.reset(context);
      context.root.clear();
      context.labelRoot && context.labelRoot.clear();

      that._params.tracker.reset(); // T173037; TODO: There is no need to reset the entire tracker - only its memory about items


      that._destroyHandles();

      context.str = selectStrategy(that._options, that._data);
      context.str.setup(context);
      that.proxy.type = context.str.type;
      that.proxy.elementType = context.str.elementType;
    }

    context.settings = processCommonSettings(context, that._options);
    context.hasSeparateLabel = !!(context.settings.label.enabled && context.str.hasLabelsGroup);
    context.hover = !!(0, _utils.parseScalar)(context.settings.hoverEnabled, true); // There is intentionally no attempt to preserve previous selection (or part of it)
    // Otherwise it would require some stack-like structure to keep selected items
    // Let's not complicate

    if (context.selection) {
      _each(context.selection.state, function (_, handle) {
        handle && handle.resetSelected();
      });
    }

    context.selection = getSelection(context.settings.selectionMode);

    if (context.hasSeparateLabel) {
      if (!context.labelRoot) {
        // TODO: Link name should be built upon layer index rather than name
        context.labelRoot = context.renderer.g().attr({
          'class': 'dxm-layer-labels'
        }).linkOn(that._container, {
          name: context.name + '-labels',
          after: context.name
        }).linkAppend();

        that._transformCore();
      }
    } else {
      if (context.labelRoot) {
        context.labelRoot.linkRemove().linkOff();
        context.labelRoot = null;
      }
    }

    if (isContextChanged) {
      that._createHandles();
    }

    dropGrouping(context);
    context.str.arrange(context, that._handles);
    context.str.updateGrouping(context);

    that._updateHandles();

    that._params.notifyReady();

    if (that._dataSourceLoaded) {
      // T890687
      that._dataSourceLoaded.resolve();

      that._dataSourceLoaded = null;
    } else {
      that._params.dataReady();
    }
  },
  getBounds: function getBounds() {
    return getMaxBound(this._handles.map(function (_ref) {
      var proxy = _ref.proxy;
      return proxy.coordinates().map(function (coords) {
        if (!_isArray(coords)) {
          return;
        }

        var coordsToBoundsSearch = _isArray(coords[0][0]) ? coords.reduce(function (ac, val) {
          return ac.concat(val);
        }, []) : coords;
        var initValue = coordsToBoundsSearch[0];
        return coordsToBoundsSearch.reduce(function (min, c) {
          return [_min(min[0], c[0]), _min(min[1], c[1]), _max(min[2], c[0]), _max(min[3], c[1])];
        }, [initValue[0], initValue[1], initValue[0], initValue[1]]);
      });
    }).map(getMaxBound));
  },
  _destroyHandles: function _destroyHandles() {
    this._handles.forEach(function (h) {
      return h.dispose();
    });

    if (this._context.selection) {
      this._context.selection.state = {};
    }

    this._handles = [];
  },
  _createHandles: function _createHandles() {
    var that = this;
    var handles = that._handles = [];
    var data = that._data;
    var i;
    var ii = handles.length = data.count();
    var context = that._context;
    var geometry = data.geometry;
    var attributes = data.attributes;
    var handle;
    var dataItem;

    for (i = 0; i < ii; ++i) {
      dataItem = data.item(i);
      handles[i] = new MapLayerElement(context, i, geometry(dataItem), attributes(dataItem));
    } // Customization must be performed before anything else happens to element (that is the idea of customization)


    (0, _type.isFunction)(that._options.customize) && customizeHandles(that.getProxies(), that._options.customize, that._params.widget);

    for (i = 0; i < ii; ++i) {
      handle = handles[i];
      handle.project();
      handle.draw();
      handle.transform();
    }

    if (context.selection) {
      _each(context.selection.state, function (_, handle) {
        handle && handle.restoreSelected();
      });
    }
  },
  _updateHandles: function _updateHandles() {
    var handles = this._handles;
    var i;
    var ii = handles.length;

    for (i = 0; i < ii; ++i) {
      handles[i].refresh();
    }

    if (this._context.settings.label.enabled) {
      for (i = 0; i < ii; ++i) {
        handles[i].measureLabel();
      }

      for (i = 0; i < ii; ++i) {
        handles[i].adjustLabel();
      }
    }
  },
  _transformCore: function _transformCore() {
    var transform = this._params.projection.getTransform();

    this._context.root.attr(transform);

    this._context.labelRoot && this._context.labelRoot.attr(transform);
  },
  _project: function _project() {
    var handles = this._handles;
    var i;
    var ii = handles.length;

    for (i = 0; i < ii; ++i) {
      handles[i].project();
    }
  },
  _transform: function _transform() {
    var handles = this._handles;
    var i;
    var ii = handles.length;

    this._transformCore();

    for (i = 0; i < ii; ++i) {
      handles[i].transform();
    }
  },
  getProxies: function getProxies() {
    return this._handles.map(function (p) {
      return p.proxy;
    });
  },
  getProxy: function getProxy(index) {
    return this._handles[index].proxy;
  },
  raiseClick: function raiseClick(i, dxEvent) {
    this._params.eventTrigger('click', {
      target: this._handles[i].proxy,
      event: dxEvent
    });
  },
  hoverItem: function hoverItem(i, state) {
    this._handles[i].setHovered(state);
  },
  selectItem: function selectItem(i, state, _noEvent) {
    this._handles[i].setSelected(state, _noEvent);
  },
  clearSelection: function clearSelection() {
    var selection = this._context.selection;

    if (selection) {
      _each(selection.state, function (_, handle) {
        handle && handle.setSelected(false);
      });

      selection.state = {};
    }
  }
}, _data_helper.default);

function createProxy(handle, coords, attrs) {
  var proxy = {
    coordinates: function coordinates() {
      return coords;
    },
    attribute: function attribute(name, value) {
      if (arguments.length > 1) {
        attrs[name] = value;
        return proxy;
      } else {
        return arguments.length > 0 ? attrs[name] : attrs;
      }
    },
    selected: function selected(state, _noEvent) {
      if (arguments.length > 0) {
        handle.setSelected(state, _noEvent);
        return proxy;
      } else {
        return handle.isSelected();
      }
    },
    applySettings: function applySettings(settings) {
      handle.update(settings);
      return proxy;
    }
  };
  return proxy;
}

MapLayerElement = function MapLayerElement(context, index, geometry, attributes) {
  var that = this;
  var proxy = that.proxy = createProxy(that, geometry.coordinates, _extend({}, attributes));
  that._ctx = context;
  that._index = index;
  that._fig = that._label = null;
  that._state = STATE_DEFAULT;
  that._coordinates = geometry.coordinates;
  that._settings = {
    label: {}
  };
  proxy.index = index;
  proxy.layer = context.layer; // TODO: Replace "name" field with one referencing layer index and use layer index (instead of name) as layer id
  // as it is more suitable, simple and consistent

  that._data = {
    name: context.name,
    index: index
  };
};

MapLayerElement.prototype = {
  constructor: MapLayerElement,
  dispose: function dispose() {
    var that = this;
    that._ctx = that.proxy = that._settings = that._fig = that._label = that.data = null;
    return that;
  },
  project: function project() {
    var context = this._ctx;
    this._projection = context.str.project(context.projection, this._coordinates);

    if (context.hasSeparateLabel && this._label) {
      this._projectLabel();
    }
  },
  _projectLabel: function _projectLabel() {
    this._labelProjection = this._ctx.str.projectLabel(this._projection);
  },
  draw: function draw() {
    var that = this;
    var context = this._ctx;
    context.str.draw(context, that._fig = {}, that._data);

    that._fig.root.append(context.root);
  },
  transform: function transform() {
    var that = this;
    var context = that._ctx;
    context.str.transform(that._fig, context.projection, that._projection);

    if (context.hasSeparateLabel && that._label) {
      that._transformLabel();
    }
  },
  _transformLabel: function _transformLabel() {
    this._ctx.str.transformLabel(this._label, this._ctx.projection, this._labelProjection);
  },
  refresh: function refresh() {
    var that = this;
    var strategy = that._ctx.str;
    var settings = getItemSettings(that._ctx, that.proxy, that._settings);
    that._styles = strategy.getStyles(settings);
    strategy.refresh(that._ctx, that._fig, that._data, that.proxy, settings);

    that._refreshLabel(settings);

    that._setState();
  },
  _refreshLabel: function _refreshLabel(settings) {
    var that = this;
    var context = that._ctx;
    var labelSettings = settings.label;
    var label = that._label;

    if (context.settings.label.enabled) {
      if (!label) {
        label = that._label = {
          root: context.labelRoot || that._fig.root,
          text: context.renderer.text().attr({
            'class': 'dxm-label'
          }),
          size: [0, 0]
        };

        if (context.hasSeparateLabel) {
          that._projectLabel();

          that._transformLabel();
        }
      }

      label.value = _String(that.proxy.text || that.proxy.attribute(labelSettings.dataField) || '');

      if (label.value) {
        // The data should be set when the element is created but it requires changes in the Renderer
        label.text.attr({
          text: label.value,
          x: 0,
          y: 0
        }).css((0, _utils.patchFontOptions)(labelSettings.font)).attr({
          align: 'center',
          stroke: labelSettings.stroke,
          'stroke-width': labelSettings['stroke-width'],
          'stroke-opacity': labelSettings['stroke-opacity']
        }).data(context.dataKey, that._data).append(label.root);
        label.settings = settings;
      }
    } else {
      if (label) {
        label.text.remove();
        that._label = null;
      }
    }
  },
  measureLabel: function measureLabel() {
    var label = this._label;
    var bBox;

    if (label.value) {
      bBox = label.text.getBBox();
      label.size = [bBox.width, bBox.height, -bBox.y - bBox.height / 2];
    }
  },
  adjustLabel: function adjustLabel() {
    var label = this._label;
    var offset;

    if (label.value) {
      offset = this._ctx.str.getLabelOffset(label, label.settings);
      label.settings = null;
      label.text.attr({
        x: offset[0],
        y: offset[1] + label.size[2]
      });
    }
  },
  update: function update(settings) {
    var that = this;
    that._settings = combineSettings(that._settings, settings); // This check is required because the method can be called during the customization stage when DOM content neither is created nor should be changed

    if (that._fig) {
      that.refresh();

      if (that._label && that._label.value) {
        that.measureLabel();
        that.adjustLabel();
      }
    }
  },
  _setState: function _setState() {
    this._ctx.str.setState(this._fig, this._styles, STATE_TO_INDEX[this._state]);
  },
  _setForeground: function _setForeground() {
    var root = this._fig.root;
    this._state ? root.toForeground() : root.toBackground();
  },
  setHovered: function setHovered(state) {
    var that = this;
    var currentState = hasFlag(that._state, STATE_HOVERED);
    var newState = !!state;

    if (that._ctx.hover && currentState !== newState) {
      that._state = setFlag(that._state, STATE_HOVERED, newState);

      that._setState();

      that._setForeground();

      raiseChanged(that._ctx, that, newState, 'hoverChanged');
    }

    return that;
  },
  setSelected: function setSelected(state, _noEvent) {
    var that = this;
    var currentState = hasFlag(that._state, STATE_SELECTED);
    var newState = !!state;
    var selection = that._ctx.selection;
    var tmp;

    if (selection && currentState !== newState) {
      that._state = setFlag(that._state, STATE_SELECTED, newState);
      tmp = selection.state[selection.single];
      selection.state[selection.single] = null; // This is to prevent stack overflow

      if (tmp) {
        tmp.setSelected(false);
      }

      selection.state[selection.single || that._index] = state ? that : null; // This check is required because the method can be called during the customization stage when DOM content neither is created nor should be changed

      if (that._fig) {
        that._setState();

        that._setForeground();

        if (!_noEvent) {
          raiseChanged(that._ctx, that, newState, 'selectionChanged');
        }
      }
    }
  },
  isSelected: function isSelected() {
    return hasFlag(this._state, STATE_SELECTED);
  },
  resetSelected: function resetSelected() {
    this._state = setFlag(this._state, STATE_SELECTED, false);
  },
  restoreSelected: function restoreSelected() {
    this._fig.root.toForeground();
  }
}; // http://en.wikipedia.org/wiki/Centroid

function calculatePolygonCentroid(coordinates) {
  var i;
  var length = coordinates.length;
  var v1;
  var v2 = coordinates[length - 1];
  var cross;
  var cx = 0;
  var cy = 0;
  var area = 0;
  var minX = Infinity;
  var maxX = -Infinity;
  var minY = Infinity;
  var maxY = -Infinity;

  for (i = 0; i < length; ++i) {
    v1 = v2;
    v2 = coordinates[i];
    cross = v1[0] * v2[1] - v2[0] * v1[1];
    area += cross;
    cx += (v1[0] + v2[0]) * cross;
    cy += (v1[1] + v2[1]) * cross;
    minX = _min(minX, v2[0]);
    maxX = _max(maxX, v2[0]);
    minY = _min(minY, v2[1]);
    maxY = _max(maxY, v2[1]);
  } // from centroid coords we need subtract the center of bbox coords to get a good geometrical center (T312029)


  return {
    area: _abs(area) / 2,
    center: [2 * cx / 3 / area - (minX + maxX) / 2, 2 * cy / 3 / area - (minY + maxY) / 2]
  };
}

function calculateLineStringData(coordinates) {
  var i;
  var ii = coordinates.length;
  var v1;
  var v2 = coordinates[0] || [];
  var totalLength = 0;
  var items = [0];
  var min0 = v2[0];
  var max0 = v2[0];
  var min1 = v2[1];
  var max1 = v2[1];

  for (i = 1; i < ii; ++i) {
    v1 = v2;
    v2 = coordinates[i];
    totalLength += _sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
    items[i] = totalLength;
    min0 = _min(min0, v2[0]);
    max0 = _max(max0, v2[0]);
    min1 = _min(min1, v2[1]);
    max1 = _max(max1, v2[1]);
  }

  i = findGroupingIndex(totalLength / 2, items);
  v1 = coordinates[i];
  v2 = coordinates[i + 1];
  var t = (totalLength / 2 - items[i]) / (items[i + 1] - items[i]);
  return ii ? [[v1[0] * (1 - t) + v2[0] * t, v1[1] * (1 - t) + v2[1] * t], [max0 - min0, max1 - min1], totalLength] : [];
} // TODO: Optimize!
// There are redundant iterations in the following cycle - interior holes of a polygon should not be taken into account
// So there is only centroid to be calculated for each "Polygon"


function projectAreaLabel(coordinates) {
  var i;
  var ii = coordinates.length;
  var centroid;
  var resultCentroid;
  var maxArea = 0;

  for (i = 0; i < ii; ++i) {
    centroid = calculatePolygonCentroid(coordinates[i]);

    if (centroid.area > maxArea) {
      maxArea = centroid.area;
      resultCentroid = centroid;
    }
  } // TODO: Move "_sqrt" to the "calculatePolygonCentroid"


  return resultCentroid ? [resultCentroid.center, [_sqrt(resultCentroid.area), _sqrt(resultCentroid.area)]] : [[], []];
}

function projectLineLabel(coordinates) {
  var i;
  var ii = coordinates.length;
  var maxLength = 0;
  var data;
  var resultData;

  for (i = 0; i < ii; ++i) {
    data = calculateLineStringData(coordinates[i]);

    if (data[2] > maxLength) {
      maxLength = data[2];
      resultData = data;
    }
  }

  return resultData || [[], []];
}

function MapLayerCollection(params) {
  var that = this;
  var renderer = params.renderer;
  that._params = params;
  that._layers = []; // TODO: Use Set instance instead of plain object

  that._layerByName = {};
  that._rect = [0, 0, 0, 0];
  that._clip = renderer.clipRect();
  that._background = renderer.rect().attr({
    'class': 'dxm-background'
  }).data(params.dataKey, {
    name: 'background'
  }).append(renderer.root);
  that._container = renderer.g().attr({
    'class': 'dxm-layers',
    'clip-path': that._clip.id
  }).append(renderer.root).enableLinks();

  that._subscribeToTracker(params.tracker, renderer, params.eventTrigger);

  that._dataReady = params.dataReady;
}

MapLayerCollection.prototype = {
  constructor: MapLayerCollection,
  dispose: function dispose() {
    var that = this;

    that._clip.dispose();

    that._layers.forEach(function (l) {
      return l.dispose();
    });

    that._offTracker();

    that._params = that._offTracker = that._layers = that._layerByName = that._clip = that._background = that._container = null;
  },
  _subscribeToTracker: function _subscribeToTracker(tracker, renderer, eventTrigger) {
    var that = this;
    that._offTracker = tracker.on({
      'click': function click(arg) {
        // TODO: Adjust `x` and `y` inside the Tracker
        var offset = renderer.getRootOffset();
        var layer = that.byName(arg.data.name);
        arg.$event.x = arg.x - offset.left;
        arg.$event.y = arg.y - offset.top; // TODO: Remove the "raiseClick" method

        if (layer) {
          layer.raiseClick(arg.data.index, arg.$event);
        } else if (arg.data.name === 'background') {
          eventTrigger('click', {
            event: arg.$event
          });
        }
      },
      'hover-on': function hoverOn(arg) {
        var layer = that.byName(arg.data.name);

        if (layer) {
          layer.hoverItem(arg.data.index, true);
        }
      },
      'hover-off': function hoverOff(arg) {
        var layer = that.byName(arg.data.name);

        if (layer) {
          layer.hoverItem(arg.data.index, false);
        }
      }
    });
  },
  setOptions: function setOptions(options) {
    var that = this;
    var optionList = options ? _isArray(options) ? options : [options] : [];
    var layers = that._layers;
    var readyCallbacks = [];
    var needToCreateLayers = optionList.length !== layers.length || layers.some(function (l, i) {
      var name = getName(optionList, i);
      return (0, _type.isDefined)(name) && name !== l.proxy.name;
    });

    if (needToCreateLayers) {
      that._params.tracker.reset();

      that._layers.forEach(function (l) {
        return l.dispose();
      });

      var layerByName = that._layerByName = {};
      that._layers = layers = [];

      for (var i = 0, ii = optionList.length; i < ii; ++i) {
        var name = getName(optionList, i) || 'map-layer-' + i;
        var layer = layers[i] = new MapLayer(that._params, that._container, name, i);
        layerByName[name] = layer;
      }
    }

    layers.forEach(function (l, i) {
      l.setOptions(optionList[i]);
    });
    readyCallbacks = layers.map(function (l) {
      return l.getDataReadyCallback();
    });
    readyCallbacks.length && _deferred.when.apply(undefined, readyCallbacks).done(that._dataReady);
  },
  _updateClip: function _updateClip() {
    var rect = this._rect;
    var bw = this._borderWidth;

    this._clip.attr({
      x: rect[0] + bw,
      y: rect[1] + bw,
      width: _max(rect[2] - bw * 2, 0),
      height: _max(rect[3] - bw * 2, 0)
    });
  },
  setBackgroundOptions: function setBackgroundOptions(options) {
    this._background.attr({
      stroke: options.borderColor,
      'stroke-width': options.borderWidth,
      fill: options.color
    });

    this._borderWidth = _max(options.borderWidth, 0);

    this._updateClip();
  },
  setRect: function setRect(rect) {
    this._rect = rect;

    this._background.attr({
      x: rect[0],
      y: rect[1],
      width: rect[2],
      height: rect[3]
    });

    this._updateClip();
  },
  byIndex: function byIndex(index) {
    return this._layers[index];
  },
  byName: function byName(name) {
    return this._layerByName[name];
  },
  items: function items() {
    return this._layers;
  }
};

/***/ }),
/* 1097 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.TooltipViewer = TooltipViewer;
var TOOLTIP_OFFSET = 12; // TODO: Somehow it should be merged with the core.Tooltip

function TooltipViewer(params) {
  this._subscribeToTracker(params.tracker, params.tooltip, params.layerCollection);
}

TooltipViewer.prototype = {
  constructor: TooltipViewer,
  dispose: function dispose() {
    this._offTracker();

    this._offTracker = null;
  },
  _subscribeToTracker: function _subscribeToTracker(tracker, tooltip, layerCollection) {
    this._offTracker = tracker.on({
      'focus-on': function focusOn(arg) {
        var layer;
        var proxy;

        if (tooltip.isEnabled()) {
          layer = layerCollection.byName(arg.data.name);
          proxy = layer && layer.getProxy(arg.data.index);

          var callback = function callback(result) {
            result && arg.done(result);
          };

          proxy && callback(tooltip.show(proxy, {
            x: arg.x,
            y: arg.y,
            offset: TOOLTIP_OFFSET
          }, {
            target: proxy
          }, undefined, callback));
        }
      },
      // There are no checks for `tooltip.isEnabled()` in the following two handlers because they are called only if the previous one has finished with `true`
      'focus-move': function focusMove(arg) {
        tooltip.move(arg.x, arg.y, TOOLTIP_OFFSET);
      },
      'focus-off': function focusOff() {
        tooltip.hide();
      }
    });
  }
};

/***/ }),
/* 1098 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.generateDataKey = generateDataKey;
var nextDataKey = 1;

function generateDataKey() {
  return 'vectormap-data-' + nextDataKey++;
}

/***/ }),
/* 1099 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _sparkline = _interopRequireDefault(__webpack_require__(1100));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = _sparkline.default;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _base_sparkline = _interopRequireDefault(__webpack_require__(608));

var _data_validator = __webpack_require__(345);

var _base_series = __webpack_require__(347);

var _utils = __webpack_require__(14);

var _type = __webpack_require__(1);

var _component_registrator = _interopRequireDefault(__webpack_require__(9));

var _data_source = __webpack_require__(186);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MIN_BAR_WIDTH = 1;
var MAX_BAR_WIDTH = 50;
var DEFAULT_BAR_INTERVAL = 4;
var DEFAULT_CANVAS_WIDTH = 250;
var DEFAULT_CANVAS_HEIGHT = 30;
var DEFAULT_POINT_BORDER = 2;
var ALLOWED_TYPES = {
  'line': true,
  'spline': true,
  'stepline': true,
  'area': true,
  'steparea': true,
  'splinearea': true,
  'bar': true,
  'winloss': true
};
var _math = Math;
var _abs = _math.abs;
var _round = _math.round;
var _max = _math.max;
var _min = _math.min;
var _isFinite = isFinite;
var _Number = Number;
var _String = String;

function findMinMax(data, valField) {
  var firstItem = data[0] || {};
  var firstValue = firstItem[valField] || 0;
  var min = firstValue;
  var max = firstValue;
  var minIndexes = [0];
  var maxIndexes = [0];
  var dataLength = data.length;
  var value;
  var i;

  for (i = 1; i < dataLength; i++) {
    value = data[i][valField];

    if (value < min) {
      min = value;
      minIndexes = [i];
    } else if (value === min) {
      minIndexes.push(i);
    }

    if (value > max) {
      max = value;
      maxIndexes = [i];
    } else if (value === max) {
      maxIndexes.push(i);
    }
  }

  if (max === min) {
    minIndexes = maxIndexes = [];
  }

  return {
    minIndexes: minIndexes,
    maxIndexes: maxIndexes
  };
}

function parseNumericDataSource(data, argField, valField, ignoreEmptyPoints) {
  return (0, _utils.map)(data, function (dataItem, index) {
    var item = null;
    var isDataNumber;
    var value;

    if (dataItem !== undefined) {
      item = {};
      isDataNumber = _isFinite(dataItem);
      item[argField] = isDataNumber ? _String(index) : dataItem[argField];
      value = isDataNumber ? dataItem : dataItem[valField];
      item[valField] = value === null ? ignoreEmptyPoints ? undefined : value : _Number(value);
      item = item[argField] !== undefined && item[valField] !== undefined ? item : null;
    }

    return item;
  });
}

function parseWinlossDataSource(data, argField, valField, target) {
  var lowBarValue = -1;
  var zeroBarValue = 0;
  var highBarValue = 1;
  var delta = 0.0001;
  return (0, _utils.map)(data, function (dataItem) {
    var item = {};
    item[argField] = dataItem[argField];

    if (_abs(dataItem[valField] - target) < delta) {
      item[valField] = zeroBarValue;
    } else if (dataItem[valField] > target) {
      item[valField] = highBarValue;
    } else {
      item[valField] = lowBarValue;
    }

    return item;
  });
}

function selectPointColor(color, options, index, pointIndexes) {
  if (index === pointIndexes.first || index === pointIndexes.last) {
    color = options.firstLastColor;
  }

  if ((pointIndexes.min || []).indexOf(index) >= 0) {
    color = options.minColor;
  }

  if ((pointIndexes.max || []).indexOf(index) >= 0) {
    color = options.maxColor;
  }

  return color;
}

function createLineCustomizeFunction(pointIndexes, options) {
  return function () {
    var color = selectPointColor(undefined, options, this.index, pointIndexes);
    return color ? {
      visible: true,
      border: {
        color: color
      }
    } : {};
  };
}

function createBarCustomizeFunction(pointIndexes, options, winlossData) {
  return function () {
    var index = this.index;
    var isWinloss = options.type === 'winloss';
    var target = isWinloss ? options.winlossThreshold : 0;
    var value = isWinloss ? winlossData[index][options.valueField] : this.value;
    var positiveColor = isWinloss ? options.winColor : options.barPositiveColor;
    var negativeColor = isWinloss ? options.lossColor : options.barNegativeColor;
    return {
      color: selectPointColor(value >= target ? positiveColor : negativeColor, options, index, pointIndexes)
    };
  };
}

var dxSparkline = _base_sparkline.default.inherit({
  _rootClassPrefix: 'dxsl',
  _rootClass: 'dxsl-sparkline',
  _themeSection: 'sparkline',
  _defaultSize: {
    width: DEFAULT_CANVAS_WIDTH,
    height: DEFAULT_CANVAS_HEIGHT
  },
  _initCore: function _initCore() {
    this.callBase();

    this._createSeries();
  },
  _initialChanges: ['DATA_SOURCE'],
  _dataSourceChangedHandler: function _dataSourceChangedHandler() {
    this._requestChange(['UPDATE']);
  },
  _updateWidgetElements: function _updateWidgetElements() {
    this._updateSeries();

    this.callBase();
  },
  _disposeWidgetElements: function _disposeWidgetElements() {
    var that = this;
    that._series && that._series.dispose();
    that._series = that._seriesGroup = that._seriesLabelGroup = null;
  },
  _cleanWidgetElements: function _cleanWidgetElements() {
    this._seriesGroup.remove();

    this._seriesLabelGroup.remove();

    this._seriesGroup.clear();

    this._seriesLabelGroup.clear();
  },
  _drawWidgetElements: function _drawWidgetElements() {
    if (this._dataIsLoaded()) {
      this._drawSeries();

      this._drawn();
    }
  },
  _getCorrectCanvas: function _getCorrectCanvas() {
    var options = this._allOptions;
    var canvas = this._canvas;
    var halfPointSize = options.pointSize && Math.ceil(options.pointSize / 2) + DEFAULT_POINT_BORDER;
    var type = options.type;

    if (type !== 'bar' && type !== 'winloss' && (options.showFirstLast || options.showMinMax)) {
      return {
        width: canvas.width,
        height: canvas.height,
        left: canvas.left + halfPointSize,
        right: canvas.right + halfPointSize,
        top: canvas.top + halfPointSize,
        bottom: canvas.bottom + halfPointSize
      };
    }

    return canvas;
  },
  _prepareOptions: function _prepareOptions() {
    var that = this;
    that._allOptions = that.callBase();
    that._allOptions.type = (0, _utils.normalizeEnum)(that._allOptions.type);

    if (!ALLOWED_TYPES[that._allOptions.type]) {
      that._allOptions.type = 'line';
    }
  },
  _createHtmlElements: function _createHtmlElements() {
    this._seriesGroup = this._renderer.g().attr({
      'class': 'dxsl-series'
    });
    this._seriesLabelGroup = this._renderer.g().attr({
      'class': 'dxsl-series-labels'
    });
  },
  _createSeries: function _createSeries() {
    this._series = new _base_series.Series({
      renderer: this._renderer,
      seriesGroup: this._seriesGroup,
      labelsGroup: this._seriesLabelGroup,
      argumentAxis: this._argumentAxis,
      valueAxis: this._valueAxis
    }, {
      widgetType: 'chart',
      type: 'line'
    });
  },
  _updateSeries: function _updateSeries() {
    var that = this;
    var singleSeries = that._series;

    that._prepareDataSource();

    var seriesOptions = that._prepareSeriesOptions();

    singleSeries.updateOptions(seriesOptions);
    var groupsData = {
      groups: [{
        series: [singleSeries]
      }]
    };
    groupsData.argumentOptions = {
      type: seriesOptions.type === 'bar' ? 'discrete' : undefined
    };
    that._simpleDataSource = (0, _data_validator.validateData)(that._simpleDataSource, groupsData, that._incidentOccurred, {
      checkTypeForAllData: false,
      convertToAxisDataType: true,
      sortingMethod: true
    })[singleSeries.getArgumentField()];
    seriesOptions.customizePoint = that._getCustomizeFunction();
    singleSeries.updateData(that._simpleDataSource);
    singleSeries.createPoints();
    that._groupsDataCategories = groupsData.categories;
  },
  _optionChangesMap: {
    dataSource: 'DATA_SOURCE'
  },
  _optionChangesOrder: ['DATA_SOURCE'],
  _change_DATA_SOURCE: function _change_DATA_SOURCE() {
    this._updateDataSource();
  },
  _prepareDataSource: function _prepareDataSource() {
    var that = this;
    var options = that._allOptions;
    var argField = options.argumentField;
    var valField = options.valueField;
    var dataSource = that._dataSourceItems() || [];
    var data = parseNumericDataSource(dataSource, argField, valField, that.option('ignoreEmptyPoints'));

    if (options.type === 'winloss') {
      that._winlossDataSource = data;
      that._simpleDataSource = parseWinlossDataSource(data, argField, valField, options.winlossThreshold);
    } else {
      that._simpleDataSource = data;
    }
  },
  _prepareSeriesOptions: function _prepareSeriesOptions() {
    var that = this;
    var options = that._allOptions;
    var type = options.type === 'winloss' ? 'bar' : options.type;
    return {
      visible: true,
      argumentField: options.argumentField,
      valueField: options.valueField,
      color: options.lineColor,
      width: options.lineWidth,
      widgetType: 'chart',
      type: type,
      opacity: type.indexOf('area') !== -1 ? that._allOptions.areaOpacity : undefined,
      point: {
        size: options.pointSize,
        symbol: options.pointSymbol,
        border: {
          visible: true,
          width: DEFAULT_POINT_BORDER
        },
        color: options.pointColor,
        visible: false,
        hoverStyle: {
          border: {}
        },
        selectionStyle: {
          border: {}
        }
      },
      border: {
        color: options.lineColor,
        width: options.lineWidth,
        visible: type !== 'bar'
      }
    };
  },
  _getCustomizeFunction: function _getCustomizeFunction() {
    var that = this;
    var options = that._allOptions;
    var dataSource = that._winlossDataSource || that._simpleDataSource;

    var drawnPointIndexes = that._getExtremumPointsIndexes(dataSource);

    var customizeFunction;

    if (options.type === 'winloss' || options.type === 'bar') {
      customizeFunction = createBarCustomizeFunction(drawnPointIndexes, options, that._winlossDataSource);
    } else {
      customizeFunction = createLineCustomizeFunction(drawnPointIndexes, options);
    }

    return customizeFunction;
  },
  _getExtremumPointsIndexes: function _getExtremumPointsIndexes(data) {
    var that = this;
    var options = that._allOptions;
    var lastIndex = data.length - 1;
    var indexes = {};
    that._minMaxIndexes = findMinMax(data, options.valueField);

    if (options.showFirstLast) {
      indexes.first = 0;
      indexes.last = lastIndex;
    }

    if (options.showMinMax) {
      indexes.min = that._minMaxIndexes.minIndexes;
      indexes.max = that._minMaxIndexes.maxIndexes;
    }

    return indexes;
  },
  _getStick: function _getStick() {
    return {
      stick: this._series.type !== 'bar'
    };
  },
  _updateRange: function _updateRange() {
    var that = this;
    var series = that._series;
    var type = series.type;
    var isBarType = type === 'bar';
    var isWinlossType = type === 'winloss';
    var DEFAULT_VALUE_RANGE_MARGIN = 0.15;
    var DEFAULT_ARGUMENT_RANGE_MARGIN = 0.1;
    var WINLOSS_MAX_RANGE = 1;
    var WINLOSS_MIN_RANGE = -1;
    var rangeData = series.getRangeData();
    var minValue = that._allOptions.minValue;

    var hasMinY = (0, _type.isDefined)(minValue) && _isFinite(minValue);

    var maxValue = that._allOptions.maxValue;

    var hasMaxY = (0, _type.isDefined)(maxValue) && _isFinite(maxValue);

    var argCoef;
    var valCoef = (rangeData.val.max - rangeData.val.min) * DEFAULT_VALUE_RANGE_MARGIN;

    if (isBarType || isWinlossType || type === 'area') {
      if (rangeData.val.min !== 0) {
        rangeData.val.min -= valCoef;
      }

      if (rangeData.val.max !== 0) {
        rangeData.val.max += valCoef;
      }
    } else {
      rangeData.val.min -= valCoef;
      rangeData.val.max += valCoef;
    }

    if (hasMinY || hasMaxY) {
      if (hasMinY && hasMaxY) {
        rangeData.val.minVisible = _min(minValue, maxValue);
        rangeData.val.maxVisible = _max(minValue, maxValue);
      } else {
        rangeData.val.minVisible = hasMinY ? _Number(minValue) : undefined;
        rangeData.val.maxVisible = hasMaxY ? _Number(maxValue) : undefined;
      }

      if (isWinlossType) {
        rangeData.val.minVisible = hasMinY ? _max(rangeData.val.minVisible, WINLOSS_MIN_RANGE) : undefined;
        rangeData.val.maxVisible = hasMaxY ? _min(rangeData.val.maxVisible, WINLOSS_MAX_RANGE) : undefined;
      }
    }

    if (series.getPoints().length > 1) {
      if (isBarType) {
        argCoef = (rangeData.arg.max - rangeData.arg.min) * DEFAULT_ARGUMENT_RANGE_MARGIN;
        rangeData.arg.min = rangeData.arg.min - argCoef;
        rangeData.arg.max = rangeData.arg.max + argCoef;
      }
    }

    rangeData.arg.categories = that._groupsDataCategories;
    that._ranges = rangeData;
  },
  _getBarWidth: function _getBarWidth(pointsCount) {
    var that = this;
    var canvas = that._canvas;
    var intervalWidth = pointsCount * DEFAULT_BAR_INTERVAL;
    var rangeWidth = canvas.width - canvas.left - canvas.right - intervalWidth;

    var width = _round(rangeWidth / pointsCount);

    if (width < MIN_BAR_WIDTH) {
      width = MIN_BAR_WIDTH;
    }

    if (width > MAX_BAR_WIDTH) {
      width = MAX_BAR_WIDTH;
    }

    return width;
  },
  _correctPoints: function _correctPoints() {
    var that = this;
    var seriesType = that._allOptions.type;

    var seriesPoints = that._series.getPoints();

    var pointsLength = seriesPoints.length;
    var barWidth;
    var i;

    if (seriesType === 'bar' || seriesType === 'winloss') {
      barWidth = that._getBarWidth(pointsLength);

      for (i = 0; i < pointsLength; i++) {
        seriesPoints[i].correctCoordinates({
          width: barWidth,
          offset: 0
        });
      }
    }
  },
  _drawSeries: function _drawSeries() {
    var that = this;

    if (that._simpleDataSource.length > 0) {
      that._correctPoints();

      that._series.draw();

      that._seriesGroup.append(that._renderer.root);
    }
  },
  _isTooltipEnabled: function _isTooltipEnabled() {
    return !!this._simpleDataSource.length;
  },
  _getTooltipData: function _getTooltipData() {
    var that = this;
    var options = that._allOptions;
    var dataSource = that._winlossDataSource || that._simpleDataSource;
    var tooltip = that._tooltip;

    if (dataSource.length === 0) {
      return {};
    }

    var minMax = that._minMaxIndexes;
    var valueField = options.valueField;
    var first = dataSource[0][valueField];
    var last = dataSource[dataSource.length - 1][valueField];
    var min = (0, _type.isDefined)(minMax.minIndexes[0]) ? dataSource[minMax.minIndexes[0]][valueField] : first;
    var max = (0, _type.isDefined)(minMax.maxIndexes[0]) ? dataSource[minMax.maxIndexes[0]][valueField] : first;
    var formattedFirst = tooltip.formatValue(first);
    var formattedLast = tooltip.formatValue(last);
    var formattedMin = tooltip.formatValue(min);
    var formattedMax = tooltip.formatValue(max);
    var customizeObject = {
      firstValue: formattedFirst,
      lastValue: formattedLast,
      minValue: formattedMin,
      maxValue: formattedMax,
      originalFirstValue: first,
      originalLastValue: last,
      originalMinValue: min,
      originalMaxValue: max,
      valueText: ['Start:', formattedFirst, 'End:', formattedLast, 'Min:', formattedMin, 'Max:', formattedMax]
    };

    if (options.type === 'winloss') {
      customizeObject.originalThresholdValue = options.winlossThreshold;
      customizeObject.thresholdValue = tooltip.formatValue(options.winlossThreshold);
    }

    return customizeObject;
  }
});

(0, _utils.map)(['lineColor', 'lineWidth', 'areaOpacity', 'minColor', 'maxColor', 'barPositiveColor', 'barNegativeColor', 'winColor', 'lessColor', 'firstLastColor', 'pointSymbol', 'pointColor', 'pointSize', 'type', 'argumentField', 'valueField', 'winlossThreshold', 'showFirstLast', 'showMinMax', 'ignoreEmptyPoints', 'minValue', 'maxValue'], function (name) {
  dxSparkline.prototype._optionChangesMap[name] = 'OPTIONS';
});
(0, _component_registrator.default)('dxSparkline', dxSparkline);
var _default = dxSparkline; // PLUGINS_SECTION

exports.default = _default;
dxSparkline.addPlugin(_data_source.plugin);
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _bullet = _interopRequireDefault(__webpack_require__(1102));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = _bullet.default;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _iterator = __webpack_require__(3);

var _base_sparkline = _interopRequireDefault(__webpack_require__(608));

var _component_registrator = _interopRequireDefault(__webpack_require__(9));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TARGET_MIN_Y = 0.02;
var TARGET_MAX_Y = 0.98;
var BAR_VALUE_MIN_Y = 0.1;
var BAR_VALUE_MAX_Y = 0.9;
var DEFAULT_CANVAS_WIDTH = 300;
var DEFAULT_CANVAS_HEIGHT = 30;
var DEFAULT_HORIZONTAL_MARGIN = 1;
var DEFAULT_VERTICAL_MARGIN = 2;
var _Number = Number;
var _isFinite = isFinite;

var dxBullet = _base_sparkline.default.inherit({
  _rootClassPrefix: 'dxb',
  _rootClass: 'dxb-bullet',
  _themeSection: 'bullet',
  _defaultSize: {
    width: DEFAULT_CANVAS_WIDTH,
    height: DEFAULT_CANVAS_HEIGHT,
    left: DEFAULT_HORIZONTAL_MARGIN,
    right: DEFAULT_HORIZONTAL_MARGIN,
    top: DEFAULT_VERTICAL_MARGIN,
    bottom: DEFAULT_VERTICAL_MARGIN
  },
  _disposeWidgetElements: function _disposeWidgetElements() {
    delete this._zeroLevelPath;
    delete this._targetPath;
    delete this._barValuePath;
  },
  _cleanWidgetElements: function _cleanWidgetElements() {
    this._zeroLevelPath.remove();

    this._targetPath.remove();

    this._barValuePath.remove();
  },
  _drawWidgetElements: function _drawWidgetElements() {
    this._drawBullet();

    this._drawn();
  },
  _createHtmlElements: function _createHtmlElements() {
    var renderer = this._renderer;
    this._zeroLevelPath = renderer.path(undefined, 'line').attr({
      'class': 'dxb-zero-level',
      'stroke-linecap': 'square'
    });
    this._targetPath = renderer.path(undefined, 'line').attr({
      'class': 'dxb-target',
      'stroke-linecap': 'square'
    });
    this._barValuePath = renderer.path(undefined, 'line').attr({
      'class': 'dxb-bar-value',
      'stroke-linecap': 'square'
    });
  },
  _prepareOptions: function _prepareOptions() {
    var that = this;
    var options;
    var startScaleValue;
    var endScaleValue;
    var level;
    var value;
    var target;
    that._allOptions = options = that.callBase();
    var isValueUndefined = that._allOptions.value === undefined;
    var isTargetUndefined = that._allOptions.target === undefined;
    that._tooltipEnabled = !(isValueUndefined && isTargetUndefined);

    if (isValueUndefined) {
      that._allOptions.value = 0;
    }

    if (isTargetUndefined) {
      that._allOptions.target = 0;
    }

    options.value = value = _Number(options.value);
    options.target = target = _Number(options.target);

    if (that._allOptions.startScaleValue === undefined) {
      that._allOptions.startScaleValue = target < value ? target : value;
      that._allOptions.startScaleValue = that._allOptions.startScaleValue < 0 ? that._allOptions.startScaleValue : 0;
    }

    if (that._allOptions.endScaleValue === undefined) {
      that._allOptions.endScaleValue = target > value ? target : value;
    }

    options.startScaleValue = startScaleValue = _Number(options.startScaleValue);
    options.endScaleValue = endScaleValue = _Number(options.endScaleValue);

    if (endScaleValue < startScaleValue) {
      level = endScaleValue;
      that._allOptions.endScaleValue = startScaleValue;
      that._allOptions.startScaleValue = level;
      that._allOptions.inverted = true;
    }
  },
  _updateRange: function _updateRange() {
    var that = this;
    var options = that._allOptions;
    that._ranges = {
      arg: {
        invert: options.rtlEnabled ? !options.inverted : options.inverted,
        min: options.startScaleValue,
        max: options.endScaleValue,
        axisType: 'continuous',
        dataType: 'numeric'
      },
      val: {
        min: 0,
        max: 1,
        axisType: 'continuous',
        dataType: 'numeric'
      }
    };
  },
  _drawBullet: function _drawBullet() {
    var that = this;
    var options = that._allOptions;
    var isValidBounds = options.startScaleValue !== options.endScaleValue;

    var isValidMin = _isFinite(options.startScaleValue);

    var isValidMax = _isFinite(options.endScaleValue);

    var isValidValue = _isFinite(options.value);

    var isValidTarget = _isFinite(options.target);

    if (isValidBounds && isValidMax && isValidMin && isValidTarget && isValidValue) {
      this._drawBarValue();

      this._drawTarget();

      this._drawZeroLevel();
    }
  },
  _getTargetParams: function _getTargetParams() {
    var that = this;
    var options = that._allOptions;

    var translatorY = that._valueAxis.getTranslator();

    var x = that._argumentAxis.getTranslator().translate(options.target);

    return {
      points: [x, translatorY.translate(TARGET_MIN_Y), x, translatorY.translate(TARGET_MAX_Y)],
      stroke: options.targetColor,
      'stroke-width': options.targetWidth
    };
  },
  _getBarValueParams: function _getBarValueParams() {
    var that = this;
    var options = that._allOptions;

    var translatorX = that._argumentAxis.getTranslator();

    var translatorY = that._valueAxis.getTranslator();

    var startLevel = options.startScaleValue;
    var endLevel = options.endScaleValue;
    var value = options.value;
    var y2 = translatorY.translate(BAR_VALUE_MIN_Y);
    var y1 = translatorY.translate(BAR_VALUE_MAX_Y);
    var x1;
    var x2;

    if (value > 0) {
      x1 = startLevel <= 0 ? 0 : startLevel;
      x2 = value >= endLevel ? endLevel : value < x1 ? x1 : value;
    } else {
      x1 = endLevel >= 0 ? 0 : endLevel;
      x2 = value < startLevel ? startLevel : value > x1 ? x1 : value;
    }

    x1 = translatorX.translate(x1);
    x2 = translatorX.translate(x2);
    return {
      points: [x1, y1, x2, y1, x2, y2, x1, y2],
      fill: options.color
    };
  },
  _getCorrectCanvas: function _getCorrectCanvas() {
    return this._canvas;
  },
  _getZeroLevelParams: function _getZeroLevelParams() {
    var that = this;

    var translatorY = that._valueAxis.getTranslator();

    var x = that._argumentAxis.getTranslator().translate(0);

    return {
      points: [x, translatorY.translate(TARGET_MIN_Y), x, translatorY.translate(TARGET_MAX_Y)],
      stroke: that._allOptions.targetColor,
      'stroke-width': 1
    };
  },
  _drawZeroLevel: function _drawZeroLevel() {
    var that = this;
    var options = that._allOptions;

    if (0 > options.endScaleValue || 0 < options.startScaleValue || !options.showZeroLevel) {
      return;
    }

    that._zeroLevelPath.attr(that._getZeroLevelParams()).sharp().append(that._renderer.root);
  },
  _drawTarget: function _drawTarget() {
    var that = this;
    var options = that._allOptions;
    var target = options.target;

    if (target > options.endScaleValue || target < options.startScaleValue || !options.showTarget) {
      return;
    }

    that._targetPath.attr(that._getTargetParams()).sharp().append(that._renderer.root);
  },
  _drawBarValue: function _drawBarValue() {
    this._barValuePath.attr(this._getBarValueParams()).append(this._renderer.root);
  },
  _getTooltipCoords: function _getTooltipCoords() {
    var canvas = this._canvas;

    var rootOffset = this._renderer.getRootOffset();

    var bBox = this._barValuePath.getBBox();

    return {
      x: bBox.x + bBox.width / 2 + rootOffset.left,
      y: canvas.height / 2 + rootOffset.top
    };
  },
  _getTooltipData: function _getTooltipData() {
    var that = this;
    var tooltip = that._tooltip;
    var options = that._allOptions;
    var value = options.value;
    var target = options.target;
    var valueText = tooltip.formatValue(value);
    var targetText = tooltip.formatValue(target);
    return {
      originalValue: value,
      originalTarget: target,
      value: valueText,
      target: targetText,
      valueText: ['Actual Value:', valueText, 'Target Value:', targetText]
    };
  },
  _isTooltipEnabled: function _isTooltipEnabled() {
    return this._tooltipEnabled;
  }
});

(0, _iterator.each)(['color', 'targetColor', 'targetWidth', 'showTarget', 'showZeroLevel', 'value', 'target', 'startScaleValue', 'endScaleValue'], function (_, name) {
  dxBullet.prototype._optionChangesMap[name] = 'OPTIONS';
});
(0, _component_registrator.default)('dxBullet', dxBullet);
var _default = dxBullet;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _tree_map = _interopRequireDefault(__webpack_require__(1104));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = _tree_map.default;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _tree_map = _interopRequireDefault(__webpack_require__(120));

__webpack_require__(609);

__webpack_require__(1105);

__webpack_require__(1106);

__webpack_require__(1107);

__webpack_require__(611);

__webpack_require__(1108);

__webpack_require__(1109);

__webpack_require__(188);

__webpack_require__(612);

__webpack_require__(1110);

__webpack_require__(614);

__webpack_require__(1111);

__webpack_require__(1112);

__webpack_require__(1113);

var _export = __webpack_require__(118);

var _title = __webpack_require__(138);

var _loading_indicator = __webpack_require__(163);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = _tree_map.default;
exports.default = _default;

_tree_map.default.addPlugin(_export.plugin);

_tree_map.default.addPlugin(_title.plugin);

_tree_map.default.addPlugin(_loading_indicator.plugin);

module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _tilingSquarified = _interopRequireDefault(__webpack_require__(610));

var _tiling = __webpack_require__(187);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function accumulate(total, current, count) {
  return ((count - 1) * total + current) / count;
}

function strip(data) {
  return (0, _tilingSquarified.default)(data, accumulate, true);
}

(0, _tiling.addAlgorithm)('strip', strip);
var _default = strip;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _tiling = __webpack_require__(187);

function sliceAndDice(data) {
  var items = data.items;
  var sidesData = (0, _tiling.buildSidesData)(data.rect, data.directions, data.isRotated ? 1 : 0);
  (0, _tiling.calculateRectangles)(items, 0, data.rect, sidesData, {
    sum: data.sum,
    count: items.length,
    side: sidesData.variedSide
  });
}

(0, _tiling.addAlgorithm)('sliceanddice', sliceAndDice);
var _default = sliceAndDice;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _tiling = __webpack_require__(187);

var sliceAndDiceAlgorithm = (0, _tiling.getAlgorithm)('sliceanddice');

function rotatedSliceAndDice(data) {
  data.isRotated = !data.isRotated;
  return sliceAndDiceAlgorithm.call(this, data);
}

(0, _tiling.addAlgorithm)('rotatedsliceanddice', rotatedSliceAndDice);

/***/ }),
/* 1108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _colorizing = __webpack_require__(246);

var _min = Math.min;
var _max = Math.max;

function createSimpleColorizer(getColor, range) {
  return function (node) {
    return getColor(node, range);
  };
}

function getRangeData(range) {
  return [Number(range[0]) || 0, range[1] - range[0] || 1];
}

function calculateRange(nodes, getValue) {
  var i;
  var ii = nodes.length;
  var codes = [];
  var code;

  for (i = 0; i < ii; ++i) {
    code = getValue(nodes[i]);

    if (isFinite(code)) {
      codes.push(code);
    }
  }

  return getRangeData([_min.apply(null, codes), _max.apply(null, codes)]);
}

function createGuessingColorizer(getColor, getValue) {
  var ranges = {};
  return function (node) {
    var parent = node.parent;
    return getColor(node, ranges[parent._id] || (ranges[parent._id] = calculateRange(parent.nodes, getValue)));
  };
}

function gradientColorizer(options, themeManager) {
  var palette = themeManager.createGradientPalette(options.palette);
  var getValue = (0, _colorizing.createColorCodeGetter)(options);
  return 'range' in options ? createSimpleColorizer(getColor, getRangeData(options.range || [])) : createGuessingColorizer(getColor, getValue);

  function getColor(node, arg) {
    return palette.getColor((getValue(node) - arg[0]) / arg[1]);
  }
}

(0, _colorizing.addColorizer)('gradient', gradientColorizer);
var _default = gradientColorizer;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _colorizing = __webpack_require__(246);

function getPaletteIndex(value, items) {
  var start = 0;
  var end = items.length - 1;
  var index = -1;
  var middle;

  if (items[start] <= value && value <= items[end]) {
    if (value === items[end]) {
      index = end - 1;
    } else {
      while (end - start > 1) {
        middle = start + end >> 1;

        if (value < items[middle]) {
          end = middle;
        } else {
          start = middle;
        }
      }

      index = start;
    }
  }

  return index;
}

function rangeColorizer(options, themeManager) {
  var range = options.range || [];
  var palette = themeManager.createDiscretePalette(options.palette, range.length - 1);
  var getValue = (0, _colorizing.createColorCodeGetter)(options);
  return function (node) {
    return palette.getColor(getPaletteIndex(getValue(node), range));
  };
}

(0, _colorizing.addColorizer)('range', rangeColorizer);
var _default = rangeColorizer;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _tree_map = _interopRequireDefault(__webpack_require__(120));

var _node = _interopRequireDefault(__webpack_require__(211));

var _helpers = __webpack_require__(184);

var _common = __webpack_require__(352);

var _utils = __webpack_require__(14);

var _array = __webpack_require__(12);

__webpack_require__(188);

__webpack_require__(613);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var proto = _tree_map.default.prototype;
var nodeProto = _node.default.prototype;
var MODE_NONE = 0;
var MODE_SINGLE = 1;
var MODE_MULTIPLE = 2;
var STATE_CODE = 2;
proto._eventsMap.onSelectionChanged = {
  name: 'selectionChanged'
};
(0, _helpers.expand)(proto._handlers, 'calculateAdditionalStates', function (states, options) {
  states[2] = options.selectionStyle ? (0, _common.buildRectAppearance)(options.selectionStyle) : {};
});
nodeProto.statesMap[2] = nodeProto.statesMap[3] = STATE_CODE;
nodeProto.additionalStates.push(2);
(0, _helpers.expand)(proto, '_onNodesCreated', function () {
  this._selectionList.length = 0;
});
(0, _helpers.expand)(proto, '_extendProxyType', function (proto) {
  var that = this;

  proto.select = function (state) {
    that._selectNode(this._id, !!state);
  };

  proto.isSelected = function () {
    return (0, _array.inArray)(this._id, that._selectionList) >= 0;
  };

  that._selectionList = [];
});

_tree_map.default.addChange({
  code: 'SELECTION_MODE',
  handler: function handler() {
    var that = this;
    var option = (0, _utils.normalizeEnum)(that._getOption('selectionMode', true));
    var selectionList = that._selectionList;
    var tmp;
    var mode = option === 'none' ? MODE_NONE : option === 'multiple' ? MODE_MULTIPLE : MODE_SINGLE;

    if (mode === MODE_SINGLE && selectionList.length > 1) {
      tmp = selectionList.pop();
      that.clearSelection();
      selectionList.push(tmp);
    } else if (mode === MODE_NONE) {
      that.clearSelection();
    }

    that._selectionMode = mode;
  },
  isThemeDependent: true,
  isOptionChange: true,
  option: 'selectionMode'
});

(0, _helpers.expand)(proto, '_applyTilesAppearance', function () {
  if (this._selectionList.length) {
    bringSelectedTilesToForeground(this._nodes, this._selectionList);
  }
});
var tileToFront = [leafToFront, groupToFront];

function bringSelectedTilesToForeground(nodes, selectionList) {
  var i;
  var ii = selectionList.length;
  var node;

  for (i = 0; i < ii; ++i) {
    node = nodes[selectionList[i]];
    tileToFront[Number(node.isNode())](node.tile);
  }
}

function leafToFront(content) {
  content.toForeground();
}

function groupToFront(content) {
  content.outer.toForeground();
  content.inner.toForeground();
}

proto._applySelectionState = function (index, state) {
  var node = this._nodes[index];
  node.setState(STATE_CODE, state);

  this._eventTrigger('selectionChanged', {
    node: node.proxy
  });
};

proto._selectNode = function (index, state) {
  var that = this;
  var selectionList;
  var k;
  var tmp;

  if (that._selectionMode !== MODE_NONE) {
    that._context.suspend();

    selectionList = that._selectionList;
    k = (0, _array.inArray)(index, selectionList);

    if (state && k === -1) {
      if (that._selectionMode === MODE_SINGLE) {
        if (selectionList.length) {
          tmp = selectionList.pop();

          that._applySelectionState(tmp, false);
        }
      }

      selectionList.push(index);

      that._applySelectionState(index, true);
    } else if (!state && k >= 0) {
      selectionList.splice(k, 1);

      that._applySelectionState(index, false);
    }

    that._context.resume();
  }
};

proto.clearSelection = function () {
  var that = this;
  var selectionList = that._selectionList;
  var i;
  var ii = selectionList.length;

  if (that._selectionMode !== MODE_NONE) {
    that._context.suspend();

    for (i = 0; i < ii; ++i) {
      that._applySelectionState(selectionList[i], false);
    }

    selectionList.length = 0;

    that._context.resume();
  }
};

/***/ }),
/* 1111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _tree_map = _interopRequireDefault(__webpack_require__(120));

var _tracker = __webpack_require__(353);

var _helpers = __webpack_require__(184);

var _utils = __webpack_require__(14);

__webpack_require__(188);

__webpack_require__(612);

__webpack_require__(614);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DATA_KEY_BASE = '__treemap_data_';
var dataKeyModifier = 0;
var proto = _tree_map.default.prototype;
proto._eventsMap.onClick = {
  name: 'click'
};

var getDataKey = function getDataKey() {
  var dataKey = DATA_KEY_BASE + dataKeyModifier++;
  return dataKey;
};

(0, _helpers.expand)(proto, '_initCore', function () {
  var that = this;
  var dataKey = getDataKey();

  var getProxy = function getProxy(index) {
    return that._nodes[index].proxy;
  };

  that._tracker = new _tracker.Tracker({
    widget: that,
    root: that._renderer.root,
    getNode: function getNode(id) {
      var proxy = getProxy(id);
      var interactWithGroup = (0, _utils.parseScalar)(that._getOption('interactWithGroup', true));
      return interactWithGroup && proxy.isLeaf() && proxy.getParent().isActive() ? proxy.getParent() : proxy;
    },
    getData: function getData(e) {
      var target = e.target;
      return (target.tagName === 'tspan' ? target.parentNode : target)[dataKey];
    },
    getProxy: getProxy,
    click: function click(e) {
      that._eventTrigger('click', e);
    }
  });

  that._handlers.setTrackerData = function (node, element) {
    element.data(dataKey, node._id);
  };
});
(0, _helpers.expand)(proto, '_disposeCore', function () {
  this._tracker.dispose();
});

/***/ }),
/* 1112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _tree_map = _interopRequireDefault(__webpack_require__(120));

var _helpers = __webpack_require__(184);

__webpack_require__(188);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var proto = _tree_map.default.prototype;
proto._eventsMap.onDrill = {
  name: 'drill'
};
(0, _helpers.expand)(proto, '_extendProxyType', function (proto) {
  var that = this;

  proto.drillDown = function () {
    that._drillToNode(this._id);
  };
});
(0, _helpers.expand)(proto, '_onNodesCreated', function () {
  this._drilldownIndex = -1;
});

proto._drillToNode = function (index) {
  var that = this;
  var node;

  if (that._drilldownIndex !== index) {
    node = that._nodes[index] || that._root;

    if (node.nodes) {
      that._drilldownIndex = index;
      that._topNode = node;

      that._context.suspend();

      that._context.change(['MAX_DEPTH', 'NODES_RESET']);

      that._context.resume();

      that._eventTrigger('drill', {
        node: node.proxy
      });
    }
  }
};

proto.resetDrillDown = function () {
  this._drillToNode(-1);

  return this;
};

proto.drillUp = function () {
  this._drillToNode(this._topNode.parent._id || -1);

  return this;
};

proto.getCurrentNode = function () {
  return this._topNode.proxy;
};

/***/ }),
/* 1113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _tree_map = _interopRequireDefault(__webpack_require__(120));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var proto = _tree_map.default.prototype;
proto._optionChangesMap.idField = proto._optionChangesMap.parentField = 'NODES_CREATE';

proto._processDataSourceItems = function (items) {
  var i;
  var struct = {};
  var currentItem;

  var idField = this._getOption('idField', true);

  var parentField = this._getOption('parentField', true);

  var parentId;
  var rootNodes = [];
  var tmpItems;
  var item;

  if (!idField || !parentField || items.length === 0) {
    return {
      items: items,
      isPlain: false
    };
  }

  for (i = 0; i < items.length; i++) {
    currentItem = items[i];
    parentId = currentItem[parentField];

    if (parentId) {
      struct[parentId] = struct[parentId] || {
        items: []
      };
      tmpItems = struct[parentId].items;
    } else {
      tmpItems = rootNodes;
    }

    tmpItems.push(currentItem);
  }

  treeFiller({
    struct: struct,
    idField: idField
  }, rootNodes);

  for (item in struct) {
    struct[item] && rootNodes.push(struct[item]);
  }

  return {
    items: rootNodes,
    isPlain: true
  };
};

function treeFiller(context, items) {
  var currentItem;
  var i;
  var struct = context.struct;
  var id;

  for (i = 0; i < items.length; i++) {
    currentItem = items[i];
    id = currentItem[context.idField];

    if (struct[id]) {
      currentItem.items = struct[id].items;
      struct[id] = null;
      treeFiller(context, currentItem.items);
    }
  }
}

/***/ }),
/* 1114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _funnel = _interopRequireDefault(__webpack_require__(615));

var _label = __webpack_require__(1119);

var _export = __webpack_require__(118);

var _title = __webpack_require__(138);

var _legend = __webpack_require__(239);

var _tracker = __webpack_require__(1120);

var _tooltip = __webpack_require__(1121);

var _loading_indicator = __webpack_require__(163);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_funnel.default.addPlugin(_label.plugin);

_funnel.default.addPlugin(_export.plugin);

_funnel.default.addPlugin(_title.plugin);

_funnel.default.addPlugin(_legend.plugin);

_funnel.default.addPlugin(_tracker.plugin);

_funnel.default.addPlugin(_tooltip.plugin);

_funnel.default.addPlugin(_loading_indicator.plugin);

var _default = _funnel.default;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.getAlgorithm = getAlgorithm;
exports.addAlgorithm = addAlgorithm;

var _utils = __webpack_require__(14);

var algorithms = {};
var defaultAlgorithm;

function getAlgorithm(name) {
  return algorithms[(0, _utils.normalizeEnum)(name)] || defaultAlgorithm;
}

function addAlgorithm(name, callback, setDefault) {
  algorithms[name] = callback;

  if (setDefault) {
    defaultAlgorithm = algorithms[name];
  }
}

/***/ }),
/* 1116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;
var CENTER = 0.5;
var _default = {
  getFigures: function getFigures(data) {
    var height = 1 / data.length;
    return data.map(function (value, index, array) {
      var nextValue = array[index + 1] ? array[index + 1] : array[index];
      return [CENTER - value / 2, height * index, CENTER + value / 2, height * index, CENTER + nextValue / 2, height * (index + 1), CENTER - nextValue / 2, height * (index + 1)];
    });
  },
  normalizeValues: function normalizeValues(items) {
    var max = items.reduce(function (max, item) {
      return Math.max(item.value, max);
    }, items[0] && items[0].value || 0);
    return items.map(function (item) {
      return item.value / max;
    });
  }
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;
var CENTER = 0.5;
var LEFTCORNER = 0;
var RIGHTCORNER = 1;
var _default = {
  getFigures: function getFigures(data, neckWidth, neckHeight) {
    var height = 0;
    var y = 0;
    var x = 0;
    var offsetX = 0;
    var halfNeckWidth = neckWidth / 2;
    var offsetFromCorner = CENTER - halfNeckWidth;
    var funnelHeight = 1 - neckHeight;
    var neckLeftCorner = CENTER - halfNeckWidth;
    var neckRightCorner = CENTER + halfNeckWidth;
    return data.map(function (value) {
      x = offsetX;
      y = height;
      height += value;
      offsetX = offsetFromCorner * height / funnelHeight;

      if (y <= funnelHeight && height <= funnelHeight) {
        return [x, y, RIGHTCORNER - x, y, RIGHTCORNER - offsetX, height, LEFTCORNER + offsetX, height];
      } else if (y <= funnelHeight && height > funnelHeight) {
        return [x, y, RIGHTCORNER - x, y, neckRightCorner, funnelHeight, neckRightCorner, height, neckLeftCorner, height, neckLeftCorner, funnelHeight];
      } else {
        return [neckLeftCorner, y, neckRightCorner, y, neckRightCorner, height, neckLeftCorner, height];
      }
    });
  },
  normalizeValues: function normalizeValues(items) {
    var sum = items.reduce(function (sum, item) {
      return sum + item.value;
    }, 0);
    return items.map(function (item) {
      return item.value / sum;
    });
  }
};
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _type = __webpack_require__(1);

var states = ['normal', 'hover', 'selection', 'selection'];

function parseStyles(color, style, baseStyle) {
  var border = style.border;
  var baseBorder = baseStyle.border;
  var borderVisible = (0, _type.isDefined)(border.visible) ? border.visible : baseBorder.visible;
  var borderWidth = (0, _type.isDefined)(border.width) ? border.width : baseBorder.width;
  return {
    fill: color,
    hatching: style.hatching,
    stroke: border.color || baseBorder.color,
    'stroke-width': borderVisible ? borderWidth : 0
  };
}

function Item(widget, options) {
  var that = this;
  var data = options.data;
  that.code = 0;
  that.widget = widget;
  that.figure = options.figure;
  that.argument = data.argument;
  that.value = data.value;
  that.data = data.dataItem;
  that.percent = options.percent;
  that.id = options.id;
  that.color = options.color;
  that.states = {
    normal: parseStyles(options.color, options.itemOptions, options.itemOptions),
    hover: parseStyles(options.color, options.itemOptions.hoverStyle, options.itemOptions),
    selection: parseStyles(options.color, options.itemOptions.selectionStyle, options.itemOptions)
  };
}

Item.prototype = {
  getState: function getState() {
    return states[this.code];
  },
  getNormalStyle: function getNormalStyle() {
    return this.states.normal;
  },
  setHover: function setHover() {
    this.hover(true);
  },
  hover: function hover(state) {
    if (!this.widget._getOption('hoverEnabled', true) || state === this.isHovered()) {
      return;
    }

    this.widget._suspend();

    state && this.widget.clearHover();
    this.setState(1, state);

    this.widget._eventTrigger('hoverChanged', {
      item: this
    });

    this.widget._resume();
  },
  setState: function setState(code, state) {
    if (state) {
      this.code |= code;
    } else {
      this.code &= ~code;
    }

    this.widget._applyTilesAppearance();
  },
  select: function select(state) {
    var mode = this.widget._getOption('selectionMode', true);

    if (mode === 'none' || state === this.isSelected()) {
      return;
    }

    this.widget._suspend();

    if (state && mode !== 'multiple') {
      this.widget.clearSelection();
    }

    this.setState(2, state);

    this.widget._eventTrigger('selectionChanged', {
      item: this
    });

    this.widget._resume();
  },
  showTooltip: function showTooltip(coords) {
    this.widget._showTooltip(this.id, coords);
  },
  getColor: function getColor() {
    return this.color;
  },
  isHovered: function isHovered() {
    return !!(this.code & 1);
  },
  isSelected: function isSelected() {
    return !!(this.code & 2);
  }
};
var _default = Item;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.plugin = void 0;

var _label = __webpack_require__(348);

var _utils = __webpack_require__(14);

var _extend = __webpack_require__(0);

var _common = __webpack_require__(4);

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var OUTSIDE_POSITION = 'outside';
var INSIDE_POSITION = 'inside';
var OUTSIDE_LABEL_INDENT = 5;
var COLUMNS_LABEL_INDENT = 20;
var CONNECTOR_INDENT = 4;
var PREVENT_EMPTY_PIXEL_OFFSET = 1;

function getLabelIndent(pos) {
  pos = (0, _utils.normalizeEnum)(pos);

  if (pos === OUTSIDE_POSITION) {
    return OUTSIDE_LABEL_INDENT;
  } else if (pos === INSIDE_POSITION) {
    return 0;
  }

  return COLUMNS_LABEL_INDENT;
}

function isOutsidePosition(pos) {
  pos = (0, _utils.normalizeEnum)(pos);
  return pos === OUTSIDE_POSITION || pos !== INSIDE_POSITION;
}

function correctYForInverted(y, bBox, inverted) {
  return inverted ? y - bBox.height : y;
}

function getOutsideRightLabelPosition(coords, bBox, options, inverted) {
  return {
    x: coords[2] + options.horizontalOffset + OUTSIDE_LABEL_INDENT,
    y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)
  };
}

function getOutsideLeftLabelPosition(coords, bBox, options, inverted) {
  return {
    x: coords[0] - bBox.width - options.horizontalOffset - OUTSIDE_LABEL_INDENT,
    y: correctYForInverted(coords[1] + options.verticalOffset, bBox, inverted)
  };
}

function getInsideLabelPosition(coords, bBox, options) {
  var width = coords[2] - coords[0];
  var height = coords[7] - coords[1];
  return {
    x: coords[0] + width / 2 + options.horizontalOffset - bBox.width / 2,
    y: coords[1] + options.verticalOffset + height / 2 - bBox.height / 2
  };
}

function getColumnLabelRightPosition(labelRect, rect, textAlignment) {
  return function (coords, bBox, options, inverted) {
    return {
      x: textAlignment === 'left' ? rect[2] + options.horizontalOffset + COLUMNS_LABEL_INDENT : labelRect[2] - bBox.width,
      y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)
    };
  };
}

function getColumnLabelLeftPosition(labelRect, rect, textAlignment) {
  return function (coords, bBox, options, inverted) {
    return {
      x: textAlignment === 'left' ? labelRect[0] : rect[0] - bBox.width - options.horizontalOffset - COLUMNS_LABEL_INDENT,
      y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)
    };
  };
}

function getConnectorStrategy(options, inverted) {
  var isLeftPos = options.horizontalAlignment === 'left';
  var connectorIndent = isLeftPos ? CONNECTOR_INDENT : -CONNECTOR_INDENT;
  var verticalCorrection = inverted ? -PREVENT_EMPTY_PIXEL_OFFSET : 0;

  function getFigureCenter(figure) {
    return isLeftPos ? [figure[0] + PREVENT_EMPTY_PIXEL_OFFSET, figure[1] + verticalCorrection] : [figure[2] - PREVENT_EMPTY_PIXEL_OFFSET, figure[3] + verticalCorrection];
  }

  return {
    isLabelInside: function isLabelInside() {
      return !isOutsidePosition(options.position);
    },
    getFigureCenter: getFigureCenter,
    prepareLabelPoints: function prepareLabelPoints(bBox) {
      var x = bBox.x + connectorIndent;
      var y = bBox.y;
      var x1 = x + bBox.width;
      return _toConsumableArray(Array(bBox.height + 1)).map(function (_, i) {
        return [x, y + i];
      }).concat(_toConsumableArray(Array(bBox.height + 1)).map(function (_, i) {
        return [x1, y + i];
      }));
    },
    isHorizontal: function isHorizontal() {
      return true;
    },
    findFigurePoint: function findFigurePoint(figure) {
      return getFigureCenter(figure);
    },
    adjustPoints: function adjustPoints(points) {
      return points.map(Math.round);
    }
  };
}

function getLabelOptions(labelOptions, defaultColor, defaultTextAlignment) {
  var opt = labelOptions || {};
  var labelFont = (0, _extend.extend)({}, opt.font) || {};
  var labelBorder = opt.border || {};
  var labelConnector = opt.connector || {};
  var backgroundAttr = {
    fill: opt.backgroundColor || defaultColor,
    'stroke-width': labelBorder.visible ? labelBorder.width || 0 : 0,
    stroke: labelBorder.visible && labelBorder.width ? labelBorder.color : 'none',
    dashStyle: labelBorder.dashStyle
  };
  var connectorAttr = {
    stroke: labelConnector.visible && labelConnector.width ? labelConnector.color || defaultColor : 'none',
    'stroke-width': labelConnector.visible ? labelConnector.width || 0 : 0,
    opacity: labelConnector.opacity
  };
  labelFont.color = opt.backgroundColor === 'none' && (0, _utils.normalizeEnum)(labelFont.color) === '#ffffff' && opt.position !== 'inside' ? defaultColor : labelFont.color;
  return {
    format: opt.format,
    textAlignment: opt.textAlignment || (isOutsidePosition(opt.position) ? defaultTextAlignment : 'center'),
    customizeText: opt.customizeText,
    attributes: {
      font: labelFont
    },
    visible: labelFont.size !== 0 ? opt.visible : false,
    showForZeroValues: opt.showForZeroValues,
    horizontalOffset: opt.horizontalOffset,
    verticalOffset: opt.verticalOffset,
    background: backgroundAttr,
    connector: connectorAttr,
    wordWrap: labelOptions.wordWrap,
    textOverflow: labelOptions.textOverflow
  };
}

function correctLabelPosition(pos, bBox, rect) {
  if (pos.x < rect[0]) {
    pos.x = rect[0];
  }

  if (pos.x + bBox.width > rect[2]) {
    pos.x = rect[2] - bBox.width;
  }

  if (pos.y < rect[1]) {
    pos.y = rect[1];
  }

  if (pos.y + bBox.height > rect[3]) {
    pos.y = rect[3] - bBox.height;
  }

  return pos;
}

function removeEmptySpace(labels, requiredSpace, startPoint) {
  labels.reduce(function (requiredSpace, label, index, labels) {
    var prevLabel = labels[index + 1];

    if (requiredSpace > 0) {
      var bBox = label.getBoundingRect();
      var point = prevLabel ? prevLabel.getBoundingRect().y + prevLabel.getBoundingRect().height : startPoint;
      var emptySpace = bBox.y - point;
      var shift = Math.min(emptySpace, requiredSpace);
      labels.slice(0, index + 1).forEach(function (label) {
        var bBox = label.getBoundingRect();
        label.shift(bBox.x, bBox.y - shift);
      });
      requiredSpace -= shift;
    }

    return requiredSpace;
  }, requiredSpace);
}

var plugin = {
  name: 'lables',
  init: _common.noop,
  dispose: _common.noop,
  extenders: {
    _initCore: function _initCore() {
      this._labelsGroup = this._renderer.g().attr({
        class: this._rootClassPrefix + '-labels'
      }).append(this._renderer.root);
      this._labels = [];
    },
    _applySize: function _applySize() {
      var options = this._getOption('label');

      var adaptiveLayout = this._getOption('adaptiveLayout');

      var rect = this._rect;
      var labelWidth = 0;
      var width = rect[2] - rect[0];
      this._labelRect = rect.slice();

      if (!this._labels.length || !isOutsidePosition(options.position)) {
        if ((0, _utils.normalizeEnum)(this._getOption('resolveLabelOverlapping', true) !== 'none')) {
          this._labels.forEach(function (l) {
            return !l.isVisible() && l.draw(true);
          });
        }

        return;
      }

      var groupWidth = this._labels.map(function (label) {
        label.resetEllipsis();
        return label.getBoundingRect().width;
      }).reduce(function (max, width) {
        return Math.max(max, width);
      }, 0);

      labelWidth = groupWidth + options.horizontalOffset + getLabelIndent(options.position);

      if (!adaptiveLayout.keepLabels && width - labelWidth < adaptiveLayout.width) {
        this._labels.forEach(function (label) {
          label.draw(false);
        });

        return;
      } else {
        if (width - labelWidth < adaptiveLayout.width) {
          labelWidth = width - adaptiveLayout.width;
          labelWidth = labelWidth > 0 ? labelWidth : 0;
        }

        this._labels.forEach(function (label) {
          label.draw(true);
        });
      }

      if (options.horizontalAlignment === 'left') {
        rect[0] += labelWidth;
      } else {
        rect[2] -= labelWidth;
      }
    },
    _buildNodes: function _buildNodes() {
      this._createLabels();
    },
    _change_TILING: function _change_TILING() {
      var that = this;

      var options = that._getOption('label');

      var getCoords = getInsideLabelPosition;

      var inverted = that._getOption('inverted', true);

      var textAlignment;

      if (isOutsidePosition(options.position)) {
        if ((0, _utils.normalizeEnum)(options.position) === OUTSIDE_POSITION) {
          getCoords = options.horizontalAlignment === 'left' ? getOutsideLeftLabelPosition : getOutsideRightLabelPosition;
        } else {
          textAlignment = this._defaultLabelTextAlignment();
          getCoords = options.horizontalAlignment === 'left' ? getColumnLabelLeftPosition(this._labelRect, this._rect, textAlignment) : getColumnLabelRightPosition(this._labelRect, this._rect, textAlignment);
        }
      }

      that._labels.forEach(function (label, index) {
        var item = that._items[index];
        var borderWidth = item.getNormalStyle()['stroke-width'];
        var halfBorderWidth = inverted ? borderWidth / 2 : -borderWidth / 2;
        var coords = halfBorderWidth ? item.coords.map(function (coord, index) {
          if (index === 1 || index === 3) {
            return coord - halfBorderWidth;
          } else if (index === 2) {
            return coord - borderWidth;
          } else if (index === 0) {
            return coord + borderWidth;
          }

          return coord;
        }) : item.coords;

        if (!options.showForZeroValues && item.value === 0) {
          label.draw(false);
          return;
        }

        if (isOutsidePosition(options.position)) {
          that._correctLabelWidth(label, item.coords, options);
        }

        var bBox = label.getBoundingRect();
        var pos = correctLabelPosition(getCoords(coords, bBox, options, inverted), bBox, that._labelRect);
        label.setFigureToDrawConnector(coords);
        label.shift(pos.x, pos.y);
      });

      that._resolveLabelOverlapping();
    }
  },
  members: {
    _resolveLabelOverlapping: function _resolveLabelOverlapping() {
      var that = this;
      var resolveLabelOverlapping = (0, _utils.normalizeEnum)(that._getOption('resolveLabelOverlapping', true));
      var labels = this._getOption('inverted', true) ? that._labels.slice().reverse() : that._labels;

      if (resolveLabelOverlapping === 'hide') {
        labels.reduce(function (height, label) {
          if (label.getBoundingRect().y < height) {
            label.hide();
          } else {
            height = label.getBoundingRect().y + label.getBoundingRect().height;
          }

          return height;
        }, 0);
      } else if (resolveLabelOverlapping === 'shift') {
        var maxHeight = this._labelRect[3];
        labels.reduce(function (_ref, label, index, labels) {
          var _ref2 = _slicedToArray(_ref, 2),
              height = _ref2[0],
              emptySpace = _ref2[1];

          var bBox = label.getBoundingRect();
          var y = bBox.y;

          if (bBox.y < height) {
            label.shift(bBox.x, height);
            y = height;
          }

          if (y - height > 0) {
            emptySpace += y - height;
          }

          if (y + bBox.height > maxHeight) {
            if (emptySpace && emptySpace > y + bBox.height - maxHeight) {
              removeEmptySpace(labels.slice(0, index).reverse(), y + bBox.height - maxHeight, that._labelRect[1]);
              emptySpace -= y + bBox.height - maxHeight;
              label.shift(bBox.x, y - (y + bBox.height - maxHeight));
              height = y - (y + bBox.height - maxHeight) + bBox.height;
            } else {
              label.hide();
            }
          } else {
            height = y + bBox.height;
          }

          return [height, emptySpace];
        }, [this._labelRect[1], 0]);
      }
    },
    _defaultLabelTextAlignment: function _defaultLabelTextAlignment() {
      return this._getOption('rtlEnabled', true) ? 'right' : 'left';
    },
    _correctLabelWidth: function _correctLabelWidth(label, item, options) {
      var isLeftPos = options.horizontalAlignment === 'left';
      var minX = isLeftPos ? this._labelRect[0] : item[2];
      var maxX = isLeftPos ? item[0] : this._labelRect[2];
      var maxWidth = maxX - minX;

      if (label.getBoundingRect().width > maxWidth) {
        label.fit(maxWidth);
      }
    },
    _createLabels: function _createLabels() {
      var that = this;

      var labelOptions = that._getOption('label');

      var connectorStrategy = getConnectorStrategy(labelOptions, that._getOption('inverted', true));

      this._labelsGroup.clear();

      if (!labelOptions.visible) {
        return;
      }

      this._labels = that._items.map(function (item) {
        var label = new _label.Label({
          renderer: that._renderer,
          labelsGroup: that._labelsGroup,
          strategy: connectorStrategy
        });
        label.setOptions(getLabelOptions(labelOptions, item.color, that._defaultLabelTextAlignment()));
        label.setData({
          item: item,
          value: item.value,
          percent: item.percent
        });
        label.draw(true);
        return label;
      });

      if (this._labels.length && isOutsidePosition(labelOptions.position)) {
        this._requestChange(['LAYOUT']);
      }
    }
  },
  customize: function customize(constructor) {
    constructor.prototype._proxyData.push(function (x, y) {
      var that = this;
      var data;

      that._labels.forEach(function (label, index) {
        var rect = label.getBoundingRect();

        if (x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height) {
          var pos = isOutsidePosition(that._getOption('label').position) ? 'outside' : 'inside';
          data = {
            id: index,
            type: pos + '-label'
          };
          return true;
        }
      });

      return data;
    });

    ['label', 'resolveLabelOverlapping'].forEach(function (optionName) {
      constructor.addChange({
        code: optionName.toUpperCase(),
        handler: function handler() {
          this._createLabels();

          this._requestChange(['LAYOUT']);
        },
        isThemeDependent: true,
        isOptionChange: true,
        option: optionName
      });
    });
  },
  fontFields: ['label.font']
};
exports.plugin = plugin;

/***/ }),
/* 1120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.plugin = void 0;

var _funnel = _interopRequireDefault(__webpack_require__(615));

var _tracker = __webpack_require__(353);

var _type = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DATA_KEY_BASE = '__funnel_data_';
var dataKeyModifier = 0;
var proto = _funnel.default.prototype;
proto._eventsMap.onItemClick = {
  name: 'itemClick'
};
proto._eventsMap.onLegendClick = {
  name: 'legendClick'
};

var getDataKey = function getDataKey() {
  return DATA_KEY_BASE + dataKeyModifier++;
};

var plugin = {
  name: 'tracker',
  init: function init() {
    var that = this;
    var dataKey = getDataKey();

    var getProxyData = function getProxyData(e) {
      var rootOffset = that._renderer.getRootOffset();

      var x = Math.floor(e.pageX - rootOffset.left);
      var y = Math.floor(e.pageY - rootOffset.top);
      return that._hitTestTargets(x, y);
    };

    that._tracker = new _tracker.Tracker({
      widget: that,
      root: that._renderer.root,
      getData: function getData(e, tooltipData) {
        var target = e.target;
        var data = target[dataKey];

        if ((0, _type.isDefined)(data)) {
          return data;
        }

        var proxyData = getProxyData(e);

        if (tooltipData && proxyData && proxyData.type !== 'inside-label') {
          return;
        }

        return proxyData && proxyData.id;
      },
      getNode: function getNode(index) {
        return that._items[index];
      },
      click: function click(e) {
        var proxyData = getProxyData(e.event);
        var dataType = proxyData && proxyData.type;
        var event = dataType === 'legend' ? 'legendClick' : 'itemClick';

        that._eventTrigger(event, {
          item: e.node,
          event: e.event
        });
      }
    });
    this._dataKey = dataKey;
  },
  dispose: function dispose() {
    this._tracker.dispose();
  },
  extenders: {
    _change_TILING: function _change_TILING() {
      var dataKey = this._dataKey;

      this._items.forEach(function (item, index) {
        item.element.data(dataKey, index);
      });
    }
  }
};
exports.plugin = plugin;

/***/ }),
/* 1121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.plugin = void 0;

var _common = __webpack_require__(4);

var _tooltip = __webpack_require__(140);

function getCoords(coords, figureCoords, renderer) {
  var offset = renderer.getRootOffset();
  return coords || figureCoords && [(figureCoords[0] + figureCoords[2]) / 2 + offset.left, (figureCoords[1] + figureCoords[5]) / 2 + offset.top] || [-1000, -1000];
}

var plugin = {
  name: 'funnel-tooltip',
  init: _common.noop,
  dispose: _common.noop,
  extenders: {
    _buildNodes: function _buildNodes() {
      this.hideTooltip();
    },
    _change_TILING: function _change_TILING() {
      if (this._tooltipIndex >= 0) {
        this._moveTooltip(this._items[this._tooltipIndex]);
      }
    }
  },
  members: {
    hideTooltip: function hideTooltip() {
      if (this._tooltipIndex >= 0) {
        this._tooltipIndex = -1;

        this._tooltip.hide();
      }
    },
    _moveTooltip: function _moveTooltip(item, coords) {
      var xy = getCoords(coords, item.coords, this._renderer);

      this._tooltip.move(xy[0], xy[1], 0);
    },
    _showTooltip: function _showTooltip(index, coords) {
      var that = this;
      var tooltip = that._tooltip;
      var item = that._items[index];

      if (that._tooltipIndex === index) {
        that._moveTooltip(item, coords);

        return;
      }

      var callback = function callback(result) {
        if (result === undefined) {
          return;
        }

        if (!result) {
          tooltip.hide();
        }

        that._tooltipIndex = result ? index : -1;
      };

      var xy = getCoords(coords, item.coords, this._renderer);
      callback(tooltip.show({
        value: item.value,
        valueText: tooltip.formatValue(item.value),
        percentText: tooltip.formatValue(item.percent, 'percent'),
        percent: item.percent,
        item: item
      }, {
        x: xy[0],
        y: xy[1],
        offset: 0
      }, {
        item: item
      }, undefined, callback));
    }
  },
  customize: function customize(constructor) {
    constructor.addPlugin(_tooltip.plugin);
  }
};
exports.plugin = plugin;

/***/ }),
/* 1122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _sankey = _interopRequireDefault(__webpack_require__(616));

var _tooltip = __webpack_require__(1127);

var _export = __webpack_require__(118);

var _title = __webpack_require__(138);

var _tracker = __webpack_require__(1128);

var _tooltip2 = __webpack_require__(140);

var _loading_indicator = __webpack_require__(163);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_sankey.default.addPlugin(_export.plugin);

_sankey.default.addPlugin(_title.plugin);

_sankey.default.addPlugin(_tracker.plugin);

_sankey.default.addPlugin(_loading_indicator.plugin);

_sankey.default.addPlugin(_tooltip2.plugin);

(0, _tooltip.setTooltipCustomOptions)(_sankey.default);
var _default = _sankey.default;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _type = __webpack_require__(1);

var _utils = __webpack_require__(14);

var states = ['normal', 'hover'];

function _compileAttrs(color, itemOptions, itemBaseOptions) {
  var border = itemOptions.border;
  var baseBorder = itemBaseOptions.border;
  var borderVisible = (0, _type.isDefined)(border.visible) ? border.visible : baseBorder.visible;
  var borderWidth = (0, _type.isDefined)(border.width) ? border.width : baseBorder.width;
  var borderOpacity = (0, _type.isDefined)(border.opacity) ? border.opacity : (0, _type.isDefined)(baseBorder.opacity) ? baseBorder.opacity : 1;
  var opacity = (0, _type.isDefined)(itemOptions.opacity) ? itemOptions.opacity : (0, _type.isDefined)(itemBaseOptions.opacity) ? itemBaseOptions.opacity : 1;
  return {
    fill: itemOptions.color || color,
    'stroke-width': borderVisible ? borderWidth : 0,
    stroke: itemOptions.border.color || itemBaseOptions.border.color,
    'stroke-opacity': borderOpacity,
    opacity: opacity,
    hatching: itemOptions.hatching
  };
}

function compileLabelAttrs(labelOptions, filter, node) {
  var _patchFontOptions = _utils.patchFontOptions;

  if (labelOptions.useNodeColors) {
    labelOptions.font.color = node.color;
  }

  var borderVisible = (0, _type.isDefined)(labelOptions.border.visible) ? labelOptions.border.visible : false;
  var borderWidth = (0, _type.isDefined)(labelOptions.border.width) ? labelOptions.border.width : 0;
  var borderColor = (0, _type.isDefined)(labelOptions.border.color) ? labelOptions.border.color : labelOptions.font.color;
  var borderOpacity = (0, _type.isDefined)(labelOptions.border.opacity) ? labelOptions.border.opacity : 1;
  var attr = {
    filter: filter
  };

  if (borderVisible && borderWidth) {
    attr.stroke = borderColor;
    attr['stroke-width'] = borderVisible ? borderWidth : 0;
    attr['stroke-opacity'] = borderOpacity;
  }

  return {
    attr: attr,
    css: _patchFontOptions(labelOptions.font)
  };
}

function Node(widget, params) {
  var that = this;

  var widgetOffset = widget._renderer.getRootOffset();

  that.code = 0;
  that.widget = widget;
  that.color = params.color;
  that.options = params.options;
  that.rect = params.rect;
  that.label = that.title = params.rect._name;
  that.coords = {
    x: params.rect.x + params.rect.width / 2 + widgetOffset.left,
    y: params.rect.y + params.rect.height / 2 + widgetOffset.top
  };
  that.id = params.id;
  that.linksIn = params.linksIn;
  that.linksOut = params.linksOut;
  this.states = {
    normal: _compileAttrs(this.color, that.options, that.options),
    hover: _compileAttrs(this.color, that.options.hoverStyle, that.options)
  };
}

Node.prototype = {
  compileAttrs: function compileAttrs() {
    return _compileAttrs(this.color, this.options);
  },
  getState: function getState() {
    return states[this.code];
  },
  isHovered: function isHovered() {
    return !!(this.code & 1);
  },
  setState: function setState(code, state) {
    var _this = this;

    if (state) {
      this.code |= code;
    } else {
      this.code &= ~code;
    }

    if (state) {
      this.linksIn.concat(this.linksOut).forEach(function (adjacentLink) {
        _this.widget._links[adjacentLink.index].setAdjacentNodeHover(true);
      });
    } else {
      this.widget._links.forEach(function (link) {
        link.isAdjacentNodeHovered() && link.adjacentNodeHover(false);
      });

      this.hideTooltip();
    }

    this.widget._applyNodesAppearance();

    this.widget._applyLinksAppearance();
  },
  hover: function hover(state) {
    if (!this.widget._getOption('hoverEnabled', true) || state === this.isHovered()) {
      return;
    }

    this.widget._suspend();

    state && this.widget.clearHover();
    this.setState(1, state);

    this.widget._eventTrigger('nodeHoverChanged', {
      target: this
    });

    this.widget._resume();
  },
  setHover: function setHover() {
    this.hover(true);
  },
  showTooltip: function showTooltip(coords) {
    this.widget._getOption('hoverEnabled', true) && this.widget._tooltip && this.widget._tooltip.show({
      type: 'node',
      info: {
        label: this.label,
        title: this.label,
        weightIn: this.linksIn.reduce(function (previousValue, currentValue) {
          return previousValue + currentValue.weight;
        }, 0),
        weightOut: this.linksOut.reduce(function (previousValue, currentValue) {
          return previousValue + currentValue.weight;
        }, 0)
      }
    }, typeof coords !== 'undefined' ? {
      x: coords[0],
      y: coords[1]
    } : this.coords);
  },
  hideTooltip: function hideTooltip() {
    this.widget._tooltip && this.widget._tooltip.hide();
  },
  getLabelAttributes: function getLabelAttributes(labelSettings, filter) {
    return compileLabelAttrs(labelSettings, filter, this);
  }
};
var _default = Node;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _constants = __webpack_require__(617);

var _type = __webpack_require__(1);

var states = ['normal', 'adjacentNodeHover', 'hover'];

function compileAttrs(color, itemOptions, itemBaseOptions, gradient) {
  var border = itemOptions.border;
  var baseBorder = itemBaseOptions.border;
  var borderVisible = (0, _type.isDefined)(border.visible) ? border.visible : baseBorder.visible;
  var borderWidth = (0, _type.isDefined)(border.width) ? border.width : baseBorder.width;
  var borderOpacity = (0, _type.isDefined)(border.opacity) ? border.opacity : (0, _type.isDefined)(baseBorder.opacity) ? baseBorder.opacity : 1;
  var opacity = (0, _type.isDefined)(itemOptions.opacity) ? itemOptions.opacity : (0, _type.isDefined)(itemBaseOptions.opacity) ? itemBaseOptions.opacity : 1;
  var fill = itemOptions.color || color;

  if (itemBaseOptions.colorMode === _constants.COLOR_MODE_TARGET || itemBaseOptions.colorMode === _constants.COLOR_MODE_SOURCE) {
    fill = color;
  } else if (itemBaseOptions.colorMode === _constants.COLOR_MODE_GRADIENT && gradient && (0, _type.isDefined)(gradient.id)) {
    fill = gradient.id;
  }

  return {
    fill: fill,
    'stroke-width': borderVisible ? borderWidth : 0,
    stroke: itemOptions.border.color || itemBaseOptions.border.color,
    'stroke-opacity': borderOpacity,
    opacity: opacity,
    hatching: itemOptions.hatching
  };
}

function Link(widget, params) {
  var that = this;

  var widgetOffset = widget._renderer.getRootOffset();

  that.code = 0;
  that.widget = widget;
  that.color = params.color;
  that.connection = params.connection;
  that.d = params.d;
  that.options = params.options;
  that.boundingRect = params.boundingRect, that.coords = {
    x: params.boundingRect.x + params.boundingRect.width / 2 + widgetOffset.left,
    y: params.boundingRect.y + params.boundingRect.height / 2 + widgetOffset.top
  };
  that.states = {
    normal: compileAttrs(that.color, that.options, that.options, params.gradient),
    adjacentNodeHover: compileAttrs(that.color, {
      opacity: 0,
      border: {}
    }, that.options, params.gradient),
    hover: compileAttrs(that.color, {
      opacity: 0,
      border: {}
    }, that.options, params.gradient)
  };
  that.overlayStates = {
    normal: compileAttrs(that.color, {
      opacity: 0,
      border: {}
    }, that.options),
    adjacentNodeHover: compileAttrs(that.color, that.options.hoverStyle, that.options),
    hover: compileAttrs(that.color, that.options.hoverStyle, that.options)
  };
}

Link.prototype = {
  getState: function getState() {
    return states[this.code];
  },
  isHovered: function isHovered() {
    return this.code === 2;
  },
  isAdjacentNodeHovered: function isAdjacentNodeHovered() {
    return this.code === 1;
  },
  setState: function setState(code, state) {
    if (state) {
      this.code = code;
    } else {
      this.code = 0;
      this.hideTooltip();
    }

    this.widget._applyLinksAppearance();
  },
  setHover: function setHover() {
    this.hover(true);
  },
  hover: function hover(state) {
    if (!this.widget._getOption('hoverEnabled', true) || state === this.isHovered()) {
      return;
    }

    this.widget._suspend();

    state && this.widget.clearHover();
    this.setState(2, state);

    this.widget._eventTrigger('linkHoverChanged', {
      target: this
    });

    this.widget._resume();
  },
  adjacentNodeHover: function adjacentNodeHover(state) {
    if (!this.widget._getOption('hoverEnabled', true) || state === this.isAdjacentNodeHovered()) {
      return;
    }

    this.widget._suspend();

    this.setState(1, state);

    this.widget._resume();
  },
  setAdjacentNodeHover: function setAdjacentNodeHover() {
    this.adjacentNodeHover(true);
  },
  showTooltip: function showTooltip(coords) {
    this.widget._getOption('hoverEnabled', true) && this.widget._tooltip && this.widget._tooltip.show({
      type: 'link',
      info: {
        source: this.connection.source,
        target: this.connection.target,
        weight: this.connection.weight
      }
    }, typeof coords !== 'undefined' ? {
      x: coords[0],
      y: coords[1]
    } : this.coords);
  },
  hideTooltip: function hideTooltip() {
    this.widget._tooltip && this.widget._tooltip.hide();
  }
};
var _default = Link;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.layout = void 0;

var _graph = _interopRequireDefault(__webpack_require__(618));

var _data_validator = _interopRequireDefault(__webpack_require__(1126));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _SPLINE_TENSION = 0.3;
var _ALIGNMENT_CENTER = 'center';
var _ALIGNMENT_BOTTOM = 'bottom';
var _ALIGNMENT_DEFAULT = _ALIGNMENT_CENTER;
var layout = {
  _weightPerPixel: null,
  _getCascadeIdx: function _getCascadeIdx(nodeTitle, cascadesConfig) {
    var nodeInfo = cascadesConfig.filter(function (c) {
      return c.name === nodeTitle;
    })[0];

    if (nodeInfo.outgoing.length > 0) {
      // in common case number of cascade is the longest path to the node
      return nodeInfo.lp;
    } else {
      // but if the node is last (ie has no outgoing edges) lets move it to the LAST cascade
      return _graph.default.routines.maxOfArray(cascadesConfig.map(function (c) {
        return c.lp;
      }));
    }
  },
  _getInWeightForNode: function _getInWeightForNode(nodeTitle, links) {
    var w = 0;
    links.forEach(function (link) {
      if (link[1] === nodeTitle) {
        w += link[2];
      }
    });
    return w;
  },
  _getOutWeightForNode: function _getOutWeightForNode(nodeTitle, links) {
    var w = 0;
    links.forEach(function (link) {
      if (link[0] === nodeTitle) {
        w += link[2];
      }
    });
    return w;
  },
  _computeCascades: function _computeCascades(links) {
    var _this = this;

    var cascadesConfig = _graph.default.struct.computeLongestPaths(links);

    var maxCascade = _graph.default.routines.maxOfArray(cascadesConfig.map(function (c) {
      return c.lp;
    }));

    var cascades = []; // init cascades

    for (var i = 0; i < maxCascade + 1; i++) {
      cascades.push({});
    } // add nodes to cascades


    links.forEach(function (link) {
      var cascade = cascades[_this._getCascadeIdx(link[0], cascadesConfig)];

      if (!cascade[link[0]]) {
        cascade[link[0]] = {
          nodeTitle: link[0]
        };
      }

      cascade = cascades[_this._getCascadeIdx(link[1], cascadesConfig)];

      if (!cascade[link[1]]) {
        cascade[link[1]] = {
          nodeTitle: link[1]
        };
      }
    }); // compute in and out weightes of all nodes of cascades

    cascades.forEach(function (cascade) {
      Object.keys(cascade).forEach(function (nodeTitle) {
        var node = cascade[nodeTitle];
        node.inWeight = _this._getInWeightForNode(node.nodeTitle, links);
        node.outWeight = _this._getOutWeightForNode(node.nodeTitle, links);
        node.maxWeight = Math.max(node.inWeight, node.outWeight);
      });
    });
    return cascades;
  },
  _getWeightForCascade: function _getWeightForCascade(cascades, cascadeIdx) {
    var wMax = 0;
    var cascade = cascades[cascadeIdx];
    Object.keys(cascade).forEach(function (nodeTitle) {
      wMax += Math.max(cascade[nodeTitle].inWeight, cascade[nodeTitle].outWeight);
    });
    return wMax;
  },
  _getMaxWeightThroughCascades: function _getMaxWeightThroughCascades(cascades) {
    var max = [];
    cascades.forEach(function (cascade) {
      var mW = 0;
      Object.keys(cascade).forEach(function (nodeTitle) {
        var node = cascade[nodeTitle];
        mW += Math.max(node.inWeight, node.outWeight);
      });
      max.push(mW);
    });
    return _graph.default.routines.maxOfArray(max);
  },
  _computeNodes: function _computeNodes(cascades, options) {
    var _this2 = this;

    var rects = [];

    var maxWeight = this._getMaxWeightThroughCascades(cascades);

    var maxNodeNum = _graph.default.routines.maxOfArray(cascades.map(function (nodesInCascade) {
      return Object.keys(nodesInCascade).length;
    }));

    var nodePadding = options.nodePadding;
    var heightAvailable = options.height - nodePadding * (maxNodeNum - 1);

    if (heightAvailable < 0) {
      // when the available height is too small, e.g. sum of all paddings is more then available height
      nodePadding = 0;
      heightAvailable = options.height - nodePadding * (maxNodeNum - 1);
    }

    this._weightPerPixel = maxWeight / heightAvailable; // compute in and out weightes of all nodes of cascades

    var cascadeIdx = 0;
    cascades.forEach(function (cascade) {
      var cascadeRects = [];
      var y = 0;
      var nodesInCascade = Object.keys(cascade).length;
      var cascadeHeight = _this2._getWeightForCascade(cascades, cascadeIdx) / _this2._weightPerPixel + nodePadding * (nodesInCascade - 1);
      var cascadeAlign;

      if (Array.isArray(options.nodeAlign)) {
        cascadeAlign = cascadeIdx < options.nodeAlign.length ? options.nodeAlign[cascadeIdx] : _ALIGNMENT_DEFAULT;
      } else {
        cascadeAlign = options.nodeAlign;
      }

      if (cascadeAlign === _ALIGNMENT_BOTTOM) {
        y = options.height - cascadeHeight;
      } else if (cascadeAlign === _ALIGNMENT_CENTER) {
        y = 0.5 * (options.height - cascadeHeight);
      }

      y = Math.round(y);
      Object.keys(cascade).forEach(function (nodeTitle) {
        cascade[nodeTitle].sort = _this2._sort && Object.prototype.hasOwnProperty.call(_this2._sort, nodeTitle) ? _this2._sort[nodeTitle] : 1;
      });
      Object.keys(cascade).sort(function (a, b) {
        return cascade[a].sort - cascade[b].sort;
      }).forEach(function (nodeTitle) {
        var node = cascade[nodeTitle];
        var height = Math.floor(heightAvailable * node.maxWeight / maxWeight);
        var x = Math.round(cascadeIdx * options.width / (cascades.length - 1)) - (cascadeIdx === 0 ? 0 : options.nodeWidth);
        var rect = {};
        rect._name = nodeTitle;
        rect.width = options.nodeWidth;
        rect.height = height;
        rect.x = x + options.x;
        rect.y = y + options.y;
        y += height + nodePadding;
        cascadeRects.push(rect);
      });
      cascadeIdx++;
      rects.push(cascadeRects);
    });
    return rects;
  },
  _findRectByName: function _findRectByName(rects, name) {
    for (var c = 0; c < rects.length; c++) {
      for (var r = 0; r < rects[c].length; r++) {
        if (name === rects[c][r]._name) return rects[c][r];
      }
    }

    return null;
  },
  _findIndexByName: function _findIndexByName(rects, nodeTitle) {
    var index = 0;

    for (var c = 0; c < rects.length; c++) {
      for (var r = 0; r < rects[c].length; r++) {
        if (nodeTitle === rects[c][r]._name) return index;
        index++;
      }
    }

    return null;
  },
  _computeLinks: function _computeLinks(links, rects, cascades) {
    var _this3 = this;

    var yOffsets = {};
    var paths = [];
    var result = [];
    cascades.forEach(function (cascade) {
      Object.keys(cascade).forEach(function (nodeTitle) {
        yOffsets[nodeTitle] = {
          in: 0,
          out: 0
        };
      });
    });
    rects.forEach(function (rectsOfCascade) {
      rectsOfCascade.forEach(function (nodeRect) {
        var nodeTitle = nodeRect._name;

        var rectFrom = _this3._findRectByName(rects, nodeTitle);

        var linksFromNode = links.filter(function (link) {
          return link[0] === nodeTitle;
        }); // all outgoing links from the node
        // all outgoing links should be sorted according to the order of their target nodes

        linksFromNode.forEach(function (link) {
          link.sort = _this3._findIndexByName(rects, link[1]);
        });
        linksFromNode.sort(function (a, b) {
          return a.sort - b.sort;
        }).forEach(function (link) {
          var rectTo = _this3._findRectByName(rects, link[1]);

          var height = Math.round(link[2] / _this3._weightPerPixel);
          var yOffsetFrom = yOffsets[link[0]].out;
          var yOffsetTo = yOffsets[link[1]].in; // heights of left and right parts of the link must fit the nodes on it's left and right

          var heightFrom = yOffsets[link[0]].out + height > rectFrom.height ? rectFrom.height - yOffsets[link[0]].out : height;
          var heightTo = yOffsets[link[1]].in + height > rectTo.height ? rectTo.height - yOffsets[link[1]].in : height;
          paths.push({
            from: {
              x: rectFrom.x,
              y: rectFrom.y + yOffsetFrom,
              width: rectFrom.width,
              height: heightFrom,
              node: rectFrom,
              weight: link[2]
            },
            to: {
              x: rectTo.x,
              y: rectTo.y + yOffsetTo,
              width: rectTo.width,
              height: heightTo,
              node: rectTo
            }
          });
          yOffsets[link[0]].out += height;
          yOffsets[link[1]].in += height;
        });
      });
    });
    paths.forEach(function (link) {
      var path = {
        d: _this3._spline(link.from, link.to),
        _boundingRect: {
          x: link.from.x + link.from.width,
          y: Math.min(link.from.y, link.to.y),
          width: link.to.x - (link.from.x + link.from.width),
          height: Math.max(link.from.x + link.from.height, link.to.y + link.to.height) - Math.min(link.from.y, link.to.y)
        },
        _weight: link.from.weight,
        _from: link.from.node,
        _to: link.to.node
      };
      result.push(path);
    });

    this._fitAllNodesHeight(rects, paths);

    return result;
  },
  _fitNodeHeight: function _fitNodeHeight(nodeName, nodeRects, paths) {
    var targetRect = this._findRectByName(nodeRects, nodeName);

    var heightOfLinksSummaryIn = 0;
    var heightOfLinksSummaryOut = 0;
    paths.forEach(function (path) {
      if (path.from.node._name === nodeName) {
        heightOfLinksSummaryOut += path.from.height;
      }

      if (path.to.node._name === nodeName) {
        heightOfLinksSummaryIn += path.to.height;
      }
    });
    targetRect.height = Math.max(heightOfLinksSummaryIn, heightOfLinksSummaryOut);
  },
  _fitAllNodesHeight: function _fitAllNodesHeight(nodeRects, paths) {
    for (var c = 0; c < nodeRects.length; c++) {
      for (var r = 0; r < nodeRects[c].length; r++) {
        this._fitNodeHeight(nodeRects[c][r]._name, nodeRects, paths);
      }
    }
  },
  _spline: function _spline(rectLeft, rectRight) {
    var p_UpLeft = {
      x: rectLeft.x + rectLeft.width,
      y: rectLeft.y
    };
    var p_DownLeft = {
      x: rectLeft.x + rectLeft.width,
      y: rectLeft.y + rectLeft.height
    };
    var p_UpRight = {
      x: rectRight.x,
      y: rectRight.y
    };
    var p_DownRight = {
      x: rectRight.x,
      y: rectRight.y + rectRight.height
    };
    var curve_width = _SPLINE_TENSION * (p_UpRight.x - p_UpLeft.x);
    var result = "M ".concat(p_UpLeft.x, " ").concat(p_UpLeft.y, " C ").concat(p_UpLeft.x + curve_width, " ").concat(p_UpLeft.y, " ").concat(p_UpRight.x - curve_width, " ").concat(p_UpRight.y, " ").concat(p_UpRight.x, " ").concat(p_UpRight.y, " L ").concat(p_DownRight.x, " ").concat(p_DownRight.y, " C ").concat(p_DownRight.x - curve_width, " ").concat(p_DownRight.y, " ").concat(p_DownLeft.x + curve_width, " ").concat(p_DownLeft.y, " ").concat(p_DownLeft.x, " ").concat(p_DownLeft.y, " Z");
    return result;
  },
  computeLayout: function computeLayout(linksData, sortData, options, incidentOccurred) {
    this._sort = sortData;
    var result = {};

    var validateResult = _data_validator.default.validate(linksData, incidentOccurred);

    if (!validateResult) {
      result.cascades = this._computeCascades(linksData);
      result.nodes = this._computeNodes(result.cascades, {
        width: options.availableRect.width,
        height: options.availableRect.height,
        x: options.availableRect.x,
        y: options.availableRect.y,
        nodePadding: options.nodePadding,
        nodeWidth: options.nodeWidth,
        nodeAlign: options.nodeAlign
      });
      result.links = this._computeLinks(linksData, result.nodes, result.cascades);
    } else {
      result.error = validateResult;
    }

    return result;
  },
  overlap: function overlap(box1, box2) {
    return !(box2.x > box1.x + box1.width || box2.x + box2.width < box1.x || box2.y >= box1.y + box1.height || box2.y + box2.height <= box1.y);
  }
};
exports.layout = layout;

/***/ }),
/* 1126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.default = void 0;

var _graph = _interopRequireDefault(__webpack_require__(618));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var validator = {
  validate: function validate(data, incidentOccurred) {
    var result = null;

    if (this._hasCycle(data)) {
      result = 'E2006';
      incidentOccurred('E2006');
    }

    return result;
  },
  _hasCycle: function _hasCycle(data) {
    return _graph.default.struct.hasCycle(data);
  }
};
var _default = validator;
exports.default = _default;
module.exports = exports.default;
module.exports.default = exports.default;

/***/ }),
/* 1127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.setTooltipCustomOptions = setTooltipCustomOptions;

var _extend2 = __webpack_require__(0);

var _type = __webpack_require__(1);

var defaultCustomizeLinkTooltip = function defaultCustomizeLinkTooltip(info) {
  return {
    html: "<strong>".concat(info.source, " > ").concat(info.target, "</strong><br/>Weight: ").concat(info.weight)
  };
};

var defaultCustomizeNodeTooltip = function defaultCustomizeNodeTooltip(info) {
  return {
    html: "<strong>".concat(info.label, "</strong><br/>Incoming weight: ").concat(info.weightIn, "<br/>Outgoing weight: ").concat(info.weightOut)
  };
};

var generateCustomCallback = function generateCustomCallback(customCallback, defaultCallback) {
  return function (objectInfo) {
    var res = (0, _type.isFunction)(customCallback) ? customCallback.call(objectInfo, objectInfo) : {};
    var hasOwnProperty = Object.prototype.hasOwnProperty.bind(res);

    if (!hasOwnProperty('html') && !hasOwnProperty('text')) {
      res = (0, _extend2.extend)(res, defaultCallback.call(objectInfo, objectInfo));
    }

    return res;
  };
};

function setTooltipCustomOptions(sankey) {
  sankey.prototype._setTooltipOptions = function () {
    var tooltip = this._tooltip;

    var options = tooltip && this._getOption('tooltip');

    var linkTemplate;
    var nodeTemplate;

    if (options.linkTooltipTemplate) {
      linkTemplate = this._getTemplate(options.linkTooltipTemplate);
    }

    if (options.nodeTooltipTemplate) {
      nodeTemplate = this._getTemplate(options.nodeTooltipTemplate);
    }

    tooltip && tooltip.update((0, _extend2.extend)({}, options, {
      customizeTooltip: function customizeTooltip(args) {
        if (!(linkTemplate && args.type === 'link' || nodeTemplate && args.type === 'node')) {
          args.skipTemplate = true;
        }

        if (args.type === 'node') {
          return generateCustomCallback(options.customizeNodeTooltip, defaultCustomizeNodeTooltip)(args.info);
        } else if (args.type === 'link') {
          return generateCustomCallback(options.customizeLinkTooltip, defaultCustomizeLinkTooltip)(args.info);
        }

        return {};
      },
      contentTemplate: function contentTemplate(arg, div) {
        var templateArgs = {
          model: arg.info,
          container: div
        };

        if (linkTemplate && arg.type === 'link') {
          return linkTemplate.render(templateArgs);
        }

        if (nodeTemplate && arg.type === 'node') {
          return nodeTemplate.render(templateArgs);
        }
      },
      enabled: options.enabled
    }));
  };

  sankey.prototype.hideTooltip = function () {
    this._tooltip && this._tooltip.hide();
  };
}

/***/ }),
/* 1128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.plugin = void 0;

var _sankey = _interopRequireDefault(__webpack_require__(616));

var _tracker = __webpack_require__(353);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var proto = _sankey.default.prototype;
var DATA_KEY_BASE = '__sankey_data_';
var dataKeyModifier = 0;
proto._eventsMap.onNodeClick = {
  name: 'nodeClick'
};
proto._eventsMap.onLinkClick = {
  name: 'linkClick'
};

var getDataKey = function getDataKey() {
  return DATA_KEY_BASE + dataKeyModifier++;
};

var plugin = {
  name: 'tracker',
  init: function init() {
    var that = this;
    var dataKey = getDataKey();
    that._tracker = new _tracker.Tracker({
      widget: that,
      root: that._renderer.root,
      getData: function getData(e) {
        var target = e.target;
        return target[dataKey];
      },
      getNode: function getNode(index) {
        if (index < that._nodes.length) {
          return that._nodes[index];
        } else {
          return that._links[index - that._nodes.length];
        }
      },
      click: function click(e) {
        var eventName = this.getData(e.event) < that._nodes.length ? 'nodeClick' : 'linkClick';

        that._eventTrigger(eventName, {
          target: e.node,
          event: e.event
        });
      }
    });
    this._dataKey = dataKey;
  },
  dispose: function dispose() {
    this._tracker.dispose();
  },
  extenders: {
    _change_LINKS_DRAW: function _change_LINKS_DRAW() {
      var dataKey = this._dataKey;

      this._nodes.concat(this._links).forEach(function (item, index) {
        item.element.data(dataKey, index);
      });
    }
  }
};
exports.plugin = plugin;

/***/ }),
/* 1129 */,
/* 1130 */,
/* 1131 */,
/* 1132 */,
/* 1133 */,
/* 1134 */,
/* 1135 */,
/* 1136 */,
/* 1137 */,
/* 1138 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1139);


/***/ }),
/* 1139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(1029);

/***/ })
/******/ ]);
